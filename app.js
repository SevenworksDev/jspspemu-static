(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, {get: all[name2], enumerable: true});
  };
  var __decorate = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __param = (index, decorator) => (target, key) => decorator(target, key, index);

  // src/global/window.ts
  if (typeof global === "undefined") {
    window.global = window;
  }
  if (typeof window === "undefined") {
    global.window = global;
  }
  if (typeof self == "undefined") {
    global.self = global;
  }
  if (typeof navigator == "undefined") {
    global.navigator = {};
  }

  // src/global/math.ts
  var MAT4_3_IDX = new Uint32Array([
    0,
    1,
    2,
    4,
    5,
    6,
    8,
    9,
    10,
    12,
    13,
    14
  ]);
  var mat4 = class {
    static create() {
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
    }
    static from4x3(out, mat4x32) {
      for (let n = 0; n < 12; n++)
        out[MAT4_3_IDX[n]] = mat4x32[n];
      out[3] = 0;
      out[7] = 0;
      out[11] = 0;
      out[15] = 1;
    }
    static from4x4(out, mat4x4) {
      out.set(mat4x4);
    }
    static identity(data) {
      data[0] = 1;
      data[1] = 0;
      data[2] = 0;
      data[3] = 0;
      data[4] = 0;
      data[5] = 1;
      data[6] = 0;
      data[7] = 0;
      data[8] = 0;
      data[9] = 0;
      data[10] = 1;
      data[11] = 0;
      data[12] = 0;
      data[13] = 0;
      data[14] = 0;
      data[15] = 1;
    }
    static ortho(out, left, right, bottom, top, near, far) {
      const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
      out[0] = -2 * lr;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = -2 * bt;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 2 * nf;
      out[11] = 0;
      out[12] = (left + right) * lr;
      out[13] = (top + bottom) * bt;
      out[14] = (far + near) * nf;
      out[15] = 1;
      return out;
    }
    static multiply(out, a, b) {
      const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
      let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }
    static scale(out, a, v) {
      const x = v[0], y = v[1], z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
    static translate(out, a, v) {
      let x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }
      return out;
    }
  };
  var _self = window;
  _self["polyfills"] = _self["polyfills"] || {};
  _self["polyfills"]["log2"] = !Math["log2"];
  if (!Math.log2) {
    Math.log2 = (x) => {
      return Math.log(x) / Math.LN2;
    };
  }
  _self["polyfills"]["log10"] = !Math["log10"];
  if (!Math.log10) {
    Math.log10 = (x) => {
      return Math.log(x) / Math.LN10;
    };
  }
  _self["polyfills"]["sign"] = !Math["sign"];
  if (!Math["sign"]) {
    Math["sign"] = (x) => {
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    };
  }
  _self["polyfills"]["rint"] = !Math["rint"];
  if (!Math["rint"]) {
    Math["rint"] = (value) => {
      const twoToThe52 = Math.pow(2, 52);
      const sign = Math.sign(value);
      value = Math.abs(value);
      if (value < twoToThe52)
        value = twoToThe52 + value - twoToThe52;
      return sign * value;
    };
  }
  _self["polyfills"]["clz32"] = !Math["clz32"];
  if (!Math["clz32"]) {
    Math["clz32"] = (x) => {
      x >>>= 0;
      if (x == 0)
        return 32;
      let result = 0;
      if ((x & 4294901760) === 0) {
        x <<= 16;
        result += 16;
      }
      if ((x & 4278190080) === 0) {
        x <<= 8;
        result += 8;
      }
      if ((x & 4026531840) === 0) {
        x <<= 4;
        result += 4;
      }
      if ((x & 3221225472) === 0) {
        x <<= 2;
        result += 2;
      }
      if ((x & 2147483648) === 0) {
        x <<= 1;
        result += 1;
      }
      return result;
    };
  }
  _self["polyfills"]["trunc"] = !Math["trunc"];
  if (!Math["trunc"]) {
    Math["trunc"] = function(x) {
      if (x < 0) {
        return Math.ceil(x) | 0;
      } else {
        return Math.floor(x) | 0;
      }
    };
  }
  _self["polyfills"]["imul"] = !Math["imul"];
  if (!Math["imul"]) {
    Math["imul"] = function(a, b) {
      const ah = a >>> 16 & 65535;
      const al = a & 65535;
      const bh = b >>> 16 & 65535;
      const bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    };
  }
  _self["polyfills"]["umul32_64"] = !Math["umul32_64"];
  if (!Math.umul32_64) {
    Math.umul32_64 = function(a, b, result) {
      if (result === void 0)
        result = new Int32Array(2);
      a >>>= 0;
      b >>>= 0;
      if (a < 32767 && b < 65536) {
        result[0] = a * b;
        result[1] = result[0] < 0 ? -1 : 0;
        return result;
      }
      const a00 = a & 65535, a16 = a >>> 16;
      const b00 = b & 65535, b16 = b >>> 16;
      const c00 = a00 * b00;
      let c16 = (c00 >>> 16) + a16 * b00;
      let c32 = c16 >>> 16;
      c16 = (c16 & 65535) + a00 * b16;
      c32 += c16 >>> 16;
      let c48 = c32 >>> 16;
      c32 = (c32 & 65535) + a16 * b16;
      c48 += c32 >>> 16;
      result[0] = (c16 & 65535) << 16 | c00 & 65535;
      result[1] = (c48 & 65535) << 16 | c32 & 65535;
      return result;
    };
  }
  _self["polyfills"]["imul32_64"] = !Math["imul32_64"];
  if (!Math.imul32_64) {
    Math.imul32_64 = function(a, b, result) {
      if (result === void 0)
        result = new Int32Array(2);
      if (a == 0) {
        result[0] = result[1] = 0;
        return result;
      }
      if (b == 0) {
        result[0] = result[1] = 0;
        return result;
      }
      a |= 0;
      b |= 0;
      if (a >= -32768 && a <= 32767 && (b >= -32768 && b <= 32767)) {
        result[0] = a * b;
        result[1] = result[0] < 0 ? -1 : 0;
        return result;
      }
      const doNegate = a < 0 ^ b < 0;
      Math.umul32_64(Math.abs(a), Math.abs(b), result);
      if (doNegate) {
        result[0] = ~result[0];
        result[1] = ~result[1];
        result[0] = result[0] + 1 | 0;
        if (result[0] == 0)
          result[1] = result[1] + 1 | 0;
      }
      return result;
    };
  }
  _self["polyfills"]["fround"] = !Math["fround"];
  if (!Math["fround"]) {
    Math["fround"] = function(x) {
      const f32 = new Float32Array(1);
      f32[0] = x;
      return f32[0];
    };
  }
  var BitUtils = class {
    static mask(value) {
      return (1 << value) - 1;
    }
    static bitrev32(v) {
      v = v >>> 1 & 1431655765 | (v & 1431655765) << 1;
      v = v >>> 2 & 858993459 | (v & 858993459) << 2;
      v = v >>> 4 & 252645135 | (v & 252645135) << 4;
      v = v >>> 8 & 16711935 | (v & 16711935) << 8;
      v = v >>> 16 & 65535 | (v & 65535) << 16;
      return v;
    }
    static rotr(value, offset) {
      return value >>> offset | value << 32 - offset;
    }
    static clo(x) {
      return Math.clz32(~x);
    }
    static clz(x) {
      return Math.clz32(x);
    }
    static seb(x) {
      return x << 24 >> 24;
    }
    static seh(x) {
      return x << 16 >> 16;
    }
    static wsbh(v) {
      return (v & 4278255360) >>> 8 | (v & 16711935) << 8;
    }
    static wsbw(v) {
      return (v & 4278190080) >>> 24 | (v & 16711680) >>> 8 | (v & 65280) << 8 | (v & 255) << 24;
    }
    static extract(data, offset, length) {
      return data >> offset & (1 << length) - 1;
    }
    static extract4(data, offset) {
      return data >> offset & 15;
    }
    static extract8(data, offset) {
      return data >> offset & 255;
    }
    static extract16(data, offset) {
      return data >> offset & 65535;
    }
    static extract24(data, offset) {
      return data >> offset & 16777215;
    }
    static extractBool(data, offset) {
      return this.extract(data, offset, 1) != 0;
    }
    static signExtend(value, bits) {
      return value << 32 - bits >> 32 - bits;
    }
    static extractSigned(data, offset, length) {
      const mask = this.mask(length);
      const signBit = 1 << offset + (length - 1);
      let value = this.extract(data, offset, length);
      if ((value & signBit) != 0)
        value |= ~mask;
      return value;
    }
    static extractScale1f(data, offset, length) {
      const mask = (1 << length) - 1;
      return (data >>> offset & mask) / mask;
    }
    static extractScalef(data, offset, length, scale) {
      return BitUtils.extractScale1f(data, offset, length) * scale;
    }
    static extractScalei(data, offset, length, scale) {
      return this.extractScalef(data, offset, length, scale) | 0;
    }
    static extractEnum(data, offset, length) {
      return this.extract(data, offset, length);
    }
    static clear(data, offset, length) {
      data &= ~(BitUtils.mask(length) << offset);
      return data;
    }
    static insert(data, offset, length, value) {
      value &= BitUtils.mask(length);
      data = BitUtils.clear(data, offset, length);
      data |= value << offset;
      return data;
    }
    static withBit(initial, bit, set) {
      return this.withMask(initial, 1 << bit, set);
    }
    static withMask(initial, mask, set) {
      return set ? initial | mask : initial & ~mask;
    }
  };
  var MathVfpu = class {
    static vqmul0(s0, s1, s2, s3, t0, t1, t2, t3) {
      return +(s0 * t3) + s1 * t2 - s2 * t1 + s3 * t0;
    }
    static vqmul1(s0, s1, s2, s3, t0, t1, t2, t3) {
      return -(s0 * t2) + s1 * t3 + s2 * t0 + s3 * t1;
    }
    static vqmul2(s0, s1, s2, s3, t0, t1, t2, t3) {
      return +(s0 * t1) - s1 * t0 + s2 * t3 + s3 * t2;
    }
    static vqmul3(s0, s1, s2, s3, t0, t1, t2, t3) {
      return -(s0 * t0) - s1 * t1 - s2 * t2 + s3 * t3;
    }
    static vc2i(index, value) {
      return value << (3 - index) * 8 & 4278190080;
    }
    static vuc2i(index, value) {
      return (value >>> index * 8 & 255) * 16843009 >> 1 & ~2147483648;
    }
    static vs2i(index, value) {
      if (index % 2 == 0)
        value <<= 16;
      return value & 4294901760;
    }
    static vi2f(value, count) {
      return MathFloat.scalb(value, count);
    }
    static vi2uc(x, y, z, w) {
      return 0 | (x < 0 ? 0 : x >>> 23 << 0) | (y < 0 ? 0 : y >>> 23 << 8) | (z < 0 ? 0 : z >>> 23 << 16) | (w < 0 ? 0 : w >>> 23 << 24);
    }
    static vf2id(value, count) {
      return MathFloat.floor(MathFloat.scalb(value, count));
    }
    static vf2in(value, count) {
      return MathFloat.rint(MathFloat.scalb(value, count));
    }
    static vf2iu(value, count) {
      return MathFloat.ceil(MathFloat.scalb(value, count));
    }
    static vf2iz(Value, count) {
      const ScalabValue = MathFloat.scalb(Value, count);
      const DoubleValue = Value >= 0 ? MathFloat.floor(ScalabValue) : MathFloat.ceil(ScalabValue);
      return isNaN(DoubleValue) ? 2147483647 : DoubleValue;
    }
    static vf2h() {
      debugger;
      return 0;
    }
    static vh2f() {
      debugger;
      return 0;
    }
  };
  var _MathFloat = class {
    static reinterpretFloatAsInt(floatValue) {
      _MathFloat.floatArray[0] = floatValue;
      return _MathFloat.intArray[0];
    }
    static reinterpretIntAsFloat(integerValue) {
      _MathFloat.intArray[0] = integerValue;
      return _MathFloat.floatArray[0];
    }
    static scalb(value, count) {
      return value * Math.pow(2, count);
    }
    static min(a, b) {
      return a < b ? a : b;
    }
    static max(a, b) {
      return a > b ? a : b;
    }
    static isnan(n) {
      return isNaN(n);
    }
    static isinf(n) {
      return n === n / 0;
    }
    static isnanorinf(n) {
      return _MathFloat.isnan(n) || _MathFloat.isinf(n);
    }
    static abs(value) {
      return Math.abs(value);
    }
    static neg(value) {
      return -value;
    }
    static ocp(value) {
      return 1 - value;
    }
    static nrcp(value) {
      return -(1 / value);
    }
    static sat0(value) {
      return MathUtils.clamp(value, 0, 1);
    }
    static sat1(value) {
      return MathUtils.clamp(value, -1, 1);
    }
    static rsq(value) {
      return 1 / Math.sqrt(value);
    }
    static sqrt(value) {
      return Math.sqrt(value);
    }
    static rint(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return Math.rint(value);
    }
    static cast(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return value < 0 ? Math.ceil(value) : Math.floor(value);
    }
    static trunc(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return Math.trunc(value);
    }
    static round(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return Math.round(value);
    }
    static floor(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return Math.floor(value);
    }
    static ceil(value) {
      if (!isFinite(value))
        return handleCastInfinite(value);
      return Math.ceil(value);
    }
    static cosv1(value) {
      return Math.cos(value * Math.PI * 0.5);
    }
    static sinv1(value) {
      return Math.sin(value * Math.PI * 0.5);
    }
    static nsinv1(value) {
      return -Math.sin(value * Math.PI * 0.5);
    }
    static asinv1(value) {
      return Math.asin(value) / (Math.PI * 0.5);
    }
    static exp2(value) {
      return Math.pow(2, value);
    }
    static rexp2(value) {
      return 1 / Math.pow(2, value);
    }
    static log2(value) {
      return Math.log2(value);
    }
    static sign(value) {
      return Math.sign(value);
    }
    static sign2(left, right) {
      const a = left - right;
      return (0 < a ? 1 : 0) - (a < 0 ? 1 : 0);
    }
    static vslt(a, b) {
      if (isNaN(a) || isNaN(b))
        return 0;
      return a < b ? 1 : 0;
    }
    static vsle(a, b) {
      if (isNaN(a) || isNaN(b))
        return 0;
      return a <= b ? 1 : 0;
    }
    static vsgt(a, b) {
      if (isNaN(a) || isNaN(b))
        return 0;
      return a > b ? 1 : 0;
    }
    static vsge(a, b) {
      if (isNaN(a) || isNaN(b))
        return 0;
      return a >= b ? 1 : 0;
    }
    static clamp(v, min, max) {
      if (v < min)
        return min;
      if (v > max)
        return max;
      return v;
    }
  };
  var MathFloat = _MathFloat;
  MathFloat.reinterpretBuffer = new ArrayBuffer(4);
  MathFloat.floatArray = new Float32Array(_MathFloat.reinterpretBuffer);
  MathFloat.intArray = new Int32Array(_MathFloat.reinterpretBuffer);
  function handleCastInfinite(value) {
    return value < 0 ? -2147483648 : 2147483647;
  }
  function compare(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  }
  function parseIntFormat(str) {
    str = str.replace(/_/g, "");
    if (str.substr(0, 2) == "0b")
      return parseInt(str.substr(2), 2);
    if (str.substr(0, 2) == "0x")
      return parseInt(str.substr(2), 16);
    return parseInt(str, 10);
  }
  var MathUtils = class {
    static sextend16(value) {
      return (value & 65535) << 16 >> 16;
    }
    static interpolate(a, b, ratio) {
      return a * (1 - ratio) + b * ratio;
    }
    static prevAligned(value, alignment) {
      return Math.floor(value / alignment) * alignment;
    }
    static isAlignedTo(value, alignment) {
      return value % alignment == 0;
    }
    static requiredBlocks(size, blockSize) {
      if (size % blockSize != 0) {
        return size / blockSize + 1;
      } else {
        return size / blockSize;
      }
    }
    static isPowerOfTwo(x) {
      return x != 0 && (x & x - 1) == 0;
    }
    static nextAligned(value, alignment) {
      if (alignment <= 1)
        return value;
      return value + (alignment - value % alignment) % alignment;
    }
    static clamp01(v) {
      if (v < 0)
        return 0;
      if (v > 1)
        return 1;
      return v;
    }
    static clamp(v, min, max) {
      if (v < min)
        return min;
      if (v > max)
        return max;
      return v;
    }
    static clampM1_1(v) {
      return this.clamp(v, -1, 1);
    }
    static clamp0_255(v) {
      return this.clamp(v, 0, 255);
    }
    static transformRange(value, srcMin, srcMax, dstMin, dstMax) {
      return this.transformRange01((value - srcMin) / (srcMax - srcMin), dstMin, dstMax);
    }
    static transformRange01(ratio, dstMin, dstMax) {
      return ratio * (dstMax - dstMin) + dstMin;
    }
  };
  function ToInt32(x) {
    return x | 0;
  }
  var ArrayUtils = class {
    static create(size, gen) {
      const out = new Array(size);
      for (let n = 0; n < size; n++)
        out[n] = gen(n);
      return out;
    }
    static create2D(w, h, generator) {
      if (!generator)
        generator = (x, y) => null;
      const matrix = [];
      for (let y = 0; y < h; y++) {
        const row = [];
        for (let x = 0; x < w; x++) {
          row.push(generator(x, y));
        }
        matrix.push(row);
      }
      return matrix;
    }
    static range(start, end) {
      const array = [];
      for (let n = start; n < end; n++)
        array.push(n);
      return array;
    }
    static keys(object) {
      const keys = [];
      for (let key in object)
        keys.push(key);
      return keys;
    }
  };
  function xrange(start, end) {
    return ArrayUtils.range(start, end);
  }
  window.MathFloat = MathFloat;
  window.BitUtils = BitUtils;

  // src/global/array.ts
  function identity(a) {
    return a;
  }
  function funcTrue(a) {
    return true;
  }
  function compareNumbers(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  }
  Array.prototype.contains = function(item) {
    return this.indexOf(item) >= 0;
  };
  Array.prototype.binarySearchValue = function(selector) {
    const array = this;
    const index = array.binarySearchIndex(selector);
    if (index < 0)
      return null;
    return array[index];
  };
  Array.prototype.binarySearchIndex = function(selector) {
    const array = this;
    let min = 0;
    let max = array.length - 1;
    let step = 0;
    if (array.length == 0)
      return -1;
    while (true) {
      let current = Math.floor((min + max) / 2);
      const item = array[current];
      const result = selector(item);
      if (result == 0) {
        return current;
      }
      if (current == min || current == max) {
        if (min != max) {
          min = max = current = current != min ? min : max;
        } else {
          break;
        }
      } else {
        if (result < 0) {
          max = current;
        } else if (result > 0) {
          min = current;
        }
      }
      step++;
      if (step >= 64)
        throw new Error("Too much steps");
    }
    return -1;
  };
  Array.prototype.min = function(selector) {
    const array = this;
    if (!selector)
      selector = (a) => a;
    if (array.length == 0)
      return null;
    return array.reduce((previous, current) => {
      return selector(previous) < selector(current) ? previous : current;
    }, array[0]);
  };
  Array.prototype.max = function(selector) {
    const array = this;
    if (!selector)
      selector = (a) => a;
    if (array.length == 0)
      return null;
    return array.reduce((previous, current) => {
      return selector(previous) > selector(current) ? previous : current;
    }, array[0]);
  };
  Array.prototype.sortBy = function(selector) {
    return this.slice(0).sort((a, b) => compare(selector(a), selector(b)));
  };
  Array.prototype.cast = function() {
    return this;
  };
  Array.prototype.count = function(selector) {
    const array = this;
    if (!selector)
      selector = funcTrue;
    let result = 0;
    for (let n = 0; n < array.length; n++)
      if (selector(array[n]))
        result++;
    return result;
  };
  Array.prototype.any = function(selector) {
    const array = this;
    if (!selector)
      selector = funcTrue;
    for (let n = 0; n < array.length; n++)
      if (selector(array[n]))
        return true;
    return false;
  };
  Array.prototype.first = function(selector) {
    const array = this;
    if (!selector)
      selector = identity;
    for (let n = 0; n < array.length; n++)
      if (selector(array[n]))
        return array[n];
    return void 0;
  };
  Array.prototype.sum = function(selector) {
    const array = this;
    if (!selector)
      selector = (a) => a;
    return array.reduce((previous, current) => {
      return previous + selector(current);
    }, 0);
  };
  Array.prototype.remove = function(item) {
    const array = this;
    const index = array.indexOf(item);
    if (index >= 0)
      array.splice(index, 1);
  };
  Array.prototype.toLookupMap = function() {
    const array = this;
    const lookup = {};
    for (let n = 0; n < array.length; n++) {
      lookup[array[n]] = n;
    }
    return lookup;
  };
  Object.defineProperty(Array.prototype, "contains", {enumerable: false});
  Object.defineProperty(Array.prototype, "toLookupMap", {enumerable: false});
  Object.defineProperty(Array.prototype, "cast", {enumerable: false});
  Object.defineProperty(Array.prototype, "count", {enumerable: false});
  Object.defineProperty(Array.prototype, "any", {enumerable: false});
  Object.defineProperty(Array.prototype, "sum", {enumerable: false});
  Object.defineProperty(Array.prototype, "min", {enumerable: false});
  Object.defineProperty(Array.prototype, "max", {enumerable: false});
  Object.defineProperty(Array.prototype, "sortBy", {enumerable: false});
  Object.defineProperty(Array.prototype, "first", {enumerable: false});
  Object.defineProperty(Array.prototype, "remove", {enumerable: false});
  Object.defineProperty(Array.prototype, "binarySearchValue", {enumerable: false});
  Object.defineProperty(Array.prototype, "binarySearchIndex", {enumerable: false});

  // src/global/utils.ts
  var _self2 = typeof window != "undefined" ? window : self;
  var u16TextDecoder = new TextDecoder("utf-16");
  String.fromUint8Array = function(array) {
    if (array.length <= 1024) {
      return String.fromCharCode.apply(null, array);
    }
    const temp = new Uint16Array(array.length);
    temp.set(array, 0);
    return u16TextDecoder.decode(temp);
  };
  Number.prototype.extract = function(offset, length) {
    return BitUtils.extract(this, offset, length);
  };
  Number.prototype.extract8 = function(offset) {
    return BitUtils.extract8(this, offset);
  };
  Number.prototype.extractBit = function(offset) {
    return BitUtils.extractBool(this, offset);
  };
  Number.prototype.signExtend = function(bits) {
    return this << 32 - bits >> 32 - bits;
  };
  String.prototype.format = function(...args) {
    return sprintf(this, ...args);
  };
  String.prototype.rstrip = function() {
    const string = this;
    return string.replace(/\s+$/, "");
  };
  String.prototype.contains = function(value) {
    const string = this;
    return string.indexOf(value) >= 0;
  };
  function sprintf(...args) {
    const regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
    const a = arguments;
    let i = 0;
    const format = a[i++];
    const pad = function(str, len, chr, leftJustify) {
      if (!chr) {
        chr = " ";
      }
      const padding = str.length >= len ? "" : new Array(1 + len - str.length >>> 0).join(chr);
      return leftJustify ? str + padding : padding + str;
    };
    const justify = function(value, prefix, leftJustify, minWidth, zeroPad, customPadChar = void 0) {
      const diff = minWidth - value.length;
      if (diff > 0) {
        if (leftJustify || !zeroPad) {
          value = pad(value, minWidth, customPadChar, leftJustify);
        } else {
          value = value.slice(0, prefix.length) + pad("", diff, "0", true) + value.slice(prefix.length);
        }
      }
      return value;
    };
    const formatBaseX = function(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
      const number = value >>> 0;
      prefix = prefix && number && {
        "2": "0b",
        "8": "0",
        "16": "0x"
      }[base] || "";
      const valueStr = prefix + pad(number.toString(base), precision || 0, "0", false);
      return justify(valueStr, prefix, leftJustify, minWidth, zeroPad);
    };
    const formatString = function(value, leftJustify, minWidth, precision, zeroPad, customPadChar = void 0) {
      if (precision != null) {
        value = value.slice(0, precision);
      }
      return justify(value, "", leftJustify, minWidth, zeroPad, customPadChar);
    };
    const doFormat = function(substring, valueIndex, flags, minWidth, _, precision, type) {
      let number, prefix, method, textTransform, value;
      if (substring === "%%") {
        return "%";
      }
      let leftJustify = false;
      let positivePrefix = "";
      let zeroPad = false;
      let prefixBaseX = false;
      let customPadChar = " ";
      const flagsl = flags.length;
      for (let j = 0; flags && j < flagsl; j++) {
        switch (flags.charAt(j)) {
          case " ":
            positivePrefix = " ";
            break;
          case "+":
            positivePrefix = "+";
            break;
          case "-":
            leftJustify = true;
            break;
          case "'":
            customPadChar = flags.charAt(j + 1);
            break;
          case "0":
            zeroPad = true;
            customPadChar = "0";
            break;
          case "#":
            prefixBaseX = true;
            break;
        }
      }
      if (!minWidth) {
        minWidth = 0;
      } else if (minWidth === "*") {
        minWidth = +a[i++];
      } else if (minWidth.charAt(0) == "*") {
        minWidth = +a[minWidth.slice(1, -1)];
      } else {
        minWidth = +minWidth;
      }
      if (minWidth < 0) {
        minWidth = -minWidth;
        leftJustify = true;
      }
      if (!isFinite(minWidth)) {
        throw new Error("sprintf: (minimum-)width must be finite");
      }
      if (!precision) {
        precision = "fFeE".indexOf(type) > -1 ? 6 : type === "d" ? 0 : void 0;
      } else if (precision === "*") {
        precision = +a[i++];
      } else if (precision.charAt(0) == "*") {
        precision = +a[precision.slice(1, -1)];
      } else {
        precision = +precision;
      }
      value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
      switch (type) {
        case "s":
          return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
        case "c":
          return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
        case "b":
          return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case "o":
          return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case "x":
          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case "X":
          return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
        case "u":
          return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case "i":
        case "d":
          number = +value || 0;
          number = Math.round(number - number % 1);
          prefix = number < 0 ? "-" : positivePrefix;
          value = prefix + pad(String(Math.abs(number)), precision, "0", false);
          return justify(value, prefix, leftJustify, minWidth, zeroPad);
        case "e":
        case "E":
        case "f":
        case "F":
        case "g":
        case "G":
          number = +value;
          prefix = number < 0 ? "-" : positivePrefix;
          method = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(type.toLowerCase())];
          textTransform = ["toString", "toUpperCase"]["eEfFgG".indexOf(type) % 2];
          value = prefix + Math.abs(number)[method](precision);
          return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
        default:
          return substring;
      }
    };
    return format.replace(regex, doFormat);
  }
  function printf(...args) {
    console.log(sprintf.apply(sprintf, arguments));
  }
  var Endian;
  (function(Endian2) {
    Endian2[Endian2["LITTLE"] = 0] = "LITTLE";
    Endian2[Endian2["BIG"] = 1] = "BIG";
  })(Endian || (Endian = {}));
  var SortedSet = class {
    constructor() {
      this.elements = [];
    }
    has(element) {
      return this.elements.indexOf(element) >= 0;
    }
    add(element) {
      if (!this.has(element))
        this.elements.push(element);
      return element;
    }
    get length() {
      return this.elements.length;
    }
    delete(element) {
      this.elements.remove(element);
    }
    filter(callback) {
      return this.elements.filter(callback);
    }
    forEach(callback) {
      this.elements.forEach(callback);
    }
  };
  var DSet = class extends SortedSet {
  };
  var UidCollection = class {
    constructor(lastId = 1) {
      this.lastId = lastId;
      this.items = {};
      this.freeItems = [];
    }
    allocate(item) {
      const id = this.freeItems.length > 0 ? this.freeItems.pop() : this.lastId++;
      this.items[id] = item;
      return id;
    }
    has(id) {
      return this.items[id] !== void 0;
    }
    get(id) {
      return this.items[id];
    }
    list() {
      const out = [];
      for (let key in this.items)
        out.push(this.items[key]);
      return out;
    }
    remove(id) {
      if (this.items[id] !== void 0) {
        delete this.items[id];
        this.freeItems.push(id);
      }
    }
  };
  var _Microtask = class {
    constructor() {
      this.queued = false;
      this.callbacks = [];
      this.timeout = -1;
      this._timedTasks = [];
    }
    queue(callback) {
      this.callbacks.push(callback);
      if (!this.queued) {
        this._executeLater();
      }
    }
    queueExecuteNow(callback) {
      this._cancelTimeout();
      this.queued = true;
      callback();
      this._execute(false);
    }
    execute() {
      this._execute(true);
    }
    _cancelTimeout() {
      if (this.timeout != -1) {
        clearTimeout(this.timeout);
        this.timeout = -1;
      }
    }
    _executeLater() {
      this.queued = true;
      this._cancelTimeout();
      this.timeout = setTimeout(() => {
        this.execute();
      }, 0);
    }
    _execute(scheduleNext) {
      const start = performance.now();
      while (this._timedTasks.length > 0) {
        const task = this._timedTasks[0];
        if (performance.now() >= task.time) {
          this._timedTasks.shift();
        } else {
          break;
        }
      }
      while (this.callbacks.length > 0) {
        const callback = this.callbacks.shift();
        callback();
        const end = performance.now();
        if (end - start >= 20) {
          if (scheduleNext) {
            this._executeLater();
          }
          return;
        }
      }
      this.queued = false;
    }
    async waitAsync(timeMs) {
      return new Promise((resolve, reject) => {
        setTimeout(resolve, timeMs);
      });
    }
  };
  var Microtask = new _Microtask();
  _self2["polyfills"] = _self2["polyfills"] || {};
  _self2["polyfills"]["ArrayBuffer_slice"] = !ArrayBuffer.prototype.slice;
  _self2["polyfills"]["performance"] = !self.performance;
  if (!_self2["performance"]) {
    _self2["performance"] = {};
    _self2["performance"]["now"] = function() {
      return Date.now();
    };
  }
  var Utf8 = class {
    static decode(input) {
      try {
        return decodeURIComponent(escape(input));
      } catch (e) {
        console.error(e);
        return input;
      }
    }
    static encode(input) {
      return unescape(encodeURIComponent(input));
    }
  };
  if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function(begin, end) {
      const that = new Uint8Array(this);
      if (end == void 0)
        end = that.length;
      const result = new ArrayBuffer(end - begin);
      const resultArray = new Uint8Array(result);
      for (let i = 0; i < resultArray.length; i++)
        resultArray[i] = that[i + begin];
      return result;
    };
  }
  _self2["AudioContext"] = _self2["AudioContext"] || _self2["webkitAudioContext"];
  _self2.navigator["getGamepads"] = _self2.navigator["getGamepads"] || _self2.navigator["webkitGetGamepads"];
  if (!_self2.requestAnimationFrame) {
    _self2.requestAnimationFrame = function(callback) {
      return setTimeout(function() {
        callback(Date.now());
      }, 1e3 / 60);
    };
    _self2.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
  var ArrayBufferUtils = class {
    static copyUint8ToArrayBuffer(input) {
      const out = new ArrayBuffer(input.length);
      new Uint8Array(out).set(input);
      return out;
    }
    static hashWordCount(data) {
      let count = data.length, result = 0;
      for (let n = 0; n < count; n++)
        result = result + data[n] ^ n | 0;
      return result;
    }
    static hashFast(data) {
      return this.hashWordCount(new Uint32Array(data.buffer, data.byteOffset, data.byteLength / 4));
    }
    static hash(data) {
      let result = 0;
      let address = 0;
      let count = data.length;
      while ((address + data.byteOffset & 3) != 0) {
        result += data[address++];
        count--;
      }
      const count2 = MathUtils.prevAligned(count, 4);
      result += this.hashWordCount(new Uint32Array(data.buffer, data.byteOffset + address, count2 / 4));
      address += count2;
      count -= count2;
      while ((address + data.byteOffset & 3) != 0) {
        result += data[address++] * 7;
        count--;
      }
      return result;
    }
    static fromUInt8Array(input) {
      return input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength);
    }
    static uint16ToUint8(input) {
      return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
    }
    static uint32ToUint8(input) {
      return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
    }
    static uint8ToUint32(input, offset = 0, length) {
      if (length === void 0)
        length = input.length - offset >>> 2;
      return new Uint32Array(input.buffer, input.byteOffset + offset, length);
    }
    static uint8ToUint16(input, offset = 0, length) {
      if (length === void 0)
        length = input.length - offset >>> 1;
      return new Uint16Array(input.buffer, input.byteOffset + offset, length);
    }
    static uint8ToUint8(input, offset = 0, length) {
      if (length === void 0)
        length = input.length - offset;
      return new Uint8Array(input.buffer, input.byteOffset + offset, length);
    }
    static copy(input, inputPosition, output, outputPosition, length) {
      output.subarray(outputPosition, outputPosition + length).set(input.subarray(inputPosition, inputPosition + length));
    }
    static copyUint8ToUint32(from) {
      const to = new Uint32Array(from.length);
      for (let n = 0; n < to.length; n++)
        to[n] = from[n];
      return to;
    }
    static copyUint8ToUint32_rep(from) {
      const to = new Uint32Array(from.length);
      for (let n = 0; n < to.length; n++)
        to[n] = from[n] | from[n] << 8 | from[n] << 16 | from[n] << 24;
      return to;
    }
    static cloneUint8Array(input) {
      const out = new Uint8Array(input.length);
      out.set(input);
      return out;
    }
    static cloneUint16Array(input) {
      const out = new Uint16Array(input.length);
      out.set(input);
      return out;
    }
    static cloneInt16Array(input) {
      const out = new Int16Array(input.length);
      out.set(input);
      return out;
    }
    static cloneUint32Array(input) {
      const out = new Uint32Array(input.length);
      out.set(input);
      return out;
    }
    static concatU8(chunks) {
      const out = new Uint8Array(chunks.sum((chunk) => chunk.length));
      let offset = 0;
      chunks.forEach((chunk) => {
        out.set(chunk, offset);
        offset += chunk.length;
      });
      return out;
    }
    static concatI16(chunks) {
      const out = new Int16Array(chunks.sum((chunk) => chunk.length));
      let offset = 0;
      chunks.forEach((chunk) => {
        out.set(chunk, offset);
        offset += chunk.length;
      });
      return out;
    }
  };
  _self2["requestFileSystem"] = _self2["requestFileSystem"] || _self2["webkitRequestFileSystem"];
  function setToString(Enum, value) {
    const items = [];
    for (const key in Enum) {
      if (Enum[key] & value && (Enum[key] & value) == Enum[key]) {
        items.push(key);
      }
    }
    return items.join(" | ");
  }
  var AcceptCallbacks;
  (function(AcceptCallbacks2) {
    AcceptCallbacks2[AcceptCallbacks2["NO"] = 0] = "NO";
    AcceptCallbacks2[AcceptCallbacks2["YES"] = 1] = "YES";
  })(AcceptCallbacks || (AcceptCallbacks = {}));
  var Compensate;
  (function(Compensate2) {
    Compensate2[Compensate2["NO"] = 0] = "NO";
    Compensate2[Compensate2["YES"] = 1] = "YES";
  })(Compensate || (Compensate = {}));
  var WaitingThreadInfo = class {
    constructor(name2, object, promise, callbacks, compensate = 1) {
      this.name = name2;
      this.object = object;
      this.promise = promise;
      this.callbacks = callbacks;
      this.compensate = compensate;
    }
  };
  window.WaitingThreadInfo = WaitingThreadInfo;
  var DebugOnceArray = {};
  function DebugOnce(name2, times = 1) {
    if (DebugOnceArray[name2] >= times)
      return false;
    if (DebugOnceArray[name2]) {
      DebugOnceArray[name2]++;
    } else {
      DebugOnceArray[name2] = 1;
    }
    return true;
  }
  function isTouchDevice() {
    return "ontouchstart" in window;
  }
  var HalfFloat = class {
    static fromFloat(Float) {
      const i = MathFloat.reinterpretFloatAsInt(Float);
      const s = i >> 16 & 32768;
      const e = (i >> 23 & 255) - (127 - 15);
      let f = i >> 0 & 8388607;
      if (e <= 0) {
        if (e < -10) {
          if (s != 0) {
            return 32768;
          }
          return 0;
        }
        f = (f | 8388608) >> 1 - e;
        return s | f >> 13;
      } else if (e == 255 - (127 - 15)) {
        if (f == 0) {
          return s | 31744;
        }
        f >>= 13;
        return s | 31744 | f | (f == 0 ? 1 : 0);
      }
      if (e > 30) {
        return s | 31744;
      }
      return s | e << 10 | f >> 13;
    }
    static toFloat(imm16) {
      const s = imm16 >> 15 & 1;
      let e = imm16 >> 10 & 31;
      let f = imm16 >> 0 & 1023;
      if (e == 0) {
        if (f == 0) {
          return MathFloat.reinterpretIntAsFloat(s << 31);
        }
        while ((f & 1024) == 0) {
          f <<= 1;
          e -= 1;
        }
        e += 1;
        f &= ~1024;
      } else if (e == 31) {
        if (f == 0) {
          return MathFloat.reinterpretIntAsFloat(s << 31 | 2139095040);
        }
        return MathFloat.reinterpretIntAsFloat(s << 31 | 2139095040 | f << 13);
      }
      e = e + (127 - 15);
      f = f << 13;
      return MathFloat.reinterpretIntAsFloat(s << 31 | e << 23 | f);
    }
  };
  function mac2string(mac) {
    return sprintf("%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  }
  function string2mac(string) {
    const array = String(string).split(":").map((item) => parseInt(item, 16));
    while (array.length < 6)
      array.push(0);
    return new Uint8Array(array);
  }
  var Signal0Cancelable = class {
    constructor(signal, callback) {
      this.signal = signal;
      this.callback = callback;
    }
    cancel() {
      this.signal.remove(this.callback);
    }
  };
  var Signal1Cancelable = class {
    constructor(signal, callback) {
      this.signal = signal;
      this.callback = callback;
    }
    cancel() {
      this.signal.remove(this.callback);
    }
  };
  var Signal2Cancelable = class {
    constructor(signal, callback) {
      this.signal = signal;
      this.callback = callback;
    }
    cancel() {
      this.signal.remove(this.callback);
    }
  };
  var WatchValue = class {
    constructor(value) {
      this.onChanged = new Signal1();
      this._value = value;
    }
    waitUntilValueAsync(expectedValue) {
      if (this.value == expectedValue)
        return PromiseFast.resolve();
      return new PromiseFast((resolve, reject) => {
        let cancelable = this.onChanged.add((changed) => {
          if (changed == expectedValue) {
            cancelable.cancel();
            resolve();
          }
        });
      });
    }
    set value(value) {
      if (this._value == value)
        return;
      this._value = value;
      this.onChanged.dispatch(value);
    }
    get value() {
      return this._value;
    }
  };
  var Signal0 = class {
    constructor() {
      this.callbacks = [];
    }
    get length() {
      return this.callbacks.length;
    }
    clear() {
      this.callbacks = [];
    }
    pipeTo(other) {
      return this.add(() => other.dispatch());
    }
    add(callback) {
      this.callbacks.push(callback);
      return new Signal0Cancelable(this, callback);
    }
    remove(callback) {
      const index = this.callbacks.indexOf(callback);
      if (index >= 0) {
        this.callbacks.splice(index, 1);
      }
    }
    once(callback) {
      const once = () => {
        this.remove(once);
        callback();
      };
      this.add(once);
      return new Signal0Cancelable(this, once);
    }
    dispatch() {
      this.callbacks.forEach((callback) => {
        callback();
      });
    }
  };
  var Signal1 = class {
    constructor() {
      this.callbacks = [];
    }
    get length() {
      return this.callbacks.length;
    }
    clear() {
      this.callbacks = [];
    }
    pipeTo(other) {
      return this.add((v) => other.dispatch(v));
    }
    add(callback) {
      this.callbacks.push(callback);
      return new Signal1Cancelable(this, callback);
    }
    remove(callback) {
      const index = this.callbacks.indexOf(callback);
      if (index >= 0) {
        this.callbacks.splice(index, 1);
      }
    }
    once(callback) {
      const once = (v1) => {
        this.remove(once);
        callback(v1);
      };
      this.add(once);
      return new Signal1Cancelable(this, once);
    }
    dispatch(v1) {
      this.callbacks.forEach((callback) => {
        callback(v1);
      });
    }
  };
  var Signal2 = class {
    constructor() {
      this.callbacks = [];
    }
    get length() {
      return this.callbacks.length;
    }
    clear() {
      this.callbacks = [];
    }
    pipeTo(other) {
      return this.add((v1, v2) => other.dispatch(v1, v2));
    }
    add(callback) {
      this.callbacks.push(callback);
      return new Signal2Cancelable(this, callback);
    }
    remove(callback) {
      const index = this.callbacks.indexOf(callback);
      if (index >= 0) {
        this.callbacks.splice(index, 1);
      }
    }
    once(callback) {
      const once = (v1, v2) => {
        this.remove(once);
        callback(v1, v2);
      };
      this.add(once);
      return new Signal2Cancelable(this, once);
    }
    dispatch(v1, v2) {
      this.callbacks.forEach((callback) => {
        callback(v1, v2);
      });
    }
  };
  var SignalPromise = class {
    constructor() {
      this.callbacks = [];
    }
    get length() {
      return this.callbacks.length;
    }
    clear() {
      this.callbacks = [];
    }
    add(callback) {
      this.callbacks.push(callback);
      return this;
    }
    dispatchAsync(v1, v2, v3, v4, v5) {
      const promises = [];
      this.callbacks.forEach((callback) => {
        promises.push(callback(v1, v2, v3, v4, v5));
      });
      return Promise.all(promises);
    }
  };
  var LoggerLevel;
  (function(LoggerLevel2) {
    LoggerLevel2[LoggerLevel2["DEBUG"] = 0] = "DEBUG";
    LoggerLevel2[LoggerLevel2["LOG"] = 1] = "LOG";
    LoggerLevel2[LoggerLevel2["INFO"] = 2] = "INFO";
    LoggerLevel2[LoggerLevel2["WARN"] = 3] = "WARN";
    LoggerLevel2[LoggerLevel2["ERROR"] = 4] = "ERROR";
  })(LoggerLevel || (LoggerLevel = {}));
  var Logger = class {
    constructor(policy, console15, name2) {
      this.policy = policy;
      this.console = console15;
      this.name = name2;
    }
    named(name2) {
      return new Logger(this.policy, this.console, `${this.name}.${name2}`.replace(/^\.+/, ""));
    }
    _log(type, level, args) {
      if (this.policy.canLog(this.name, level)) {
        args.unshift(this.name + ":");
        if (this.console[type])
          this.console[type].apply(this.console, args);
      }
    }
    trace(...args) {
      this._log("debug", 0, args);
    }
    debug(...args) {
      this._log("debug", 0, args);
    }
    log(...args) {
      this._log("log", 1, args);
    }
    info(...args) {
      this._log("info", 2, args);
    }
    warn(...args) {
      this._log("warn", 3, args);
    }
    error(...args) {
      this._log("error", 4, args);
    }
    groupCollapsed(...args) {
      this._log("groupCollapsed", 5, args);
    }
    groupEnd(...args) {
      this._log("groupEnd", 5, args);
    }
    isEnabled(level) {
      return loggerPolicies.canLog(this.name, level);
    }
    get isTraceEnabled() {
      return this.isEnabled(0);
    }
    get isDebugEnabled() {
      return this.isEnabled(0);
    }
    get isLogEnabled() {
      return this.isEnabled(1);
    }
    get isInfoEnabled() {
      return this.isEnabled(2);
    }
    get isWarnEnabled() {
      return this.isEnabled(3);
    }
    get isErrorEnabled() {
      return this.isEnabled(4);
    }
    setMinLoggerLevel(level) {
      loggerPolicies.setNameMinLoggerLevel(this.name, level);
    }
  };
  var LoggerPolicies = class {
    constructor() {
      this.disableAll = false;
      this.minLogLevel = 1;
      this.namedLevels = {};
    }
    setNameMinLoggerLevel(name2, level) {
      this.namedLevels[name2] = level;
    }
    canLog(name2, level) {
      if (this.disableAll)
        return false;
      if (level < this.minLogLevel)
        return false;
      if (name2 in this.namedLevels && level < this.namedLevels[name2])
        return false;
      return true;
    }
  };
  var loggerPolicies = new LoggerPolicies();
  var logger = new Logger(loggerPolicies, console, "");
  window.loggerPolicies = loggerPolicies;
  window.logger = logger;
  function numberToSeparator(value) {
    return (+value).toLocaleString();
  }
  function numberToFileSize(value) {
    const KB = 1024;
    const MB = 1024 * KB;
    const GB = 1024 * MB;
    const TB = 1024 * GB;
    if (value >= GB * 0.5)
      return `${(value / GB).toFixed(2)} GB`;
    if (value >= MB * 0.5)
      return `${(value / MB).toFixed(2)} MB`;
    if (value >= KB * 0.5)
      return `${(value / KB).toFixed(2)} KB`;
    return `${value} B`;
  }
  function addressToHex(address) {
    return `0x${addressToHex2(address)}`;
  }
  function addressToHex2(address) {
    return `00000000${(address >>> 0).toString(16)}`.substr(-8);
  }
  Promise.prototype.promise = function() {
    return this;
  };
  Promise.prototype.thenFast = Promise.prototype.then;
  var PromiseFast = class {
    constructor(callback) {
      this._resolvedValue = null;
      this._rejectedValue = null;
      this._solved = false;
      this._resolvedCallbacks = [];
      this._rejectedCallbacks = [];
      this._rejectedPropagated = false;
      callback(this._resolve.bind(this), this._reject.bind(this));
    }
    promise() {
      if (this._promise) {
        return this._promise;
      }
      if (this._solved) {
        if (this._rejectedValue) {
          return Promise.reject(this._rejectedValue);
        } else {
          return Promise.resolve(this._resolvedValue);
        }
      }
      return new Promise((resolve, reject) => {
        this.thenFast(resolve, reject);
      });
    }
    static delay(timeoutMs, value) {
      return new PromiseFast((resolve, _) => {
        setTimeout(() => {
          resolve(value);
        }, timeoutMs);
      });
    }
    static resolve(value) {
      if (value instanceof Promise)
        return PromiseFast.fromPromise(value);
      if (value instanceof PromiseFast)
        return value;
      const result = new PromiseFast((resolve, _) => _);
      result._promise = Promise.resolve(value);
      result._solved = true;
      result._resolvedValue = value;
      return result;
    }
    static reject(error) {
      return new PromiseFast((resolve, reject) => reject(error));
    }
    static all(promises) {
      return new PromiseFast((resolve, reject) => {
        if (promises.length == 0)
          return resolve();
        let total = promises.length;
        const one = () => {
          total--;
          if (total <= 0)
            resolve();
        };
        const oneError = (e) => {
          reject(e);
        };
        for (let p of promises) {
          if (p instanceof PromiseFast) {
            p.thenFast(one, oneError);
          } else {
            one();
          }
        }
      });
    }
    static race(promises) {
      return new PromiseFast((resolve, reject) => {
        if (promises.length == 0)
          return resolve();
        for (let p of promises) {
          if (p instanceof PromiseFast) {
            p.thenFast(resolve, reject);
          } else {
            resolve();
            return;
          }
        }
      });
    }
    static ensure(object) {
      if (object instanceof PromiseFast)
        return object;
      if (object instanceof Promise)
        return PromiseFast.fromPromise(object);
      return PromiseFast.resolve(object);
    }
    static isPromise(object) {
      return object instanceof Promise || object instanceof PromiseFast;
    }
    static fromPromise(promise) {
      const promiseFast = this.fromThenable(promise);
      promiseFast._promise = promise;
      return promiseFast;
    }
    static fromThenable(thenable) {
      return new PromiseFast((resolve, reject) => {
        thenable.then((v) => resolve(v), (error) => reject(error));
      });
    }
    _resolve(value) {
      if (this._solved)
        return;
      this._resolvedValue = value;
      this._solved = true;
      this._queueCheck();
    }
    _reject(error) {
      if (this._solved)
        return;
      this._rejectedValue = error;
      this._solved = true;
      this._queueCheck();
    }
    then(resolved, rejected) {
      if (this._promise) {
        return PromiseFast.ensure(this._promise.then(resolved, rejected));
      }
      return this.thenFast(resolved, rejected);
    }
    thenFast(resolved, rejected) {
      const promise = new PromiseFast((resolve, reject) => {
        if (resolved) {
          this._resolvedCallbacks.push((a) => {
            try {
              const result = resolved(a);
              if (result instanceof PromiseFast) {
                result.thenFast(resolve, reject);
              } else {
                resolve(result);
              }
            } catch (e) {
              reject(e);
            }
          });
        } else {
          this._resolvedCallbacks.push(resolve);
        }
        if (rejected) {
          this._rejectedCallbacks.push((a) => {
            try {
              const result = rejected(a);
              if (result instanceof PromiseFast) {
                result.thenFast(resolve, reject);
              } else {
                resolve(result);
              }
            } catch (e) {
              reject(e);
            }
          });
        } else {
          this._rejectedCallbacks.push(reject);
        }
      });
      this._queueCheck();
      return promise;
    }
    catch(rejected) {
      return this.thenFast(null, rejected);
    }
    _queueCheck() {
      Microtask.queue(() => this._check());
    }
    _check() {
      if (!this._solved)
        return;
      if (this._rejectedValue != null) {
        while (this._rejectedCallbacks.length > 0) {
          this._rejectedPropagated = true;
          this._rejectedCallbacks.shift()(this._rejectedValue);
        }
        if (!this._rejectedPropagated) {
        }
      } else {
        while (this._resolvedCallbacks.length > 0)
          this._resolvedCallbacks.shift()(this._resolvedValue);
      }
    }
  };
  var DomHelp = class {
    constructor(e) {
      this.e = e;
    }
    get e2() {
      return this.e;
    }
    static fromId(e) {
      return new DomHelp(document.getElementById(e));
    }
    mousedown(callback) {
      return this.on("mousedown", callback);
    }
    mouseup(callback) {
      return this.on("mouseup", callback);
    }
    mousemove(callback) {
      return this.on("mousemove", callback);
    }
    click(callback) {
      if (callback == null)
        this.e.click();
      return this.on("click", callback);
    }
    showToggle() {
      if (this.e.style.visibility == "visible") {
        this.hide();
      } else {
        this.show();
      }
    }
    hide() {
      if (this.e)
        this.e.style.visibility = "hidden";
    }
    show() {
      if (this.e)
        this.e.style.visibility = "visible";
    }
    set width(value) {
      if (this.e)
        this.e.style.width = value + "px";
    }
    set height(value) {
      if (this.e)
        this.e.style.height = value + "px";
    }
    set top(value) {
      if (this.e)
        this.e.style.top = value + "px";
    }
    set left(value) {
      if (this.e)
        this.e.style.left = value + "px";
    }
    get position() {
      return {top: this.top, left: this.left};
    }
    get size() {
      return {width: this.width, height: this.height};
    }
    get width() {
      return this.e.offsetWidth || this.e2.innerWidth;
    }
    get height() {
      return this.e.offsetHeight || this.e2.innerHeight;
    }
    get top() {
      return this.e.offsetTop;
    }
    get left() {
      return this.e.offsetLeft;
    }
    get html() {
      return this.e ? this.e.innerHTML : "";
    }
    set html(value) {
      if (this.e)
        this.e.innerHTML = value;
    }
    val() {
      return this.e.innerText;
    }
    css(key, value) {
      this.e.style[key] = value;
      return this;
    }
    on(event, callback) {
      if (this.e)
        this.e.addEventListener(event, callback);
    }
    removeClass(clazz) {
      if (this.e)
        this.e.className = this.e.className.replace(clazz, "");
    }
    addClass(clazz) {
      if (this.e)
        this.e.className = `${this.e.className} ${clazz}`;
    }
    toggleClass(clazz, value) {
      if (value)
        this.addClass(clazz);
      else
        this.removeClass(clazz);
    }
  };
  var CpuBreakException = class extends Error {
    constructor() {
      super("CpuBreakException");
    }
    static is(v) {
      return v instanceof CpuBreakException;
    }
  };
  var InterruptBreakException = class extends Error {
    constructor() {
      super("InterruptBreakException");
    }
    static is(v) {
      return v instanceof InterruptBreakException;
    }
  };
  var ProgramExitException = class extends Error {
    constructor(message) {
      super(`ProgramExitException: ${message}`);
    }
    static is(v) {
      return v instanceof ProgramExitException;
    }
  };
  function throwWaitPromise(promise) {
    const error = new Error("WaitPromise");
    error.promise = promise;
    return error;
  }
  async function delay(ms) {
    await new Promise((resolve, _) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
  }
  function fields() {
    return new Proxy({}, {
      get: function(_target, prop, _receiver) {
        return prop;
      }
    });
  }
  window.sprintf = sprintf;
  window.throwWaitPromise = throwWaitPromise;
  window.PromiseFast = PromiseFast;
  window.DomHelp = DomHelp;

  // src/global/async.ts
  function waitAsync(timems, retval) {
    return new PromiseFast((resolve, reject) => {
      setTimeout(() => {
        resolve(retval);
      }, timems);
    });
  }
  function _downloadFileAsync(method, url, headers) {
    return new Promise((resolve, reject) => {
      const request = new XMLHttpRequest();
      request.open(method, url, true);
      request.overrideMimeType("text/plain; charset=x-user-defined");
      if (headers) {
        for (const headerKey in headers) {
          request.setRequestHeader(headerKey, headers[headerKey]);
        }
      }
      request.responseType = "arraybuffer";
      request.onerror = function(e) {
        reject(e["error"]);
      };
      request.onload = function(e) {
        if (request.status < 400) {
          resolve(request);
        } else {
          reject(new Error("HTTP " + request.status));
        }
      };
      request.send();
    });
  }
  function toArrayBuffer(buffer) {
    const ab = new ArrayBuffer(buffer.length);
    const view = new Uint8Array(ab);
    for (let i = 0; i < buffer.length; ++i) {
      view[i] = buffer[i];
    }
    return ab;
  }
  var isNodeJs = typeof XMLHttpRequest === "undefined";
  var fs = isNodeJs ? eval("require")("fs") : null;
  async function downloadFileAsync(url, headers) {
    if (isNodeJs) {
      return new Promise((resolve, reject) => {
        fs.readFile(url, (err, data) => {
          if (err) {
            reject(err);
          } else {
            resolve(toArrayBuffer(data));
          }
        });
      });
    } else {
      const request = await _downloadFileAsync("GET", url, headers);
      return request.response;
    }
  }
  function downloadFileChunkAsync(url, from, count) {
    let rangeString;
    if (count !== void 0) {
      const to = from + count - 1;
      rangeString = `bytes=${from}-${to}`;
    } else {
      rangeString = `bytes=${from}-`;
    }
    return downloadFileAsync(url, {
      Range: rangeString
    });
  }
  async function statFileAsync(url) {
    if (isNodeJs) {
      return new PromiseFast((resolve, reject) => {
        fs.stat(url, (err, stats) => {
          if (err) {
            reject(new Error(`File not found: '${url}'`));
          } else if (stats.isDirectory()) {
            reject(new Error(`File is a directory: '${url}'`));
          } else {
            resolve({size: stats.size, date: stats.mtime});
          }
        });
      });
    } else {
      const request = await _downloadFileAsync("HEAD", url);
      const size = parseInt(request.getResponseHeader("content-length") ?? "0");
      const date = new Date(Date.parse(request.getResponseHeader("last-modified") ?? ""));
      return {size, date};
    }
  }

  // src/global/int64.ts
  var _Integer64 = class {
    constructor(low, high) {
      this._low = low | 0;
      this._high = high | 0;
    }
    static fromInt(value) {
      return new _Integer64(value | 0, value < 0 ? -1 : 0);
    }
    static fromUnsignedInt(value) {
      return new _Integer64(value | 0, 0);
    }
    static fromBits(low, high) {
      return new _Integer64(low, high);
    }
    static fromNumber(value) {
      if (isNaN(value) || !isFinite(value)) {
        return _Integer64.ZERO;
      } else if (value <= -_Integer64._TWO_PWR_63_DBL) {
        return _Integer64.MIN_VALUE;
      } else if (value + 1 >= _Integer64._TWO_PWR_63_DBL) {
        return _Integer64.MAX_VALUE;
      } else if (value < 0) {
        return _Integer64.fromNumber(-value).negate();
      } else {
        return new _Integer64(value % _Integer64._TWO_PWR_32_DBL | 0, value / _Integer64._TWO_PWR_32_DBL | 0);
      }
    }
    get low() {
      return this._low;
    }
    get lowUnsigned() {
      return this._low >= 0 ? this._low : _Integer64._TWO_PWR_32_DBL + this._low;
    }
    get high() {
      return this._high;
    }
    get number() {
      return this._high * _Integer64._TWO_PWR_32_DBL + this.lowUnsigned;
    }
    getNumber() {
      return this._high * _Integer64._TWO_PWR_32_DBL + this.lowUnsigned;
    }
    equals(other) {
      return this._high == other._high && this._low == other._low;
    }
    negate() {
      if (this.equals(_Integer64.MIN_VALUE))
        return _Integer64.MIN_VALUE;
      return this.not().add(_Integer64.ONE);
    }
    not() {
      return _Integer64.fromBits(~this._low, ~this._high);
    }
    isZero() {
      return this._high == 0 && this._low == 0;
    }
    isNegative() {
      return this._high < 0;
    }
    isOdd() {
      return (this._low & 1) == 1;
    }
    sub(other) {
      return this.add(other.negate());
    }
    add(other) {
      const a48 = this._high >>> 16;
      const a32 = this._high & 65535;
      const a16 = this._low >>> 16;
      const a00 = this._low & 65535;
      const b48 = other._high >>> 16;
      const b32 = other._high & 65535;
      const b16 = other._low >>> 16;
      const b00 = other._low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return _Integer64.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    lessThan(other) {
      return this.compare(other) < 0;
    }
    compare(other) {
      if (this.equals(other)) {
        return 0;
      }
      const thisNeg = this.isNegative();
      const otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.sub(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    }
    isLowEnoughForMul() {
      if (this._high == 0 && this._low >>> 0 < _Integer64._TWO_PWR_23_DBL)
        return true;
      if (this._high == -1 && -this._low >>> 0 < _Integer64._TWO_PWR_23_DBL)
        return true;
      return false;
    }
    multiply(other) {
      if (this.isZero())
        return _Integer64.ZERO;
      if (other.isZero())
        return _Integer64.ZERO;
      if (this.isLowEnoughForMul() && other.isLowEnoughForMul()) {
        return _Integer64.fromNumber(this.getNumber() * other.getNumber());
      }
      if (this.equals(_Integer64.MIN_VALUE))
        return other.isOdd() ? _Integer64.MIN_VALUE : _Integer64.ZERO;
      if (other.equals(_Integer64.MIN_VALUE))
        return this.isOdd() ? _Integer64.MIN_VALUE : _Integer64.ZERO;
      if (this.isNegative()) {
        if (other.isNegative())
          return this.negate().multiply(other.negate());
        return this.negate().multiply(other).negate();
      }
      if (other.isNegative())
        return this.multiply(other.negate()).negate();
      const a48 = this._high >>> 16;
      const a32 = this._high & 65535;
      const a16 = this._low >>> 16;
      const a00 = this._low & 65535;
      const b48 = other._high >>> 16;
      const b32 = other._high & 65535;
      const b16 = other._low >>> 16;
      const b00 = other._low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return _Integer64.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
  };
  var Integer64 = _Integer64;
  Integer64.ZERO = _Integer64.fromInt(0);
  Integer64.ONE = _Integer64.fromInt(1);
  Integer64.MIN_VALUE = _Integer64.fromBits(0, 2147483648 | 0);
  Integer64.MAX_VALUE = _Integer64.fromBits(4294967295 | 0, 2147483647 | 0);
  Integer64._TWO_PWR_16_DBL = Math.pow(2, 16);
  Integer64._TWO_PWR_23_DBL = Math.pow(2, 23);
  Integer64._TWO_PWR_24_DBL = Math.pow(2, 24);
  Integer64._TWO_PWR_32_DBL = Math.pow(2, 32);
  Integer64._TWO_PWR_63_DBL = Math.pow(2, 63);
  Integer64._TWO_PWR_24 = _Integer64.fromInt(1 << 24);
  window.Integer64 = Integer64;

  // src/global/stream.ts
  var BaseAsyncStream = class {
    readChunkAsync(offset, count) {
      return PromiseFast.ensure(this.readChunkPromiseAsync(offset, count));
    }
  };
  var ProxyAsyncStream = class extends BaseAsyncStream {
    constructor(stream) {
      super();
      this.stream = stream;
    }
    get name() {
      return this.stream.name;
    }
    get date() {
      return this.stream.date;
    }
    get size() {
      return this.stream.size;
    }
    readChunkPromiseAsync(offset, count) {
      return this.stream.readChunkPromiseAsync(offset, count);
    }
  };
  var BufferedAsyncStream = class extends ProxyAsyncStream {
    constructor(stream, bufferSize = 131072) {
      super(stream);
      this.bufferSize = bufferSize;
      this.cache = {start: 0, end: 0, data: new ArrayBuffer(0)};
    }
    get name() {
      return this.stream.name + "+buffered";
    }
    getCachedEntry(start, end) {
      if (start >= this.cache.start && end <= this.cache.end) {
        return this.cache;
      } else {
        return null;
      }
    }
    putCacheEntry(start, data) {
      this.cache.start = start;
      this.cache.end = start + data.byteLength;
      this.cache.data = data;
    }
    async readChunkPromiseAsync(offset, count) {
      const availableFromOffset = this.size - offset;
      const start = offset;
      let end = offset + count;
      const cache = this.getCachedEntry(start, end);
      if (cache) {
        return cache.data.slice(start - cache.start, end - cache.start);
      } else {
        let bigCount = Math.max(count, this.bufferSize);
        bigCount = Math.min(bigCount, availableFromOffset);
        end = start + bigCount;
        const data = await this.stream.readChunkAsync(offset, bigCount);
        this.putCacheEntry(start, data);
        return this.readChunkPromiseAsync(offset, count);
      }
    }
  };
  var MemoryAsyncStream = class extends BaseAsyncStream {
    constructor(data, name2 = "memory", date = new Date()) {
      super();
      this.data = data;
      this.name = name2;
      this.date = date;
    }
    static fromArrayBuffer(data) {
      return new MemoryAsyncStream(data);
    }
    get size() {
      return this.data.byteLength;
    }
    async readChunkPromiseAsync(offset, count) {
      return this.data.slice(offset, offset + count);
    }
  };
  var UrlAsyncStream = class extends BaseAsyncStream {
    constructor(url, stat) {
      super();
      this.url = url;
      this.stat = stat;
      this.name = url;
      this.date = stat.date;
    }
    static async fromUrlAsync(url) {
      console.info("open ", url);
      const stat = await statFileAsync(url);
      console.info("fromUrlAsync", stat);
      if (stat.size == 0) {
        console.error("Invalid file with size '" + stat.size + "'", stat);
        throw new Error("Invalid file with size '" + stat.size + "'");
      }
      if (stat.size < 5 * 1024 * 1024) {
        const data = await downloadFileAsync(url);
        return MemoryAsyncStream.fromArrayBuffer(data);
      } else {
        return new BufferedAsyncStream(new UrlAsyncStream(url, stat));
      }
    }
    get size() {
      return this.stat.size;
    }
    async readChunkPromiseAsync(offset, count) {
      console.info("download chunk", this.url, `${offset}-${offset + count}`, "(" + count + ")");
      return downloadFileChunkAsync(this.url, offset, count);
    }
  };
  var FileAsyncStream = class extends BaseAsyncStream {
    constructor(file) {
      super();
      this.file = file;
      this.date = file.lastModifiedDate;
    }
    get name() {
      return this.file.name;
    }
    get size() {
      return this.file.size;
    }
    readChunkPromiseAsync(offset, count) {
      return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = (e) => {
          resolve(fileReader.result);
        };
        fileReader.onerror = (e) => {
          reject(e["error"]);
        };
        fileReader.readAsArrayBuffer(this.file.slice(offset, offset + count));
      });
    }
  };
  var _Stream = class {
    constructor(data, offset = 0) {
      this.data = data;
      this.offset = offset;
    }
    static fromArrayBuffer(data) {
      return new _Stream(new DataView(data));
    }
    static fromDataView(data, offset = 0) {
      return new _Stream(data);
    }
    static fromBase64(data) {
      const outstr = atob(data);
      const out = new ArrayBuffer(outstr.length);
      const ia = new Uint8Array(out);
      for (let n = 0; n < outstr.length; n++)
        ia[n] = outstr.charCodeAt(n);
      return new _Stream(new DataView(out));
    }
    static fromUint8Array(array) {
      return _Stream.fromArray(array);
    }
    static fromSize(size) {
      return _Stream.fromUint8Array(new Uint8Array(size));
    }
    static fromArray(array) {
      const buffer = new ArrayBuffer(array.length);
      const w8 = new Uint8Array(buffer);
      for (let n = 0; n < array.length; n++)
        w8[n] = array[n];
      return new _Stream(new DataView(buffer));
    }
    toImageUrl() {
      try {
        const urlCreator = window["URL"] || window["webkitURL"];
        const blob = new Blob([this.toUInt8Array()], {type: "image/jpeg"});
        return urlCreator.createObjectURL(blob);
      } catch (e) {
        return `data:image/png;base64,${this.toBase64()}`;
      }
    }
    toBase64() {
      let out = "";
      const array = this.toUInt8Array();
      for (let n = 0; n < array.length; n++) {
        out += String.fromCharCode(array[n]);
      }
      return btoa(out);
    }
    toStringAll() {
      return this.sliceWithLength(0).readString(this.length);
    }
    toUInt8Array() {
      return new Uint8Array(this.toArrayBuffer());
    }
    toArrayBuffer() {
      return this.data.buffer.slice(this.data.byteOffset, this.data.byteOffset + this.data.byteLength);
    }
    clone() {
      return this.sliceWithLowHigh(this.position, this.length);
    }
    slice() {
      return this.clone();
    }
    sliceFrom(low) {
      return this.sliceWithLength(low);
    }
    sliceWithLength(low, count) {
      if (count === void 0)
        count = this.length - low;
      return new _Stream(new DataView(this.data.buffer, this.data.byteOffset + low, count));
    }
    sliceWithLowHigh(low, high) {
      return new _Stream(new DataView(this.data.buffer, this.data.byteOffset + low, high - low));
    }
    get available() {
      return this.length - this.offset;
    }
    get length() {
      return this.data.byteLength;
    }
    set position(value) {
      this.offset = value;
    }
    get isNull() {
      return this.offset == 0;
    }
    get position() {
      return this.offset;
    }
    skipThis(count) {
      this.offset += count;
      return this;
    }
    skip(count, pass) {
      this.offset += count;
      return pass;
    }
    set(index, value) {
      this.data.setInt8(index, value);
      return this;
    }
    get(index) {
      return this.data.getUint8(index);
    }
    readInt8LE() {
      return this.readInt8(Endian.LITTLE);
    }
    readInt16LE() {
      return this.readInt16(Endian.LITTLE);
    }
    readInt32LE() {
      return this.readInt32(Endian.LITTLE);
    }
    readInt64LE() {
      return this.readInt64(Endian.LITTLE);
    }
    readFloat32LE() {
      return this.readFloat32(Endian.LITTLE);
    }
    readUInt8LE() {
      return this.readUInt8(Endian.LITTLE);
    }
    readUInt16LE() {
      return this.readUInt16(Endian.LITTLE);
    }
    readUInt32LE() {
      return this.readUInt32(Endian.LITTLE);
    }
    readInt8BE() {
      return this.readInt8(Endian.BIG);
    }
    readInt16BE() {
      return this.readInt16(Endian.BIG);
    }
    readInt32BE() {
      return this.readInt32(Endian.BIG);
    }
    readInt64BE() {
      return this.readInt64(Endian.BIG);
    }
    readFloat32BE() {
      return this.readFloat32(Endian.BIG);
    }
    readUInt8BE() {
      return this.readUInt8(Endian.BIG);
    }
    readUInt16BE() {
      return this.readUInt16(Endian.BIG);
    }
    readUInt32BE() {
      return this.readUInt32(Endian.BIG);
    }
    readInt8(endian = Endian.LITTLE) {
      return this.skip(1, this.data.getInt8(this.offset));
    }
    readInt16(endian = Endian.LITTLE) {
      return this.skip(2, this.data.getInt16(this.offset, endian == Endian.LITTLE));
    }
    readInt32(endian = Endian.LITTLE) {
      return this.skip(4, this.data.getInt32(this.offset, endian == Endian.LITTLE));
    }
    readInt64(endian = Endian.LITTLE) {
      const items = [this.readUInt32(endian), this.readUInt32(endian)];
      const low = items[endian == Endian.LITTLE ? 0 : 1];
      const high = items[endian == Endian.LITTLE ? 1 : 0];
      return Integer64.fromBits(low, high);
    }
    readFloat32(endian = Endian.LITTLE) {
      return this.skip(4, this.data.getFloat32(this.offset, endian == Endian.LITTLE));
    }
    readUInt8(endian = Endian.LITTLE) {
      return this.skip(1, this.data.getUint8(this.offset));
    }
    readUInt16(endian = Endian.LITTLE) {
      return this.skip(2, this.data.getUint16(this.offset, endian == Endian.LITTLE));
    }
    readUInt32(endian = Endian.LITTLE) {
      return this.skip(4, this.data.getUint32(this.offset, endian == Endian.LITTLE));
    }
    readStruct(struct) {
      return struct.read(this);
    }
    copyTo(other) {
      other.writeBytes(this.readBytes(this.available));
    }
    writeByteRepeated(value, count = -1) {
      let n;
      if (count < 0)
        count = this.available;
      for (n = 0; n < count; n++)
        this.data.setInt8(this.offset + n, value);
      this.skip(n);
      return this;
    }
    writeInt8LE(value) {
      return this.writeInt8(value, Endian.LITTLE);
    }
    writeInt16LE(value) {
      return this.writeInt16(value, Endian.LITTLE);
    }
    writeInt32LE(value) {
      return this.writeInt32(value, Endian.LITTLE);
    }
    writeInt64LE(value) {
      return this.writeInt64(value, Endian.LITTLE);
    }
    writeFloat32LE(value) {
      return this.writeFloat32(value, Endian.LITTLE);
    }
    writeUInt8LE(value) {
      return this.writeUInt8(value, Endian.LITTLE);
    }
    writeUInt16LE(value) {
      return this.writeUInt16(value, Endian.LITTLE);
    }
    writeUInt32LE(value) {
      return this.writeUInt32(value, Endian.LITTLE);
    }
    writeUInt64LE(value) {
      return this.writeUInt64(value, Endian.LITTLE);
    }
    writeInt8BE(value) {
      return this.writeInt8(value, Endian.BIG);
    }
    writeInt16BE(value) {
      return this.writeInt16(value, Endian.BIG);
    }
    writeInt32BE(value) {
      return this.writeInt32(value, Endian.BIG);
    }
    writeInt64BE(value) {
      return this.writeInt64(value, Endian.BIG);
    }
    writeFloat32BE(value) {
      return this.writeFloat32(value, Endian.BIG);
    }
    writeUInt8BE(value) {
      return this.writeUInt8(value, Endian.BIG);
    }
    writeUInt16BE(value) {
      return this.writeUInt16(value, Endian.BIG);
    }
    writeUInt32BE(value) {
      return this.writeUInt32(value, Endian.BIG);
    }
    writeUInt64BE(value) {
      return this.writeUInt64(value, Endian.BIG);
    }
    writeInt8(value, endian = Endian.LITTLE) {
      this.ensure(1);
      this.data.setInt8(this.offset, value);
      return this.skip(1, this);
    }
    writeInt16(value, endian = Endian.LITTLE) {
      this.ensure(2);
      this.data.setInt16(this.offset, value, endian == Endian.LITTLE);
      return this.skip(2, this);
    }
    writeInt32(value, endian = Endian.LITTLE) {
      this.ensure(4);
      this.data.setInt32(this.offset, value, endian == Endian.LITTLE);
      return this.skip(4, this);
    }
    writeInt64(value, endian = Endian.LITTLE) {
      this.ensure(8);
      return this._writeUInt64(value, endian);
    }
    writeFloat32(value, endian = Endian.LITTLE) {
      this.ensure(4);
      this.data.setFloat32(this.offset, value, endian == Endian.LITTLE);
      return this.skip(4, this);
    }
    writeUInt8(value, endian = Endian.LITTLE) {
      this.ensure(1);
      this.data.setUint8(this.offset, value);
      return this.skip(1, this);
    }
    writeUInt16(value, endian = Endian.LITTLE) {
      this.ensure(2);
      this.data.setUint16(this.offset, value, endian == Endian.LITTLE);
      return this.skip(2, this);
    }
    writeUInt32(value, endian = Endian.LITTLE) {
      this.ensure(4);
      this.data.setUint32(this.offset, value, endian == Endian.LITTLE);
      return this.skip(4, this);
    }
    writeUInt64(value, endian = Endian.LITTLE) {
      this.ensure(8);
      return this._writeUInt64(value, endian);
    }
    _writeUInt64(value, endian = Endian.LITTLE) {
      this.writeUInt32(endian == Endian.LITTLE ? value.low : value.high, endian);
      this.writeUInt32(endian == Endian.LITTLE ? value.high : value.low, endian);
      return this;
    }
    writeStruct(struct, value) {
      struct.write(this, value);
    }
    writeStream(stream) {
      return this.writeBytes(stream.slice().readBytes(stream.available));
    }
    writeString(str) {
      try {
        str.split("").forEach((char) => {
          this.writeUInt8(char.charCodeAt(0));
        });
      } catch (e) {
        console.log("Can't write string '" + str + "'");
        debugger;
        console.warn(this.data);
        console.error(e);
        throw e;
      }
    }
    writeStringz(str) {
      return this.writeString(str + String.fromCharCode(0));
    }
    ensure(count) {
      if (count > this.available) {
        throw new Error("Trying to write outside");
      }
    }
    writeBytes(data) {
      this.ensure(data.length);
      const out = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      out.set(data, this.offset);
      this.skip(data.length);
    }
    readBytes(count) {
      return this.skip(count, new Uint8Array(this.data.buffer, this.data.byteOffset + this.offset, count));
    }
    readBytesCloned(count) {
      const inp = this.readBytes(count);
      const out = new Uint8Array(inp.length);
      out.set(inp);
      return out;
    }
    readAllBytes() {
      return this.readBytes(this.available);
    }
    readInt16Array(count) {
      return this.skip(count, new Int16Array(this.data.buffer, this.data.byteOffset + this.offset, count));
    }
    readFloat32Array(count) {
      return new Float32Array(this.readBytes(count));
    }
    readStream(count) {
      return _Stream.fromUint8Array(this.readBytes(count));
    }
    readUtf8String(count) {
      return Utf8.decode(this.readString(count));
    }
    readString(count) {
      if (count > 1 * 1024 * 1024)
        throw new Error("Trying to read a string larger than 128KB");
      let str = "";
      for (let n = 0; n < count; n++) {
        str += String.fromCharCode(this.readUInt8());
      }
      return str;
    }
    readUtf8Stringz(maxCount = 131072) {
      return Utf8.decode(this.readStringz(maxCount));
    }
    readStringz(maxCount = 131072) {
      let str = "";
      for (let n = 0; n < maxCount; n++) {
        if (this.available <= 0)
          break;
        const char = this.readUInt8();
        if (char == 0)
          break;
        str += String.fromCharCode(char);
      }
      return str;
    }
  };
  var Stream = _Stream;
  Stream.INVALID = _Stream.fromArray([]);

  // src/global/struct.ts
  var Int64Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      let low;
      let high;
      if (this.endian == Endian.LITTLE) {
        low = stream.readUInt32(this.endian);
        high = stream.readUInt32(this.endian);
      } else {
        high = stream.readUInt32(this.endian);
        low = stream.readUInt32(this.endian);
      }
      return high * Math.pow(2, 32) + low;
    }
    write(stream, value) {
      const low = Math.floor(value % Math.pow(2, 32));
      const high = Math.floor(value / Math.pow(2, 32));
      if (this.endian == Endian.LITTLE) {
        stream.writeInt32(low, this.endian);
        stream.writeInt32(high, this.endian);
      } else {
        stream.writeInt32(high, this.endian);
        stream.writeInt32(low, this.endian);
      }
    }
    get length() {
      return 8;
    }
  };
  var Integer64Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      let high;
      let low;
      if (this.endian == Endian.LITTLE) {
        low = stream.readUInt32(this.endian);
        high = stream.readUInt32(this.endian);
      } else {
        high = stream.readUInt32(this.endian);
        low = stream.readUInt32(this.endian);
      }
      return new Integer64(low, high);
    }
    write(stream, value) {
      const low = value.low;
      const high = value.high;
      if (this.endian == Endian.LITTLE) {
        stream.writeInt32(low, this.endian);
        stream.writeInt32(high, this.endian);
      } else {
        stream.writeInt32(high, this.endian);
        stream.writeInt32(low, this.endian);
      }
    }
    get length() {
      return 8;
    }
  };
  var Int32Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readInt32(this.endian);
    }
    write(stream, value) {
      stream.writeInt32(value, this.endian);
    }
    get length() {
      return 4;
    }
  };
  var Int16Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readInt16(this.endian);
    }
    write(stream, value) {
      stream.writeInt16(value, this.endian);
    }
    get length() {
      return 2;
    }
  };
  var Int8Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readInt8(this.endian);
    }
    write(stream, value) {
      stream.writeInt8(value, this.endian);
    }
    get length() {
      return 1;
    }
  };
  var UInt32Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readUInt32(this.endian);
    }
    write(stream, value) {
      stream.writeUInt32(value, this.endian);
    }
    get length() {
      return 4;
    }
  };
  var PtrType = class {
    read(stream) {
      return stream.readUInt32LE();
    }
    write(stream, value) {
      stream.writeUInt32LE(value);
    }
    get length() {
      return 4;
    }
  };
  var UInt16Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readUInt16(this.endian);
    }
    write(stream, value) {
      stream.writeUInt16(value, this.endian);
    }
    get length() {
      return 2;
    }
  };
  var UInt8Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readUInt8(this.endian);
    }
    write(stream, value) {
      stream.writeUInt8(value, this.endian);
    }
    get length() {
      return 1;
    }
  };
  var Float32Type = class {
    constructor(endian) {
      this.endian = endian;
    }
    read(stream) {
      return stream.readFloat32(this.endian);
    }
    write(stream, value) {
      stream.writeFloat32(value, this.endian);
    }
    get length() {
      return 4;
    }
  };
  var StructClass = class {
    constructor(_class, items) {
      this._class = _class;
      this.items = items;
      this.processedItems = [];
      for (const item of items) {
        let add = 0;
        for (const key in item) {
          this.addItem(key, item[key]);
          add++;
        }
        if (!add)
          throw new Error("Entry must have one item");
      }
    }
    addItem(name2, type) {
      this.processedItems.push({name: name2, type});
    }
    static create(_class, items) {
      return new StructClass(_class, items);
    }
    createProxy(stream) {
      stream = stream.clone();
      const objectf = function(stream2) {
      };
      const object = new objectf(stream);
      this.processedItems.forEach((item) => {
        const getOffset = () => {
          return this.offsetOfField(item.name);
        };
        if (item.type instanceof StructClass) {
          object[item.name] = item.type.createProxy(stream.sliceFrom(getOffset()));
        } else {
          Object.defineProperty(objectf.prototype, item.name, {
            enumerable: true,
            configurable: true,
            get: () => {
              return item.type.read(stream.sliceFrom(getOffset()));
            },
            set: (value) => {
              item.type.write(stream.sliceFrom(getOffset()), value);
            }
          });
        }
      });
      return object;
    }
    async readWriteAsync(stream, callback, process3) {
      const p = this.read(stream.clone());
      const v = await callback(p);
      if (process3 != null)
        process3(p, v);
      this.write(stream.clone(), p);
      return v;
    }
    read(stream) {
      const _class = this._class;
      const out = new _class();
      for (let n = 0; n < this.processedItems.length; n++) {
        const item = this.processedItems[n];
        out[item.name] = item.type.read(stream, out);
      }
      return out;
    }
    write(stream, value) {
      for (let n = 0; n < this.processedItems.length; n++) {
        const item = this.processedItems[n];
        item.type.write(stream, value[item.name], value);
      }
    }
    offsetOfField(name2) {
      let offset = 0;
      for (let n = 0; n < this.processedItems.length; n++) {
        const item = this.processedItems[n];
        if (item.name == name2)
          return offset;
        offset += item.type.length;
      }
      return -1;
    }
    get length() {
      let sum = 0;
      for (let n = 0; n < this.processedItems.length; n++) {
        const item = this.processedItems[n];
        if (!item)
          throw "Invalid item!!";
        if (!item.type) {
          console.log(item);
          throw "Invalid item type!!";
        }
        sum += item.type.length;
      }
      return sum;
    }
  };
  var StructArrayClass = class {
    constructor(elementType, count) {
      this.elementType = elementType;
      this.count = count;
    }
    read(stream) {
      const out = [];
      for (let n = 0; n < this.count; n++) {
        out.push(this.elementType.read(stream, out));
      }
      return out;
    }
    write(stream, value) {
      for (let n = 0; n < this.count; n++)
        this.elementType.write(stream, value[n], value);
    }
    get length() {
      return this.elementType.length * this.count;
    }
  };
  function StructArray(elementType, count) {
    return new StructArrayClass(elementType, count);
  }
  var StructStringn = class {
    constructor(count) {
      this.count = count;
    }
    read(stream) {
      let out = "";
      for (let n = 0; n < this.count; n++) {
        out += String.fromCharCode(stream.readUInt8());
      }
      return out;
    }
    write(stream, value) {
      throw "Not implemented StructStringn.write";
    }
    get length() {
      return this.count;
    }
  };
  var StructStringz = class {
    constructor(count, readTransformer, writeTransformer) {
      this.count = count;
      this.readTransformer = readTransformer;
      this.writeTransformer = writeTransformer;
      this.stringn = new StructStringn(count);
    }
    read(stream) {
      let value = this.stringn.read(stream).split(String.fromCharCode(0))[0];
      if (this.readTransformer)
        value = this.readTransformer(value);
      return value;
    }
    write(stream, value) {
      if (this.writeTransformer)
        value = this.writeTransformer(value);
      if (!value)
        value = "";
      const items = value.split("").map((char) => char.charCodeAt(0));
      while (items.length < this.count)
        items.push(0);
      for (let n = 0; n < items.length; n++)
        stream.writeUInt8(items[n]);
    }
    get length() {
      return this.count;
    }
  };
  var StructStringzVariable = class {
    constructor() {
    }
    read(stream) {
      return stream.readStringz();
    }
    write(stream, value) {
      stream.writeString(value);
      stream.writeUInt8(0);
    }
    get length() {
      return 0;
    }
  };
  var UInt32_2lbStruct = class {
    read(stream) {
      const l = stream.readUInt32(Endian.LITTLE);
      const b = stream.readUInt32(Endian.BIG);
      return l;
    }
    write(stream, value) {
      stream.writeUInt32(value, Endian.LITTLE);
      stream.writeUInt32(value, Endian.BIG);
    }
    get length() {
      return 8;
    }
  };
  var UInt16_2lbStruct = class {
    read(stream) {
      const l = stream.readUInt16(Endian.LITTLE);
      const b = stream.readUInt16(Endian.BIG);
      return l;
    }
    write(stream, value) {
      stream.writeUInt16(value, Endian.LITTLE);
      stream.writeUInt16(value, Endian.BIG);
    }
    get length() {
      return 4;
    }
  };
  var StructStringWithSize = class {
    constructor(getStringSize) {
      this.getStringSize = getStringSize;
    }
    read(stream, context) {
      return stream.readString(this.getStringSize(context));
    }
    write(stream, value, context) {
      stream.writeString(value);
    }
    get length() {
      return 0;
    }
  };
  var Int16 = new Int16Type(Endian.LITTLE);
  var Int32 = new Int32Type(Endian.LITTLE);
  var Int64 = new Int64Type(Endian.LITTLE);
  var Int8 = new Int8Type(Endian.LITTLE);
  var Int16_l = new Int16Type(Endian.LITTLE);
  var Int32_l = new Int32Type(Endian.LITTLE);
  var Int64_l = new Int64Type(Endian.LITTLE);
  var Int8_l = new Int8Type(Endian.LITTLE);
  var Int16_b = new Int16Type(Endian.BIG);
  var Int32_b = new Int32Type(Endian.BIG);
  var Int64_b = new Int64Type(Endian.BIG);
  var Int8_b = new Int8Type(Endian.BIG);
  var UInt8 = new UInt8Type(Endian.LITTLE);
  var UInt16 = new UInt16Type(Endian.LITTLE);
  var UInt32 = new UInt32Type(Endian.LITTLE);
  var Ptr = new PtrType();
  var Float32 = new Float32Type(Endian.LITTLE);
  var UInt16_l = new UInt16Type(Endian.LITTLE);
  var UInt32_l = new UInt32Type(Endian.LITTLE);
  var UInt16_b = new UInt16Type(Endian.BIG);
  var UInt32_b = new UInt32Type(Endian.BIG);
  var UInt32_2lb = new UInt32_2lbStruct();
  var UInt16_2lb = new UInt16_2lbStruct();
  var Integer64_l = new Integer64Type(Endian.LITTLE);
  var Integer64_b = new Integer64Type(Endian.BIG);
  var StringzVariable = new StructStringzVariable();
  function Stringn(count) {
    return new StructStringn(count);
  }
  function Stringz(count) {
    return new StructStringz(count);
  }
  function Utf8Stringz(count) {
    return new StructStringz(count, (s) => Utf8.decode(s), (s) => Utf8.encode(s));
  }
  function StringWithSize(callback) {
    return new StructStringWithSize(callback);
  }
  var Pointer = class {
    constructor(type, memory2, address) {
      this.type = type;
      this.memory = memory2;
      this.address = address;
      this.stream = memory2.getPointerStream(this.address);
    }
    readWrite(callback) {
      const value = this.read();
      try {
        callback(value);
      } finally {
        this.write(value);
      }
    }
    read() {
      return this.type.read(this.stream.clone());
    }
    write(value) {
      this.type.write(this.stream.clone(), value);
    }
  };
  function StructMember(kind) {
    return (target, key, descriptor) => {
      if (!target.$$struct) {
        target.$$struct = StructClass.create(target.constructor, []);
      }
      target.$$struct.addItem(key, kind);
      return descriptor;
    };
  }
  var StructUInt8 = StructMember(UInt8);
  var StructInt8 = StructMember(Int8);
  var StructUInt16 = StructMember(UInt16);
  var StructInt16 = StructMember(Int16);
  var StructInt32 = StructMember(Int32);
  var StructUInt32 = StructMember(UInt32);
  var StructUInt32_2lb = StructMember(UInt32_2lb);
  var StructUInt16_2lb = StructMember(UInt16_2lb);
  var StructInt32_l = StructMember(Int32_l);
  var StructUInt32_l = StructMember(UInt32_l);
  var StructInt32_b = StructMember(Int32_b);
  var StructUInt32_b = StructMember(UInt32_b);
  var StructInt64 = StructMember(Int64);
  var StructInteger64_l = StructMember(Integer64_l);
  var StructInteger64_b = StructMember(Integer64_b);
  var StructStructStringzVariable = StructMember(StringzVariable);
  function StructStructStringn(count) {
    return StructMember(Stringn(count));
  }
  function StructStructStringz(count) {
    return StructMember(Stringz(count));
  }
  function StructStructUtf8Stringz(count) {
    return StructMember(Utf8Stringz(count));
  }
  function StructStructArray(elementType, count) {
    return StructMember(StructArray(elementType, count));
  }
  var Struct = class {
    static get struct() {
      return GetStruct(this);
    }
  };
  function GetStruct(clazz) {
    return clazz.prototype.$$struct || clazz.struct;
  }

  // src/emu/global.ts
  function globalReferenced() {
    return true;
  }

  // src/core/gpu/webgl/webgl_enums.ts
  var GL;
  (function(GL2) {
    GL2[GL2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GL2[GL2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GL2[GL2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    GL2[GL2["POINTS"] = 0] = "POINTS";
    GL2[GL2["LINES"] = 1] = "LINES";
    GL2[GL2["LINE_LOOP"] = 2] = "LINE_LOOP";
    GL2[GL2["LINE_STRIP"] = 3] = "LINE_STRIP";
    GL2[GL2["TRIANGLES"] = 4] = "TRIANGLES";
    GL2[GL2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GL2[GL2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    GL2[GL2["ZERO"] = 0] = "ZERO";
    GL2[GL2["ONE"] = 1] = "ONE";
    GL2[GL2["SRC_COLOR"] = 768] = "SRC_COLOR";
    GL2[GL2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GL2[GL2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GL2[GL2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GL2[GL2["DST_ALPHA"] = 772] = "DST_ALPHA";
    GL2[GL2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GL2[GL2["DST_COLOR"] = 774] = "DST_COLOR";
    GL2[GL2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GL2[GL2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GL2[GL2["BYTE"] = 5120] = "BYTE";
    GL2[GL2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL2[GL2["SHORT"] = 5122] = "SHORT";
    GL2[GL2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL2[GL2["INT"] = 5124] = "INT";
    GL2[GL2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL2[GL2["FLOAT"] = 5126] = "FLOAT";
    GL2[GL2["NEVER"] = 512] = "NEVER";
    GL2[GL2["LESS"] = 513] = "LESS";
    GL2[GL2["EQUAL"] = 514] = "EQUAL";
    GL2[GL2["LEQUAL"] = 515] = "LEQUAL";
    GL2[GL2["GREATER"] = 516] = "GREATER";
    GL2[GL2["NOTEQUAL"] = 517] = "NOTEQUAL";
    GL2[GL2["GEQUAL"] = 518] = "GEQUAL";
    GL2[GL2["ALWAYS"] = 519] = "ALWAYS";
    GL2[GL2["KEEP"] = 7680] = "KEEP";
    GL2[GL2["REPLACE"] = 7681] = "REPLACE";
    GL2[GL2["INCR"] = 7682] = "INCR";
    GL2[GL2["DECR"] = 7683] = "DECR";
    GL2[GL2["INVERT"] = 5386] = "INVERT";
    GL2[GL2["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GL2[GL2["DECR_WRAP"] = 34056] = "DECR_WRAP";
    GL2[GL2["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GL2[GL2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GL2[GL2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GL2[GL2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GL2[GL2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GL2[GL2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    GL2[GL2["NO_ERROR"] = 0] = "NO_ERROR";
    GL2[GL2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GL2[GL2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GL2[GL2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GL2[GL2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GL2[GL2["REPEAT"] = 10497] = "REPEAT";
    GL2[GL2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GL2[GL2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(GL || (GL = {}));
  var ClearBufferSet;
  (function(ClearBufferSet2) {
    ClearBufferSet2[ClearBufferSet2["ColorBuffer"] = 1] = "ColorBuffer";
    ClearBufferSet2[ClearBufferSet2["StencilBuffer"] = 2] = "StencilBuffer";
    ClearBufferSet2[ClearBufferSet2["DepthBuffer"] = 4] = "DepthBuffer";
    ClearBufferSet2[ClearBufferSet2["FastClear"] = 16] = "FastClear";
  })(ClearBufferSet || (ClearBufferSet = {}));

  // src/core/gpu/gpu_opcodes.ts
  var GpuOpCodes;
  (function(GpuOpCodes2) {
    GpuOpCodes2[GpuOpCodes2["NOP"] = 0] = "NOP";
    GpuOpCodes2[GpuOpCodes2["VADDR"] = 1] = "VADDR";
    GpuOpCodes2[GpuOpCodes2["IADDR"] = 2] = "IADDR";
    GpuOpCodes2[GpuOpCodes2["Unknown0x03"] = 3] = "Unknown0x03";
    GpuOpCodes2[GpuOpCodes2["PRIM"] = 4] = "PRIM";
    GpuOpCodes2[GpuOpCodes2["BEZIER"] = 5] = "BEZIER";
    GpuOpCodes2[GpuOpCodes2["SPLINE"] = 6] = "SPLINE";
    GpuOpCodes2[GpuOpCodes2["BOUNDINGBOX"] = 7] = "BOUNDINGBOX";
    GpuOpCodes2[GpuOpCodes2["JUMP"] = 8] = "JUMP";
    GpuOpCodes2[GpuOpCodes2["BJUMP"] = 9] = "BJUMP";
    GpuOpCodes2[GpuOpCodes2["CALL"] = 10] = "CALL";
    GpuOpCodes2[GpuOpCodes2["RET"] = 11] = "RET";
    GpuOpCodes2[GpuOpCodes2["END"] = 12] = "END";
    GpuOpCodes2[GpuOpCodes2["Unknown0x0D"] = 13] = "Unknown0x0D";
    GpuOpCodes2[GpuOpCodes2["SIGNAL"] = 14] = "SIGNAL";
    GpuOpCodes2[GpuOpCodes2["FINISH"] = 15] = "FINISH";
    GpuOpCodes2[GpuOpCodes2["BASE"] = 16] = "BASE";
    GpuOpCodes2[GpuOpCodes2["Unknown0x11"] = 17] = "Unknown0x11";
    GpuOpCodes2[GpuOpCodes2["VERTEXTYPE"] = 18] = "VERTEXTYPE";
    GpuOpCodes2[GpuOpCodes2["OFFSETADDR"] = 19] = "OFFSETADDR";
    GpuOpCodes2[GpuOpCodes2["ORIGIN"] = 20] = "ORIGIN";
    GpuOpCodes2[GpuOpCodes2["REGION1"] = 21] = "REGION1";
    GpuOpCodes2[GpuOpCodes2["REGION2"] = 22] = "REGION2";
    GpuOpCodes2[GpuOpCodes2["LIGHTINGENABLE"] = 23] = "LIGHTINGENABLE";
    GpuOpCodes2[GpuOpCodes2["LIGHTENABLE0"] = 24] = "LIGHTENABLE0";
    GpuOpCodes2[GpuOpCodes2["LIGHTENABLE1"] = 25] = "LIGHTENABLE1";
    GpuOpCodes2[GpuOpCodes2["LIGHTENABLE2"] = 26] = "LIGHTENABLE2";
    GpuOpCodes2[GpuOpCodes2["LIGHTENABLE3"] = 27] = "LIGHTENABLE3";
    GpuOpCodes2[GpuOpCodes2["CLIPENABLE"] = 28] = "CLIPENABLE";
    GpuOpCodes2[GpuOpCodes2["CULLFACEENABLE"] = 29] = "CULLFACEENABLE";
    GpuOpCodes2[GpuOpCodes2["TEXTUREMAPENABLE"] = 30] = "TEXTUREMAPENABLE";
    GpuOpCodes2[GpuOpCodes2["FOGENABLE"] = 31] = "FOGENABLE";
    GpuOpCodes2[GpuOpCodes2["DITHERENABLE"] = 32] = "DITHERENABLE";
    GpuOpCodes2[GpuOpCodes2["ALPHABLENDENABLE"] = 33] = "ALPHABLENDENABLE";
    GpuOpCodes2[GpuOpCodes2["ALPHATESTENABLE"] = 34] = "ALPHATESTENABLE";
    GpuOpCodes2[GpuOpCodes2["ZTESTENABLE"] = 35] = "ZTESTENABLE";
    GpuOpCodes2[GpuOpCodes2["STENCILTESTENABLE"] = 36] = "STENCILTESTENABLE";
    GpuOpCodes2[GpuOpCodes2["ANTIALIASENABLE"] = 37] = "ANTIALIASENABLE";
    GpuOpCodes2[GpuOpCodes2["PATCHCULLENABLE"] = 38] = "PATCHCULLENABLE";
    GpuOpCodes2[GpuOpCodes2["COLORTESTENABLE"] = 39] = "COLORTESTENABLE";
    GpuOpCodes2[GpuOpCodes2["LOGICOPENABLE"] = 40] = "LOGICOPENABLE";
    GpuOpCodes2[GpuOpCodes2["Unknown0x29"] = 41] = "Unknown0x29";
    GpuOpCodes2[GpuOpCodes2["BONEMATRIXNUMBER"] = 42] = "BONEMATRIXNUMBER";
    GpuOpCodes2[GpuOpCodes2["BONEMATRIXDATA"] = 43] = "BONEMATRIXDATA";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT0"] = 44] = "MORPHWEIGHT0";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT1"] = 45] = "MORPHWEIGHT1";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT2"] = 46] = "MORPHWEIGHT2";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT3"] = 47] = "MORPHWEIGHT3";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT4"] = 48] = "MORPHWEIGHT4";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT5"] = 49] = "MORPHWEIGHT5";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT6"] = 50] = "MORPHWEIGHT6";
    GpuOpCodes2[GpuOpCodes2["MORPHWEIGHT7"] = 51] = "MORPHWEIGHT7";
    GpuOpCodes2[GpuOpCodes2["Unknown0x34"] = 52] = "Unknown0x34";
    GpuOpCodes2[GpuOpCodes2["Unknown0x35"] = 53] = "Unknown0x35";
    GpuOpCodes2[GpuOpCodes2["PATCHDIVISION"] = 54] = "PATCHDIVISION";
    GpuOpCodes2[GpuOpCodes2["PATCHPRIMITIVE"] = 55] = "PATCHPRIMITIVE";
    GpuOpCodes2[GpuOpCodes2["PATCHFACING"] = 56] = "PATCHFACING";
    GpuOpCodes2[GpuOpCodes2["Unknown0x39"] = 57] = "Unknown0x39";
    GpuOpCodes2[GpuOpCodes2["WORLDMATRIXNUMBER"] = 58] = "WORLDMATRIXNUMBER";
    GpuOpCodes2[GpuOpCodes2["WORLDMATRIXDATA"] = 59] = "WORLDMATRIXDATA";
    GpuOpCodes2[GpuOpCodes2["VIEWMATRIXNUMBER"] = 60] = "VIEWMATRIXNUMBER";
    GpuOpCodes2[GpuOpCodes2["VIEWMATRIXDATA"] = 61] = "VIEWMATRIXDATA";
    GpuOpCodes2[GpuOpCodes2["PROJMATRIXNUMBER"] = 62] = "PROJMATRIXNUMBER";
    GpuOpCodes2[GpuOpCodes2["PROJMATRIXDATA"] = 63] = "PROJMATRIXDATA";
    GpuOpCodes2[GpuOpCodes2["TGENMATRIXNUMBER"] = 64] = "TGENMATRIXNUMBER";
    GpuOpCodes2[GpuOpCodes2["TGENMATRIXDATA"] = 65] = "TGENMATRIXDATA";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTX1"] = 66] = "VIEWPORTX1";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTY1"] = 67] = "VIEWPORTY1";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTZ1"] = 68] = "VIEWPORTZ1";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTX2"] = 69] = "VIEWPORTX2";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTY2"] = 70] = "VIEWPORTY2";
    GpuOpCodes2[GpuOpCodes2["VIEWPORTZ2"] = 71] = "VIEWPORTZ2";
    GpuOpCodes2[GpuOpCodes2["TEXSCALEU"] = 72] = "TEXSCALEU";
    GpuOpCodes2[GpuOpCodes2["TEXSCALEV"] = 73] = "TEXSCALEV";
    GpuOpCodes2[GpuOpCodes2["TEXOFFSETU"] = 74] = "TEXOFFSETU";
    GpuOpCodes2[GpuOpCodes2["TEXOFFSETV"] = 75] = "TEXOFFSETV";
    GpuOpCodes2[GpuOpCodes2["OFFSETX"] = 76] = "OFFSETX";
    GpuOpCodes2[GpuOpCodes2["OFFSETY"] = 77] = "OFFSETY";
    GpuOpCodes2[GpuOpCodes2["Unknown0x4E"] = 78] = "Unknown0x4E";
    GpuOpCodes2[GpuOpCodes2["Unknown0x4F"] = 79] = "Unknown0x4F";
    GpuOpCodes2[GpuOpCodes2["SHADEMODE"] = 80] = "SHADEMODE";
    GpuOpCodes2[GpuOpCodes2["REVERSENORMAL"] = 81] = "REVERSENORMAL";
    GpuOpCodes2[GpuOpCodes2["Unknown0x52"] = 82] = "Unknown0x52";
    GpuOpCodes2[GpuOpCodes2["MATERIALUPDATE"] = 83] = "MATERIALUPDATE";
    GpuOpCodes2[GpuOpCodes2["MATERIALEMISSIVE"] = 84] = "MATERIALEMISSIVE";
    GpuOpCodes2[GpuOpCodes2["MATERIALAMBIENT"] = 85] = "MATERIALAMBIENT";
    GpuOpCodes2[GpuOpCodes2["MATERIALDIFFUSE"] = 86] = "MATERIALDIFFUSE";
    GpuOpCodes2[GpuOpCodes2["MATERIALSPECULAR"] = 87] = "MATERIALSPECULAR";
    GpuOpCodes2[GpuOpCodes2["MATERIALALPHA"] = 88] = "MATERIALALPHA";
    GpuOpCodes2[GpuOpCodes2["Unknown0x59"] = 89] = "Unknown0x59";
    GpuOpCodes2[GpuOpCodes2["Unknown0x5A"] = 90] = "Unknown0x5A";
    GpuOpCodes2[GpuOpCodes2["MATERIALSPECULARCOEF"] = 91] = "MATERIALSPECULARCOEF";
    GpuOpCodes2[GpuOpCodes2["AMBIENTCOLOR"] = 92] = "AMBIENTCOLOR";
    GpuOpCodes2[GpuOpCodes2["AMBIENTALPHA"] = 93] = "AMBIENTALPHA";
    GpuOpCodes2[GpuOpCodes2["LIGHTMODE"] = 94] = "LIGHTMODE";
    GpuOpCodes2[GpuOpCodes2["LIGHTTYPE0"] = 95] = "LIGHTTYPE0";
    GpuOpCodes2[GpuOpCodes2["LIGHTTYPE1"] = 96] = "LIGHTTYPE1";
    GpuOpCodes2[GpuOpCodes2["LIGHTTYPE2"] = 97] = "LIGHTTYPE2";
    GpuOpCodes2[GpuOpCodes2["LIGHTTYPE3"] = 98] = "LIGHTTYPE3";
    GpuOpCodes2[GpuOpCodes2["LXP0"] = 99] = "LXP0";
    GpuOpCodes2[GpuOpCodes2["LYP0"] = 100] = "LYP0";
    GpuOpCodes2[GpuOpCodes2["LZP0"] = 101] = "LZP0";
    GpuOpCodes2[GpuOpCodes2["LXP1"] = 102] = "LXP1";
    GpuOpCodes2[GpuOpCodes2["LYP1"] = 103] = "LYP1";
    GpuOpCodes2[GpuOpCodes2["LZP1"] = 104] = "LZP1";
    GpuOpCodes2[GpuOpCodes2["LXP2"] = 105] = "LXP2";
    GpuOpCodes2[GpuOpCodes2["LYP2"] = 106] = "LYP2";
    GpuOpCodes2[GpuOpCodes2["LZP2"] = 107] = "LZP2";
    GpuOpCodes2[GpuOpCodes2["LXP3"] = 108] = "LXP3";
    GpuOpCodes2[GpuOpCodes2["LYP3"] = 109] = "LYP3";
    GpuOpCodes2[GpuOpCodes2["LZP3"] = 110] = "LZP3";
    GpuOpCodes2[GpuOpCodes2["LXD0"] = 111] = "LXD0";
    GpuOpCodes2[GpuOpCodes2["LYD0"] = 112] = "LYD0";
    GpuOpCodes2[GpuOpCodes2["LZD0"] = 113] = "LZD0";
    GpuOpCodes2[GpuOpCodes2["LXD1"] = 114] = "LXD1";
    GpuOpCodes2[GpuOpCodes2["LYD1"] = 115] = "LYD1";
    GpuOpCodes2[GpuOpCodes2["LZD1"] = 116] = "LZD1";
    GpuOpCodes2[GpuOpCodes2["LXD2"] = 117] = "LXD2";
    GpuOpCodes2[GpuOpCodes2["LYD2"] = 118] = "LYD2";
    GpuOpCodes2[GpuOpCodes2["LZD2"] = 119] = "LZD2";
    GpuOpCodes2[GpuOpCodes2["LXD3"] = 120] = "LXD3";
    GpuOpCodes2[GpuOpCodes2["LYD3"] = 121] = "LYD3";
    GpuOpCodes2[GpuOpCodes2["LZD3"] = 122] = "LZD3";
    GpuOpCodes2[GpuOpCodes2["LCA0"] = 123] = "LCA0";
    GpuOpCodes2[GpuOpCodes2["LLA0"] = 124] = "LLA0";
    GpuOpCodes2[GpuOpCodes2["LQA0"] = 125] = "LQA0";
    GpuOpCodes2[GpuOpCodes2["LCA1"] = 126] = "LCA1";
    GpuOpCodes2[GpuOpCodes2["LLA1"] = 127] = "LLA1";
    GpuOpCodes2[GpuOpCodes2["LQA1"] = 128] = "LQA1";
    GpuOpCodes2[GpuOpCodes2["LCA2"] = 129] = "LCA2";
    GpuOpCodes2[GpuOpCodes2["LLA2"] = 130] = "LLA2";
    GpuOpCodes2[GpuOpCodes2["LQA2"] = 131] = "LQA2";
    GpuOpCodes2[GpuOpCodes2["LCA3"] = 132] = "LCA3";
    GpuOpCodes2[GpuOpCodes2["LLA3"] = 133] = "LLA3";
    GpuOpCodes2[GpuOpCodes2["LQA3"] = 134] = "LQA3";
    GpuOpCodes2[GpuOpCodes2["SPOTEXP0"] = 135] = "SPOTEXP0";
    GpuOpCodes2[GpuOpCodes2["SPOTEXP1"] = 136] = "SPOTEXP1";
    GpuOpCodes2[GpuOpCodes2["SPOTEXP2"] = 137] = "SPOTEXP2";
    GpuOpCodes2[GpuOpCodes2["SPOTEXP3"] = 138] = "SPOTEXP3";
    GpuOpCodes2[GpuOpCodes2["SPOTCUT0"] = 139] = "SPOTCUT0";
    GpuOpCodes2[GpuOpCodes2["SPOTCUT1"] = 140] = "SPOTCUT1";
    GpuOpCodes2[GpuOpCodes2["SPOTCUT2"] = 141] = "SPOTCUT2";
    GpuOpCodes2[GpuOpCodes2["SPOTCUT3"] = 142] = "SPOTCUT3";
    GpuOpCodes2[GpuOpCodes2["ALC0"] = 143] = "ALC0";
    GpuOpCodes2[GpuOpCodes2["DLC0"] = 144] = "DLC0";
    GpuOpCodes2[GpuOpCodes2["SLC0"] = 145] = "SLC0";
    GpuOpCodes2[GpuOpCodes2["ALC1"] = 146] = "ALC1";
    GpuOpCodes2[GpuOpCodes2["DLC1"] = 147] = "DLC1";
    GpuOpCodes2[GpuOpCodes2["SLC1"] = 148] = "SLC1";
    GpuOpCodes2[GpuOpCodes2["ALC2"] = 149] = "ALC2";
    GpuOpCodes2[GpuOpCodes2["DLC2"] = 150] = "DLC2";
    GpuOpCodes2[GpuOpCodes2["SLC2"] = 151] = "SLC2";
    GpuOpCodes2[GpuOpCodes2["ALC3"] = 152] = "ALC3";
    GpuOpCodes2[GpuOpCodes2["DLC3"] = 153] = "DLC3";
    GpuOpCodes2[GpuOpCodes2["SLC3"] = 154] = "SLC3";
    GpuOpCodes2[GpuOpCodes2["CULL"] = 155] = "CULL";
    GpuOpCodes2[GpuOpCodes2["FRAMEBUFPTR"] = 156] = "FRAMEBUFPTR";
    GpuOpCodes2[GpuOpCodes2["FRAMEBUFWIDTH"] = 157] = "FRAMEBUFWIDTH";
    GpuOpCodes2[GpuOpCodes2["ZBUFPTR"] = 158] = "ZBUFPTR";
    GpuOpCodes2[GpuOpCodes2["ZBUFWIDTH"] = 159] = "ZBUFWIDTH";
    GpuOpCodes2[GpuOpCodes2["TEXADDR0"] = 160] = "TEXADDR0";
    GpuOpCodes2[GpuOpCodes2["TEXADDR1"] = 161] = "TEXADDR1";
    GpuOpCodes2[GpuOpCodes2["TEXADDR2"] = 162] = "TEXADDR2";
    GpuOpCodes2[GpuOpCodes2["TEXADDR3"] = 163] = "TEXADDR3";
    GpuOpCodes2[GpuOpCodes2["TEXADDR4"] = 164] = "TEXADDR4";
    GpuOpCodes2[GpuOpCodes2["TEXADDR5"] = 165] = "TEXADDR5";
    GpuOpCodes2[GpuOpCodes2["TEXADDR6"] = 166] = "TEXADDR6";
    GpuOpCodes2[GpuOpCodes2["TEXADDR7"] = 167] = "TEXADDR7";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH0"] = 168] = "TEXBUFWIDTH0";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH1"] = 169] = "TEXBUFWIDTH1";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH2"] = 170] = "TEXBUFWIDTH2";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH3"] = 171] = "TEXBUFWIDTH3";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH4"] = 172] = "TEXBUFWIDTH4";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH5"] = 173] = "TEXBUFWIDTH5";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH6"] = 174] = "TEXBUFWIDTH6";
    GpuOpCodes2[GpuOpCodes2["TEXBUFWIDTH7"] = 175] = "TEXBUFWIDTH7";
    GpuOpCodes2[GpuOpCodes2["CLUTADDR"] = 176] = "CLUTADDR";
    GpuOpCodes2[GpuOpCodes2["CLUTADDRUPPER"] = 177] = "CLUTADDRUPPER";
    GpuOpCodes2[GpuOpCodes2["TRXSBP"] = 178] = "TRXSBP";
    GpuOpCodes2[GpuOpCodes2["TRXSBW"] = 179] = "TRXSBW";
    GpuOpCodes2[GpuOpCodes2["TRXDBP"] = 180] = "TRXDBP";
    GpuOpCodes2[GpuOpCodes2["TRXDBW"] = 181] = "TRXDBW";
    GpuOpCodes2[GpuOpCodes2["Unknown0xB6"] = 182] = "Unknown0xB6";
    GpuOpCodes2[GpuOpCodes2["Unknown0xB7"] = 183] = "Unknown0xB7";
    GpuOpCodes2[GpuOpCodes2["TSIZE0"] = 184] = "TSIZE0";
    GpuOpCodes2[GpuOpCodes2["TSIZE1"] = 185] = "TSIZE1";
    GpuOpCodes2[GpuOpCodes2["TSIZE2"] = 186] = "TSIZE2";
    GpuOpCodes2[GpuOpCodes2["TSIZE3"] = 187] = "TSIZE3";
    GpuOpCodes2[GpuOpCodes2["TSIZE4"] = 188] = "TSIZE4";
    GpuOpCodes2[GpuOpCodes2["TSIZE5"] = 189] = "TSIZE5";
    GpuOpCodes2[GpuOpCodes2["TSIZE6"] = 190] = "TSIZE6";
    GpuOpCodes2[GpuOpCodes2["TSIZE7"] = 191] = "TSIZE7";
    GpuOpCodes2[GpuOpCodes2["TMAP"] = 192] = "TMAP";
    GpuOpCodes2[GpuOpCodes2["TEXTURE_ENV_MAP_MATRIX"] = 193] = "TEXTURE_ENV_MAP_MATRIX";
    GpuOpCodes2[GpuOpCodes2["TMODE"] = 194] = "TMODE";
    GpuOpCodes2[GpuOpCodes2["TPSM"] = 195] = "TPSM";
    GpuOpCodes2[GpuOpCodes2["CLOAD"] = 196] = "CLOAD";
    GpuOpCodes2[GpuOpCodes2["CMODE"] = 197] = "CMODE";
    GpuOpCodes2[GpuOpCodes2["TFLT"] = 198] = "TFLT";
    GpuOpCodes2[GpuOpCodes2["TWRAP"] = 199] = "TWRAP";
    GpuOpCodes2[GpuOpCodes2["TBIAS"] = 200] = "TBIAS";
    GpuOpCodes2[GpuOpCodes2["TFUNC"] = 201] = "TFUNC";
    GpuOpCodes2[GpuOpCodes2["TEC"] = 202] = "TEC";
    GpuOpCodes2[GpuOpCodes2["TFLUSH"] = 203] = "TFLUSH";
    GpuOpCodes2[GpuOpCodes2["TSYNC"] = 204] = "TSYNC";
    GpuOpCodes2[GpuOpCodes2["FFAR"] = 205] = "FFAR";
    GpuOpCodes2[GpuOpCodes2["FDIST"] = 206] = "FDIST";
    GpuOpCodes2[GpuOpCodes2["FCOL"] = 207] = "FCOL";
    GpuOpCodes2[GpuOpCodes2["TSLOPE"] = 208] = "TSLOPE";
    GpuOpCodes2[GpuOpCodes2["Unknown0xD1"] = 209] = "Unknown0xD1";
    GpuOpCodes2[GpuOpCodes2["PSM"] = 210] = "PSM";
    GpuOpCodes2[GpuOpCodes2["CLEAR"] = 211] = "CLEAR";
    GpuOpCodes2[GpuOpCodes2["SCISSOR1"] = 212] = "SCISSOR1";
    GpuOpCodes2[GpuOpCodes2["SCISSOR2"] = 213] = "SCISSOR2";
    GpuOpCodes2[GpuOpCodes2["MINZ"] = 214] = "MINZ";
    GpuOpCodes2[GpuOpCodes2["MAXZ"] = 215] = "MAXZ";
    GpuOpCodes2[GpuOpCodes2["CTST"] = 216] = "CTST";
    GpuOpCodes2[GpuOpCodes2["CREF"] = 217] = "CREF";
    GpuOpCodes2[GpuOpCodes2["CMSK"] = 218] = "CMSK";
    GpuOpCodes2[GpuOpCodes2["ATST"] = 219] = "ATST";
    GpuOpCodes2[GpuOpCodes2["STST"] = 220] = "STST";
    GpuOpCodes2[GpuOpCodes2["SOP"] = 221] = "SOP";
    GpuOpCodes2[GpuOpCodes2["ZTST"] = 222] = "ZTST";
    GpuOpCodes2[GpuOpCodes2["ALPHA"] = 223] = "ALPHA";
    GpuOpCodes2[GpuOpCodes2["SFIX"] = 224] = "SFIX";
    GpuOpCodes2[GpuOpCodes2["DFIX"] = 225] = "DFIX";
    GpuOpCodes2[GpuOpCodes2["DTH0"] = 226] = "DTH0";
    GpuOpCodes2[GpuOpCodes2["DTH1"] = 227] = "DTH1";
    GpuOpCodes2[GpuOpCodes2["DTH2"] = 228] = "DTH2";
    GpuOpCodes2[GpuOpCodes2["DTH3"] = 229] = "DTH3";
    GpuOpCodes2[GpuOpCodes2["LOP"] = 230] = "LOP";
    GpuOpCodes2[GpuOpCodes2["ZMSK"] = 231] = "ZMSK";
    GpuOpCodes2[GpuOpCodes2["PMSKC"] = 232] = "PMSKC";
    GpuOpCodes2[GpuOpCodes2["PMSKA"] = 233] = "PMSKA";
    GpuOpCodes2[GpuOpCodes2["TRXKICK"] = 234] = "TRXKICK";
    GpuOpCodes2[GpuOpCodes2["TRXSPOS"] = 235] = "TRXSPOS";
    GpuOpCodes2[GpuOpCodes2["TRXDPOS"] = 236] = "TRXDPOS";
    GpuOpCodes2[GpuOpCodes2["Unknown0xED"] = 237] = "Unknown0xED";
    GpuOpCodes2[GpuOpCodes2["TRXSIZE"] = 238] = "TRXSIZE";
    GpuOpCodes2[GpuOpCodes2["Unknown0xEF"] = 239] = "Unknown0xEF";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF0"] = 240] = "Unknown0xF0";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF1"] = 241] = "Unknown0xF1";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF2"] = 242] = "Unknown0xF2";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF3"] = 243] = "Unknown0xF3";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF4"] = 244] = "Unknown0xF4";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF5"] = 245] = "Unknown0xF5";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF6"] = 246] = "Unknown0xF6";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF7"] = 247] = "Unknown0xF7";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF8"] = 248] = "Unknown0xF8";
    GpuOpCodes2[GpuOpCodes2["Unknown0xF9"] = 249] = "Unknown0xF9";
    GpuOpCodes2[GpuOpCodes2["Unknown0xFA"] = 250] = "Unknown0xFA";
    GpuOpCodes2[GpuOpCodes2["Unknown0xFB"] = 251] = "Unknown0xFB";
    GpuOpCodes2[GpuOpCodes2["Unknown0xFC"] = 252] = "Unknown0xFC";
    GpuOpCodes2[GpuOpCodes2["Unknown0xFD"] = 253] = "Unknown0xFD";
    GpuOpCodes2[GpuOpCodes2["Unknown0xFE"] = 254] = "Unknown0xFE";
    GpuOpCodes2[GpuOpCodes2["DUMMY"] = 255] = "DUMMY";
    GpuOpCodes2[GpuOpCodes2["MAT_TEXTURE"] = 272] = "MAT_TEXTURE";
    GpuOpCodes2[GpuOpCodes2["MAT_PROJ"] = 288] = "MAT_PROJ";
    GpuOpCodes2[GpuOpCodes2["MAT_VIEW"] = 304] = "MAT_VIEW";
    GpuOpCodes2[GpuOpCodes2["MAT_WORLD"] = 320] = "MAT_WORLD";
    GpuOpCodes2[GpuOpCodes2["MAT_BONES"] = 336] = "MAT_BONES";
  })(GpuOpCodes || (GpuOpCodes = {}));

  // src/core/pixelformat.ts
  var PixelFormatUtils = class {
    static hasClut(pixelFormat) {
      return pixelFormat >= PixelFormat.PALETTE_T4 && pixelFormat <= PixelFormat.PALETTE_T32;
    }
  };
  var PixelFormat;
  (function(PixelFormat3) {
    PixelFormat3[PixelFormat3["NONE"] = -1] = "NONE";
    PixelFormat3[PixelFormat3["RGBA_5650"] = 0] = "RGBA_5650";
    PixelFormat3[PixelFormat3["RGBA_5551"] = 1] = "RGBA_5551";
    PixelFormat3[PixelFormat3["RGBA_4444"] = 2] = "RGBA_4444";
    PixelFormat3[PixelFormat3["RGBA_8888"] = 3] = "RGBA_8888";
    PixelFormat3[PixelFormat3["PALETTE_T4"] = 4] = "PALETTE_T4";
    PixelFormat3[PixelFormat3["PALETTE_T8"] = 5] = "PALETTE_T8";
    PixelFormat3[PixelFormat3["PALETTE_T16"] = 6] = "PALETTE_T16";
    PixelFormat3[PixelFormat3["PALETTE_T32"] = 7] = "PALETTE_T32";
    PixelFormat3[PixelFormat3["COMPRESSED_DXT1"] = 8] = "COMPRESSED_DXT1";
    PixelFormat3[PixelFormat3["COMPRESSED_DXT3"] = 9] = "COMPRESSED_DXT3";
    PixelFormat3[PixelFormat3["COMPRESSED_DXT5"] = 10] = "COMPRESSED_DXT5";
  })(PixelFormat || (PixelFormat = {}));
  var sizes = new Float32Array(16);
  sizes[8] = 0.5;
  sizes[9] = 1;
  sizes[10] = 1;
  sizes[6] = 2;
  sizes[7] = 4;
  sizes[5] = 1;
  sizes[4] = 0.5;
  sizes[2] = 2;
  sizes[1] = 2;
  sizes[0] = 2;
  sizes[3] = 4;
  var _PixelConverter = class {
    static getSizeInBits(format) {
      return sizes[format] * 8;
    }
    static getSizeInBytes(format, count) {
      return sizes[format] * count;
    }
    static unswizzleInline(format, from, width, height) {
      const rowWidth = _PixelConverter.getSizeInBytes(format, width);
      const textureHeight = height;
      const size = rowWidth * textureHeight;
      const temp = new Uint8Array(size);
      _PixelConverter.unswizzle(from, temp, rowWidth, textureHeight);
      ArrayBufferUtils.copy(temp, 0, from, 0, size);
    }
    static unswizzle(input, output, rowWidth, textureHeight) {
      const pitch = ToInt32((rowWidth - 16) / 4);
      const bxc = ToInt32(rowWidth / 16);
      const byc = ToInt32(textureHeight / 8);
      const pitch4 = ToInt32(pitch * 4);
      let src = 0;
      let ydest = 0;
      for (let by = 0; by < byc; by++) {
        let xdest = ydest;
        for (let bx = 0; bx < bxc; bx++) {
          let dest = xdest;
          for (let n = 0; n < 8; n++, dest += pitch4) {
            for (let m = 0; m < 16; m++)
              output[dest++] = input[src++];
          }
          xdest += 16;
        }
        ydest += rowWidth * 8;
      }
    }
    static decodeIndex(format, from, to) {
      switch (format) {
        case 4:
          let m = 0;
          for (let n = 0; n < from.length; n++) {
            const value = from[n];
            to[m++] = value >> 0 & 15;
            to[m++] = value >> 4 & 15;
          }
          return to;
        case 5:
          to.set(from);
          return to;
        default:
          throw new Error(`Unsupported pixel format ${format}`);
      }
    }
    static decode(format, from, to, useAlpha = true, palette = null, clutStart = 0, clutShift = 0, clutMask = 0) {
      switch (format) {
        case 3:
          return _PixelConverter.decode8888(from, to, useAlpha);
        case 1:
          return _PixelConverter.update5551(ArrayBufferUtils.uint8ToUint16(from), to, useAlpha);
        case 0:
          return _PixelConverter.update5650(ArrayBufferUtils.uint8ToUint16(from), to, useAlpha);
        case 2:
          return _PixelConverter.update4444(ArrayBufferUtils.uint8ToUint16(from), to, useAlpha);
        case 4:
          return _PixelConverter.updateT4(from, to, useAlpha, palette, clutStart, clutShift, clutMask);
        case 5:
          return _PixelConverter.updateT8(from, to, useAlpha, palette, clutStart, clutShift, clutMask);
        default:
          throw new Error(`Unsupported pixel format ${format} [${PixelFormat[format]}]`);
      }
    }
    static updateT4(from, to, useAlpha, palette, clutStart, clutShift, clutMask) {
      const orValue = useAlpha ? 0 : 4278190080;
      const count = to.length;
      clutStart |= 0;
      clutShift |= 0;
      clutMask &= 15;
      const updateT4Translate = _PixelConverter.updateTranslate;
      for (let m = 0; m < 16; m++)
        updateT4Translate[m] = palette[clutStart + m >>> clutShift & clutMask];
      for (let n = 0, m = 0; n < count; n++) {
        const char = from[n];
        to[m++] = updateT4Translate[char >>> 0 & 15] | orValue;
        to[m++] = updateT4Translate[char >>> 4 & 15] | orValue;
      }
      return to;
    }
    static updateT8(from, to, useAlpha, palette, clutStart, clutShift, clutMask) {
      const orValue = useAlpha ? 0 : 4278190080;
      const count = to.length;
      clutMask &= 255;
      if (count > 1024) {
        const updateT8Translate = _PixelConverter.updateTranslate;
        for (let m = 0; m < 256; m++)
          updateT8Translate[m] = palette[clutStart + m >>> clutShift & clutMask];
        for (let m = 0; m < count; m++)
          to[m] = updateT8Translate[from[m]] | orValue;
      } else {
        for (let m = 0; m < count; m++)
          to[m] = palette[clutStart + ((from[m] & clutMask) << clutShift)] | orValue;
      }
      return to;
    }
    static decode8888(from8, to, useAlpha = true) {
      const from = ArrayBufferUtils.uint8ToUint32(from8);
      for (let n = 0; n < to.length; n++)
        to[n] = this._decode8888(from[n]);
      return to;
    }
    static update5551(from, to, useAlpha = true) {
      for (let n = 0; n < to.length; n++) {
        to[n] = this.decode5551(from[n], useAlpha);
      }
      return to;
    }
    static update5650(from, to, useAlpha = true) {
      for (let n = 0; n < to.length; n++) {
        to[n] = this.decode5650(from[n], useAlpha);
      }
      return to;
    }
    static update4444(from, to, useAlpha = true) {
      for (let n = 0; n < to.length; n++) {
        to[n] = this.decode4444(from[n], useAlpha);
      }
      return to;
    }
    static _decode8888(it, useAlpha = true) {
      const orValue = useAlpha ? 0 : 4278190080;
      return it | orValue;
    }
    static decode5551(it, useAlpha = true) {
      let value = 0;
      value |= BitUtils.extractScalei(it, 0, 5, 255) << 0;
      value |= BitUtils.extractScalei(it, 5, 5, 255) << 8;
      value |= BitUtils.extractScalei(it, 10, 5, 255) << 16;
      value |= BitUtils.extractScalei(it, 15, 1, 255) << 24;
      value |= useAlpha ? 0 : 4278190080;
      return value;
    }
    static decode5650(it, useAlpha = true) {
      let value = 0;
      value |= BitUtils.extractScalei(it, 0, 5, 255) << 0;
      value |= BitUtils.extractScalei(it, 5, 6, 255) << 8;
      value |= BitUtils.extractScalei(it, 11, 5, 255) << 16;
      value |= 4278190080;
      return value;
    }
    static decode4444(it, useAlpha = true) {
      let value = 0;
      value |= BitUtils.extractScalei(it, 0, 4, 255) << 0;
      value |= BitUtils.extractScalei(it, 4, 4, 255) << 8;
      value |= BitUtils.extractScalei(it, 8, 4, 255) << 16;
      value |= (useAlpha ? BitUtils.extractScalei(it, 12, 4, 255) : 255) << 24;
      return value;
    }
    static unpackToRGBA(pixelFormat, rawColor, useAlpha = true) {
      switch (pixelFormat) {
        case 3:
          return this._decode8888(rawColor, useAlpha);
        case 1:
          return this.decode5551(rawColor, useAlpha);
        case 0:
          return this.decode5650(rawColor, useAlpha);
        case 2:
          return this.decode4444(rawColor, useAlpha);
        default:
          throw new Error(`Unsupported pixelFormat ${pixelFormat}`);
      }
    }
  };
  var PixelConverter = _PixelConverter;
  PixelConverter.updateTranslate = new Uint32Array(256);

  // src/core/gpu/gpu_state.ts
  var Op = GpuOpCodes;
  function bool1(p) {
    return p != 0;
  }
  function parambool(p, offset) {
    return (p >> offset & 1) != 0;
  }
  function param1(p, offset) {
    return p >> offset & 1;
  }
  function param2(p, offset) {
    return p >> offset & 3;
  }
  function param3(p, offset) {
    return p >> offset & 7;
  }
  function param4(p, offset) {
    return p >> offset & 15;
  }
  function param5(p, offset) {
    return p >> offset & 31;
  }
  function param6(p, offset) {
    return p >> offset & 63;
  }
  function param8(p, offset) {
    return p >> offset & 255;
  }
  function param10(p, offset) {
    return p >> offset & 1023;
  }
  function param16(p, offset) {
    return p >> offset & 65535;
  }
  function param24(p) {
    return p & 16777215;
  }
  function float1(p) {
    return MathFloat.reinterpretIntAsFloat(p << 8);
  }
  var CullingDirection;
  (function(CullingDirection2) {
    CullingDirection2[CullingDirection2["CounterClockWise"] = 0] = "CounterClockWise";
    CullingDirection2[CullingDirection2["ClockWise"] = 1] = "ClockWise";
  })(CullingDirection || (CullingDirection = {}));
  var SyncType;
  (function(SyncType3) {
    SyncType3[SyncType3["WaitForCompletion"] = 0] = "WaitForCompletion";
    SyncType3[SyncType3["Peek"] = 1] = "Peek";
  })(SyncType || (SyncType = {}));
  var DisplayListStatus;
  (function(DisplayListStatus2) {
    DisplayListStatus2[DisplayListStatus2["Completed"] = 0] = "Completed";
    DisplayListStatus2[DisplayListStatus2["Queued"] = 1] = "Queued";
    DisplayListStatus2[DisplayListStatus2["Drawing"] = 2] = "Drawing";
    DisplayListStatus2[DisplayListStatus2["Stalling"] = 3] = "Stalling";
    DisplayListStatus2[DisplayListStatus2["Paused"] = 4] = "Paused";
  })(DisplayListStatus || (DisplayListStatus = {}));
  var GpuFrameBufferState = class {
    constructor(data) {
      this.data = data;
    }
    get width() {
      return param16(this.data[GpuOpCodes.FRAMEBUFWIDTH], 0);
    }
    get highAddress() {
      return param8(this.data[GpuOpCodes.FRAMEBUFWIDTH], 16);
    }
    get lowAddress() {
      return param24(this.data[GpuOpCodes.FRAMEBUFPTR]);
    }
  };
  var IndexEnum;
  (function(IndexEnum2) {
    IndexEnum2[IndexEnum2["Void"] = 0] = "Void";
    IndexEnum2[IndexEnum2["Byte"] = 1] = "Byte";
    IndexEnum2[IndexEnum2["Short"] = 2] = "Short";
  })(IndexEnum || (IndexEnum = {}));
  var NumericEnum;
  (function(NumericEnum2) {
    NumericEnum2[NumericEnum2["Void"] = 0] = "Void";
    NumericEnum2[NumericEnum2["Byte"] = 1] = "Byte";
    NumericEnum2[NumericEnum2["Short"] = 2] = "Short";
    NumericEnum2[NumericEnum2["Float"] = 3] = "Float";
  })(NumericEnum || (NumericEnum = {}));
  var ColorEnum;
  (function(ColorEnum3) {
    ColorEnum3[ColorEnum3["Void"] = 0] = "Void";
    ColorEnum3[ColorEnum3["Invalid1"] = 1] = "Invalid1";
    ColorEnum3[ColorEnum3["Invalid2"] = 2] = "Invalid2";
    ColorEnum3[ColorEnum3["Invalid3"] = 3] = "Invalid3";
    ColorEnum3[ColorEnum3["Color5650"] = 4] = "Color5650";
    ColorEnum3[ColorEnum3["Color5551"] = 5] = "Color5551";
    ColorEnum3[ColorEnum3["Color4444"] = 6] = "Color4444";
    ColorEnum3[ColorEnum3["Color8888"] = 7] = "Color8888";
  })(ColorEnum || (ColorEnum = {}));
  var _VertexInfo = class {
    constructor() {
      this.weightOffset = 0;
      this.textureOffset = 0;
      this.colorOffset = 0;
      this.normalOffset = 0;
      this.positionOffset = 0;
      this.textureComponentsCount = 0;
      this.align = 0;
      this.size = 0;
      this.value = -1;
      this.reversedNormal = false;
      this.address = 0;
      this.weight = 0;
      this.texture = 0;
      this.color = 0;
      this.normal = 0;
      this.position = 0;
      this.index = 0;
      this.weightCount = 0;
      this.morphingVertexCount = 0;
      this.transform2D = false;
      this.weightSize = 0;
      this.colorSize = 0;
      this.textureSize = 0;
      this.positionSize = 0;
      this.normalSize = 0;
    }
    describe() {
      return `vertexInfo_${this.value >>> 0}_${this.textureComponentsCount}`;
    }
    clone() {
      return new _VertexInfo().copyFrom(this);
    }
    copyFrom(that) {
      this.weightOffset = that.weightOffset;
      this.textureOffset = that.textureOffset;
      this.colorOffset = that.colorOffset;
      this.normalOffset = that.normalOffset;
      this.positionOffset = that.positionOffset;
      this.textureComponentsCount = that.textureComponentsCount;
      this.value = that.value;
      this.size = that.size;
      this.reversedNormal = that.reversedNormal;
      this.address = that.address;
      this.texture = that.texture;
      this.color = that.color;
      this.normal = that.normal;
      this.position = that.position;
      this.weight = that.weight;
      this.index = that.index;
      this.weightCount = that.weightCount;
      this.morphingVertexCount = that.morphingVertexCount;
      this.transform2D = that.transform2D;
      this.weightSize = that.weightSize;
      this.colorSize = that.colorSize;
      this.textureSize = that.textureSize;
      this.positionSize = that.positionSize;
      this.normalSize = that.normalSize;
      this.align = that.align;
      return this;
    }
    setState(state) {
      let vstate = state.vertex;
      this.address = vstate.address;
      if (this.value != vstate.value || this.textureComponentsCount != state.texture.textureComponentsCount || this.reversedNormal != vstate.reversedNormal) {
        this.textureComponentsCount = state.texture.textureComponentsCount;
        this.reversedNormal = vstate.reversedNormal;
        this.value = vstate.value;
        this.texture = vstate.texture;
        this.color = vstate.color;
        this.normal = vstate.normal;
        this.position = vstate.position;
        this.weight = vstate.weight;
        this.index = vstate.index;
        this.weightCount = vstate.weightCount;
        this.morphingVertexCount = vstate.morphingVertexCount;
        this.transform2D = vstate.transform2D;
        this.updateSizeAndPositions();
      }
      return this;
    }
    updateSizeAndPositions() {
      this.weightSize = _VertexInfo.NumericEnumSizes[this.weight];
      this.colorSize = _VertexInfo.ColorEnumSizes[this.color];
      this.textureSize = _VertexInfo.NumericEnumSizes[this.texture];
      this.positionSize = _VertexInfo.NumericEnumSizes[this.position];
      this.normalSize = _VertexInfo.NumericEnumSizes[this.normal];
      this.size = 0;
      this.size = MathUtils.nextAligned(this.size, this.weightSize);
      this.weightOffset = this.size;
      this.size += this.realWeightCount * this.weightSize;
      this.size = MathUtils.nextAligned(this.size, this.textureSize);
      this.textureOffset = this.size;
      this.size += this.textureComponentsCount * this.textureSize;
      this.size = MathUtils.nextAligned(this.size, this.colorSize);
      this.colorOffset = this.size;
      this.size += 1 * this.colorSize;
      this.size = MathUtils.nextAligned(this.size, this.normalSize);
      this.normalOffset = this.size;
      this.size += 3 * this.normalSize;
      this.size = MathUtils.nextAligned(this.size, this.positionSize);
      this.positionOffset = this.size;
      this.size += 3 * this.positionSize;
      this.align = Math.max(this.weightSize, this.colorSize, this.textureSize, this.positionSize, this.normalSize);
      this.size = MathUtils.nextAligned(this.size, this.align);
    }
    oneWeightOffset(n) {
      return this.weightOffset + this.weightSize * n;
    }
    get realWeightCount() {
      return this.hasWeight ? this.weightCount + 1 : 0;
    }
    get realMorphingVertexCount() {
      return this.morphingVertexCount + 1;
    }
    get hasTexture() {
      return this.texture != 0;
    }
    get hasColor() {
      return this.color != 0;
    }
    get hasNormal() {
      return this.normal != 0;
    }
    get hasPosition() {
      return this.position != 0;
    }
    get hasWeight() {
      return this.weight != 0;
    }
    get hasIndex() {
      return this.index != 0;
    }
    get positionComponents() {
      return 3;
    }
    get normalComponents() {
      return 3;
    }
    get colorComponents() {
      return 4;
    }
    get textureComponents() {
      return this.textureComponentsCount;
    }
    get hash() {
      return this.value + this.textureComponentsCount * Math.pow(2, 24) | 0;
    }
    read(memory2, count) {
      const vertices = [];
      for (let n = 0; n < count; n++)
        vertices.push(this.readOne(memory2));
      return vertices;
    }
    readOne(memory2) {
      const address = this.address;
      const vertex = {};
      this.address += this.size;
      return vertex;
    }
    toString() {
      return `VertexInfo(${JSON.stringify({
        address: this.address,
        texture: this.texture,
        color: this.color,
        normal: this.normal,
        position: this.position,
        weight: this.weight,
        index: this.index,
        realWeightCount: this.realWeightCount,
        morphingVertexCount: this.morphingVertexCount,
        transform2D: this.transform2D
      })})`;
    }
  };
  var VertexInfo = _VertexInfo;
  VertexInfo.NumericEnumSizes = [0, 1, 2, 4];
  VertexInfo.ColorEnumSizes = [0, 0, 0, 0, 2, 2, 2, 4];
  var VertexState = class {
    constructor(data) {
      this.data = data;
    }
    get value() {
      return param24(this.data[Op.VERTEXTYPE]);
    }
    get reversedNormal() {
      return bool1(this.data[Op.REVERSENORMAL]);
    }
    get address() {
      return param24(this.data[Op.VADDR]);
    }
    set address(value) {
      this.data[Op.VADDR] = value | Op.VADDR << 24;
    }
    get texture() {
      return param2(this.data[Op.VERTEXTYPE], 0);
    }
    get color() {
      return param3(this.data[Op.VERTEXTYPE], 2);
    }
    get normal() {
      return param2(this.data[Op.VERTEXTYPE], 5);
    }
    get position() {
      return param2(this.data[Op.VERTEXTYPE], 7);
    }
    get weight() {
      return param2(this.data[Op.VERTEXTYPE], 9);
    }
    get index() {
      return param2(this.data[Op.VERTEXTYPE], 11);
    }
    get weightCount() {
      return param3(this.data[Op.VERTEXTYPE], 14);
    }
    get morphingVertexCount() {
      return param2(this.data[Op.VERTEXTYPE], 18);
    }
    get transform2D() {
      return parambool(this.data[Op.VERTEXTYPE], 23);
    }
  };
  function createMatrix4x4(data, offset) {
    return new Float32Array(data.buffer).subarray(offset, offset + 16);
  }
  function createMatrix4x3(data, offset) {
    return new Float32Array(data.buffer).subarray(offset, offset + 12);
  }
  var ViewPort = class {
    constructor(data) {
      this.data = data;
    }
    get x() {
      return float1(this.data[Op.VIEWPORTX2]);
    }
    get y() {
      return float1(this.data[Op.VIEWPORTY2]);
    }
    get z() {
      return float1(this.data[Op.VIEWPORTZ2]);
    }
    get width() {
      return float1(this.data[Op.VIEWPORTX1]);
    }
    get height() {
      return float1(this.data[Op.VIEWPORTY1]);
    }
    get depth() {
      return float1(this.data[Op.VIEWPORTZ1]);
    }
  };
  var Region = class {
    constructor(data) {
      this.data = data;
    }
    get x1() {
      return param10(this.data[Op.REGION1], 0);
    }
    get y1() {
      return param10(this.data[Op.REGION1], 10);
    }
    get x2() {
      return param10(this.data[Op.REGION2], 0);
    }
    get y2() {
      return param10(this.data[Op.REGION2], 10);
    }
  };
  var _Light = class {
    constructor(data, index) {
      this.data = data;
      this.index = index;
    }
    get enabled() {
      return bool1(this.data[Op.LIGHTENABLE0 + this.index]);
    }
    get kind() {
      return param8(this.data[_Light.REG_TYPES[this.index]], 0);
    }
    get type() {
      return param8(this.data[_Light.REG_TYPES[this.index]], 8);
    }
    get pw() {
      return this.type == LightTypeEnum.SpotLight ? 1 : 0;
    }
    get px() {
      return float1(this.data[_Light.LXP[this.index]]);
    }
    get py() {
      return float1(this.data[_Light.LYP[this.index]]);
    }
    get pz() {
      return float1(this.data[_Light.LZP[this.index]]);
    }
    get dx() {
      return float1(this.data[_Light.LXD[this.index]]);
    }
    get dy() {
      return float1(this.data[_Light.LYD[this.index]]);
    }
    get dz() {
      return float1(this.data[_Light.LZD[this.index]]);
    }
    get spotExponent() {
      return float1(this.data[_Light.REG_SPOTEXP[this.index]]);
    }
    get spotCutoff() {
      return float1(this.data[_Light.REG_SPOTCUT[this.index]]);
    }
    get constantAttenuation() {
      return float1(this.data[_Light.REG_LCA[this.index]]);
    }
    get linearAttenuation() {
      return float1(this.data[_Light.REG_LLA[this.index]]);
    }
    get quadraticAttenuation() {
      return float1(this.data[_Light.REG_LQA[this.index]]);
    }
    get ambientColor() {
      return new Color().setRGB(_Light.ALC[this.index]);
    }
    get diffuseColor() {
      return new Color().setRGB(_Light.DLC[this.index]);
    }
    get specularColor() {
      return new Color().setRGB(_Light.SLC[this.index]);
    }
  };
  var Light = _Light;
  Light.REG_TYPES = [Op.LIGHTTYPE0, Op.LIGHTTYPE1, Op.LIGHTTYPE2, Op.LIGHTTYPE3];
  Light.REG_LCA = [Op.LCA0, Op.LCA1, Op.LCA2, Op.LCA3];
  Light.REG_LLA = [Op.LLA0, Op.LLA1, Op.LLA2, Op.LLA3];
  Light.REG_LQA = [Op.LQA0, Op.LQA1, Op.LQA2, Op.LQA3];
  Light.REG_SPOTEXP = [Op.SPOTEXP0, Op.SPOTEXP1, Op.SPOTEXP2, Op.SPOTEXP3];
  Light.REG_SPOTCUT = [Op.SPOTCUT0, Op.SPOTCUT1, Op.SPOTCUT2, Op.SPOTCUT3];
  Light.LXP = [Op.LXP0, Op.LXP1, Op.LXP2, Op.LXP3];
  Light.LYP = [Op.LYP0, Op.LYP1, Op.LYP2, Op.LYP3];
  Light.LZP = [Op.LZP0, Op.LZP1, Op.LZP2, Op.LZP3];
  Light.LXD = [Op.LXD0, Op.LXD1, Op.LXD2, Op.LXD3];
  Light.LYD = [Op.LYD0, Op.LYD1, Op.LYD2, Op.LYD3];
  Light.LZD = [Op.LZD0, Op.LZD1, Op.LZD2, Op.LZD3];
  Light.ALC = [Op.ALC0, Op.ALC1, Op.ALC2, Op.ALC3];
  Light.DLC = [Op.DLC0, Op.DLC1, Op.DLC2, Op.DLC3];
  Light.SLC = [Op.SLC0, Op.SLC1, Op.SLC2, Op.SLC3];
  var LightTypeEnum;
  (function(LightTypeEnum2) {
    LightTypeEnum2[LightTypeEnum2["Directional"] = 0] = "Directional";
    LightTypeEnum2[LightTypeEnum2["PointLight"] = 1] = "PointLight";
    LightTypeEnum2[LightTypeEnum2["SpotLight"] = 2] = "SpotLight";
  })(LightTypeEnum || (LightTypeEnum = {}));
  var LightModelEnum;
  (function(LightModelEnum2) {
    LightModelEnum2[LightModelEnum2["SingleColor"] = 0] = "SingleColor";
    LightModelEnum2[LightModelEnum2["SeparateSpecularColor"] = 1] = "SeparateSpecularColor";
  })(LightModelEnum || (LightModelEnum = {}));
  var Lightning = class {
    constructor(data) {
      this.data = data;
      this.lights = [
        new Light(this.data, 0),
        new Light(this.data, 1),
        new Light(this.data, 2),
        new Light(this.data, 3)
      ];
    }
    get lightModel() {
      return param8(this.data[Op.LIGHTMODE], 0);
    }
    get specularPower() {
      return float1(this.data[Op.MATERIALSPECULARCOEF]);
    }
    get ambientLightColor() {
      return new Color().setRGB_A(this.data[Op.AMBIENTCOLOR], this.data[Op.AMBIENTALPHA]);
    }
    get enabled() {
      return bool1(this.data[Op.LIGHTINGENABLE]);
    }
  };
  var MipmapState = class {
    constructor(texture, data, index) {
      this.texture = texture;
      this.data = data;
      this.index = index;
    }
    get bufferWidth() {
      return param16(this.data[Op.TEXBUFWIDTH0 + this.index], 0);
    }
    get address() {
      return param24(this.data[Op.TEXADDR0 + this.index]) | param8(this.data[Op.TEXBUFWIDTH0 + this.index], 16) << 24;
    }
    get addressEnd() {
      return this.address + this.sizeInBytes;
    }
    get textureWidth() {
      return 1 << param4(this.data[Op.TSIZE0 + this.index], 0);
    }
    get textureHeight() {
      return 1 << param4(this.data[Op.TSIZE0 + this.index], 8);
    }
    get size() {
      return this.bufferWidth * this.textureHeight;
    }
    get sizeInBytes() {
      return PixelConverter.getSizeInBytes(this.texture.pixelFormat, this.size);
    }
  };
  var ClutState = class {
    constructor(data) {
      this.data = data;
    }
    getHashFast() {
      return (this.data[Op.CMODE] << 0) + (this.data[Op.CLOAD] << 8) + (this.data[Op.CLUTADDR] << 16) + (this.data[Op.CLUTADDRUPPER] << 24);
    }
    get cmode() {
      return this.data[Op.CMODE];
    }
    get cload() {
      return this.data[Op.CLOAD];
    }
    get address() {
      return param24(this.data[Op.CLUTADDR]) | this.data[Op.CLUTADDRUPPER] << 8 & 4278190080;
    }
    get addressEnd() {
      return this.address + this.sizeInBytes;
    }
    get numberOfBlocks() {
      return param6(this.cload, 0);
    }
    get numberOfColors() {
      return this.numberOfBlocks << 4;
    }
    get pixelFormat() {
      return param2(this.data[Op.CMODE], 0);
    }
    get colorBits() {
      return PixelConverter.getSizeInBits(this.pixelFormat);
    }
    get shift() {
      return param5(this.data[Op.CMODE], 2);
    }
    get mask() {
      return param8(this.data[Op.CMODE], 8);
    }
    get start() {
      return param5(this.data[Op.CMODE], 16);
    }
    get sizeInBytes() {
      return PixelConverter.getSizeInBytes(this.pixelFormat, this.numberOfColors);
    }
    getIndex(n) {
      return (n >> this.shift & this.mask) + (this.start << 4);
    }
    getRawColor(mem, n) {
      switch (this.colorBits) {
        case 16:
          return mem.lhu(this.address + this.getIndex(n) * 2);
        case 32:
          return mem.lw(this.address + this.getIndex(n) * 4);
        default:
          throw new Error("Invalid palette");
      }
    }
    getColor(mem, n) {
      return PixelConverter.unpackToRGBA(this.pixelFormat, this.getRawColor(mem, n));
    }
  };
  var TextureProjectionMapMode;
  (function(TextureProjectionMapMode2) {
    TextureProjectionMapMode2[TextureProjectionMapMode2["GU_POSITION"] = 0] = "GU_POSITION";
    TextureProjectionMapMode2[TextureProjectionMapMode2["GU_UV"] = 1] = "GU_UV";
    TextureProjectionMapMode2[TextureProjectionMapMode2["GU_NORMALIZED_NORMAL"] = 2] = "GU_NORMALIZED_NORMAL";
    TextureProjectionMapMode2[TextureProjectionMapMode2["GU_NORMAL"] = 3] = "GU_NORMAL";
  })(TextureProjectionMapMode || (TextureProjectionMapMode = {}));
  var TextureMapMode;
  (function(TextureMapMode2) {
    TextureMapMode2[TextureMapMode2["GU_TEXTURE_COORDS"] = 0] = "GU_TEXTURE_COORDS";
    TextureMapMode2[TextureMapMode2["GU_TEXTURE_MATRIX"] = 1] = "GU_TEXTURE_MATRIX";
    TextureMapMode2[TextureMapMode2["GU_ENVIRONMENT_MAP"] = 2] = "GU_ENVIRONMENT_MAP";
  })(TextureMapMode || (TextureMapMode = {}));
  var TextureLevelMode;
  (function(TextureLevelMode2) {
    TextureLevelMode2[TextureLevelMode2["Auto"] = 0] = "Auto";
    TextureLevelMode2[TextureLevelMode2["Const"] = 1] = "Const";
    TextureLevelMode2[TextureLevelMode2["Slope"] = 2] = "Slope";
  })(TextureLevelMode || (TextureLevelMode = {}));
  var TextureState = class {
    constructor(data) {
      this.data = data;
      this.matrix = createMatrix4x4(this.data, Op.MAT_TEXTURE);
      this.clut = new ClutState(this.data);
      this.mipmaps = [
        new MipmapState(this, this.data, 0),
        new MipmapState(this, this.data, 1),
        new MipmapState(this, this.data, 2),
        new MipmapState(this, this.data, 3),
        new MipmapState(this, this.data, 4),
        new MipmapState(this, this.data, 5),
        new MipmapState(this, this.data, 6),
        new MipmapState(this, this.data, 7)
      ];
    }
    get hasClut() {
      return PixelFormatUtils.hasClut(this.pixelFormat);
    }
    getHashSlow(textureData, clutData) {
      const hash = [];
      hash.push(ArrayBufferUtils.hashFast(textureData));
      hash.push(this.mipmap.address);
      hash.push(this.mipmap.textureWidth);
      hash.push(this.colorComponent);
      hash.push(this.mipmap.textureHeight);
      hash.push(+this.swizzled);
      hash.push(+this.pixelFormat);
      if (this.hasClut) {
        hash.push(this.clut.getHashFast());
        hash.push(ArrayBufferUtils.hashFast(clutData));
      }
      return hash.join("_");
    }
    get mipmap() {
      return this.mipmaps[0];
    }
    get wrapU() {
      return param8(this.data[Op.TWRAP], 0);
    }
    get wrapV() {
      return param8(this.data[Op.TWRAP], 8);
    }
    get levelMode() {
      return param8(this.data[Op.TBIAS], 0);
    }
    get mipmapBias() {
      return param8(this.data[Op.TBIAS], 16) / 16;
    }
    get offsetU() {
      return float1(this.data[Op.TEXOFFSETU]);
    }
    get offsetV() {
      return float1(this.data[Op.TEXOFFSETV]);
    }
    get scaleU() {
      return float1(this.data[Op.TEXSCALEU]);
    }
    get scaleV() {
      return float1(this.data[Op.TEXSCALEV]);
    }
    get shadeU() {
      return param2(this.data[Op.TEXTURE_ENV_MAP_MATRIX], 0);
    }
    get shadeV() {
      return param2(this.data[Op.TEXTURE_ENV_MAP_MATRIX], 8);
    }
    get effect() {
      return param8(this.data[Op.TFUNC], 0);
    }
    get hasAlpha() {
      return this.colorComponent == TextureColorComponent.Rgba;
    }
    get colorComponent() {
      return param8(this.data[Op.TFUNC], 8);
    }
    get fragment2X() {
      return param8(this.data[Op.TFUNC], 16) != 0;
    }
    get envColor() {
      return new Color().setRGB(param24(this.data[Op.TEC]));
    }
    get pixelFormat() {
      return param4(this.data[Op.TPSM], 0);
    }
    get slopeLevel() {
      return float1(this.data[Op.TSLOPE]);
    }
    get swizzled() {
      return param8(this.data[Op.TMODE], 0) != 0;
    }
    get mipmapShareClut() {
      return param8(this.data[Op.TMODE], 8) != 0;
    }
    get mipmapMaxLevel() {
      return param8(this.data[Op.TMODE], 16) != 0;
    }
    get filterMinification() {
      return param8(this.data[Op.TFLT], 0);
    }
    get filterMagnification() {
      return param8(this.data[Op.TFLT], 8);
    }
    get enabled() {
      return bool1(this.data[Op.TEXTUREMAPENABLE]);
    }
    get textureMapMode() {
      return param8(this.data[Op.TMAP], 0);
    }
    get textureProjectionMapMode() {
      return param8(this.data[Op.TMAP], 8);
    }
    get tmode() {
      return this.data[Op.TMODE];
    }
    getPixelsSize(size) {
      return PixelConverter.getSizeInBytes(this.pixelFormat, size);
    }
    get textureComponentsCount() {
      switch (this.textureMapMode) {
        default:
          throw new Error("Invalid textureMapMode");
        case 0:
          return 2;
        case 1:
          switch (this.textureProjectionMapMode) {
            case 3:
              return 3;
            case 2:
              return 3;
            case 0:
              return 3;
            case 1:
              return 2;
          }
          return 2;
        case 2:
          return 2;
      }
    }
  };
  var CullingState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.CULLFACEENABLE]);
    }
    get direction() {
      return param24(this.data[Op.CULL]);
    }
  };
  var TestFunctionEnum;
  (function(TestFunctionEnum2) {
    TestFunctionEnum2[TestFunctionEnum2["Never"] = 0] = "Never";
    TestFunctionEnum2[TestFunctionEnum2["Always"] = 1] = "Always";
    TestFunctionEnum2[TestFunctionEnum2["Equal"] = 2] = "Equal";
    TestFunctionEnum2[TestFunctionEnum2["NotEqual"] = 3] = "NotEqual";
    TestFunctionEnum2[TestFunctionEnum2["Less"] = 4] = "Less";
    TestFunctionEnum2[TestFunctionEnum2["LessOrEqual"] = 5] = "LessOrEqual";
    TestFunctionEnum2[TestFunctionEnum2["Greater"] = 6] = "Greater";
    TestFunctionEnum2[TestFunctionEnum2["GreaterOrEqual"] = 7] = "GreaterOrEqual";
  })(TestFunctionEnum || (TestFunctionEnum = {}));
  var DepthTestState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.ZTESTENABLE]);
    }
    get func() {
      return param8(this.data[Op.ZTST], 0);
    }
    get mask() {
      return param16(this.data[Op.ZMSK], 0);
    }
    get rangeNear() {
      return (this.data[Op.MAXZ] & 65535) / 65536;
    }
    get rangeFar() {
      return (this.data[Op.MINZ] & 65535) / 65536;
    }
  };
  var ShadingModelEnum;
  (function(ShadingModelEnum2) {
    ShadingModelEnum2[ShadingModelEnum2["Flat"] = 0] = "Flat";
    ShadingModelEnum2[ShadingModelEnum2["Smooth"] = 1] = "Smooth";
  })(ShadingModelEnum || (ShadingModelEnum = {}));
  var GuBlendingFactor;
  (function(GuBlendingFactor2) {
    GuBlendingFactor2[GuBlendingFactor2["GU_SRC_COLOR"] = 0] = "GU_SRC_COLOR";
    GuBlendingFactor2[GuBlendingFactor2["GU_ONE_MINUS_SRC_COLOR"] = 1] = "GU_ONE_MINUS_SRC_COLOR";
    GuBlendingFactor2[GuBlendingFactor2["GU_SRC_ALPHA"] = 2] = "GU_SRC_ALPHA";
    GuBlendingFactor2[GuBlendingFactor2["GU_ONE_MINUS_SRC_ALPHA"] = 3] = "GU_ONE_MINUS_SRC_ALPHA";
    GuBlendingFactor2[GuBlendingFactor2["GU_DST_ALPHA"] = 4] = "GU_DST_ALPHA";
    GuBlendingFactor2[GuBlendingFactor2["GU_ONE_MINUS_DST_ALPHA"] = 5] = "GU_ONE_MINUS_DST_ALPHA";
    GuBlendingFactor2[GuBlendingFactor2["GU_FIX"] = 10] = "GU_FIX";
  })(GuBlendingFactor || (GuBlendingFactor = {}));
  var GuBlendingEquation;
  (function(GuBlendingEquation2) {
    GuBlendingEquation2[GuBlendingEquation2["Add"] = 0] = "Add";
    GuBlendingEquation2[GuBlendingEquation2["Substract"] = 1] = "Substract";
    GuBlendingEquation2[GuBlendingEquation2["ReverseSubstract"] = 2] = "ReverseSubstract";
    GuBlendingEquation2[GuBlendingEquation2["Min"] = 3] = "Min";
    GuBlendingEquation2[GuBlendingEquation2["Max"] = 4] = "Max";
    GuBlendingEquation2[GuBlendingEquation2["Abs"] = 5] = "Abs";
  })(GuBlendingEquation || (GuBlendingEquation = {}));
  var Color = class {
    constructor(r = 0, g = 0, b = 0, a = 1) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    setRGB(rgb) {
      this.r = BitUtils.extractScale1f(rgb, 0, 8);
      this.g = BitUtils.extractScale1f(rgb, 8, 8);
      this.b = BitUtils.extractScale1f(rgb, 16, 8);
      this.a = 1;
      return this;
    }
    setRGB_A(rgb, a) {
      this.setRGB(rgb);
      this.a = BitUtils.extractScale1f(a, 0, 8);
      return this;
    }
    set(r, g, b, a = 1) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      return this;
    }
    static add(a, b, dest = new Color()) {
      dest.r = a.r + b.r;
      dest.g = a.g + b.g;
      dest.b = a.b + b.b;
      dest.a = a.a * b.a;
      return dest;
    }
    equals(r, g, b, a) {
      return this.r == r && this.g == g && this.b == b && this.a == a;
    }
  };
  var Blending = class {
    constructor(data) {
      this.data = data;
    }
    get fixColorSource() {
      return new Color().setRGB(param24(this.data[Op.SFIX]));
    }
    get fixColorDestination() {
      return new Color().setRGB(param24(this.data[Op.DFIX]));
    }
    get enabled() {
      return bool1(this.data[Op.ALPHABLENDENABLE]);
    }
    get functionSource() {
      return param4(this.data[Op.ALPHA], 0);
    }
    get functionDestination() {
      return param4(this.data[Op.ALPHA], 4);
    }
    get equation() {
      return param4(this.data[Op.ALPHA], 8);
    }
    get colorMask() {
      return new Color().setRGB_A(param24(this.data[Op.PMSKC]), param8(this.data[Op.PMSKA], 0));
    }
  };
  var AlphaTest = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.ALPHATESTENABLE]);
    }
    get func() {
      return param8(this.data[Op.ATST], 0);
    }
    get value() {
      return param8(this.data[Op.ATST], 8);
    }
    get mask() {
      return param8(this.data[Op.ATST], 16);
    }
  };
  var Rectangle = class {
    constructor(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    }
    get width() {
      return this.right - this.left;
    }
    get height() {
      return this.bottom - this.top;
    }
  };
  var ClipPlane = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.CLIPENABLE]);
    }
    get scissor() {
      return new Rectangle(this.left, this.top, this.right, this.bottom);
    }
    get left() {
      return param10(this.data[Op.SCISSOR1], 0);
    }
    get top() {
      return param10(this.data[Op.SCISSOR1], 10);
    }
    get right() {
      return param10(this.data[Op.SCISSOR2], 0);
    }
    get bottom() {
      return param10(this.data[Op.SCISSOR2], 10);
    }
  };
  var SkinningState = class {
    constructor(data) {
      this.data = data;
      this.dataf = new Float32Array(this.data.buffer);
      this.boneMatrices = [
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 0),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 1),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 2),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 3),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 4),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 5),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 6),
        createMatrix4x3(this.data, Op.MAT_BONES + 12 * 7)
      ];
    }
  };
  var StencilOperationEnum;
  (function(StencilOperationEnum2) {
    StencilOperationEnum2[StencilOperationEnum2["Keep"] = 0] = "Keep";
    StencilOperationEnum2[StencilOperationEnum2["Zero"] = 1] = "Zero";
    StencilOperationEnum2[StencilOperationEnum2["Replace"] = 2] = "Replace";
    StencilOperationEnum2[StencilOperationEnum2["Invert"] = 3] = "Invert";
    StencilOperationEnum2[StencilOperationEnum2["Increment"] = 4] = "Increment";
    StencilOperationEnum2[StencilOperationEnum2["Decrement"] = 5] = "Decrement";
  })(StencilOperationEnum || (StencilOperationEnum = {}));
  var StencilState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.STENCILTESTENABLE]);
    }
    get fail() {
      return param8(this.data[Op.SOP], 0);
    }
    get zfail() {
      return param8(this.data[Op.SOP], 8);
    }
    get zpass() {
      return param8(this.data[Op.SOP], 16);
    }
    get func() {
      return param8(this.data[Op.STST], 0);
    }
    get funcRef() {
      return param8(this.data[Op.STST], 8);
    }
    get funcMask() {
      return param8(this.data[Op.STST], 16);
    }
  };
  var PatchState = class {
    constructor(data) {
      this.data = data;
    }
    get divs() {
      return param8(this.data[Op.PATCHDIVISION], 0);
    }
    get divt() {
      return param8(this.data[Op.PATCHDIVISION], 8);
    }
  };
  var Fog = class {
    constructor(data) {
      this.data = data;
    }
    get color() {
      return new Color().setRGB(this.data[Op.FCOL]);
    }
    get far() {
      return float1(this.data[Op.FFAR]);
    }
    get dist() {
      return float1(this.data[Op.FDIST]);
    }
    get enabled() {
      return bool1(this.data[Op.FOGENABLE]);
    }
  };
  var LogicOp = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return this.data[Op.LOGICOPENABLE];
    }
  };
  var LineSmoothState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.ANTIALIASENABLE]);
    }
  };
  var PatchCullingState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.PATCHCULLENABLE]);
    }
    get faceFlag() {
      return bool1(this.data[Op.PATCHFACING]);
    }
  };
  var OffsetState = class {
    constructor(data) {
      this.data = data;
    }
    get x() {
      return param4(this.data[Op.OFFSETX], 0);
    }
    get y() {
      return param4(this.data[Op.OFFSETY], 0);
    }
  };
  var GpuState = class {
    constructor() {
      this.data = new Uint32Array(512);
      this.dataf = new Float32Array(this.data.buffer);
      this.frameBuffer = new GpuFrameBufferState(this.data);
      this.vertex = new VertexState(this.data);
      this.stencil = new StencilState(this.data);
      this.skinning = new SkinningState(this.data);
      this.projectionMatrix = createMatrix4x4(this.data, Op.MAT_PROJ);
      this.viewMatrix = createMatrix4x3(this.data, Op.MAT_VIEW);
      this.worldMatrix = createMatrix4x3(this.data, Op.MAT_WORLD);
      this.viewport = new ViewPort(this.data);
      this.region = new Region(this.data);
      this.offset = new OffsetState(this.data);
      this.fog = new Fog(this.data);
      this.clipPlane = new ClipPlane(this.data);
      this.logicOp = new LogicOp(this.data);
      this.lightning = new Lightning(this.data);
      this.alphaTest = new AlphaTest(this.data);
      this.blending = new Blending(this.data);
      this.patch = new PatchState(this.data);
      this.texture = new TextureState(this.data);
      this.lineSmoothState = new LineSmoothState(this.data);
      this.patchCullingState = new PatchCullingState(this.data);
      this.culling = new CullingState(this.data);
      this.dithering = new DitheringState(this.data);
      this.colorTest = new ColorTestState(this.data);
      this.depthTest = new DepthTestState(this.data);
    }
    copyFrom(that) {
      return this.writeData(that.data);
    }
    writeData(data) {
      this.data.set(data);
      return this;
    }
    readData() {
      return ArrayBufferUtils.cloneUint32Array(this.data);
    }
    get clearing() {
      return param1(this.data[Op.CLEAR], 0) != 0;
    }
    get clearFlags() {
      return param8(this.data[Op.CLEAR], 8);
    }
    get baseAddress() {
      return param24(this.data[Op.BASE]) << 8 & 4278190080;
    }
    set baseOffset(value) {
      this.data[Op.OFFSETADDR] &= ~16777215;
      this.data[Op.OFFSETADDR] |= value >>> 8 & 16777215;
    }
    get baseOffset() {
      return param24(this.data[Op.OFFSETADDR]) << 8;
    }
    get indexAddress() {
      return param24(this.data[Op.IADDR]);
    }
    get shadeModel() {
      return param16(this.data[Op.SHADEMODE], 0);
    }
    get ambientModelColor() {
      return new Color().setRGB_A(this.data[Op.MATERIALAMBIENT], this.data[Op.MATERIALALPHA]);
    }
    get diffuseModelColor() {
      return new Color().setRGB(this.data[Op.MATERIALDIFFUSE]);
    }
    get specularModelColor() {
      return new Color().setRGB(this.data[Op.MATERIALSPECULAR]);
    }
    get drawPixelFormat() {
      return param4(this.data[Op.PSM], 0);
    }
    writeFloat(index, offset, data) {
      this.dataf[offset + this.data[index]++] = data;
    }
    getMorphWeight(index) {
      return float1(this.data[Op.MORPHWEIGHT0 + index]);
    }
    getAddressRelativeToBase(relativeAddress) {
      return this.baseAddress | relativeAddress;
    }
    getAddressRelativeToBaseOffset(relativeAddress) {
      return (this.baseAddress | relativeAddress) + this.baseOffset;
    }
  };
  var ColorTestState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.COLORTESTENABLE]);
    }
  };
  var DitheringState = class {
    constructor(data) {
      this.data = data;
    }
    get enabled() {
      return bool1(this.data[Op.DITHERENABLE]);
    }
  };
  var WrapMode;
  (function(WrapMode2) {
    WrapMode2[WrapMode2["Repeat"] = 0] = "Repeat";
    WrapMode2[WrapMode2["Clamp"] = 1] = "Clamp";
  })(WrapMode || (WrapMode = {}));
  var TextureEffect;
  (function(TextureEffect2) {
    TextureEffect2[TextureEffect2["Modulate"] = 0] = "Modulate";
    TextureEffect2[TextureEffect2["Decal"] = 1] = "Decal";
    TextureEffect2[TextureEffect2["Blend"] = 2] = "Blend";
    TextureEffect2[TextureEffect2["Replace"] = 3] = "Replace";
    TextureEffect2[TextureEffect2["Add"] = 4] = "Add";
  })(TextureEffect || (TextureEffect = {}));
  var TextureFilter;
  (function(TextureFilter2) {
    TextureFilter2[TextureFilter2["Nearest"] = 0] = "Nearest";
    TextureFilter2[TextureFilter2["Linear"] = 1] = "Linear";
    TextureFilter2[TextureFilter2["NearestMipmapNearest"] = 4] = "NearestMipmapNearest";
    TextureFilter2[TextureFilter2["LinearMipmapNearest"] = 5] = "LinearMipmapNearest";
    TextureFilter2[TextureFilter2["NearestMipmapLinear"] = 6] = "NearestMipmapLinear";
    TextureFilter2[TextureFilter2["LinearMipmapLinear"] = 7] = "LinearMipmapLinear";
  })(TextureFilter || (TextureFilter = {}));
  var TextureColorComponent;
  (function(TextureColorComponent2) {
    TextureColorComponent2[TextureColorComponent2["Rgb"] = 0] = "Rgb";
    TextureColorComponent2[TextureColorComponent2["Rgba"] = 1] = "Rgba";
  })(TextureColorComponent || (TextureColorComponent = {}));
  var PrimitiveType;
  (function(PrimitiveType2) {
    PrimitiveType2[PrimitiveType2["Points"] = 0] = "Points";
    PrimitiveType2[PrimitiveType2["Lines"] = 1] = "Lines";
    PrimitiveType2[PrimitiveType2["LineStrip"] = 2] = "LineStrip";
    PrimitiveType2[PrimitiveType2["Triangles"] = 3] = "Triangles";
    PrimitiveType2[PrimitiveType2["TriangleStrip"] = 4] = "TriangleStrip";
    PrimitiveType2[PrimitiveType2["TriangleFan"] = 5] = "TriangleFan";
    PrimitiveType2[PrimitiveType2["Sprites"] = 6] = "Sprites";
  })(PrimitiveType || (PrimitiveType = {}));

  // src/core/gpu/webgl/webgl_utils.ts
  var mat4x3 = mat4.create();
  var WrappedWebGLUniform = class {
    constructor(gl, program, name2) {
      this.gl = gl;
      this.program = program;
      this.name = name2;
      this.location = gl.getUniformLocation(program, name2);
    }
    setMat4(data) {
      this.gl.uniformMatrix4fv(this.location, false, data);
    }
    setMat4x3(data) {
      mat4.from4x3(mat4x3, data);
      this.gl.uniformMatrix4fv(this.location, false, mat4x3);
    }
    set1i(x) {
      this.gl.uniform1i(this.location, x);
    }
    set1f(x) {
      this.gl.uniform1f(this.location, x);
    }
    set2f(x, y) {
      this.gl.uniform2f(this.location, x, y);
    }
    set4f(x, y, z, w) {
      this.gl.uniform4f(this.location, x, y, z, w);
    }
  };
  var WrappedWebGLAttrib = class {
    constructor(gl, program, name2) {
      this.gl = gl;
      this.program = program;
      this.name = name2;
      this.location = gl.getAttribLocation(program, name2);
    }
    enable() {
      if (this.location < 0)
        return;
      this.gl.enableVertexAttribArray(this.location);
    }
    disable() {
      if (this.location < 0)
        return;
      this.gl.disableVertexAttribArray(this.location);
    }
    setFloats(rsize, arr) {
      if (this.location < 0)
        return;
      const gl = this.gl;
      if (!this.buffer)
        this.buffer = this.gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, arr, gl.DYNAMIC_DRAW);
      this.enable();
      gl.vertexAttribPointer(this.location, rsize, gl.FLOAT, false, 0, 0);
    }
  };
  var WrappedWebGLProgram = class {
    constructor(gl, program, vs, fs2) {
      this.gl = gl;
      this.program = program;
      this.vs = vs;
      this.fs = fs2;
      this.uniforms = {};
      this.attribs = {};
      this.vPosition = this.getAttrib("vPosition");
      this.vColor = this.getAttrib("vColor");
      this.vTexcoord = this.getAttrib("vTexcoord");
      this.vNormal = this.getAttrib("vNormal");
      this.vertexWeight1 = this.getAttrib("vertexWeight1");
      this.vertexWeight2 = this.getAttrib("vertexWeight2");
    }
    use() {
      this.gl.useProgram(this.program);
    }
    getUniform(name2) {
      let uniform = this.uniforms[name2];
      if (!uniform)
        uniform = this.uniforms[name2] = new WrappedWebGLUniform(this.gl, this.program, name2);
      return uniform;
    }
    getAttrib(name2) {
      let attrib = this.attribs[name2];
      if (!attrib)
        attrib = this.attribs[name2] = new WrappedWebGLAttrib(this.gl, this.program, name2);
      return attrib;
    }
  };
  var FastFloat32Buffer = class {
    constructor() {
      this.arrayBuffer = new ArrayBuffer(32768 * 4 * 4 * 4);
      this.float32Array = new Float32Array(this.arrayBuffer);
      this.index = 0;
    }
    restart() {
      this.index = 0;
    }
    push(value) {
      this.float32Array[this.index++] = value;
    }
    push2(x, y) {
      this.float32Array[this.index++] = x;
      this.float32Array[this.index++] = y;
    }
    push3(x, y, z) {
      this.float32Array[this.index++] = x;
      this.float32Array[this.index++] = y;
      this.float32Array[this.index++] = z;
    }
    push4(x, y, z, w) {
      this.float32Array[this.index++] = x;
      this.float32Array[this.index++] = y;
      this.float32Array[this.index++] = z;
      this.float32Array[this.index++] = w;
    }
    slice() {
      return new Float32Array(this.arrayBuffer, 0, this.index);
    }
  };

  // src/core/gpu/webgl/webgl_shader.ts
  var ShaderCache = class {
    constructor(gl, shaderVertString, shaderFragString) {
      this.gl = gl;
      this.shaderVertString = shaderVertString;
      this.shaderFragString = shaderFragString;
      this.programs = {};
    }
    invalidateWithGl(gl) {
      this.programs = {};
      this.gl = gl;
    }
    getProgram(vertex, state, optimized) {
      let hash = vertex.hash;
      hash += Math.pow(2, 32) * (state.alphaTest.enabled ? 1 : 0);
      hash += Math.pow(2, 33) * (state.clearing ? 1 : 0);
      hash += Math.pow(2, 34) * (optimized ? 1 : 0);
      if (this.programs[hash])
        return this.programs[hash];
      return this.programs[hash] = this.createProgram(vertex, state, optimized);
    }
    createProgram(vertex, state, optimized) {
      const defines = [];
      if (optimized)
        defines.push("OPTIMIZED 1");
      if (vertex.transform2D)
        defines.push("TRANSFORM_2D 1");
      if (vertex.hasPosition)
        defines.push(`VERTEX_POSITION ${vertex.position}`);
      if (vertex.hasColor)
        defines.push(`VERTEX_COLOR ${vertex.color}`);
      if (vertex.hasTexture) {
        defines.push(`VERTEX_TEXTURE ${vertex.texture}`);
        if (PixelFormatUtils.hasClut(state.texture.pixelFormat)) {
          defines.push("TEXTURE_CLUT 1");
        }
      }
      if (vertex.hasNormal)
        defines.push(`VERTEX_NORMAL ${vertex.normal}`);
      if (vertex.hasWeight)
        defines.push(`VERTEX_WEIGHT ${vertex.weight}`);
      if (!state.clearing) {
        if (state.alphaTest.enabled)
          defines.push("ALPHATEST 1");
      }
      defines.push(`VERTEX_SKINNING ${vertex.realWeightCount}`);
      const preppend = defines.map((item) => `#define ${item}`).join("\n");
      return ShaderCache.shaderProgram(this.gl, preppend + "\n" + this.shaderVertString, preppend + "\n" + this.shaderFragString);
    }
    static shaderProgram(gl, vs, fs2) {
      const prog = gl.createProgram();
      const addshader = (type, source) => {
        const s = gl.createShader(type == "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
          throw new Error("Could not compile " + type + " shader:\n\n" + gl.getShaderInfoLog(s) + "\n\n" + source);
        gl.attachShader(prog, s);
      };
      addshader("vertex", vs);
      addshader("fragment", fs2);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
        throw new Error("Could not link the shader program!");
      return new WrappedWebGLProgram(gl, prog, vs, fs2);
    }
  };

  // src/core/gpu/webgl/webgl_texture.ts
  var Texture = class {
    constructor(gl) {
      this.gl = gl;
      this.valid = false;
      this.hash = "";
      this.recheckCount = 0;
      this.framesEqual = 0;
      this._width = void 0;
      this._height = void 0;
      this.texture = gl.createTexture();
      this.state = new GpuState();
    }
    get textureState() {
      return this.state.texture;
    }
    get mipmap() {
      return this.textureState.mipmaps[0];
    }
    get width() {
      return this._width || this.mipmap.textureWidth;
    }
    get height() {
      return this._height || this.mipmap.textureHeight;
    }
    get swizzled() {
      return this.textureState.swizzled;
    }
    get addressStart() {
      return this.mipmap.address;
    }
    get addressEnd() {
      return this.mipmap.addressEnd;
    }
    get pixelFormat() {
      return this.textureState.pixelFormat;
    }
    updateFromState(state, textureData, clutData, mem) {
      this.state.copyFrom(state);
      const textureState = state.texture;
      const clutState = state.texture.clut;
      const mipmap = textureState.mipmaps[0];
      const h = mipmap.textureHeight, w = mipmap.textureWidth, w2 = mipmap.bufferWidth;
      const data = new Uint8Array(PixelConverter.getSizeInBytes(state.texture.pixelFormat, w2 * h));
      data.set(textureData);
      if (state.texture.swizzled)
        PixelConverter.unswizzleInline(state.texture.pixelFormat, data, w2, h);
      let clut = null;
      if (textureState.hasClut) {
        clut = new Uint32Array(clutState.numberOfColors);
        for (let n = 0; n < clut.length; n++) {
          clut[n] = clutState.getColor(mem, n);
        }
      }
      this.fromBytesRGBA(PixelConverter.decode(textureState.pixelFormat, data, new Uint32Array(w2 * h), textureState.hasAlpha, clut, 0, 0, 255), w2, h);
    }
    _create(callbackTex2D) {
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      callbackTex2D();
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    fromBytesRGBA(data, width, height) {
      const gl = this.gl;
      this._width = width;
      this._height = height;
      this._create(() => {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, ArrayBufferUtils.uint32ToUint8(data));
      });
    }
    fromCanvas(canvas) {
      const gl = this.gl;
      this._width = canvas.width;
      this._height = canvas.height;
      this._create(() => {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      });
    }
    bind(textureUnit, min, mag, wraps, wrapt) {
      const gl = this.gl;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, min);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mag);
      if (!MathUtils.isPowerOfTwo(this.width) || !MathUtils.isPowerOfTwo(this.height)) {
        wraps = wrapt = gl.CLAMP_TO_EDGE;
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wraps);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapt);
    }
    static createCanvas() {
    }
    toString() {
      return `Texture(address = ${this.addressStart}, hash = ${this.hash}, pixelFormat = ${this.pixelFormat}, swizzled = ${this.swizzled}`;
    }
  };
  var TextureHandler = class {
    constructor(gl, stats, mem) {
      this.gl = gl;
      this.stats = stats;
      this.mem = mem;
      this.texturesByHash = new Map();
      this.texturesByAddress = new Map();
      this.textures = [];
      this.rehashSignal = new Signal1();
      this.invalidateWithGl(gl);
    }
    invalidateWithGl(gl) {
      this.gl = gl;
      this.texturesByHash = new Map();
      this.texturesByAddress = new Map();
      this.textures = [];
    }
    invalidatedMemoryAll() {
      for (let texture of this.textures)
        texture.valid = false;
    }
    invalidatedMemoryRange(low, high) {
      for (let texture of this.textures) {
        if (texture.addressStart >= low && texture.addressEnd <= high)
          texture.valid = false;
      }
    }
    startFrame() {
    }
    endFrame() {
    }
    bindTexture(prog, state, enableBilinear, buffer, batch) {
      const gl = this.gl;
      const textureId = batch.textureLow + batch.clutLow * Math.pow(2, 24);
      const textureData = batch.textureLow > 0 ? new Uint8Array(buffer, batch.textureLow, batch.textureHigh - batch.textureLow) : null;
      const clutData = batch.clutLow > 0 ? new Uint8Array(buffer, batch.clutLow, batch.clutHigh - batch.clutLow) : null;
      const mipmap = state.texture.mipmaps[0];
      if (mipmap.bufferWidth == 0)
        return;
      if (mipmap.textureWidth == 0)
        return;
      if (mipmap.textureHeight == 0)
        return;
      let hasClut = PixelFormatUtils.hasClut(state.texture.pixelFormat);
      let clutState = state.texture.clut;
      let textureState = state.texture;
      let clutAddress = hasClut ? clutState.address : 0;
      let texture;
      const fastHash = mipmap.address + clutAddress * Math.pow(2, 24) + textureState.colorComponent * Math.pow(2, 18);
      if (!this.texturesByAddress.get(fastHash)) {
        texture = new Texture(gl);
        this.texturesByAddress.set(fastHash, texture);
        this.textures.push(texture);
      }
      texture = this.texturesByAddress.get(fastHash);
      if (!texture.valid) {
        const hash = textureState.getHashSlow(textureData, clutData);
        this.stats.hashMemoryCount++;
        this.stats.hashMemorySize += mipmap.sizeInBytes;
        this.rehashSignal.dispatch(mipmap.sizeInBytes);
        if (this.texturesByHash.has(hash)) {
          texture = this.texturesByHash.get(hash);
        } else if (texture.hash != hash) {
          this.texturesByHash.delete(texture.hash);
          texture.hash = hash;
          texture.valid = true;
          this.texturesByHash.set(hash, texture);
          texture.updateFromState(state, textureData, clutData, this.mem);
        }
      }
      texture.bind(0, enableBilinear && state.texture.filterMinification == TextureFilter.Linear ? gl.LINEAR : gl.NEAREST, enableBilinear && state.texture.filterMagnification == TextureFilter.Linear ? gl.LINEAR : gl.NEAREST, convertWrapMode[state.texture.wrapU], convertWrapMode[state.texture.wrapV]);
      prog.getUniform("textureSize").set2f(texture.width, texture.height);
      prog.getUniform("pixelSize").set2f(1 / texture.width, 1 / texture.height);
      prog.getUniform("uSampler").set1i(0);
    }
    unbindTexture(program, state) {
      const gl = this.gl;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  };
  var convertWrapMode = [GL.REPEAT, GL.CLAMP_TO_EDGE];

  // src/core/gpu/webgl/webgl_shaders.ts
  var shader_frag = `
precision mediump float;

//#define DEBUG 1

#define GU_TCC_RGB       0
#define GU_TCC_RGBA      1

uniform int u_enableColors;
uniform int u_enableTextures;
uniform int u_enableBilinear;

#ifdef VERTEX_COLOR
  varying vec4 v_Color;
#else
  uniform vec4 uniformColor;
#endif

#ifdef VERTEX_TEXTURE
  uniform sampler2D uSampler;
  uniform vec2 textureSize;
  uniform vec2 pixelSize;
  uniform int tfx;
  uniform int tcc;
  varying vec4 v_Texcoord;
#endif

#ifdef ALPHATEST
  uniform int alphaTestFunc;
  uniform int alphaTestReference;
  uniform int alphaTestMask;
#endif

uniform float time;

void main() {
  #ifdef DEBUG
    #ifdef VERTEX_TEXTURE
      gl_FragColor = vec4(v_Texcoord.s, v_Texcoord.t, 0.0, 1.0);
    #else
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    #endif
    return;
  #else
    #ifdef VERTEX_COLOR
      gl_FragColor = v_Color;
    #else
      gl_FragColor = uniformColor;
    #endif

    #ifdef VERTEX_TEXTURE
      vec4 texColor;
      texColor = texture2D(uSampler, vec2(v_Texcoord.s, v_Texcoord.t));
      if (u_enableTextures == 0) {
        texColor.rgb = vec3(1.0, 1.0, 1.0);
      }

      #ifdef ALPHATEST
        int alphaTestColor = int(texColor.a * 255.0);
        if (alphaTestMask != 0xFF) alphaTestColor = 0;

             if (alphaTestFunc == 0) { discard; } // GU_NEVER
        else if (alphaTestFunc == 1) { } // GU_ALWAYS
        else if (alphaTestFunc == 2) { if (!(alphaTestColor == alphaTestReference)) discard; } // GU_EQUAL
        else if (alphaTestFunc == 3) { if (!(alphaTestColor != alphaTestReference)) discard; } // GU_NOT_EQUAL
        else if (alphaTestFunc == 4) { if (!(alphaTestColor  < alphaTestReference)) discard; } // GU_LESS
        else if (alphaTestFunc == 5) { if (!(alphaTestColor <= alphaTestReference)) discard; } // GU_LESS_OR_EQUAL
        else if (alphaTestFunc == 6) { if (!(alphaTestColor  > alphaTestReference)) discard; } // GU_GREATER
        else if (alphaTestFunc == 7) { if (!(alphaTestColor >= alphaTestReference)) discard; } // GU_GREATER_OR_EQUAL
      #endif

      if (u_enableColors != 0) {
        if (tfx == 0) { // GU_TFX_MODULATE
          gl_FragColor.rgb = texColor.rgb * gl_FragColor.rgb;
          gl_FragColor.a = (tcc == GU_TCC_RGBA) ? (gl_FragColor.a * texColor.a) : texColor.a;
        } else if (tfx == 1) { // GU_TFX_DECAL
          if (tcc == GU_TCC_RGB) {
            gl_FragColor.rgba = texColor.rgba;
          } else {
            gl_FragColor.rgb = texColor.rgb * gl_FragColor.rgb;
            gl_FragColor.a = texColor.a;
          }
        } else if (tfx == 2) { // GU_TFX_BLEND
          gl_FragColor.rgba = mix(texColor, gl_FragColor, 0.5);
        } else if (tfx == 3) { // GU_TFX_REPLACE
          gl_FragColor.rgb = texColor.rgb;
          gl_FragColor.a = (tcc == GU_TCC_RGB) ? gl_FragColor.a : texColor.a;
        } else if (tfx == 4) { // GU_TFX_ADD
          gl_FragColor.rgb += texColor.rgb;
          gl_FragColor.a = (tcc == GU_TCC_RGB) ? gl_FragColor.a : (texColor.a * gl_FragColor.a);
        } else {
          gl_FragColor = vec4(1, 0, 1, 1);
        }
      } else {
        gl_FragColor = texColor;
      }
    #endif
  #endif
}
`;
  var shader_vert = `
//#extension GL_ARB_gpu_shader_fp64 : enable
//#pragma optionNV(fastmath off)
//#pragma optionNV(fastprecision off)

precision mediump float;

uniform mat4 u_modelViewProjMatrix;

attribute vec4 vPosition;

uniform int u_enableSkinning;

#define TYPE_VOID 0
#define TYPE_BYTE 1
#define TYPE_SHORT 2
#define TYPE_FLOAT 3

#define COLOR_VOID 0
#define COLOR_5650 4
#define COLOR_5551 5
#define COLOR_4444 6
#define COLOR_8888 7

#ifdef VERTEX_COLOR
  attribute highp vec4 vColor;
  varying vec4 v_Color;
#endif

#ifdef VERTEX_TEXTURE
  uniform mat4 u_texMatrix;
  attribute highp vec4 vTexcoord;
  varying vec4 v_Texcoord;
#endif

#ifdef VERTEX_NORMAL
  attribute vec4 vNormal;
#endif

#if (VERTEX_SKINNING >= 1)
  uniform mat4 matrixBone0;
  uniform mat4 matrixBone1;
  uniform mat4 matrixBone2;
  uniform mat4 matrixBone3;
  uniform mat4 matrixBone4;
  uniform mat4 matrixBone5;
  uniform mat4 matrixBone6;
  uniform mat4 matrixBone7;

  attribute vec4 vertexWeight1;
  attribute vec4 vertexWeight2;

  mat4 getMatrixBone(int index) {
    if (index == 0) return matrixBone0;
    if (index == 1) return matrixBone1;
    if (index == 2) return matrixBone2;
    if (index == 3) return matrixBone3;
    if (index == 4) return matrixBone4;
    if (index == 5) return matrixBone5;
    if (index == 6) return matrixBone6;
    return matrixBone7;
  }

  
  float _getVertexWeight(int index) {
    if (index == 0) return vertexWeight1.x;
    if (index == 1) return vertexWeight1.y;
    if (index == 2) return vertexWeight1.z;
    if (index == 3) return vertexWeight1.w;
    if (index == 4) return vertexWeight2.x;
    if (index == 5) return vertexWeight2.y;
    if (index == 6) return vertexWeight2.z;
    if (index == 7) return vertexWeight2.w;
    return 0.0;
  }
  
  float getVertexWeight(int index) {
    float weight = _getVertexWeight(index);
    
    #if VERTEX_WEIGHT == TYPE_BYTE
    weight /= 128.0;
    #elif VERTEX_WEIGHT == TYPE_SHORT
    weight /= 32768.0;
    #endif

    return weight;
  }

  vec4 performSkinning(vec4 vertexIn) {
    vec4 vertexOut = vec4(0.0, 0.0, 0.0, 0.0);
  
    float totalWeight = 0.0;
    for (int n = 0; n < VERTEX_SKINNING; n++) totalWeight += (getVertexWeight(n));
    for (int n = 0; n < VERTEX_SKINNING; n++) vertexOut += (getMatrixBone(n) * (getVertexWeight(n)) / totalWeight) * vertexIn;

    return vertexOut;
  }

  //vec4 prepareNormal(vec4 normal) {
  //  return hasReversedNormal ? -normal : normal;
  //}
#endif

#ifdef VERTEX_COLOR

// We will be able to use >> and && when webgl2 is released.
// Since the emulator requires quite power, probably mobiles/desktops
// that we will be able to run it at decent speeds will support opengl es 3.0,
// and thus webgl2

void DecodeColor5650(inout highp vec4 C)
{
    int packedBits = int(C.x);
    int rBits = packedBits - (packedBits / 32 * 32);
    int gBits = (packedBits / 32) - (packedBits / 32 / 64 * 64);
    int bBits = packedBits / 2048;
    C.r = float((rBits * 8) + (rBits /  4));
    C.g = float((gBits * 4) + (gBits / 16));
    C.b = float((bBits * 8) + (bBits /  4));
    C.a = 1.0;
    C.rgb /= 255.0;
}

void DecodeColor5551(inout highp vec4 C)
{
    int packedBits = int(C.x);
    int rBits = packedBits - (packedBits / 32 * 32);
    int gBits = (packedBits / 32) - (packedBits / 32 / 32 * 32);
    int bBits = (packedBits / 1024) - (packedBits / 1024 / 32 * 32);
    C.r = float((rBits * 8) + (rBits / 4));
    C.g = float((gBits * 8) + (gBits / 4));
    C.b = float((bBits * 8) + (bBits / 4));
    C.a = float(packedBits / 32768);
    C.rgb /= 255.0;
}
void DecodeColor4444(inout highp vec4 C)
{
    int packedBits = int(C.x);
    int rBits = packedBits - (packedBits / 16 * 16);
    int gBits = (packedBits / 16) - (packedBits / 16 / 16 * 16);
    int bBits = (packedBits / 256) - (packedBits / 256 / 16 * 16);
    int aBits = packedBits / 4096;
    C.r = float((rBits * 16) + rBits);
    C.g = float((gBits * 16) + gBits);
    C.b = float((bBits * 16) + bBits);
    C.a = float((aBits * 16) + aBits);
    C /= 255.0;
}
#endif

void main() {
  #ifdef VERTEX_COLOR
    v_Color = vColor;
    #ifdef OPTIMIZED
      #if VERTEX_COLOR == COLOR_5650
      DecodeColor5650(v_Color);
      #elif VERTEX_COLOR == COLOR_5551
      DecodeColor5551(v_Color);
      #elif VERTEX_COLOR == COLOR_4444
      DecodeColor4444(v_Color);
      #elif VERTEX_COLOR == COLOR_8888
      v_Color /= vec4(255.0);
      #endif
    #endif
  #endif
  
  #ifdef VERTEX_TEXTURE
    vec4 tcoord = vTexcoord;
    #ifndef TRANSFORM_2D
      #if VERTEX_TEXTURE == TYPE_BYTE
      tcoord.xy /= vec2(128.0);
      #elif VERTEX_TEXTURE == TYPE_SHORT
      tcoord.xy /= vec2(32768.0);
      #endif
    #endif
    v_Texcoord = u_texMatrix * tcoord;
  #endif

  vec4 pos = vPosition;
  #ifndef TRANSFORM_2D
    #if VERTEX_POSITION == TYPE_BYTE
    pos.xyz /= vec3(127.0);
    #elif VERTEX_POSITION == TYPE_SHORT
    pos.xyz /= vec3(32767.0);
    #endif
  #endif
  
  #if (VERTEX_SKINNING >= 1)
    if (u_enableSkinning != 0) {
      pos = performSkinning(pos);
    }
  #endif

  gl_Position = u_modelViewProjMatrix * pos;
}
`;

  // src/ui/emulator_ui.ts
  var EmulatorUI = class {
    static openMessageAsync(message) {
      console.error(message);
      if (window.alert)
        window.alert(message);
      return PromiseFast.resolve(true);
    }
  };

  // src/core/gpu/webgl/webgl_driver.ts
  var globalDriver = null;
  var WebGlPspDrawDriver = class {
    constructor(canvas, stats) {
      this.canvas = canvas;
      this.stats = stats;
      this.glAntialiasing = false;
      this.clearing = false;
      this.clearingFlags = 0;
      this.projectionMatrix = mat4.create();
      this.viewMatrix = mat4.create();
      this.worldMatrix = mat4.create();
      this.transformMatrix = mat4.create();
      this.transformMatrix2d = mat4.create();
      this.equationTranslate = [GL.FUNC_ADD, GL.FUNC_SUBTRACT, GL.FUNC_REVERSE_SUBTRACT, GL.FUNC_ADD, GL.FUNC_ADD, GL.FUNC_ADD];
      this.opsConvertTable = [GL.KEEP, GL.ZERO, GL.REPLACE, GL.INVERT, GL.INCR, GL.DECR];
      this.testConvertTable = [GL.NEVER, GL.ALWAYS, GL.EQUAL, GL.NOTEQUAL, GL.LESS, GL.LEQUAL, GL.GREATER, GL.GEQUAL];
      this.testConvertTable_inv = [GL.NEVER, GL.ALWAYS, GL.EQUAL, GL.NOTEQUAL, GL.GREATER, GL.GEQUAL, GL.LESS, GL.LEQUAL];
      this.optimizedDataBuffer = null;
      this.optimizedIndexBuffer = null;
      this.enableColors = true;
      this.enableTextures = true;
      this.enableSkinning = true;
      this.enableBilinear = true;
      this.frameBufferWidth = 480;
      this.frameBufferHeight = 272;
      this.state = new GpuState();
      this.drawRatio = 1;
      this.lastTransfer = null;
      this.vs = new VertexInfo();
      this.testCount = 20;
      this.positionData = new FastFloat32Buffer();
      this.colorData = new FastFloat32Buffer();
      this.textureData = new FastFloat32Buffer();
      this.normalData = new FastFloat32Buffer();
      this.vertexWeightData1 = new FastFloat32Buffer();
      this.vertexWeightData2 = new FastFloat32Buffer();
      this.lastBaseAddress = 0;
      this.tempVec = new Float32Array([0, 0, 0]);
      this.texMat = mat4.create();
      globalDriver = this;
      this.createCanvas(false);
      this.transformMatrix2d = mat4.ortho(mat4.create(), 0, 480, 272, 0, 0, -65535);
    }
    set antialiasing(value) {
      if (this.glAntialiasing == value)
        return;
      this.glAntialiasing = value;
      this.createCanvas(value);
    }
    get antialiasing() {
      return this.glAntialiasing;
    }
    createCanvas(glAntialiasing) {
      this.glAntialiasing = glAntialiasing;
      const webglOptions = {
        alpha: false,
        depth: true,
        stencil: true,
        antialias: glAntialiasing,
        preserveDrawingBuffer: false
      };
      this.gl = this.canvas.getContext("webgl", webglOptions);
      if (!this.gl)
        this.gl = this.canvas.getContext("experimental-webgl", webglOptions);
      if (!this.gl) {
        EmulatorUI.openMessageAsync("Can't initialize WebGL!");
        throw new Error("Can't initialize WebGL!");
      }
      if (this.cache)
        this.cache.invalidateWithGl(this.gl);
      if (this.textureHandler)
        this.textureHandler.invalidateWithGl(this.gl);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    }
    invalidatedMemoryAll() {
      this.textureHandler.invalidatedMemoryAll();
    }
    invalidatedMemoryRange(low, high) {
      this.textureHandler.invalidatedMemoryRange(low, high);
    }
    register(memory2) {
      this.cache = new ShaderCache(this.gl, shader_vert, shader_frag);
      this.textureHandler = new TextureHandler(this.gl, this.stats, memory2);
    }
    unregister() {
      this.rehashSignal.clear();
    }
    setClearMode(clearing, flags) {
      this.clearing = clearing;
      this.clearingFlags = flags;
    }
    setMatrices(projectionMatrix, viewMatrix, worldMatrix) {
      mat4.from4x4(this.projectionMatrix, projectionMatrix);
      mat4.from4x3(this.viewMatrix, viewMatrix);
      mat4.from4x3(this.worldMatrix, worldMatrix);
      mat4.identity(this.transformMatrix);
      mat4.multiply(this.transformMatrix, this.transformMatrix, this.projectionMatrix);
      mat4.multiply(this.transformMatrix, this.transformMatrix, this.viewMatrix);
      mat4.multiply(this.transformMatrix, this.transformMatrix, this.worldMatrix);
    }
    enableDisable(type, enable) {
      if (enable)
        this.gl.enable(type);
      else
        this.gl.disable(type);
      return enable;
    }
    updateNormalState(program, vertexInfo, primitiveType) {
      const state = this.state;
      const gl = this.gl;
      if (this.enableDisable(gl.CULL_FACE, state.culling.enabled && primitiveType != PrimitiveType.Sprites)) {
        gl.cullFace(state.culling.direction == CullingDirection.ClockWise ? gl.FRONT : gl.BACK);
      }
      if (this.enableDisable(gl.SCISSOR_TEST, state.clipPlane.enabled)) {
        const rect = state.clipPlane.scissor;
        const ratio = this.getScaleRatio();
        gl.scissor(rect.left * ratio, rect.top * ratio, rect.width * ratio, rect.height * ratio);
      }
      const blending = state.blending;
      if (this.enableDisable(gl.BLEND, blending.enabled)) {
        const getBlendFix = (color) => {
          if (color.equals(0, 0, 0, 1))
            return gl.ZERO;
          if (color.equals(1, 1, 1, 1))
            return gl.ONE;
          return gl.CONSTANT_COLOR;
        };
        let sfactor = gl.SRC_COLOR + blending.functionSource;
        let dfactor = gl.SRC_COLOR + blending.functionDestination;
        if (blending.functionSource == GuBlendingFactor.GU_FIX) {
          sfactor = getBlendFix(blending.fixColorSource);
        }
        if (blending.functionDestination == GuBlendingFactor.GU_FIX) {
          if (sfactor == gl.CONSTANT_COLOR && Color.add(blending.fixColorSource, blending.fixColorDestination).equals(1, 1, 1, 1)) {
            dfactor = gl.ONE_MINUS_CONSTANT_COLOR;
          } else {
            dfactor = getBlendFix(blending.fixColorDestination);
          }
        }
        gl.blendEquation(this.equationTranslate[blending.equation]);
        gl.blendFunc(sfactor, dfactor);
        switch (blending.equation) {
          case GuBlendingEquation.Abs:
          case GuBlendingEquation.Max:
          case GuBlendingEquation.Min:
          case GuBlendingEquation.Add:
            gl.blendEquation(gl.FUNC_ADD);
            break;
          case GuBlendingEquation.Substract:
            gl.blendEquation(gl.FUNC_SUBTRACT);
            break;
          case GuBlendingEquation.ReverseSubstract:
            gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
            break;
        }
        const blendColor = blending.fixColorDestination;
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
      }
      const stencil = state.stencil;
      if (this.enableDisable(gl.STENCIL_TEST, stencil.enabled)) {
        gl.stencilFunc(this.testConvertTable[stencil.func], stencil.funcRef, stencil.funcMask);
        gl.stencilOp(this.opsConvertTable[stencil.fail], this.opsConvertTable[stencil.zfail], this.opsConvertTable[stencil.zpass]);
      }
      gl.depthRange(state.depthTest.rangeFar, state.depthTest.rangeNear);
      gl.depthMask(state.depthTest.mask == 0);
      if (this.enableDisable(gl.DEPTH_TEST, state.depthTest.enabled && !state.vertex.transform2D)) {
        gl.depthFunc(this.testConvertTable_inv[state.depthTest.func]);
      }
      const alphaTest = state.alphaTest;
      if (alphaTest.enabled) {
        program.getUniform("alphaTestFunc").set1i(alphaTest.func);
        program.getUniform("alphaTestReference").set1i(alphaTest.value);
        program.getUniform("alphaTestMask").set1i(alphaTest.mask);
      } else {
      }
    }
    updateClearStateEnd(program, vertexInfo, primitiveType) {
      const gl = this.gl;
      gl.colorMask(true, true, true, true);
    }
    updateClearStateStart(program, vertexInfo, primitiveType) {
      const state = this.state;
      const gl = this.gl;
      let ccolorMask = false, calphaMask = false;
      const clearingFlags = this.clearingFlags;
      gl.disable(gl.SCISSOR_TEST);
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.disable(gl.CULL_FACE);
      gl.depthMask(false);
      if (clearingFlags & ClearBufferSet.ColorBuffer) {
        ccolorMask = true;
      }
      if (clearingFlags & ClearBufferSet.StencilBuffer) {
        calphaMask = true;
        gl.enable(gl.STENCIL_TEST);
        gl.stencilFunc(gl.ALWAYS, 0, 255);
        gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
      }
      if (clearingFlags & ClearBufferSet.DepthBuffer) {
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.ALWAYS);
        gl.depthMask(true);
        gl.depthRange(state.depthTest.rangeNear, state.depthTest.rangeNear);
      }
      gl.colorMask(ccolorMask, ccolorMask, ccolorMask, calphaMask);
    }
    updateCommonState(program, vertexInfo, primitiveType) {
      const viewport = this.state.viewport;
      const x = 2048 - viewport.x;
      const y = 2048 - viewport.y;
      const width = Math.abs(viewport.width * 2);
      const height = Math.abs(-viewport.height * 2);
      const ratio = this.getScaleRatio();
      this.gl.viewport(x * ratio, y * ratio, width * ratio, height * ratio);
    }
    updateState(program, vertexInfo, primitiveType) {
      program.getUniform("u_enableColors").set1i(this.enableColors ? 1 : 0);
      program.getUniform("u_enableTextures").set1i(this.enableTextures ? 1 : 0);
      program.getUniform("u_enableSkinning").set1i(this.enableSkinning ? 1 : 0);
      program.getUniform("u_enableBilinear").set1i(this.enableBilinear ? 1 : 0);
      if (this.state.clearing) {
        this.updateClearStateStart(program, vertexInfo, primitiveType);
      } else {
        this.updateNormalState(program, vertexInfo, primitiveType);
      }
      this.updateCommonState(program, vertexInfo, primitiveType);
    }
    getScaleRatio() {
      return this.canvas.width / 480;
    }
    beforeDraw(state) {
      this.state.copyFrom(state);
      this.setClearMode(state.clearing, state.clearFlags);
      this.setMatrices(state.projectionMatrix, state.viewMatrix, state.worldMatrix);
    }
    setAttribute(databuffer, attribPosition, componentCount, componentType, vertexSize, offset) {
      if (attribPosition.location < 0)
        return;
      const gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, databuffer);
      gl.enableVertexAttribArray(attribPosition.location);
      gl.vertexAttribPointer(attribPosition.location, componentCount, componentType, false, vertexSize, offset);
    }
    get rehashSignal() {
      return this.textureHandler.rehashSignal;
    }
    setFramebufferSize(width, height) {
      this.canvas.setAttribute("width", `${width}`);
      this.canvas.setAttribute("height", `${height}`);
    }
    getFramebufferSize() {
      return {width: +this.canvas.getAttribute("width"), height: +this.canvas.getAttribute("height")};
    }
    redrawLastTransfer() {
      if (this.lastTransfer != null)
        this.drawBatchesTransfer(this.lastTransfer);
    }
    drawBatchesTransfer(transfer) {
      this.lastTransfer = transfer;
      const buffer = transfer.buffer;
      const verticesData = new Uint8Array(buffer, transfer.data.data, transfer.data.datasize);
      const indicesData = new Uint16Array(buffer, transfer.data.indices, transfer.data.indicesCount);
      let gl = this.gl;
      if (!this.optimizedDataBuffer)
        this.optimizedDataBuffer = gl.createBuffer();
      if (!this.optimizedIndexBuffer)
        this.optimizedIndexBuffer = gl.createBuffer();
      let databuffer = this.optimizedDataBuffer;
      let indexbuffer = this.optimizedIndexBuffer;
      gl.bindBuffer(gl.ARRAY_BUFFER, databuffer);
      gl.bufferData(gl.ARRAY_BUFFER, verticesData, gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesData, gl.DYNAMIC_DRAW);
      this.textureHandler.startFrame();
      for (let batch of transfer.batches.slice(0, this.drawRatio * transfer.batches.length)) {
        this.drawOptimized(buffer, batch);
      }
      this.textureHandler.endFrame();
    }
    drawOptimized(data, batch) {
      this.state.writeData(new Uint32Array(data, batch.stateOffset, 512));
      this.beforeDraw(this.state);
      const state = this.state;
      let gl = this.gl;
      if (!this.optimizedDataBuffer)
        this.optimizedDataBuffer = gl.createBuffer();
      if (!this.optimizedIndexBuffer)
        this.optimizedIndexBuffer = gl.createBuffer();
      let databuffer = this.optimizedDataBuffer;
      let indexbuffer = this.optimizedIndexBuffer;
      let vs = this.vs;
      vs.setState(this.state);
      let primType = batch.primType;
      const globalVertexOffset = batch.dataLow;
      let indexStart = batch.indexLow * 2;
      gl.bindBuffer(gl.ARRAY_BUFFER, databuffer);
      const program = this.cache.getProgram(vs, state, true);
      program.use();
      program.getUniform("time").set1f(performance.now() / 1e3);
      program.getUniform("u_modelViewProjMatrix").setMat4(vs.transform2D ? this.transformMatrix2d : this.transformMatrix);
      if (vs.hasPosition) {
        this.setAttribute(databuffer, program.vPosition, vs.positionComponents, convertVertexNumericEnum[vs.position], vs.size, vs.positionOffset + globalVertexOffset);
      }
      if (vs.hasTexture) {
        this.setAttribute(databuffer, program.vTexcoord, vs.textureComponents, convertVertexNumericUnsignedEnum[vs.texture], vs.size, vs.textureOffset + globalVertexOffset);
      }
      if (vs.hasColor) {
        if (vs.color == ColorEnum.Color8888) {
          this.setAttribute(databuffer, program.vColor, 4, GL.UNSIGNED_BYTE, vs.size, vs.colorOffset + globalVertexOffset);
        } else {
          this.setAttribute(databuffer, program.vColor, 1, GL.UNSIGNED_SHORT, vs.size, vs.colorOffset + globalVertexOffset);
        }
      }
      if (vs.hasNormal) {
        this.setAttribute(databuffer, program.vNormal, vs.normalComponents, convertVertexNumericEnum[vs.normal], vs.size, vs.normalOffset + globalVertexOffset);
      }
      if (vs.realWeightCount > 0) {
        this.setAttribute(databuffer, program.vertexWeight1, Math.min(4, vs.realWeightCount), convertVertexNumericEnum[vs.weight], vs.size, vs.oneWeightOffset(0) + globalVertexOffset);
        if (vs.realWeightCount > 4) {
          this.setAttribute(databuffer, program.vertexWeight2, Math.min(4, vs.realWeightCount - 4), convertVertexNumericEnum[vs.weight], vs.size, vs.oneWeightOffset(4) + globalVertexOffset);
        }
        for (let n = 0; n < vs.realWeightCount; n++) {
          program.getUniform("matrixBone" + n).setMat4x3(this.state.skinning.boneMatrices[n]);
        }
      }
      if (!vs.hasColor) {
        const ac = this.state.ambientModelColor;
        program.getUniform("uniformColor").set4f(ac.r, ac.g, ac.b, ac.a);
      }
      if (vs.hasTexture) {
        program.getUniform("tfx").set1i(state.texture.effect);
        program.getUniform("tcc").set1i(state.texture.colorComponent);
      }
      this.updateState(program, vs, batch.primType);
      if (this.clearing) {
        this.textureHandler.unbindTexture(program, state);
      } else {
        this.prepareTexture(gl, program, vs, data, batch);
      }
      if (vs.hasTexture) {
        this.calcTexMatrix(vs);
        program.getUniform("u_texMatrix").setMat4(this.texMat);
      }
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuffer);
      gl.drawElements(convertPrimitiveType[primType], batch.indexCount, gl.UNSIGNED_SHORT, indexStart);
      if (vs.hasPosition)
        program.vPosition.disable();
      if (vs.hasColor)
        program.vColor.disable();
      if (vs.hasTexture)
        program.vTexcoord.disable();
      if (vs.hasNormal)
        program.vNormal.disable();
      if (vs.realWeightCount > 0) {
        program.vertexWeight1.disable();
        if (vs.realWeightCount > 4) {
          program.vertexWeight2.disable();
        }
      }
    }
    prepareTexture(gl, program, vertexInfo, buffer, batch) {
      if (vertexInfo.hasTexture && this.enableTextures) {
        this.textureHandler.bindTexture(program, this.state, this.enableBilinear, buffer, batch);
      } else {
        this.textureHandler.unbindTexture(program, this.state);
      }
    }
    calcTexMatrix(vertexInfo) {
      const texture = this.state.texture;
      const mipmap = texture.mipmaps[0];
      mat4.identity(this.texMat);
      const t = this.tempVec;
      if (vertexInfo.transform2D) {
        t[0] = 1 / mipmap.bufferWidth;
        t[1] = 1 / mipmap.textureHeight;
        t[2] = 1;
        mat4.scale(this.texMat, this.texMat, t);
      } else {
        switch (texture.textureMapMode) {
          case TextureMapMode.GU_TEXTURE_COORDS:
            t[0] = texture.offsetU;
            t[1] = texture.offsetV;
            t[2] = 0;
            mat4.translate(this.texMat, this.texMat, t);
            t[0] = texture.scaleU;
            t[1] = texture.scaleV;
            t[2] = 1;
            mat4.scale(this.texMat, this.texMat, t);
            break;
          default:
            break;
        }
      }
    }
    setProgramParameters(gl, program, vertexInfo) {
      program.getUniform("u_modelViewProjMatrix").setMat4(vertexInfo.transform2D ? this.transformMatrix2d : this.transformMatrix);
      program.getAttrib("vPosition").setFloats(3, this.positionData.slice());
      if (vertexInfo.hasTexture) {
        program.getUniform("tfx").set1i(this.state.texture.effect);
        program.getUniform("tcc").set1i(this.state.texture.colorComponent);
        program.getAttrib("vTexcoord").setFloats(3, this.textureData.slice());
      }
      if (vertexInfo.hasNormal) {
        program.getAttrib("vNormal").setFloats(3, this.normalData.slice());
      }
      if (vertexInfo.realWeightCount > 0) {
        program.getAttrib("vertexWeight1").setFloats(4, this.vertexWeightData1.slice());
        if (vertexInfo.realWeightCount > 4) {
          program.getAttrib("vertexWeight2").setFloats(4, this.vertexWeightData2.slice());
        }
        for (let n = 0; n < vertexInfo.realWeightCount; n++) {
          program.getUniform("matrixBone" + n).setMat4x3(this.state.skinning.boneMatrices[n]);
        }
      }
      if (vertexInfo.hasColor) {
        program.getAttrib("vColor").setFloats(4, this.colorData.slice());
      } else {
        const ac = this.state.ambientModelColor;
        program.getUniform("uniformColor").set4f(ac.r, ac.g, ac.b, ac.a);
      }
      if (vertexInfo.hasTexture) {
        this.calcTexMatrix(vertexInfo);
        program.getUniform("u_texMatrix").setMat4(this.texMat);
      }
    }
    unsetProgramParameters(gl, program, vertexInfo) {
      program.getAttrib("vPosition").disable();
      if (vertexInfo.hasTexture)
        program.getAttrib("vTexcoord").disable();
      if (vertexInfo.hasNormal)
        program.getAttrib("vNormal").disable();
      if (vertexInfo.hasColor)
        program.getAttrib("vColor").disable();
      if (vertexInfo.realWeightCount >= 1)
        program.getAttrib("vertexWeight1").disable();
      if (vertexInfo.realWeightCount >= 4)
        program.getAttrib("vertexWeight2").disable();
    }
  };
  var convertPrimitiveType = new Int32Array([GL.POINTS, GL.LINES, GL.LINE_STRIP, GL.TRIANGLES, GL.TRIANGLE_STRIP, GL.TRIANGLE_FAN, GL.TRIANGLES]);
  var convertVertexNumericEnum = new Int32Array([0, GL.BYTE, GL.SHORT, GL.FLOAT]);
  var convertVertexNumericUnsignedEnum = new Int32Array([0, GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT, GL.FLOAT]);

  // src/hle/vfs/vfs.ts
  var Vfs = class {
    devctlAsync(command, input, output) {
      console.error("VfsMustOverride devctlAsync", this);
      throw new Error("Must override devctlAsync : " + this);
    }
    openAsync(path, flags, mode) {
      return PromiseFast.ensure(this.openPromiseAsync(path, flags, mode));
    }
    openPromiseAsync(path, flags, mode) {
      console.error("VfsMustOverride openAsync", this);
      throw new Error("Must override openAsync : " + this);
    }
    async readAllAsync(path) {
      let entry = await this.openAsync(path, FileOpenFlags.Read, parseInt("0777", 8));
      return entry.readAllAsync();
    }
    async writeAllAsync(path, data) {
      let entry = await this.openAsync(path, FileOpenFlags.Create | FileOpenFlags.Truncate | FileOpenFlags.Write, parseInt("0777", 8));
      return await entry.writeAllAsync(data);
    }
    deleteAsync(path) {
      throw new Error("Must override openAsync : " + this);
    }
    openDirectoryAsync(path) {
      return this.openAsync(path, FileOpenFlags.Read, parseInt("0777", 8));
    }
    getStatAsync(path) {
      return PromiseFast.ensure(this.getStatPromiseAsync(path));
    }
    async getStatPromiseAsync(path) {
      const entry = await this.openPromiseAsync(path, FileOpenFlags.Read, parseInt("0777", 8));
      return entry.stat();
    }
    existsAsync(path) {
      return PromiseFast.ensure(this.existsPromiseAsync(path));
    }
    async existsPromiseAsync(path) {
      try {
        await this.getStatPromiseAsync(path);
        return true;
      } catch (e) {
        return false;
      }
    }
  };
  var ProxyVfs = class extends Vfs {
    constructor(parentVfsList) {
      super();
      this.parentVfsList = parentVfsList;
    }
    _callChainWhenError(callback) {
      let promise = PromiseFast.reject(new Error());
      this.parentVfsList.forEach((parentVfs) => {
        promise = promise.catch((e) => {
          return callback(parentVfs, e);
        });
      });
      return promise;
    }
    _callChainWhenErrorPromise(callback) {
      let promise = Promise.reject(new Error());
      this.parentVfsList.forEach((parentVfs) => {
        promise = promise.catch((e) => {
          return callback(parentVfs, e);
        });
      });
      return promise;
    }
    devctlAsync(command, input, output) {
      return this._callChainWhenError((vfs, e) => {
        return vfs.devctlAsync(command, input, output);
      });
    }
    async openPromiseAsync(path, flags, mode) {
      const errors = [];
      for (const vfs of this.parentVfsList) {
        try {
          return await vfs.openPromiseAsync(path, flags, mode);
        } catch (e) {
          errors.push(e);
        }
      }
      throw errors.first() || new Error("Error ProxyVfs.openPromiseAsync");
    }
    deleteAsync(path) {
      return this._callChainWhenError((vfs, e) => {
        return vfs.deleteAsync(path);
      });
    }
    openDirectoryAsync(path) {
      return this._callChainWhenError((vfs, e) => {
        return vfs.openDirectoryAsync(path);
      });
    }
    async getStatPromiseAsync(path) {
      return this._callChainWhenErrorPromise((vfs, e) => {
        return vfs.getStatPromiseAsync(path);
      });
    }
  };
  var VfsEntry = class {
    get isDirectory() {
      return this.stat().isDirectory;
    }
    get size() {
      return this.stat().size;
    }
    readAllAsync() {
      return this.readChunkAsync(0, this.size);
    }
    writeAllAsync(data) {
      return this.writeChunkAsync(0, data, true);
    }
    enumerateAsync() {
      throw new Error("Must override enumerateAsync : " + this);
    }
    readChunkAsync(offset, length) {
      throw new Error("Must override readChunkAsync : " + this);
    }
    writeChunkAsync(offset, data, truncate) {
      throw new Error("Must override writeChunkAsync : " + this);
    }
    stat() {
      throw new Error("Must override stat");
    }
    close() {
    }
  };
  var VfsEntryStream = class extends VfsEntry {
    constructor(asyncStream) {
      super();
      this.asyncStream = asyncStream;
    }
    get size() {
      return this.asyncStream.size;
    }
    readChunkAsync(offset, length) {
      return this.asyncStream.readChunkAsync(offset, length);
    }
    close() {
    }
    stat() {
      return {
        name: this.asyncStream.name,
        size: this.asyncStream.size,
        isDirectory: false,
        timeCreation: this.asyncStream.date,
        timeLastAccess: this.asyncStream.date,
        timeLastModification: this.asyncStream.date
      };
    }
  };
  var FileOpenFlags;
  (function(FileOpenFlags5) {
    FileOpenFlags5[FileOpenFlags5["Read"] = 1] = "Read";
    FileOpenFlags5[FileOpenFlags5["Write"] = 2] = "Write";
    FileOpenFlags5[FileOpenFlags5["ReadWrite"] = 3] = "ReadWrite";
    FileOpenFlags5[FileOpenFlags5["NoBlock"] = 4] = "NoBlock";
    FileOpenFlags5[FileOpenFlags5["_InternalDirOpen"] = 8] = "_InternalDirOpen";
    FileOpenFlags5[FileOpenFlags5["Append"] = 256] = "Append";
    FileOpenFlags5[FileOpenFlags5["Create"] = 512] = "Create";
    FileOpenFlags5[FileOpenFlags5["Truncate"] = 1024] = "Truncate";
    FileOpenFlags5[FileOpenFlags5["Excl"] = 2048] = "Excl";
    FileOpenFlags5[FileOpenFlags5["Unknown1"] = 16384] = "Unknown1";
    FileOpenFlags5[FileOpenFlags5["NoWait"] = 32768] = "NoWait";
    FileOpenFlags5[FileOpenFlags5["Unknown2"] = 983040] = "Unknown2";
    FileOpenFlags5[FileOpenFlags5["Unknown3"] = 33554432] = "Unknown3";
  })(FileOpenFlags || (FileOpenFlags = {}));
  var FileMode;
  (function(FileMode10) {
  })(FileMode || (FileMode = {}));

  // src/global/importScript.ts
  async function importScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.async = true;
      script.src = src;
      script.addEventListener("load", (event) => {
        resolve();
      });
      script.addEventListener("error", () => reject(`Error loading script "${src}"`));
      script.addEventListener("abort", () => reject(`Script loading aborted for "${src}"`));
      document.head.appendChild(script);
    });
  }

  // src/hle/vfs/pathinfo.ts
  var PathInfo = class {
    constructor(fullPath) {
      this.fullPath = fullPath;
    }
    get parent() {
      const lastIndex = this.fullPath.lastIndexOf("/");
      return lastIndex >= 0 ? new PathInfo(this.fullPath.substr(0, lastIndex)) : null;
    }
    get baseName() {
      const lastIndex = this.fullPath.lastIndexOf("/");
      return lastIndex >= 0 ? this.fullPath.substr(lastIndex + 1) : this.fullPath;
    }
  };

  // src/hle/vfs/vfs_dropbox.ts
  var DROPBOX_APP_KEY = "4mdwp62ogo4tna1";
  var DirectoryInfo = class {
    constructor(entries) {
      this.entries = entries;
      this.entriesByName = new Map();
      for (const entry of entries) {
        this.entriesByName.set(entry.name, entry);
      }
    }
    add(entry) {
      this.entries.push(entry);
      this.entriesByName.set(entry.name, entry);
    }
  };
  function getCanonicalPath(name2) {
    const canonicalPath = `/${name2.replace(/^\/+/, "").replace(/\/+$/, "")}`;
    return canonicalPath == "/" ? "" : canonicalPath;
  }
  function hasDropboxToken() {
    if (!window.localStorage || !window.document)
      return false;
    return !!localStorage.getItem("DROPBOX_TOKEN");
  }
  function dropboxTryStoreCodeAndRefresh() {
    if (!window.localStorage || !window.document)
      return;
    const params = new URLSearchParams(`?${window.document.location.hash.substr(1)}`);
    const access_token = params.get("access_token");
    const token_type = params.get("token_type");
    const account_id = params.get("account_id");
    const scope = params.get("scope");
    if (access_token) {
      localStorage.setItem("DROPBOX_TOKEN", access_token);
      window.document.location.href = "/";
    }
  }
  function getDropboxCodeOrRedirect() {
    if (!window.localStorage || !window.document)
      return false;
    const token = localStorage.getItem("DROPBOX_TOKEN");
    if (!token) {
      window.document.location.href = generateDropboxAuthorizeUrl();
    }
    return token;
  }
  function generateDropboxAuthorizeUrl() {
    return `https://www.dropbox.com/oauth2/authorize?client_id=${DROPBOX_APP_KEY}&redirect_uri=${document.location.protocol}//${document.location.host}&response_type=token`;
  }
  function referenceDropbox() {
  }
  dropboxTryStoreCodeAndRefresh();
  var AsyncClient = class {
    constructor(key) {
      this.key = key;
      this.initPromise = null;
      this._cacheFileLinks = new Map();
      this.statCachePromise = {};
      this.readdirInfoCachePromise = new Map();
    }
    async initOnceAsync() {
      if (!this.initPromise) {
        this.initPromise = (async () => {
          await importScript("https://cdnjs.cloudflare.com/ajax/libs/dropbox.js/9.2.0/Dropbox-sdk.min.js");
          const accessToken = getDropboxCodeOrRedirect();
          this.client = new Dropbox.Dropbox({accessToken});
          console.warn("Dropbox client initialized");
        })();
      }
      return await this.initPromise;
    }
    async writeFileAsync(fullpath, content) {
      await this.initOnceAsync();
      const canonicalPath = getCanonicalPath(fullpath);
      const path = new PathInfo(canonicalPath);
      const folderPath = path.parent.fullPath;
      const baseName = path.baseName;
      const statsInfo = await this.readdirInfoAsync(folderPath);
      const entry = statsInfo.entriesByName.get(baseName);
      if (entry) {
        entry.size = content.byteLength;
      } else {
        this.readdirInfoCachePromise.delete(folderPath);
      }
      await this.client.filesUpload({path: canonicalPath, contents: content, mode: "overwrite", autorename: false});
    }
    async mkdirAsync(path) {
      await this.initOnceAsync();
      return await new Promise((resolve, reject) => {
        this.client.mkdir(path, (e, data) => {
          if (e) {
            reject(e);
          } else {
            resolve(data);
          }
        });
      });
    }
    async readFileAsync(name2, offset = 0, length = void 0) {
      await this.initOnceAsync();
      const canonicalPath = getCanonicalPath(name2);
      if (offset === 0 && length === void 0) {
        const result = await this.client.filesDownload({path: canonicalPath});
        return result.result.fileBlob.arrayBuffer();
      }
      if (!this._cacheFileLinks.has(canonicalPath)) {
        const result = await this.client.filesGetTemporaryLink({path: canonicalPath});
        this._cacheFileLinks.set(canonicalPath, result.result.link);
      }
      const link = this._cacheFileLinks.get(canonicalPath);
      return await downloadFileChunkAsync(link, offset, length);
    }
    async statAsync(fullpath) {
      const canonicalPath = getCanonicalPath(fullpath);
      const path = new PathInfo(canonicalPath);
      if (path.parent == null)
        throw new Error("Invalid path");
      const folderInfo = await this.readdirInfoAsync(path.parent.fullPath);
      const baseName = path.baseName;
      const info = folderInfo.entriesByName.get(baseName);
      if (!info) {
        return {".tag": "none", name: baseName, id: "-"};
      }
      return info;
    }
    async readdirAsync(name2) {
      return (await this.readdirInfoAsync(name2)).entries.map((it) => it.name);
    }
    async readdirInfoAsync(name2) {
      const canonicalPath = getCanonicalPath(name2);
      await this.initOnceAsync();
      if (!this.readdirInfoCachePromise.has(canonicalPath)) {
        this.readdirInfoCachePromise.set(canonicalPath, (async () => {
          const result = await this.client.filesListFolder({path: canonicalPath});
          return new DirectoryInfo(result.result.entries);
        })());
      }
      return await this.readdirInfoCachePromise.get(canonicalPath);
    }
  };
  var client = new AsyncClient(DROPBOX_APP_KEY);
  var dropboxClient = client;
  (async () => {
  })();

  // src/emu/emulator_overlay.ts
  var canDOMCreateElements = typeof document != "undefined";
  var OverlayCounter = class {
    constructor(name2, resetValue, representer) {
      this.name = name2;
      this.resetValue = resetValue;
      this.representer = representer;
      this.reset();
      if (canDOMCreateElements) {
        this.element = document.createElement("div");
      }
    }
    update() {
      if (this.element)
        this.element.innerText = `${this.name}: ${this.representedValue}`;
    }
    get representedValue() {
      return this.representer ? this.representer(this.value) : this.value;
    }
    reset() {
      this.value = this.resetValue;
    }
  };
  var OverlayIntent = class {
    constructor(text, action) {
      if (canDOMCreateElements) {
        this.element = document.createElement("button");
        this.element.innerHTML = text;
        this.element.onclick = (e) => action();
      }
    }
    update() {
    }
    reset() {
    }
  };
  var OverlaySlider = class {
    constructor(text, initialRatio, action) {
      if (canDOMCreateElements) {
        this.element = document.createElement("input");
        this.element.type = "range";
        this.element.min = `0`;
        this.element.max = `1000`;
        this.element.value = `${initialRatio * 1e3}`;
        let lastReportedValue = NaN;
        const report = (e) => {
          if (this.ratio == lastReportedValue)
            return;
          lastReportedValue = this.ratio;
          action(this.ratio);
        };
        this.element.onmousemove = report;
        this.element.onchange = report;
      }
    }
    set ratio(value) {
      this.value = value * 1e3;
    }
    get ratio() {
      return this.value / 1e3;
    }
    set value(v) {
      this.element.value = `${v}`;
    }
    get value() {
      return +this.element.value;
    }
    update() {
    }
    reset() {
    }
  };
  var Overlay = class {
    constructor() {
      this.sections = [];
      const element = this.element = canDOMCreateElements ? document.createElement("div") : null;
      if (element) {
        element.style.position = "absolute";
        element.style.zIndex = "10000";
        element.style.top = "0";
        element.style.right = "0";
        element.style.background = "rgba(0, 0, 0, 0.3)";
        element.style.font = "12px Arial";
        element.style.width = "200px";
        element.style.height = "auto";
        element.style.padding = "4px";
        element.style.color = "white";
        document.body.appendChild(element);
      }
    }
    addElement(element) {
      this.sections.push(element);
      if (this.element) {
        this.element.appendChild(element.element);
      }
      return element;
    }
    createCounter(name2, resetValue, representer) {
      return this.addElement(new OverlayCounter(name2, resetValue, representer));
    }
    createIntent(text, action) {
      return this.addElement(new OverlayIntent(text, action));
    }
    createSlider(text, initialRatio, action) {
      return this.addElement(new OverlaySlider(text, initialRatio, action));
    }
    update() {
      for (let section of this.sections)
        section.update();
    }
    reset() {
      for (let s of this.sections)
        s.reset();
    }
    updateAndReset() {
      this.update();
      this.reset();
    }
  };
  var DebugOverlay = class {
    constructor(webglDriver) {
      this.webglDriver = webglDriver;
      this.overlay = new Overlay();
      this.freezing = new WatchValue(false);
      this.overlayBatchSlider = this.overlay.createSlider("batch", 1, (ratio) => {
        this.webglDriver.drawRatio = ratio;
        this.webglDriver.redrawLastTransfer();
      });
      this.overlayIndexCount = this.overlay.createCounter("indexCount", 0, numberToSeparator);
      this.overlayNonIndexCount = this.overlay.createCounter("nonIndexCount", 0, numberToSeparator);
      this.overlayVertexCount = this.overlay.createCounter("vertexCount", 0, numberToSeparator);
      this.trianglePrimCount = this.overlay.createCounter("trianglePrimCount", 0, numberToSeparator);
      this.triangleStripPrimCount = this.overlay.createCounter("triangleStripPrimCount", 0, numberToSeparator);
      this.spritePrimCount = this.overlay.createCounter("spritePrimCount", 0, numberToSeparator);
      this.otherPrimCount = this.overlay.createCounter("otherPrimCount", 0, numberToSeparator);
      this.hashMemoryCount = this.overlay.createCounter("hashMemoryCount", 0, numberToSeparator);
      this.hashMemorySize = this.overlay.createCounter("hashMemorySize", 0, numberToFileSize);
      this.totalCommands = this.overlay.createCounter("totalCommands", 0, numberToSeparator);
      this.totalStalls = this.overlay.createCounter("totalStalls", 0, numberToSeparator);
      this.primCount = this.overlay.createCounter("primCount", 0, numberToSeparator);
      this.batchCount = this.overlay.createCounter("batchCount", 0, numberToSeparator);
      this.timePerFrame = this.overlay.createCounter("time", 0, (v) => `${v.toFixed(0)} ms`);
      this.gpuFreezing = new Signal1();
      this.gpuDumpCommands = new Signal0();
    }
    register() {
      let webglDriver = this.webglDriver;
      let overlay = this.overlay;
      overlay.createIntent("toggle colors", () => {
        webglDriver.enableColors = !webglDriver.enableColors;
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("toggle antialiasing", () => {
        webglDriver.antialiasing = !webglDriver.antialiasing;
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("toggle textures", () => {
        webglDriver.enableTextures = !webglDriver.enableTextures;
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("skinning", () => {
        webglDriver.enableSkinning = !webglDriver.enableSkinning;
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("bilinear", () => {
        webglDriver.enableBilinear = !webglDriver.enableBilinear;
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("freeze", () => {
        this.freezing.value = !this.freezing.value;
        this.gpuFreezing.dispatch(this.freezing.value);
      });
      const dumpFrameCommandsList2 = [];
      overlay.createIntent("dump frame commands", () => {
        this.gpuDumpCommands.dispatch();
      });
      overlay.createIntent("dropbox login", () => {
        dropboxClient.initOnceAsync();
      });
      overlay.createIntent("x1", () => {
        webglDriver.setFramebufferSize(480 * 1, 272 * 1);
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("x2", () => {
        webglDriver.setFramebufferSize(480 * 2, 272 * 2);
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("x3", () => {
        webglDriver.setFramebufferSize(480 * 3, 272 * 3);
        webglDriver.redrawLastTransfer();
      });
      overlay.createIntent("x4", () => {
        webglDriver.setFramebufferSize(480 * 4, 272 * 4);
        webglDriver.redrawLastTransfer();
      });
      overlay.updateAndReset();
    }
    linkTo(emulator) {
      let stats = emulator.gpuStats;
      stats.onStats.add((stats2) => {
        this.totalStalls.value = stats2.totalStalls;
        this.primCount.value = stats2.primCount;
        this.totalCommands.value = stats2.totalCommands;
        this.timePerFrame.value = stats2.timePerFrame;
        this.overlayVertexCount.value = stats2.vertexCount;
        this.batchCount.value = stats2.batchCount;
        this.overlayIndexCount.value = stats2.indexCount;
        this.overlayNonIndexCount.value = stats2.nonIndexCount;
        this.trianglePrimCount.value = stats2.trianglePrimCount;
        this.triangleStripPrimCount.value = stats2.triangleStripPrimCountalue;
        this.spritePrimCount.value = stats2.spritePrimCount;
        this.otherPrimCount.value = stats2.otherPrimCount;
        this.hashMemoryCount.value = stats2.hashMemoryCount;
        this.hashMemorySize.value = stats2.hashMemorySize;
      });
    }
  };

  // src/core/gpu/gpu_stats.ts
  var GpuStats = class {
    constructor() {
      this.onStats = new Signal1();
      this.totalStalls = 0;
      this.primCount = 0;
      this.totalCommands = 0;
      this.timePerFrame = 0;
      this.vertexCount = 0;
      this.batchCount = 0;
      this.indexCount = 0;
      this.nonIndexCount = 0;
      this.trianglePrimCount = 0;
      this.triangleStripPrimCountalue = 0;
      this.spritePrimCount = 0;
      this.otherPrimCount = 0;
      this.hashMemoryCount = 0;
      this.hashMemorySize = 0;
    }
    reset() {
      this.totalStalls = 0;
      this.primCount = 0;
      this.totalCommands = 0;
      this.timePerFrame = 0;
      this.vertexCount = 0;
      this.batchCount = 0;
      this.indexCount = 0;
      this.nonIndexCount = 0;
      this.trianglePrimCount = 0;
      this.triangleStripPrimCountalue = 0;
      this.spritePrimCount = 0;
      this.otherPrimCount = 0;
      this.hashMemoryCount = 0;
      this.hashMemorySize = 0;
    }
    updateAndReset() {
      this.onStats.dispatch(this);
      this.reset();
    }
  };

  // src/emu/context.ts
  var EmulatorContext = class {
    constructor() {
      this.onStdout = new Signal1();
      this.onStderr = new Signal1();
      this.container = {};
      this.gameTitle = "unknown";
      this.gameId = "unknown";
    }
    get currentThread() {
      return this.threadManager.current;
    }
    get currentState() {
      return this.currentThread.state;
    }
    get currentInstructionCache() {
      return this.currentState.icache;
    }
    init(interruptManager, display, controller2, gpu, memoryManager, threadManager, audio, memory2, fileManager, rtc, callbackManager, moduleManager, config, interop, netManager, battery) {
      this.interruptManager = interruptManager;
      this.display = display;
      this.controller = controller2;
      this.gpu = gpu;
      this.memoryManager = memoryManager;
      this.threadManager = threadManager;
      this.audio = audio;
      this.memory = memory2;
      this.fileManager = fileManager;
      this.rtc = rtc;
      this.callbackManager = callbackManager;
      this.moduleManager = moduleManager;
      this.config = config;
      this.interop = interop;
      this.netManager = netManager;
      this.battery = battery;
    }
  };

  // src/core/memory.ts
  function saveAs(data, fileName) {
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    const url = URL.createObjectURL(data);
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
    document.body.removeChild(a);
  }
  var MASK = 268435455;
  var LWR_MASK = new Uint32Array([0, 4278190080, 4294901760, 4294967040]);
  var LWR_SHIFT = new Uint32Array([0, 8, 16, 24]);
  var LWL_MASK = new Uint32Array([16777215, 65535, 255, 0]);
  var LWL_SHIFT = new Uint32Array([24, 16, 8, 0]);
  var SWL_MASK = new Uint32Array([4294967040, 4294901760, 4278190080, 0]);
  var SWL_SHIFT = new Uint32Array([24, 16, 8, 0]);
  var SWR_MASK = new Uint32Array([0, 255, 65535, 16777215]);
  var SWR_SHIFT = new Uint32Array([0, 8, 16, 24]);
  var Memory = class {
    constructor() {
      this.invalidateDataRange = new Signal2();
      this.invalidateDataAll = new Signal0();
      this.writeBreakpoints = [];
    }
    read8(addr) {
      return this.lb(addr);
    }
    lwl(address, value) {
      const align = address & 3;
      const oldvalue = this.lw(address & ~3);
      return oldvalue << LWL_SHIFT[align] | value & LWL_MASK[align];
    }
    lwr(address, value) {
      const align = address & 3;
      const oldvalue = this.lw(address & ~3);
      return oldvalue >>> LWR_SHIFT[align] | value & LWR_MASK[align];
    }
    swl(address, value) {
      const align = address & 3;
      const aadress = address & ~3;
      const vwrite = value >>> SWL_SHIFT[align] | this.lw(aadress) & SWL_MASK[align];
      this.sw(aadress, vwrite);
    }
    swr(address, value) {
      const align = address & 3;
      const aadress = address & ~3;
      const vwrite = value << SWR_SHIFT[align] | this.lw(aadress) & SWR_MASK[align];
      this.sw(aadress, vwrite);
    }
    writeInt8(address, value) {
      this.sb(address, value);
    }
    writeInt16(address, value) {
      this.sh(address, value);
    }
    writeInt32(address, value) {
      this.sw(address, value);
    }
    writeFloat32(address, value) {
      this.swc1(address, value);
    }
    readInt8(address) {
      return this.lb(address);
    }
    readUInt8(address) {
      return this.lbu(address);
    }
    readInt16(address) {
      return this.lh(address);
    }
    readUInt16(address) {
      return this.lhu(address);
    }
    readInt32(address) {
      return this.lw(address);
    }
    readUInt32(address) {
      return this.lwu(address);
    }
    readFloat32(address) {
      return this.lwc1(address);
    }
    readUInt32_2(address) {
      return this.lw_2(address);
    }
    sb(address, value) {
      throw `Must override`;
    }
    sh(address, value) {
      throw `Must override`;
    }
    sw(address, value) {
      throw `Must override`;
    }
    swc1(address, value) {
      throw `Must override`;
    }
    lb(address) {
      throw `Must override`;
    }
    lbu(address) {
      throw `Must override`;
    }
    lh(address) {
      throw `Must override`;
    }
    lhu(address) {
      throw `Must override`;
    }
    lw(address) {
      throw `Must override`;
    }
    lwu(address) {
      throw `Must override`;
    }
    lwc1(address) {
      throw `Must override`;
    }
    lw_2(address) {
      throw `Must override`;
    }
    getBuffer(address) {
      throw `Must override`;
    }
    getOffsetInBuffer(address) {
      throw `Must override`;
    }
    availableAfterAddress(address) {
      throw `Must override`;
    }
    isAddressInRange(address, min, max) {
      address &= FastMemory.MASK;
      address >>>= 0;
      min &= FastMemory.MASK;
      min >>>= 0;
      max &= FastMemory.MASK;
      max >>>= 0;
      return address >= min && address < max;
    }
    isValidAddress(address) {
      address &= FastMemory.MASK;
      if ((address & 1040187392) == 134217728)
        return true;
      if ((address & 1065353216) == 67108864)
        return true;
      if ((address & 3221159936) == 65536)
        return true;
      if (this.isAddressInRange(address, FastMemory.DEFAULT_FRAME_ADDRESS, FastMemory.DEFAULT_FRAME_ADDRESS + 2097152))
        return true;
      if (this.isAddressInRange(address, 134217728, 134217728 + 67108864))
        return true;
      return false;
    }
    getPointerPointer(type, address) {
      if (address == 0)
        return null;
      return new Pointer(type, this, address);
    }
    getPointerDataView(address, size = this.availableAfterAddress(address)) {
      const buffer = this.getBuffer(address), offset = this.getOffsetInBuffer(address);
      return new DataView(buffer, offset, size);
    }
    slice(low, high) {
      const buffer = this.getBuffer(low), offset = this.getOffsetInBuffer(low);
      return new Uint8Array(buffer, offset, high - low);
    }
    getPointerU8Array(address, size = this.availableAfterAddress(address)) {
      const buffer = this.getBuffer(address), offset = this.getOffsetInBuffer(address);
      return new Uint8Array(buffer, offset, size);
    }
    getPointerU16Array(address, size = this.availableAfterAddress(address)) {
      const buffer = this.getBuffer(address), offset = this.getOffsetInBuffer(address);
      return new Uint16Array(buffer, offset, size / 2);
    }
    getPointerU32Array(address, size = this.availableAfterAddress(address)) {
      const buffer = this.getBuffer(address), offset = this.getOffsetInBuffer(address);
      return new Uint32Array(buffer, offset, size / 4);
    }
    getPointerStream(address, size) {
      if (address == 0)
        return null;
      if (size === 0)
        return new Stream(new DataView(new ArrayBuffer(0)));
      if (!this.isValidAddress(address))
        return Stream.INVALID;
      if (size === void 0)
        size = this.availableAfterAddress(address & FastMemory.MASK);
      if (size < 0)
        return Stream.INVALID;
      return new Stream(this.getPointerDataView(address & FastMemory.MASK, size));
    }
    getU8Array(address, size) {
      if (address == 0)
        return null;
      if (!this.isValidAddress(address))
        return null;
      return this.getPointerU8Array(address & FastMemory.MASK, size);
    }
    getU16Array(address, size) {
      if (address == 0)
        return null;
      if (!this.isValidAddress(address))
        return null;
      return this.getPointerU16Array(address & FastMemory.MASK, size);
    }
    addWatch4(address) {
      this.addWriteAction(address, (address2) => {
        console.log(sprintf("Watch:0x%08X <- 0x%08X", address2, this.lwu(address2)));
      });
    }
    addBreakpointOnValue(address, value) {
      this.addWriteAction(address, (actualAddress) => {
        const actualValue = this.lwu(address);
        console.log(sprintf("TryBreakpoint:0x%08X <- 0x%08X | 0x%08X (%d)", address, actualValue, value, actualValue == value));
        if (actualValue == value) {
          debugger;
        }
      });
    }
    addWriteAction(address, action) {
      this.writeBreakpoints.push({address, action});
    }
    readArrayBuffer(address, length) {
      const out = new Uint8Array(length);
      out.set(this.getPointerU8Array(address, length));
      return out.buffer;
    }
    sliceWithBounds(low, high) {
      return new Stream(this.getPointerDataView(low, high - low));
    }
    sliceWithSize(address, size) {
      return new Stream(this.getPointerDataView(address, size));
    }
    copy(from, to, length) {
      if (length <= 0)
        return;
      this.getPointerU8Array(to, length).set(this.getPointerU8Array(from, length));
    }
    memset(address, value, length) {
      let buffer = this.getPointerU8Array(address, length);
      let value8 = value & 255;
      if (typeof buffer.fill != "undefined") {
        buffer.fill(value8);
      } else {
        for (let n = 0; n < buffer.length; n++)
          buffer[n] = value8;
      }
    }
    writeBytes(address, data) {
      this.getPointerU8Array(address, data.byteLength).set(new Uint8Array(data));
    }
    writeUint8Array(address, data) {
      this.getPointerU8Array(address, data.length).set(data);
    }
    writeStream(address, stream) {
      this.writeUint8Array(address, stream.slice().readAllBytes());
    }
    readStringz(address) {
      if (address == 0)
        return null;
      let endAddress = address;
      while (this.lbu(endAddress) != 0)
        endAddress++;
      const length = endAddress - address;
      const data = this.getPointerU8Array(address, length);
      return String.fromUint8Array(data);
    }
    hashWordCount(_addressAligned, _count) {
      let addressAligned = _addressAligned >>> 2 | 0;
      let count = _count >>> 2 | 0;
      let result = 0;
      for (let n = 0; n < count; n++) {
        const v = this.lw_2(addressAligned + n);
        result = result + v ^ n;
      }
      return result;
    }
    hash(address, count) {
      let result = 0;
      address &= MASK;
      while ((address & 3) != 0) {
        result += this.lbu(address++);
        count--;
      }
      const count2 = MathUtils.prevAligned(count, 4);
      result += this.hashWordCount(address, count2);
      address += count2;
      count -= count2;
      while ((address & 3) != 0) {
        result += this.lbu(address++) * 7;
        count--;
      }
      return result;
    }
    static memoryCopy(source, sourcePosition, destination, destinationPosition, length) {
      const _source = new Uint8Array(source, sourcePosition, length);
      const _destination = new Uint8Array(destination, destinationPosition, length);
      _destination.set(_source);
    }
    dump(name2 = "memory.bin") {
      saveAs(new Blob([this.getPointerDataView(134217728, 33554432)]), name2);
    }
  };
  Memory.DEFAULT_FRAME_ADDRESS = 67108864;
  Memory.MASK = 268435455;
  Memory.MAIN_OFFSET = 134217728;
  var MemoryFields = fields();
  var FastMemory = class extends Memory {
    constructor(size = 167772160 + 4) {
      super();
      this.buffer = new ArrayBuffer(size);
      this.s8 = new Int8Array(this.buffer);
      this.u8 = new Uint8Array(this.buffer);
      this.u16 = new Uint16Array(this.buffer);
      this.s16 = new Int16Array(this.buffer);
      this.s32 = new Int32Array(this.buffer);
      this.u32 = new Uint32Array(this.buffer);
      this.f32 = new Float32Array(this.buffer);
    }
    reset() {
      this.s8.fill(0);
      return this;
    }
    sb(address, value) {
      this.u8[(address & MASK) >> 0] = value;
    }
    sh(address, value) {
      this.u16[(address & MASK) >> 1] = value;
    }
    sw(address, value) {
      this.u32[(address & MASK) >> 2] = value;
    }
    swc1(address, value) {
      this.f32[(address & MASK) >> 2] = value;
    }
    lb(address) {
      return this.s8[(address & MASK) >> 0];
    }
    lbu(address) {
      return this.u8[(address & MASK) >> 0];
    }
    lh(address) {
      return this.s16[(address & MASK) >> 1];
    }
    lhu(address) {
      return this.u16[(address & MASK) >> 1];
    }
    lw(address) {
      return this.s32[(address & MASK) >> 2];
    }
    lwu(address) {
      return this.u32[(address & MASK) >> 2];
    }
    lwc1(address) {
      return this.f32[(address & MASK) >> 2];
    }
    lw_2(address) {
      return this.u32[address];
    }
    getBuffer(address) {
      return this.buffer;
    }
    getOffsetInBuffer(address) {
      return address & MASK;
    }
    availableAfterAddress(address) {
      return this.buffer.byteLength - (address & MASK);
    }
  };
  var LowMemorySegment = class {
    constructor(name2, offset, buffer) {
      this.name = name2;
      this.offset = offset;
      this.buffer = buffer;
      this.size = buffer.byteLength;
      this.low = offset;
      this.high = this.low + this.size;
      this.s8 = new Int8Array(this.buffer);
      this.u8 = new Uint8Array(this.buffer);
      this.u16 = new Uint16Array(this.buffer);
      this.s16 = new Int16Array(this.buffer);
      this.s32 = new Int32Array(this.buffer);
      this.u32 = new Uint32Array(this.buffer);
      this.f32 = new Float32Array(this.buffer);
    }
    contains(address) {
      address &= MASK;
      return address >= this.low && address < this.high;
    }
    fixAddress(address) {
      return (address & MASK) - this.offset;
    }
    sb(address, value) {
      this.u8[this.fixAddress(address) >> 0] = value;
    }
    sh(address, value) {
      this.u16[this.fixAddress(address) >> 1] = value;
    }
    sw(address, value) {
      this.u32[this.fixAddress(address) >> 2] = value;
    }
    swc1(address, value) {
      this.f32[this.fixAddress(address) >> 2] = value;
    }
    lb(address) {
      return this.s8[this.fixAddress(address) >> 0];
    }
    lbu(address) {
      return this.u8[this.fixAddress(address) >> 0];
    }
    lh(address) {
      return this.s16[this.fixAddress(address) >> 1];
    }
    lhu(address) {
      return this.u16[this.fixAddress(address) >> 1];
    }
    lw(address) {
      return this.s32[this.fixAddress(address) >> 2];
    }
    lwu(address) {
      return this.u32[this.fixAddress(address) >> 2];
    }
    lwc1(address) {
      return this.f32[this.fixAddress(address) >> 2];
    }
    getBuffer(address) {
      return this.buffer;
    }
    getOffsetInBuffer(address) {
      return this.fixAddress(address);
    }
    availableAfterAddress(address) {
      return this.buffer.byteLength - this.fixAddress(address);
    }
  };
  var LowMemory = class extends Memory {
    constructor() {
      super();
      this.scratchpad = new LowMemorySegment("scatchpad", 0, new ArrayBuffer(16 * 1024 + 65536));
      this.videomem = new LowMemorySegment("videomem", 67108864, new ArrayBuffer(2 * 1024 * 1024));
      this.mainmem = new LowMemorySegment("mainmem", 134217728, new ArrayBuffer(32 * 1024 * 1024));
    }
    reset() {
      this.scratchpad.u8.fill(0);
      this.videomem.u8.fill(0);
      this.mainmem.u8.fill(0);
      return this;
    }
    getMemRange(address) {
      address &= MASK;
      if (address >= 134217728) {
        return this.mainmem;
      } else {
        if (this.mainmem.contains(address))
          return this.mainmem;
        if (this.videomem.contains(address))
          return this.videomem;
        if (this.scratchpad.contains(address))
          return this.scratchpad;
        printf("Unmapped: %08X", address);
        return null;
      }
    }
    sb(address, value) {
      this.getMemRange(address).sb(address, value);
    }
    sh(address, value) {
      this.getMemRange(address).sh(address, value);
    }
    sw(address, value) {
      this.getMemRange(address).sw(address, value);
    }
    swc1(address, value) {
      this.getMemRange(address).swc1(address, value);
    }
    lb(address) {
      return this.getMemRange(address).lb(address);
    }
    lbu(address) {
      return this.getMemRange(address).lbu(address);
    }
    lh(address) {
      return this.getMemRange(address).lh(address);
    }
    lhu(address) {
      return this.getMemRange(address).lhu(address);
    }
    lw(address) {
      return this.getMemRange(address).lw(address);
    }
    lwu(address) {
      return this.getMemRange(address).lwu(address);
    }
    lwc1(address) {
      return this.getMemRange(address).lwc1(address);
    }
    lw_2(address4) {
      return this.getMemRange(address4 * 4).lw(address4 * 4);
    }
    getBuffer(address) {
      return this.getMemRange(address).getBuffer(address);
    }
    getOffsetInBuffer(address) {
      return this.getMemRange(address).getOffsetInBuffer(address);
    }
    availableAfterAddress(address) {
      return this.getMemRange(address).availableAfterAddress(address);
    }
  };
  function supportFastMemory() {
    return true;
  }
  function create() {
    if (supportFastMemory()) {
      return new FastMemory();
    } else {
      return new LowMemory();
    }
  }
  var _instance = null;
  function getMemoryInstance() {
    if (_instance == null)
      _instance = create();
    return _instance;
  }

  // src/core/rtc.ts
  var PspRtc = class {
    getCurrentUnixSeconds() {
      return Date.now() / 1e3;
    }
    getCurrentUnixMicroseconds() {
      return Date.now() * 1e3;
    }
    getClockMicroseconds() {
      return performance.now() * 1e3 >>> 0;
    }
    getDayOfWeek(year, month, day) {
      return new Date(year, month - 1, day).getDay();
    }
    getDaysInMonth(year, month) {
      return new Date(year, month, 0).getDate();
    }
  };

  // src/codegen/simplerelooper.ts
  var RelooperBlock = class {
    constructor(index, code) {
      this.index = index;
      this.code = code;
      this.conditionalBranches = [];
      this.nextBlock = null;
      this.conditionalReferences = [];
    }
  };
  var RelooperBranch = class {
    constructor(to, cond, onjumpCode) {
      this.to = to;
      this.cond = cond;
      this.onjumpCode = onjumpCode;
    }
  };
  var IndentWriter = class {
    constructor() {
      this.i = "";
      this.startline = true;
      this.chunks = [];
    }
    write(chunk) {
      this.chunks.push(chunk);
    }
    indent() {
      this.i += "	";
    }
    unindent() {
      this.i = this.i.substr(0, -1);
    }
    get output() {
      return this.chunks.join("");
    }
  };
  var SimpleRelooper = class {
    constructor() {
      this.blocks = [];
      this.lastId = 0;
    }
    init() {
      this.lastId = 0;
    }
    cleanup() {
    }
    addBlock(code) {
      const block = new RelooperBlock(this.lastId++, code);
      this.blocks.push(block);
      return block;
    }
    addBranch(from, to, cond, onjumpcode) {
      const branch = new RelooperBranch(to, cond, onjumpcode);
      if (cond) {
        from.conditionalBranches.push(branch);
        to.conditionalReferences.push(from);
      } else {
        from.nextBlock = to;
      }
    }
    render(first) {
      const writer = new IndentWriter();
      if (this.blocks.length <= 1) {
        if (this.blocks.length == 1)
          writer.write(this.blocks[0].code);
      } else {
        writer.write("label = 0; loop_label: while (true) switch (label) { case 0:\n");
        writer.indent();
        for (let block of this.blocks) {
          let nblock = this.blocks[block.index + 1];
          if (block.index != 0) {
            writer.write(`case ${block.index}:
`);
            writer.indent();
          }
          if (block.conditionalBranches.length == 0 && block.conditionalReferences.length == 1 && block.conditionalReferences[0] == nblock) {
            let branch = nblock.conditionalBranches[0];
            writer.write(`while (true) {
`);
            writer.indent();
            writer.write(block.code);
            writer.write(`if (!(${branch.cond})) break;
`);
            writer.write(`${branch.onjumpCode};
`);
            writer.unindent();
            writer.write(`}
`);
            writer.write(nblock.code);
          } else {
            for (let branch of block.conditionalBranches) {
              writer.write(`if (${branch.cond}) { ${branch.onjumpCode}; label = ${branch.to.index}; continue loop_label; }
`);
            }
            writer.write(block.code);
          }
          if (block.nextBlock) {
            if (block.nextBlock != nblock) {
              writer.write(`label = ${block.nextBlock.index}; continue loop_label;
`);
            }
          } else {
            writer.write("break loop_label;\n");
          }
          if (block.index != 0)
            writer.unindent();
        }
        writer.unindent();
        writer.write("}");
      }
      return writer.output;
    }
  };

  // src/codegen/relooper.ts
  function processSimple(callback) {
    const sr = new SimpleRelooper();
    sr.init();
    try {
      callback(sr);
      return sr.render(sr.blocks[0]);
    } finally {
      sr.cleanup();
    }
  }
  function relooperProcess(callback) {
    return processSimple(callback);
  }

  // src/core/cpu/cpu_ast.ts
  var ANode = class {
    constructor() {
      this.index = 0;
    }
    toJs() {
      return "";
    }
    optimize() {
      return this;
    }
  };
  var ANodeStm = class extends ANode {
  };
  var ANodeStmLabel = class extends ANodeStm {
    constructor(address) {
      super();
      this.address = 0;
      this.references = [];
      this.type = "normal";
      this.address = address;
    }
    toJs() {
      switch (this.type) {
        case "none":
          return ``;
        case "normal":
          if (this.references.length == 0)
            return ``;
          return `case ${addressToHex(this.address)}:`;
        case "while":
          return `loop_${addressToHex(this.address)}: while (true) {`;
        default:
          throw new Error(`Unexpected type ${this.type}`);
      }
    }
  };
  var ANodeStmStaticJump = class extends ANodeStm {
    constructor(cond, address, branchCode) {
      super();
      this.cond = cond;
      this.address = address;
      this.branchCode = branchCode;
      this.type = "normal";
    }
    get branchCodeJs() {
      return this.branchCode?.toJs() ?? "";
    }
    toJs() {
      switch (this.type) {
        case "normal":
          return `if (${this.cond.toJs()}) { ${this.branchCodeJs}; loop_state = ${addressToHex(this.address)}; continue loop; }`;
        case "while":
          return `if (${this.cond.toJs()}) { ${this.branchCodeJs}; continue loop_${addressToHex(this.address)}; } else { break loop_${addressToHex(this.address)}; } }`;
        default:
          throw new Error(`Unexpected type ${this.type}`);
      }
    }
  };
  var ANodeStmReturn = class extends ANodeStm {
    toJs() {
      return "return;";
    }
  };
  var ANodeStmList = class extends ANodeStm {
    constructor(childs) {
      super();
      this.childs = childs;
    }
    add(node) {
      this.childs.push(node);
    }
    toJs() {
      return this.childs.map((c) => c.toJs()).join("\n");
    }
  };
  var ABlock = class {
    constructor(index, label = null, jump = null) {
      this.index = index;
      this.label = label;
      this.jump = jump;
      this.code = "";
      this.rblock = null;
    }
    add(node) {
      this.code += node.toJs() + "\n";
    }
  };
  var ANodeFunction = class extends ANodeStmList {
    constructor(address, prefix, sufix, childs) {
      super(childs);
      this.address = address;
      this.prefix = prefix;
      this.sufix = sufix;
    }
    toJs() {
      let block = new ABlock(0, null);
      const blocksByLabel = {};
      const blocks = [block];
      for (let child of this.childs) {
        if (child instanceof ANodeStmLabel) {
          blocks.push(block = new ABlock(blocks.length, child, null));
          blocksByLabel[child.address] = block;
        } else if (child instanceof ANodeStmStaticJump) {
          blocks.push(block = new ABlock(blocks.length, null, child));
        } else {
          block.add(child);
        }
      }
      const text = relooperProcess((relooper) => {
        for (let block2 of blocks)
          block2.rblock = relooper.addBlock(block2.code);
        for (let n = 0; n < blocks.length; n++) {
          let block2 = blocks[n];
          let nblock = n < blocks.length - 1 ? blocks[n + 1] : null;
          let jblock = block2.jump ? blocksByLabel[block2.jump.address] : null;
          if (nblock)
            relooper.addBranch(block2.rblock, nblock.rblock);
          if (jblock)
            relooper.addBranch(block2.rblock, jblock.rblock, block2.jump.cond.toJs(), block2.jump.branchCodeJs);
        }
      });
      return `${this.prefix.toJs()}
${text}${this.sufix.toJs()}
`;
    }
  };
  var ANodeStmRaw = class extends ANodeStm {
    constructor(content) {
      super();
      this.content = content;
    }
    toJs() {
      return this.content;
    }
  };
  var ANodeStmExpr = class extends ANodeStm {
    constructor(expr) {
      super();
      this.expr = expr;
    }
    toJs() {
      return this.expr.toJs() + ";";
    }
  };
  var ANodeAllocVarStm = class extends ANodeStm {
    constructor(name2, initialValue) {
      super();
      this.name = name2;
      this.initialValue = initialValue;
    }
    toJs() {
      return `var ${this.name} = ${this.initialValue.toJs()};`;
    }
  };
  var ANodeExpr = class extends ANode {
  };
  var ANodeExprLValue = class extends ANodeExpr {
    toAssignJs(right) {
      return "";
    }
  };
  var ANodeExprLValueSetGet = class extends ANodeExpr {
    constructor(setTemplate, getTemplate, replacements) {
      super();
      this.setTemplate = setTemplate;
      this.getTemplate = getTemplate;
      this.replacements = replacements;
    }
    _toJs(template, right) {
      return template.replace(/(\$\d|#)/g, (match) => {
        if (match == "#") {
          return right.toJs();
        } else if (match.startsWith("$")) {
          return this.replacements[parseInt(match.substr(1))].toJs();
        } else {
          return match;
        }
      });
    }
    toAssignJs(right) {
      return this._toJs(this.setTemplate, right);
    }
    toJs() {
      return this._toJs(this.getTemplate);
    }
  };
  var ANodeExprLValueVar = class extends ANodeExprLValue {
    constructor(name2) {
      super();
      this.name = name2;
    }
    toAssignJs(right) {
      return `${this.name} = ${right.toJs()}`;
    }
    toJs() {
      return this.name;
    }
  };
  var ANodeExprI32 = class extends ANodeExpr {
    constructor(value) {
      super();
      this.value = value;
    }
    toJs() {
      return String(this.value);
    }
  };
  var ANodeExprFloat = class extends ANodeExpr {
    constructor(value) {
      super();
      this.value = value;
    }
    toJs() {
      const rfloat = MathFloat.reinterpretFloatAsInt(this.value);
      if (rfloat & 2147483648) {
        return `-${MathFloat.reinterpretIntAsFloat(rfloat & 2147483647)}`;
      } else {
        return String(this.value);
      }
    }
  };
  var ANodeExprU32 = class extends ANodeExpr {
    constructor(value) {
      super();
      this.value = value;
    }
    toJs() {
      return addressToHex(this.value);
    }
  };
  var ANodeExprBinop = class extends ANodeExpr {
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
      if (!this.left || !this.left.toJs)
        debugger;
      if (!this.right || !this.right.toJs)
        debugger;
    }
    toJs() {
      return `(${this.left.toJs()} ${this.op} ${this.right.toJs()})`;
    }
  };
  var ANodeExprUnop = class extends ANodeExpr {
    constructor(op, right) {
      super();
      this.op = op;
      this.right = right;
    }
    toJs() {
      return `(${this.op}(${this.right.toJs()}))`;
    }
  };
  var ANodeExprAssign = class extends ANodeExpr {
    constructor(left, right) {
      super();
      this.left = left;
      this.right = right;
      if (!this.left || !this.left.toAssignJs)
        debugger;
      if (!this.right)
        debugger;
    }
    toJs() {
      return this.left.toAssignJs(this.right);
    }
  };
  var ANodeExprArray = class extends ANodeExpr {
    constructor(_items) {
      super();
      this._items = _items;
    }
    toJs() {
      return `[${this._items.map((item) => item.toJs()).join(", ")}]`;
    }
  };
  var ANodeExprCall = class extends ANodeExpr {
    constructor(name2, _arguments) {
      super();
      this.name = name2;
      this._arguments = _arguments;
      if (!_arguments)
        debugger;
      this._arguments.forEach((argument) => {
        if (!argument || !(argument instanceof ANodeExpr))
          debugger;
      });
    }
    toJs() {
      return `${this.name}(${this._arguments.map((argument) => argument.toJs()).join(", ")})`;
    }
  };
  var ANodeStmIf = class extends ANodeStm {
    constructor(cond, codeTrue, codeFalse) {
      super();
      this.cond = cond;
      this.codeTrue = codeTrue;
      this.codeFalse = codeFalse;
    }
    toJs() {
      let result = "";
      result += `if (${this.cond.toJs()})`;
      result += ` { ${this.codeTrue.toJs()} }`;
      if (this.codeFalse)
        result += ` else { ${this.codeFalse.toJs()} }`;
      return result;
    }
  };
  var AstBuilder = class {
    assign(ref, value) {
      return new ANodeExprAssign(ref, value);
    }
    _if(cond, codeTrue, codeFalse) {
      return new ANodeStmIf(cond, codeTrue, codeFalse);
    }
    binop(left, op, right) {
      return new ANodeExprBinop(left, op, right);
    }
    unop(op, right) {
      return new ANodeExprUnop(op, right);
    }
    binop_i(left, op, right) {
      return this.binop(left, op, this.imm32(right));
    }
    imm32(value) {
      return new ANodeExprI32(value);
    }
    imm_f(value) {
      return new ANodeExprFloat(value);
    }
    u_imm32(value) {
      return new ANodeExprU32(value);
    }
    stm(expr) {
      return expr ? new ANodeStmExpr(expr) : new ANodeStm();
    }
    stms(stms2) {
      return new ANodeStmList(stms2);
    }
    func(address, prefix, sufix, stms2) {
      return new ANodeFunction(address, prefix, sufix, stms2);
    }
    array(exprList) {
      return new ANodeExprArray(exprList);
    }
    arrayNumbers(values) {
      return this.array(values.map((value) => this.imm_f(value)));
    }
    call(name2, exprList) {
      return new ANodeExprCall(name2, exprList);
    }
    label(address) {
      return new ANodeStmLabel(address);
    }
    sjump(cond, value, branchCode) {
      return new ANodeStmStaticJump(cond, value, branchCode);
    }
    _return() {
      return new ANodeStmReturn();
    }
    raw_stm(content) {
      return new ANodeStmRaw(content);
    }
    raw(content) {
      return new ANodeExprLValueVar(content);
    }
    allocVar(name2, initialValue) {
      return new ANodeAllocVarStm(name2, initialValue);
    }
  };
  var MipsAstBuilder = class extends AstBuilder {
    debugger(comment = "-") {
      return new ANodeStmRaw("debugger; // " + comment + "\n");
    }
    gpr(index) {
      if (index === 0)
        return new ANodeExprLValueVar("0");
      if (CpuState.GPR_require_castToInt()) {
        return new ANodeExprLValueVar(CpuState.GPR_access("state", index));
      } else {
        return new ANodeExprLValueVar(CpuState.GPR_access(null, index));
      }
    }
    gpr_f(index) {
      if (index === 0)
        return new ANodeExprLValueVar("0");
      return new ANodeExprLValueVar(`gpr_f[${index}]`);
    }
    tempr(index) {
      return new ANodeExprLValueVar(`state.temp[${index}]`);
    }
    vector_vs(index) {
      return new ANodeExprLValueVar(`state.vector_vs[${index}]`);
    }
    vector_vt(index) {
      return new ANodeExprLValueVar(`state.vector_vt[${index}]`);
    }
    vfpr(index) {
      return new ANodeExprLValueVar(`state.vfpr[${index}]`);
    }
    vfprc(index) {
      return new ANodeExprLValueVar(`state.vfprc[${index}]`);
    }
    vfpr_i(index) {
      return new ANodeExprLValueVar(`state.vfpr_i[${index}]`);
    }
    fpr(index) {
      return new ANodeExprLValueVar(`state.fpr[${index}]`);
    }
    fpr_i(index) {
      return new ANodeExprLValueVar(`state.fpr_i[${index}]`);
    }
    fcr31_cc() {
      return new ANodeExprLValueVar("state.fcr31_cc");
    }
    lo() {
      return new ANodeExprLValueVar("state.LO");
    }
    hi() {
      return new ANodeExprLValueVar("state.HI");
    }
    ic() {
      return new ANodeExprLValueVar("state.IC");
    }
    pc() {
      return new ANodeExprLValueVar("state.PC");
    }
    VCC(index) {
      return new ANodeExprLValueSetGet("state.setVfrCc($0, #)", "state.getVfrCc($0)", [this.imm32(index)]);
    }
    ra() {
      return new ANodeExprLValueVar(CpuState.GPR_access("state", 31));
    }
    branchflag() {
      return new ANodeExprLValueVar("BRANCHFLAG");
    }
    branchpc() {
      return new ANodeExprLValueVar("BRANCHPC");
    }
    assignGpr(index, expr) {
      if (index == 0)
        return this.stm();
      if (CpuState.GPR_require_castToInt()) {
        return this.stm(this.assign(this.gpr(index), this.binop(expr, "|", this.imm32(0))));
      } else {
        return this.stm(this.assign(this.gpr(index), expr));
      }
    }
    assignIC(expr) {
      return this.stm(this.assign(this.ic(), expr));
    }
    assignFpr(index, expr) {
      return this.stm(this.assign(this.fpr(index), expr));
    }
    assignFpr_I(index, expr) {
      return this.stm(this.assign(this.fpr_i(index), expr));
    }
  };

  // src/util/IndentStringGenerator.ts
  var IndentStringGenerator = class {
    constructor() {
      this.indentation = 0;
      this.output = "";
      this.newLine = true;
    }
    indent(callback) {
      this.indentation++;
      try {
        callback();
      } finally {
        this.indentation--;
      }
    }
    write(text) {
      const chunks = text.split("\n");
      for (let n = 0; n < chunks.length; n++) {
        if (n != 0)
          this.writeBreakLine();
        this.writeInline(chunks[n]);
      }
    }
    writeInline(text) {
      if (text == null || text.length == 0)
        return;
      if (this.newLine) {
        for (let n = 0; n < this.indentation; n++)
          this.output += "	";
        this.newLine = false;
      }
      this.output += text;
    }
    writeBreakLine() {
      this.output += "\n";
      this.newLine = true;
    }
  };

  // src/core/cpu/cpu_instructions.ts
  var ADDR_TYPE_NONE = 0;
  var ADDR_TYPE_REG = 1;
  var ADDR_TYPE_16 = 2;
  var ADDR_TYPE_26 = 3;
  var INSTR_TYPE_PSP = 1 << 0;
  var INSTR_TYPE_SYSCALL = 1 << 1;
  var INSTR_TYPE_B = 1 << 2;
  var INSTR_TYPE_LIKELY = 1 << 3;
  var INSTR_TYPE_JAL = 1 << 4;
  var INSTR_TYPE_JUMP = 1 << 5;
  var INSTR_TYPE_BREAK = 1 << 6;
  function VM(format) {
    const counts = {
      cstw: 1,
      cstz: 1,
      csty: 1,
      cstx: 1,
      absw: 1,
      absz: 1,
      absy: 1,
      absx: 1,
      mskw: 1,
      mskz: 1,
      msky: 1,
      mskx: 1,
      negw: 1,
      negz: 1,
      negy: 1,
      negx: 1,
      one: 1,
      two: 1,
      vt1: 1,
      vt2: 2,
      satw: 2,
      satz: 2,
      saty: 2,
      satx: 2,
      swzw: 2,
      swzz: 2,
      swzy: 2,
      swzx: 2,
      imm3: 3,
      imm4: 4,
      fcond: 4,
      c0dr: 5,
      c0cr: 5,
      c1dr: 5,
      c1cr: 5,
      imm5: 5,
      vt5: 5,
      rs: 5,
      rd: 5,
      rt: 5,
      sa: 5,
      lsb: 5,
      msb: 5,
      fs: 5,
      fd: 5,
      ft: 5,
      vs: 7,
      vt: 7,
      vd: 7,
      imm7: 7,
      imm8: 8,
      imm14: 14,
      imm16: 16,
      imm20: 20,
      imm26: 26
    };
    let value = 0;
    let mask = 0;
    format.split(":").forEach((item) => {
      if (/^[01\-]+$/.test(item)) {
        for (let n = 0; n < item.length; n++) {
          value <<= 1;
          mask <<= 1;
          if (item[n] == "0") {
            value |= 0;
            mask |= 1;
          }
          if (item[n] == "1") {
            value |= 1;
            mask |= 1;
          }
          if (item[n] == "-") {
            value |= 0;
            mask |= 0;
          }
        }
      } else {
        const displacement = counts[item];
        if (displacement === void 0)
          throw "Invalid item '" + item + "'";
        value <<= displacement;
        mask <<= displacement;
      }
    });
    return {value, mask};
  }
  var InstructionType = class {
    constructor(name2, vm, format, addressType, instructionType) {
      this.name = name2;
      this.vm = vm;
      this.format = format;
      this.addressType = addressType;
      this.instructionType = instructionType;
    }
    match(i32) {
      return (i32 & this.vm.mask) == (this.vm.value & this.vm.mask);
    }
    isInstructionType(mask) {
      return (this.instructionType & mask) != 0;
    }
    get isSyscall() {
      return this.isInstructionType(INSTR_TYPE_SYSCALL);
    }
    get isBreak() {
      return this.isInstructionType(INSTR_TYPE_BREAK);
    }
    get isBranch() {
      return this.isInstructionType(INSTR_TYPE_B);
    }
    get isCall() {
      return this.isInstructionType(INSTR_TYPE_JAL);
    }
    get isJump() {
      return this.isInstructionType(INSTR_TYPE_JAL) || this.isInstructionType(INSTR_TYPE_JUMP);
    }
    get isJumpNoLink() {
      return this.isInstructionType(INSTR_TYPE_JUMP);
    }
    get isJal() {
      return this.isInstructionType(INSTR_TYPE_JAL);
    }
    get isJumpOrBranch() {
      return this.isBranch || this.isJump;
    }
    get isLikely() {
      return this.isInstructionType(INSTR_TYPE_LIKELY);
    }
    get isRegister() {
      return this.addressType == ADDR_TYPE_REG;
    }
    get isFixedAddressJump() {
      return this.isJumpOrBranch && !this.isRegister;
    }
    get hasDelayedBranch() {
      return this.isJumpOrBranch;
    }
    toString() {
      return `InstructionType('${this.name}', ${addressToHex(this.vm.value)}, ${addressToHex(this.vm.mask)})`;
    }
  };
  var Instructions = class {
    constructor() {
      this.instructionTypeListByName = {};
      this.instructionTypeList = [];
      const ID = (name2, vm, format, addressType, instructionType) => {
        this.add(name2, vm, format, addressType, instructionType);
      };
      ID("add", VM("000000:rs:rt:rd:00000:100000"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("addu", VM("000000:rs:rt:rd:00000:100001"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("addi", VM("001000:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
      ID("addiu", VM("001001:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
      ID("sub", VM("000000:rs:rt:rd:00000:100010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("subu", VM("000000:rs:rt:rd:00000:100011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("and", VM("000000:rs:rt:rd:00000:100100"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("andi", VM("001100:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
      ID("nor", VM("000000:rs:rt:rd:00000:100111"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("or", VM("000000:rs:rt:rd:00000:100101"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("ori", VM("001101:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
      ID("xor", VM("000000:rs:rt:rd:00000:100110"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("xori", VM("001110:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
      ID("sll", VM("000000:00000:rt:rd:sa:000000"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
      ID("sllv", VM("000000:rs:rt:rd:00000:000100"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
      ID("sra", VM("000000:00000:rt:rd:sa:000011"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
      ID("srav", VM("000000:rs:rt:rd:00000:000111"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
      ID("srl", VM("000000:00000:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
      ID("srlv", VM("000000:rs:rt:rd:00000:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
      ID("rotr", VM("000000:00001:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
      ID("rotrv", VM("000000:rs:rt:rd:00001:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
      ID("slt", VM("000000:rs:rt:rd:00000:101010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("slti", VM("001010:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
      ID("sltu", VM("000000:rs:rt:rd:00000:101011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
      ID("sltiu", VM("001011:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
      ID("lui", VM("001111:00000:rt:imm16"), "%t, %I", ADDR_TYPE_NONE, 0);
      ID("seb", VM("011111:00000:rt:rd:10000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
      ID("seh", VM("011111:00000:rt:rd:11000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
      ID("bitrev", VM("011111:00000:rt:rd:10100:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("max", VM("000000:rs:rt:rd:00000:101100"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("min", VM("000000:rs:rt:rd:00000:101101"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("div", VM("000000:rs:rt:00000:00000:011010"), "%s, %t", ADDR_TYPE_NONE, 0);
      ID("divu", VM("000000:rs:rt:00000:00000:011011"), "%s, %t", ADDR_TYPE_NONE, 0);
      ID("mult", VM("000000:rs:rt:00000:00000:011000"), "%s, %t", ADDR_TYPE_NONE, 0);
      ID("multu", VM("000000:rs:rt:00000:00000:011001"), "%s, %t", ADDR_TYPE_NONE, 0);
      ID("madd", VM("000000:rs:rt:00000:00000:011100"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("maddu", VM("000000:rs:rt:00000:00000:011101"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("msub", VM("000000:rs:rt:00000:00000:101110"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("msubu", VM("000000:rs:rt:00000:00000:101111"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mfhi", VM("000000:00000:00000:rd:00000:010000"), "%d", ADDR_TYPE_NONE, 0);
      ID("mflo", VM("000000:00000:00000:rd:00000:010010"), "%d", ADDR_TYPE_NONE, 0);
      ID("mthi", VM("000000:rs:00000:00000:00000:010001"), "%s", ADDR_TYPE_NONE, 0);
      ID("mtlo", VM("000000:rs:00000:00000:00000:010011"), "%s", ADDR_TYPE_NONE, 0);
      ID("movz", VM("000000:rs:rt:rd:00000:001010"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("movn", VM("000000:rs:rt:rd:00000:001011"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("ext", VM("011111:rs:rt:msb:lsb:000000"), "%t, %s, %a, %ne", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("ins", VM("011111:rs:rt:msb:lsb:000100"), "%t, %s, %a, %ni", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("clz", VM("000000:rs:00000:rd:00000:010110"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("clo", VM("000000:rs:00000:rd:00000:010111"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("wsbh", VM("011111:00000:rt:rd:00010:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("wsbw", VM("011111:00000:rt:rd:00011:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("beq", VM("000100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("beql", VM("010100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bgez", VM("000001:rs:00001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bgezl", VM("000001:rs:00011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bgezal", VM("000001:rs:10001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
      ID("bgezall", VM("000001:rs:10011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
      ID("bltz", VM("000001:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bltzl", VM("000001:rs:00010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bltzal", VM("000001:rs:10000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
      ID("bltzall", VM("000001:rs:10010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
      ID("blez", VM("000110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("blezl", VM("010110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bgtz", VM("000111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bgtzl", VM("010111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bne", VM("000101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bnel", VM("010101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("j", VM("000010:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JUMP);
      ID("jr", VM("000000:rs:00000:00000:00000:001000"), "%J", ADDR_TYPE_REG, INSTR_TYPE_JUMP);
      ID("jalr", VM("000000:rs:00000:rd:00000:001001"), "%J, %d", ADDR_TYPE_REG, INSTR_TYPE_JAL);
      ID("jal", VM("000011:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JAL);
      ID("bc1f", VM("010001:01000:00000:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bc1t", VM("010001:01000:00001:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
      ID("bc1fl", VM("010001:01000:00010:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bc1tl", VM("010001:01000:00011:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("lb", VM("100000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lh", VM("100001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lw", VM("100011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lwl", VM("100010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lwr", VM("100110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lbu", VM("100100:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("lhu", VM("100101:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("sb", VM("101000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("sh", VM("101001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("sw", VM("101011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("swl", VM("101010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("swr", VM("101110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("ll", VM("110000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
      ID("sc", VM("111000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
      ID("lwc1", VM("110001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("swc1", VM("111001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
      ID("add.s", VM("010001:10000:ft:fs:fd:000000"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
      ID("sub.s", VM("010001:10000:ft:fs:fd:000001"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
      ID("mul.s", VM("010001:10000:ft:fs:fd:000010"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
      ID("div.s", VM("010001:10000:ft:fs:fd:000011"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
      ID("sqrt.s", VM("010001:10000:00000:fs:fd:000100"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("abs.s", VM("010001:10000:00000:fs:fd:000101"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("mov.s", VM("010001:10000:00000:fs:fd:000110"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("neg.s", VM("010001:10000:00000:fs:fd:000111"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("round.w.s", VM("010001:10000:00000:fs:fd:001100"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("trunc.w.s", VM("010001:10000:00000:fs:fd:001101"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("ceil.w.s", VM("010001:10000:00000:fs:fd:001110"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("floor.w.s", VM("010001:10000:00000:fs:fd:001111"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("cvt.s.w", VM("010001:10100:00000:fs:fd:100000"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("cvt.w.s", VM("010001:10000:00000:fs:fd:100100"), "%D, %S", ADDR_TYPE_NONE, 0);
      ID("mfc1", VM("010001:00000:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
      ID("mtc1", VM("010001:00100:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
      ID("cfc1", VM("010001:00010:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
      ID("ctc1", VM("010001:00110:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
      ID("c.f.s", VM("010001:10000:ft:fs:00000:11:0000"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.un.s", VM("010001:10000:ft:fs:00000:11:0001"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.eq.s", VM("010001:10000:ft:fs:00000:11:0010"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ueq.s", VM("010001:10000:ft:fs:00000:11:0011"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.olt.s", VM("010001:10000:ft:fs:00000:11:0100"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ult.s", VM("010001:10000:ft:fs:00000:11:0101"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ole.s", VM("010001:10000:ft:fs:00000:11:0110"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ule.s", VM("010001:10000:ft:fs:00000:11:0111"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.sf.s", VM("010001:10000:ft:fs:00000:11:1000"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ngle.s", VM("010001:10000:ft:fs:00000:11:1001"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.seq.s", VM("010001:10000:ft:fs:00000:11:1010"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ngl.s", VM("010001:10000:ft:fs:00000:11:1011"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.lt.s", VM("010001:10000:ft:fs:00000:11:1100"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.nge.s", VM("010001:10000:ft:fs:00000:11:1101"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.le.s", VM("010001:10000:ft:fs:00000:11:1110"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("c.ngt.s", VM("010001:10000:ft:fs:00000:11:1111"), "%S, %T", ADDR_TYPE_NONE, 0);
      ID("syscall", VM("000000:imm20:001100"), "%C", ADDR_TYPE_NONE, INSTR_TYPE_SYSCALL);
      ID("cache", VM("101111:rs:-----:imm16"), "%k, %o", ADDR_TYPE_NONE, 0);
      ID("sync", VM("000000:00000:00000:00000:00000:001111"), "", ADDR_TYPE_NONE, 0);
      ID("break", VM("000000:imm20:001101"), "%c", ADDR_TYPE_NONE, INSTR_TYPE_BREAK);
      ID("dbreak", VM("011100:00000:00000:00000:00000:111111"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP | INSTR_TYPE_BREAK);
      ID("halt", VM("011100:00000:00000:00000:00000:000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("dret", VM("011100:00000:00000:00000:00000:111110"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("eret", VM("010000:10000:00000:00000:00000:011000"), "", ADDR_TYPE_NONE, 0);
      ID("mfic", VM("011100:rt:00000:00000:00000:100100"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mtic", VM("011100:rt:00000:00000:00000:100110"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mfdr", VM("011100:00000:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mtdr", VM("011100:00100:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("cfc0", VM("010000:00010:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("ctc0", VM("010000:00110:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mfc0", VM("010000:00000:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
      ID("mtc0", VM("010000:00100:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
      ID("mfv", VM("010010:00:011:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mfvc", VM("010010:00:011:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mtv", VM("010010:00:111:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mtvc", VM("010010:00:111:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("lv.s", VM("110010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("lv.q", VM("110110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("lvl.q", VM("110101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("lvr.q", VM("110101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("sv.q", VM("111110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vdot", VM("011001:001:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vscl", VM("011001:010:vt:two:vs:one:vd"), "%zp, %yp, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsge", VM("011011:110:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vslt", VM("011011:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrot", VM("111100:111:01:imm5:two:vs:one:vd"), "%zp, %ys, %vr", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vzero", VM("110100:00:000:0:0110:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vone", VM("110100:00:000:0:0111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmov", VM("110100:00:000:0:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vabs", VM("110100:00:000:0:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vneg", VM("110100:00:000:0:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vocp", VM("110100:00:010:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsgn", VM("110100:00:010:0:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrcp", VM("110100:00:000:1:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrsq", VM("110100:00:000:1:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsin", VM("110100:00:000:1:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcos", VM("110100:00:000:1:0011:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vexp2", VM("110100:00:000:1:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vlog2", VM("110100:00:000:1:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsqrt", VM("110100:00:000:1:0110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vasin", VM("110100:00:000:1:0111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vnrcp", VM("110100:00:000:1:1000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vnsin", VM("110100:00:000:1:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrexp2", VM("110100:00:000:1:1100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsat0", VM("110100:00:000:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsat1", VM("110100:00:000:0:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcst", VM("110100:00:011:imm5:two:0000000:one:vd"), "%zp, %vk", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmmul", VM("111100:000:vt:two:vs:one:vd"), "%zm, %tym, %xm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vhdp", VM("011001:100:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcrs.t", VM("011001:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcrsp.t", VM("111100:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vi2c", VM("110100:00:001:11:101:two:vs:one:vd"), "%zs, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vi2uc", VM("110100:00:001:11:100:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vtfm2", VM("111100:001:vt:0:vs:1:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vtfm3", VM("111100:010:vt:1:vs:0:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vtfm4", VM("111100:011:vt:1:vs:1:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vhtfm2", VM("111100:001:vt:0:vs:0:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vhtfm3", VM("111100:010:vt:0:vs:1:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vhtfm4", VM("111100:011:vt:1:vs:0:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsrt3", VM("110100:00:010:01000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vfad", VM("110100:00:010:00110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmin", VM("011011:010:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmax", VM("011011:011:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vadd", VM("011000:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsub", VM("011000:001:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vdiv", VM("011000:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmul", VM("011001:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vidt", VM("110100:00:000:0:0011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmidt", VM("111100:111:00:00011:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("viim", VM("110111:11:0:vd:imm16"), "%xs, %vi", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmmov", VM("111100:111:00:00000:two:vs:one:vd"), "%zm, %ym", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmzero", VM("111100:111:00:00110:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmone", VM("111100:111:00:00111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vnop", VM("111111:1111111111:00000:00000000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsync", VM("111111:1111111111:00000:01100100000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vflush", VM("111111:1111111111:00000:10000001101"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vpfxd", VM("110111:10:------------:mskw:mskz:msky:mskx:satw:satz:saty:satx"), "[%vp4, %vp5, %vp6, %vp7]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vpfxs", VM("110111:00:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vpfxt", VM("110111:01:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vdet", VM("011001:110:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrnds", VM("110100:00:001:00:000:two:vs:one:0000000"), "%ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrndi", VM("110100:00:001:00:001:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrndf1", VM("110100:00:001:00:010:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vrndf2", VM("110100:00:001:00:011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcmp", VM("011011:000:vt:two:vs:one:000:imm4"), "%Zn, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcmovf", VM("110100:10:101:01:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vcmovt", VM("110100:10:101:00:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vavg", VM("110100:00:010:00111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vf2id", VM("110100:10:011:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vf2in", VM("110100:10:000:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vf2iu", VM("110100:10:010:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vf2iz", VM("110100:10:001:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vi2f", VM("110100:10:100:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vscmp", VM("011011:101:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmscl", VM("111100:100:vt:two:vs:one:vd"), "%zm, %ym, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vt4444.q", VM("110100:00:010:11001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vt5551.q", VM("110100:00:010:11010:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vt5650.q", VM("110100:00:010:11011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmfvc", VM("110100:00:010:10000:1:imm7:0:vd"), "%zs, %2s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vmtvc", VM("110100:00:010:10001:0:vs:1:imm7"), "%2d, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("mfvme", VM("011010--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
      ID("mtvme", VM("101100--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
      ID("sv.s", VM("111010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vfim", VM("110111:11:1:vt:imm16"), "%xs, %vh", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("svl.q", VM("111101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("svr.q", VM("111101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vbfy1", VM("110100:00:010:00010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vbfy2", VM("110100:00:010:00011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vf2h", VM("110100:00:001:10:010:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vh2f", VM("110100:00:001:10:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vi2s", VM("110100:00:001:11:111:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vi2us", VM("110100:00:001:11:110:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vlgb", VM("110100:00:001:10:111:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vqmul", VM("111100:101:vt:1:vs:1:vd"), "%zq, %yq, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vs2i", VM("110100:00:001:11:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vc2i", VM("110100:00:001:11:001:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vuc2i", VM("110100:00:001:11:000:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsbn", VM("011000:010:vt:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsbz", VM("110100:00:001:10110:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsocp", VM("110100:00:010:00101:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsrt1", VM("110100:00:010:00000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsrt2", VM("110100:00:010:00001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vsrt4", VM("110100:00:010:01001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vus2i", VM("110100:00:001:11010:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("vwbn", VM("110100:11:imm8:two:vs:one:vd"), "%zs, %xs, %I", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
      ID("bvf", VM("010010:01:000:imm3:00:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
      ID("bvt", VM("010010:01:000:imm3:01:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
      ID("bvfl", VM("010010:01:000:imm3:10:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
      ID("bvtl", VM("010010:01:000:imm3:11:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
    }
    static get instance() {
      if (!Instructions._instance)
        Instructions._instance = new Instructions();
      return Instructions._instance;
    }
    get instructions() {
      return this.instructionTypeList.slice(0);
    }
    add(name2, vm, format, addressType, instructionType) {
      const it = new InstructionType(name2, vm, format, addressType, instructionType);
      this.instructionTypeListByName[name2] = it;
      this.instructionTypeList.push(it);
    }
    findByName(name2) {
      const instructionType = this.instructionTypeListByName[name2];
      if (!instructionType)
        throw "Cannot find instruction " + sprintf("%s", name2);
      return instructionType;
    }
    findByData(i32, pc2 = 0) {
      return this.fastFindByData(i32, pc2);
    }
    fastFindByData(i32, pc2 = 0) {
      if (!this.decoder) {
        const switchCode2 = DecodingTable.createSwitch(this.instructionTypeList, (iname) => `return instructionsByName[${JSON.stringify(iname)}];`);
        this.decoder = new Function("instructionsByName", "value", "pc", `"use strict";${switchCode2}`);
      }
      return this.decoder(this.instructionTypeListByName, i32, pc2);
    }
    slowFindByData(i32, pc2 = 0) {
      for (let n = 0; n < this.instructionTypeList.length; n++) {
        const instructionType = this.instructionTypeList[n];
        if (instructionType.match(i32))
          return instructionType;
      }
      throw sprintf("Cannot find instruction 0x%08X at 0x%08X", i32, pc2);
    }
  };
  var DecodingTable = class {
    constructor() {
      this.lastId = 0;
    }
    getCommonMask(instructions, baseMask = 4294967295) {
      return instructions.reduce((left, item) => left & item.vm.mask, baseMask);
    }
    static createSwitch(instructions, gen) {
      const writer = new IndentStringGenerator();
      const decodingTable = new DecodingTable();
      decodingTable._createSwitch(writer, instructions, gen);
      return writer.output;
    }
    _createSwitch(writer, instructions, gen, baseMask = 4294967295, level = 0) {
      if (level >= 10)
        throw "ERROR: Recursive detection";
      const commonMask = this.getCommonMask(instructions, baseMask);
      const groups = {};
      instructions.forEach((item) => {
        const commonValue = item.vm.value & commonMask;
        if (!groups[commonValue])
          groups[commonValue] = [];
        groups[commonValue].push(item);
      });
      writer.write(`switch ((value & ${sprintf("0x%08X", commonMask)}) >>> 0) {
`);
      writer.indent(() => {
        for (const groupKey in groups) {
          const group = groups[groupKey];
          writer.write(`case ${sprintf("0x%08X", groupKey)}:`);
          writer.indent(() => {
            if (group.length == 1) {
              writer.write(` ${gen(group[0].name)}`);
            } else {
              writer.write("\n");
              this._createSwitch(writer, group, gen, ~commonMask, level + 1);
              writer.write("break;\n");
            }
          });
        }
        writer.write(`default: throw(sprintf("Invalid instruction 0x%08X at 0x%08X (${this.lastId++}) failed mask 0x%08X", value, pc, ${commonMask}));
`);
      });
      writer.write("}\n");
    }
  };

  // src/core/cpu/cpu_codegen.ts
  var ast = new MipsAstBuilder();
  function assignGpr(index, expr) {
    return ast.assignGpr(index, expr);
  }
  function assignFpr(index, expr) {
    return ast.assignFpr(index, expr);
  }
  function assignFpr_I(index, expr) {
    return ast.assignFpr_I(index, expr);
  }
  function assignIC(expr) {
    return ast.assignIC(expr);
  }
  function fcr31_cc() {
    return ast.fcr31_cc();
  }
  function fpr(index) {
    return ast.fpr(index);
  }
  function fpr_i(index) {
    return ast.fpr_i(index);
  }
  function gpr(index) {
    return ast.gpr(index);
  }
  function vfpr(reg) {
    return ast.vfpr(reg);
  }
  function vfprc(reg) {
    return ast.vfprc(reg);
  }
  function vfpr_i(index) {
    return ast.vfpr_i(index);
  }
  function immBool(value) {
    return ast.imm32(value ? 1 : 0);
  }
  function imm32(value) {
    return ast.imm32(value);
  }
  function imm_f(value) {
    return ast.imm_f(value);
  }
  function u_imm32(value) {
    return ast.u_imm32(value);
  }
  function unop(op, right) {
    return ast.unop(op, right);
  }
  function binop(left, op, right) {
    return ast.binop(left, op, right);
  }
  function _if(cond, codeTrue, codeFalse) {
    return ast._if(cond, codeTrue, codeFalse);
  }
  function call(name2, exprList) {
    return ast.call(name2, exprList);
  }
  function call_stm(name2, exprList) {
    return stm(ast.call(name2, exprList));
  }
  function stm(expr) {
    return ast.stm(expr);
  }
  function stms(stms2) {
    return ast.stms(stms2);
  }
  function pc() {
    return ast.pc();
  }
  function lo() {
    return ast.lo();
  }
  function hi() {
    return ast.hi();
  }
  function ic() {
    return ast.ic();
  }
  function branchflag() {
    return ast.branchflag();
  }
  function branchpc() {
    return ast.branchpc();
  }
  function assign(ref, value) {
    return ast.assign(ref, value);
  }
  function assign_stm(ref, value) {
    return stm(ast.assign(ref, value));
  }
  function rs_imm16(i) {
    return binop(binop(gpr(i.rs), "+", imm32(i.imm16)), "|", imm32(0));
  }
  var VectorSize;
  (function(VectorSize2) {
    VectorSize2[VectorSize2["Single"] = 1] = "Single";
    VectorSize2[VectorSize2["Pair"] = 2] = "Pair";
    VectorSize2[VectorSize2["Triple"] = 3] = "Triple";
    VectorSize2[VectorSize2["Quad"] = 4] = "Quad";
  })(VectorSize || (VectorSize = {}));
  var MatrixSize;
  (function(MatrixSize2) {
    MatrixSize2[MatrixSize2["M_2x2"] = 2] = "M_2x2";
    MatrixSize2[MatrixSize2["M_3x3"] = 3] = "M_3x3";
    MatrixSize2[MatrixSize2["M_4x4"] = 4] = "M_4x4";
  })(MatrixSize || (MatrixSize = {}));
  function getVectorRegs(vectorReg, N) {
    const mtx = vectorReg >>> 2 & 7;
    const col = vectorReg & 3;
    let row = 0;
    let length = 0;
    let transpose = vectorReg >>> 5 & 1;
    switch (N) {
      case 1:
        transpose = 0;
        row = vectorReg >>> 5 & 3;
        length = 1;
        break;
      case 2:
        row = vectorReg >>> 5 & 2;
        length = 2;
        break;
      case 3:
        row = vectorReg >>> 6 & 1;
        length = 3;
        break;
      case 4:
        row = vectorReg >>> 5 & 2;
        length = 4;
        break;
      default:
        debugger;
    }
    const regs = new Array(length);
    for (let i = 0; i < length; i++) {
      let index = mtx * 4;
      if (transpose) {
        index += (row + i & 3) + col * 32;
      } else {
        index += col + (row + i & 3) * 32;
      }
      regs[i] = index;
    }
    return regs;
  }
  function getMatrixRegs(matrixReg, N) {
    const mtx = matrixReg >> 2 & 7;
    const col = matrixReg & 3;
    let row = 0;
    let side = 0;
    switch (N) {
      case 2:
        row = matrixReg >> 5 & 2;
        side = 2;
        break;
      case 3:
        row = matrixReg >> 6 & 1;
        side = 3;
        break;
      case 4:
        row = matrixReg >> 5 & 2;
        side = 4;
        break;
      default:
        debugger;
    }
    const transpose = matrixReg >> 5 & 1;
    const regs = new Array(side * side);
    for (let i = 0; i < side; i++) {
      for (let j = 0; j < side; j++) {
        let index = mtx * 4;
        if (transpose) {
          index += (row + i & 3) + (col + j & 3) * 32;
        } else {
          index += (col + j & 3) + (row + i & 3) * 32;
        }
        regs[j * side + i] = index;
      }
    }
    return regs;
  }
  function readVector_f(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map((index) => vfpr(index));
  }
  function readVector_i(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map((index) => vfpr_i(index));
  }
  function readVector_type(vectorReg, N, type) {
    return type == "float" ? readVector_f(vectorReg, N) : readVector_i(vectorReg, N);
  }
  function readMatrix(vectorReg, N) {
    return getMatrixRegs(vectorReg, N).map((index) => vfpr(index));
  }
  function setMemoryVector(offset, items) {
    const out = [];
    for (let n = 0; n < items.length; n++) {
      const item = items[n];
      out.push(ast.raw_stm(`memory.${MemoryFields.swc1}(${offset.toJs()} + ${n * 4}, ${item.toJs()});`));
    }
    return ast.stms(out);
  }
  function memoryRef(type, address) {
    switch (type) {
      case "float":
        return new ANodeExprLValueSetGet(`memory.${MemoryFields.swc1}($0, #)`, `memory.${MemoryFields.lwc1}($0)`, [address]);
      default:
        throw new Error("Not implemented memoryRef type '" + type + "'");
    }
  }
  function getMemoryVector(offset, count) {
    return ArrayUtils.range(0, count).map((item) => memoryRef("float", binop(offset, "+", imm32(item * 4))));
  }
  function setItems(leftList, values) {
    return stms(leftList.map((left, index) => ast.assign(left, values[index])));
  }
  function address_RS_IMM14(i, offset = 0) {
    return binop(gpr(i.rs), "+", imm32(i.IMM14 * 4 + offset));
  }
  function setMatrix(leftList, generator) {
    const side = Math.sqrt(leftList.length);
    return call_stm(`state.${CpuStateFields.vfpuStore}`, [
      ast.array(leftList.map((item) => imm32(item))),
      ast.array(ArrayUtils.range(0, leftList.length).map((index) => generator(Math.floor(index % side), Math.floor(index / side), index)))
    ]);
  }
  function setVector_i(leftList, generator) {
    return call_stm(`state.${CpuStateFields.vfpuStore_i}`, [
      ast.array(leftList.map((item) => imm32(item))),
      ast.array(ArrayUtils.range(0, leftList.length).map((index) => generator(index)))
    ]);
  }
  var VfpuConstants = [
    {name: "VFPU_ZERO", value: 0},
    {name: "VFPU_HUGE", value: 34028234663852886e22},
    {name: "VFPU_SQRT2", value: Math.sqrt(2)},
    {name: "VFPU_SQRT1_2", value: Math.sqrt(1 / 2)},
    {name: "VFPU_2_SQRTPI", value: 2 / Math.sqrt(Math.PI)},
    {name: "VFPU_2_PI", value: 2 / Math.PI},
    {name: "VFPU_1_PI", value: 1 / Math.PI},
    {name: "VFPU_PI_4", value: Math.PI / 4},
    {name: "VFPU_PI_2", value: Math.PI / 2},
    {name: "VFPU_PI", value: Math.PI},
    {name: "VFPU_E", value: Math.E},
    {name: "VFPU_LOG2E", value: Math.log2(Math.E)},
    {name: "VFPU_LOG10E", value: Math.log10(Math.E)},
    {name: "VFPU_LN2", value: Math.log(2)},
    {name: "VFPU_LN10", value: Math.log(10)},
    {name: "VFPU_2PI", value: 2 * Math.PI},
    {name: "VFPU_PI_6", value: Math.PI / 6},
    {name: "VFPU_LOG10TWO", value: Math.log10(2)},
    {name: "VFPU_LOG2TEN", value: Math.log2(10)},
    {name: "VFPU_SQRT3_2", value: Math.sqrt(3) / 2}
  ];
  function getMatrixRegsVD(i) {
    return getMatrixRegs(i.VD, i.ONE_TWO);
  }
  var VfpuPrefixes = class {
    static transformRead(n, info, values) {
      const sourceIndex = info >> 0 + n * 2 & 3;
      const sourceAbsolute = info >> 8 + n * 1 & 1;
      const sourceConstant = info >> 12 + n * 1 & 1;
      const sourceNegate = info >> 16 + n * 1 & 1;
      let value;
      if (sourceConstant) {
        switch (sourceIndex) {
          case 0:
            value = imm_f(sourceAbsolute ? 3 : 0);
            break;
          case 1:
            value = imm_f(sourceAbsolute ? 1 / 3 : 1);
            break;
          case 2:
            value = imm_f(sourceAbsolute ? 1 / 4 : 2);
            break;
          case 3:
            value = imm_f(sourceAbsolute ? 1 / 6 : 1 / 2);
            break;
          default:
            throw new Error("Invalid operation");
        }
      } else {
        value = values[sourceIndex];
        if (sourceAbsolute)
          value = call("Math.abs", [value]);
      }
      if (sourceNegate)
        value = call("MathFloat.neg", [value]);
      return value;
    }
    static transformStore(n, info, left, value) {
      const destinationSaturation = info >> 0 + n * 2 & 3;
      const destinationMask = info >> 8 + n * 1 & 1;
      if (destinationMask) {
        return ast.stm();
      } else {
        let v = value;
        switch (destinationSaturation) {
          case 1:
            v = call("MathFloat.sat0", [v]);
            break;
          case 3:
            v = call("MathFloat.sat1", [v]);
            break;
          default:
            break;
        }
        return assign_stm(left, v);
      }
    }
  };
  var PrefixPrediction = class {
    constructor(default_value) {
      this.default_value = default_value;
      this.known = true;
      this.value = this.default_value;
    }
    reset() {
      this.set(this.default_value);
    }
    eat() {
      this.set(this.default_value);
    }
    set(value) {
      this.known = true;
      this.value = value;
    }
    setUnknown() {
      this.known = false;
      this.value = this.default_value;
    }
  };
  PrefixPrediction.DEFAULT_LOAD_VALUE = 3690987748;
  PrefixPrediction.DEFAULT_STORE_VALUE = 0;
  var BranchFlagStm = class extends ANodeStm {
    constructor(cond, pc2) {
      super();
      this.cond = cond;
      this.pc = pc2;
    }
    toJs() {
      return `BRANCHFLAG = ${this.cond.toJs()};`;
    }
  };
  var InstructionAst = class {
    constructor() {
      this._vpfxs = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
      this._vpfxt = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
      this._vpfxd = new PrefixPrediction(PrefixPrediction.DEFAULT_STORE_VALUE);
      this.enableStaticPrefixVfpuOptimization = true;
    }
    reset() {
      this._vpfxs.reset();
      this._vpfxt.reset();
      this._vpfxd.reset();
    }
    eatPrefixes() {
      this._vpfxs.eat();
      this._vpfxt.eat();
      this._vpfxd.eat();
    }
    lui(i) {
      return assignGpr(i.rt, u_imm32(i.imm16 << 16));
    }
    _vset1(i, generate, destSize = 0, destType = "float") {
      const st = [];
      this._vset_storeVD(st, i, destType, destSize, (index) => generate(index));
      return stms(st);
    }
    _vset2(i, generate, destSize = 0, srcSize = 0, destType = "float", srcType = "float") {
      const st = [];
      const src = this._vset_readVS(st, i, srcType, srcSize);
      this._vset_storeVD(st, i, destType, destSize, (index) => generate(index, src));
      return stms(st);
    }
    _vset3(i, generate, destSize = 0, srcSize = 0, targetSize = 0, destType = "float", srcType = "float", targetType = "float") {
      const st = [];
      const src = this._vset_readVS(st, i, srcType, srcSize);
      const target = this._vset_readVT(st, i, targetType, targetSize);
      this._vset_storeVD(st, i, destType, destSize, (index) => generate(index, src, target));
      return stms(st);
    }
    _vset_readVS(st, i, type, size) {
      return this._vset_readVSVT(st, i, type, size, "vs");
    }
    _vset_readVT(st, i, type, size) {
      return this._vset_readVSVT(st, i, type, size, "vt");
    }
    _vset_readVSVT(st, i, type, size, name2) {
      if (size <= 0)
        size = i.ONE_TWO;
      const regs = readVector_type(name2 == "vs" ? i.VS : i.VT, size, type);
      const prefix = name2 == "vs" ? this._vpfxs : this._vpfxt;
      if (this.enableStaticPrefixVfpuOptimization && prefix.known) {
        const out = [];
        for (let n = 0; n < size; n++) {
          const vname = (name2 == "vs" ? "s" : "t") + n;
          out.push(ast.raw(vname));
          st.push(ast.allocVar(vname, VfpuPrefixes.transformRead(n, prefix.value, regs)));
        }
        return out;
      } else {
        st.push(call_stm(name2 == "vs" ? `state.${CpuStateFields.loadVs_prefixed}` : `state.${CpuStateFields.loadVt_prefixed}`, [ast.array(regs)]));
      }
      return xrange(0, size).map((index) => name2 == "vs" ? ast.vector_vs(index) : ast.vector_vt(index));
    }
    _vset_storeVD(st, i, type, size, generate) {
      if (size <= 0)
        size = i.ONE_TWO;
      const dest_regs = getVectorRegs(i.VD, size);
      if (this.enableStaticPrefixVfpuOptimization && this._vpfxd.known) {
        for (let n = 0; n < size; n++) {
          const dest_reg = dest_regs[n];
          st.push(VfpuPrefixes.transformStore(n, this._vpfxd.value, type == "float" ? vfpr(dest_reg) : vfpr_i(dest_reg), generate(n)));
        }
      } else {
        st.push(call_stm(type == "float" ? `state.${CpuStateFields.storeVd_prefixed}` : `state.${CpuStateFields.storeVd_prefixed_i}`, [
          ast.arrayNumbers(dest_regs),
          ast.array(xrange(0, size).map((n) => generate(n)))
        ]));
      }
      st.push(call_stm(`state.${CpuStateFields.eatPrefixes}`, []));
      this.eatPrefixes();
    }
    vpfxs(i) {
      this._vpfxs.set(i.IDATA);
      return stms([
        call_stm(`state.${CpuStateFields.setVpfxs}`, [imm32(i.IDATA)])
      ]);
    }
    vpfxt(i) {
      this._vpfxt.set(i.IDATA);
      return stms([
        call_stm(`state.${CpuStateFields.setVpfxt}`, [imm32(i.IDATA)])
      ]);
    }
    vpfxd(i) {
      this._vpfxd.set(i.IDATA);
      return stms([
        call_stm(`state.${CpuStateFields.setVpfxd}`, [imm32(i.IDATA)])
      ]);
    }
    "lv.s"(i) {
      return assign_stm(vfpr(i.VT5_2), call(`memory.${MemoryFields.lwc1}`, [address_RS_IMM14(i, 0)]));
    }
    "sv.s"(i) {
      return call_stm(`memory.${MemoryFields.swc1}`, [address_RS_IMM14(i, 0), vfpr(i.VT5_2)]);
    }
    "lv.q"(i) {
      return setItems(readVector_f(i.VT5_1, 4), getMemoryVector(address_RS_IMM14(i), 4));
    }
    "lvl.q"(i) {
      return call_stm(`state.${CpuStateFields.lvl_q}`, [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, 4).map((item) => imm32(item)))]);
    }
    "lvr.q"(i) {
      return call_stm(`state.${CpuStateFields.lvr_q}`, [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, 4).map((item) => imm32(item)))]);
    }
    "sv.q"(i) {
      return setMemoryVector(address_RS_IMM14(i), readVector_f(i.VT5_1, 4));
    }
    "svl.q"(i) {
      return call_stm(`state.${CpuStateFields.svl_q}`, [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, 4).map((item) => imm32(item)))]);
    }
    "svr.q"(i) {
      return call_stm(`state.${CpuStateFields.svr_q}`, [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, 4).map((item) => imm32(item)))]);
    }
    viim(i) {
      return assign_stm(vfpr(i.VT), imm32(i.imm16));
    }
    vfim(i) {
      return assign_stm(vfpr(i.VT), imm_f(i.IMM_HF));
    }
    vcst(i) {
      return assign_stm(vfpr(i.VD), imm_f(VfpuConstants[i.IMM5].value));
    }
    vhdp(i) {
      const vectorSize = i.ONE_TWO;
      return this._vset3(i, (_, src, target) => {
        return this._aggregateV(imm_f(0), vectorSize, (aggregate, index) => {
          return binop(aggregate, "+", binop(target[index], "*", index == vectorSize - 1 ? imm_f(1) : src[index]));
        });
      }, 1, vectorSize, vectorSize);
    }
    vmidt(i) {
      return setMatrix(getMatrixRegsVD(i), (c, r) => imm32(c == r ? 1 : 0));
    }
    vmzero(i) {
      return setMatrix(getMatrixRegsVD(i), (c, r) => imm32(0));
    }
    vmone(i) {
      return setMatrix(getMatrixRegsVD(i), (c, r) => imm32(1));
    }
    _vtfm_x(i, vectorSize) {
      const srcMat = readMatrix(i.VS, vectorSize);
      const st = [];
      st.push(call_stm(`state.${CpuStateFields.loadVt_prefixed}`, [ast.array(readVector_f(i.VT, vectorSize))]));
      st.push(call_stm(`state.${CpuStateFields.storeVd_prefixed}`, [
        ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
        ast.array(xrange(0, vectorSize).map((n) => {
          return this._aggregateV(imm_f(0), vectorSize, (aggregated, m) => binop(aggregated, "+", binop(srcMat[n * vectorSize + m], "*", ast.vector_vt(m))));
        }))
      ]));
      this.eatPrefixes();
      return stms(st);
    }
    _vhtfm_x(i, vectorSize) {
      const srcMat = readMatrix(i.VS, vectorSize);
      const st = [];
      st.push(call_stm(`state.${CpuStateFields.loadVt_prefixed}`, [ast.array(readVector_f(i.VT, vectorSize))]));
      st.push(call_stm(`state.${CpuStateFields.storeVd_prefixed}`, [
        ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
        ast.array(xrange(0, vectorSize).map((n) => {
          return this._aggregateV(imm_f(0), vectorSize, (aggregated, m) => binop(aggregated, "+", binop(srcMat[n * vectorSize + m], "*", m == vectorSize - 1 ? imm_f(1) : ast.vector_vt(m))));
        }))
      ]));
      this.eatPrefixes();
      return stms(st);
    }
    vtfm2(i) {
      return this._vtfm_x(i, 2);
    }
    vtfm3(i) {
      return this._vtfm_x(i, 3);
    }
    vtfm4(i) {
      return this._vtfm_x(i, 4);
    }
    vhtfm2(i) {
      return this._vhtfm_x(i, 2);
    }
    vhtfm3(i) {
      return this._vhtfm_x(i, 3);
    }
    vhtfm4(i) {
      return this._vhtfm_x(i, 4);
    }
    vmscl(i) {
      const vectorSize = i.ONE_TWO;
      const src = readMatrix(i.VS, vectorSize);
      return setMatrix(getMatrixRegsVD(i), (c, r, index) => binop(src[index], "*", vfpr(i.VT)));
    }
    vzero(i) {
      return this._vset1(i, (i2) => imm_f(0));
    }
    vone(i) {
      return this._vset1(i, (i2) => imm_f(1));
    }
    vmov(i) {
      return this._vset3(i, (i2, s, t) => s[i2]);
    }
    vrcp(i) {
      return this._vset2(i, (i2, s) => binop(imm_f(1), "/", s[i2]));
    }
    vmul(i) {
      return this._vset3(i, (i2, s, t) => binop(s[i2], "*", t[i2]));
    }
    vbfy1(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return binop(src[0], "+", src[1]);
          case 1:
            return binop(src[0], "-", src[1]);
          case 2:
            return binop(src[2], "+", src[3]);
          case 3:
            return binop(src[2], "-", src[3]);
          default:
            throw new Error("vbfy1: Invalid operation");
        }
      });
    }
    vbfy2(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return binop(src[0], "+", src[2]);
          case 1:
            return binop(src[1], "+", src[3]);
          case 2:
            return binop(src[0], "-", src[2]);
          case 3:
            return binop(src[1], "-", src[3]);
          default:
            throw new Error("vbfy1: Invalid operation");
        }
      });
    }
    vsocp(i) {
      const vectorSize = i.ONE_TWO;
      return this._vset2(i, (index, src) => {
        switch (index) {
          case 0:
            return ast.call("MathFloat.sat0", [binop(imm_f(1), "-", src[0])]);
          case 1:
            return ast.call("MathFloat.sat0", [src[0]]);
          case 2:
            return ast.call("MathFloat.sat0", [binop(imm_f(1), "-", src[1])]);
          case 3:
            return ast.call("MathFloat.sat0", [src[1]]);
          default:
            throw new Error("vsocp: " + index);
        }
      }, vectorSize * 2, vectorSize);
    }
    vsrt1(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return call("MathFloat.min", [src[0], src[1]]);
          case 1:
            return call("MathFloat.max", [src[0], src[1]]);
          case 2:
            return call("MathFloat.min", [src[2], src[3]]);
          case 3:
            return call("MathFloat.max", [src[2], src[3]]);
          default:
            throw new Error("vsrt1: Invalid operation");
        }
      }, i.ONE_TWO, 4);
    }
    vsrt2(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return call("MathFloat.min", [src[0], src[3]]);
          case 1:
            return call("MathFloat.min", [src[1], src[2]]);
          case 2:
            return call("MathFloat.max", [src[1], src[2]]);
          case 3:
            return call("MathFloat.max", [src[0], src[3]]);
          default:
            throw new Error("vsrt2: Invalid operation");
        }
      }, i.ONE_TWO, 4);
    }
    vsrt3(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return call("MathFloat.max", [src[0], src[1]]);
          case 1:
            return call("MathFloat.min", [src[0], src[1]]);
          case 2:
            return call("MathFloat.max", [src[2], src[3]]);
          case 3:
            return call("MathFloat.min", [src[2], src[3]]);
          default:
            throw new Error("vsrt3: Invalid operation");
        }
      }, i.ONE_TWO, 4);
    }
    vsrt4(i) {
      return this._vset2(i, (i2, src) => {
        switch (i2) {
          case 0:
            return call("MathFloat.max", [src[0], src[3]]);
          case 1:
            return call("MathFloat.max", [src[1], src[2]]);
          case 2:
            return call("MathFloat.min", [src[1], src[2]]);
          case 3:
            return call("MathFloat.min", [src[0], src[3]]);
          default:
            throw new Error("vsrt4: Invalid operation");
        }
      }, i.ONE_TWO, 4);
    }
    vrnds(i) {
      return call_stm(`state.${CpuStateFields.vrnds}`, []);
    }
    vrndi(i) {
      return this._vset1(i, (i2) => call(`state.${CpuStateFields.vrndi}`, []), void 0, "int");
    }
    vrndf1(i) {
      return this._vset1(i, (i2) => call(`state.${CpuStateFields.vrndf1}`, []));
    }
    vrndf2(i) {
      return this._vset1(i, (i2) => call(`state.${CpuStateFields.vrndf2}`, []));
    }
    _aggregateV(val, size, generator) {
      for (let n = 0; n < size; n++)
        val = generator(val, n);
      return val;
    }
    vnop(i) {
      return ast.stm();
    }
    vsync(i) {
      return ast.stm();
    }
    vflush(i) {
      return ast.stm();
    }
    vfad(i) {
      const vectorSize = i.ONE_TWO;
      return this._vset2(i, (i2, src) => {
        return this._aggregateV(imm_f(0), vectorSize, (value, index) => binop(value, "+", src[index]));
      }, 1, vectorSize);
    }
    vavg(i) {
      const vectorSize = i.ONE_TWO;
      return this._vset2(i, (i2, src) => {
        return binop(this._aggregateV(imm_f(0), vectorSize, (value, index) => binop(value, "+", src[index])), "/", imm_f(vectorSize));
      }, 1, vectorSize);
    }
    vidt(i) {
      return this._vset1(i, (index) => imm_f(index == i.IMM7 % i.ONE_TWO ? 1 : 0));
    }
    "vcrs.t"(i) {
      return this._vset3(i, (index, src, target) => {
        switch (index) {
          case 0:
            return binop(src[1], "*", target[2]);
          case 1:
            return binop(src[2], "*", target[0]);
          case 2:
            return binop(src[0], "*", target[1]);
          default:
            throw new Error("vcrs_t not implemented");
        }
      }, 3, 3, 3);
    }
    "vcrsp.t"(i) {
      return this._vset3(i, (index, src, target) => {
        switch (index) {
          case 0:
            return binop(binop(src[1], "*", target[2]), "-", binop(src[2], "*", target[1]));
          case 1:
            return binop(binop(src[2], "*", target[0]), "-", binop(src[0], "*", target[2]));
          case 2:
            return binop(binop(src[0], "*", target[1]), "-", binop(src[1], "*", target[0]));
          default:
            throw new Error("vcrs_t assert");
        }
      }, 3, 3, 3);
    }
    vc2i(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vc2i}`, [imm32(index), src[0]]), 0, 1, "int", "int");
    }
    vuc2i(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vuc2i}`, [imm32(index), src[0]]), 0, 1, "int", "int");
    }
    vs2i(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vs2i}`, [imm32(index), src[Math.floor(index / 2)]]), i.ONE_TWO * 2, i.ONE_TWO, "int", "int");
    }
    vi2f(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vi2f}`, [src[index], imm32(-i.IMM5)]), 0, 0, "float", "int");
    }
    vi2uc(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vi2uc}`, [src[0], src[1], src[2], src[3]]), 1, 4, "int", "int");
    }
    vf2id(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vf2id}`, [src[index], imm32(i.IMM5)]), 0, 0, "int", "float");
    }
    vf2in(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vf2in}`, [src[index], imm32(i.IMM5)]), 0, 0, "int", "float");
    }
    vf2iu(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vf2iu}`, [src[index], imm32(i.IMM5)]), 0, 0, "int", "float");
    }
    vf2iz(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vf2iz}`, [src[index], imm32(i.IMM5)]), 0, 0, "int", "float");
    }
    vf2h(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vf2h}`, [imm32(index), src[index]]), 0, 0, "float", "float");
    }
    vh2f(i) {
      return this._vset2(i, (index, src) => call(`state.${CpuStateFields.vh2f}`, [imm32(index), src[index]]), 0, 0, "float", "float");
    }
    vdet(i) {
      return this._vset3(i, (i2, s, t) => {
        return binop(binop(s[0], "*", t[1]), "-", binop(s[1], "*", t[0]));
      }, 1, 2, 2);
    }
    vqmul(i) {
      return this._vset3(i, (i2, s, t) => {
        switch (i2) {
          case 0:
            return call(`state.${CpuStateFields.vqmul0}`, [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
          case 1:
            return call(`state.${CpuStateFields.vqmul1}`, [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
          case 2:
            return call(`state.${CpuStateFields.vqmul2}`, [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
          case 3:
            return call(`state.${CpuStateFields.vqmul3}`, [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
          default:
            throw new Error(`Unexpected ${i2}`);
        }
      }, 4, 4, 4);
    }
    vslt(i) {
      return this._vset3(i, (i2, s, t) => call(`MathFloat.vslt`, [s[i2], t[i2]]));
    }
    vsle(i) {
      return this._vset3(i, (i2, s, t) => call(`MathFloat.vsle`, [s[i2], t[i2]]));
    }
    vsge(i) {
      return this._vset3(i, (i2, s, t) => call(`MathFloat.vsge`, [s[i2], t[i2]]));
    }
    vsgt(i) {
      return this._vset3(i, (i2, s, t) => call(`MathFloat.vsgt`, [s[i2], t[i2]]));
    }
    vscmp(i) {
      return this._vset3(i, (i2, s, t) => call(`MathFloat.sign2`, [s[i2], t[i2]]));
    }
    _bvtf(i, cond) {
      const reg = i.IMM3;
      let branchExpr = ast.VCC(reg);
      if (!cond)
        branchExpr = unop("!", branchExpr);
      return this._branch(i, branchExpr);
    }
    bvf(i) {
      return this._bvtf(i, false);
    }
    bvt(i) {
      return this._bvtf(i, true);
    }
    bvfl(i) {
      return this.bvf(i);
    }
    bvtl(i) {
      return this.bvt(i);
    }
    mtv(i) {
      return this._vset1(i, (_) => gpr(i.rt), 1, "int");
    }
    mfv(i) {
      return assign_stm(gpr(i.rt), vfpr_i(i.VD));
    }
    mtvc(i) {
      switch (i.IMM7) {
        case 0:
          this._vpfxs.setUnknown();
          break;
        case 1:
          this._vpfxt.setUnknown();
          break;
        case 2:
          this._vpfxd.setUnknown();
          break;
      }
      return assign_stm(vfprc(i.IMM7), gpr(i.rt));
    }
    mfvc(i) {
      return assign_stm(gpr(i.rt), vfprc(i.IMM7));
    }
    _vcmovtf(i, True) {
      const result = call_stm(`state.${CpuStateFields.vcmovtf}`, [
        imm32(i.IMM3),
        immBool(True),
        ast.arrayNumbers(getVectorRegs(i.VD, i.ONE_TWO)),
        ast.arrayNumbers(getVectorRegs(i.VS, i.ONE_TWO))
      ]);
      this.eatPrefixes();
      return result;
    }
    vcmovt(i) {
      return this._vcmovtf(i, true);
    }
    vcmovf(i) {
      return this._vcmovtf(i, false);
    }
    vcmp(ins) {
      const out = [];
      const vectorSize = ins.ONE_TWO;
      this._vset_readVS(out, ins, "float", vectorSize);
      this._vset_readVT(out, ins, "float", vectorSize);
      const conds = [];
      for (let i = 0; i < vectorSize; i++) {
        const c = false;
        let cond = "";
        switch (ins.IMM4) {
          case VCondition.FL:
            cond = `false`;
            break;
          case VCondition.EQ:
            cond = `s${i} == t${i}`;
            break;
          case VCondition.LT:
            cond = `s${i} < t${i}`;
            break;
          case VCondition.LE:
            cond = `s${i} <= t${i}`;
            break;
          case VCondition.TR:
            cond = `true`;
            break;
          case VCondition.NE:
            cond = `s${i} != t${i}`;
            break;
          case VCondition.GE:
            cond = `s${i} >= t${i}`;
            break;
          case VCondition.GT:
            cond = `s${i} > t${i}`;
            break;
          case VCondition.EZ:
            cond = `(s${i} == 0.0) || (s${i} == -0.0)`;
            break;
          case VCondition.EN:
            cond = `MathFloat.isnan(s${i})`;
            break;
          case VCondition.EI:
            cond = `MathFloat.isinf(s${i})`;
            break;
          case VCondition.ES:
            cond = `MathFloat.isnanorinf(s${i})`;
            break;
          case VCondition.NZ:
            cond = `s${i} != 0;`;
            break;
          case VCondition.NN:
            cond = `!MathFloat.isnan(s${i})`;
            break;
          case VCondition.NI:
            cond = `!MathFloat.isinf(s${i})`;
            break;
          case VCondition.NS:
            cond = `!(MathFloat.isnanorinf(s${i}))`;
            break;
        }
        conds.push(`((${cond}) << ${i})`);
      }
      let mask = (1 << vectorSize) - 1;
      let inv_affected_bits = ~(mask | 1 << 4 | 1 << 5);
      out.push(ast.raw_stm(`
		{
		    let cc = ${conds.join(" | ")};
		    cc |= ((cc & ${mask}) != 0) << 4;
		    cc |= ((cc & ${mask}) == ${mask}) << 5;
		    state.vfprc[${VFPU_CTRL.CC}] = (state.vfprc[${VFPU_CTRL.CC}] & ${inv_affected_bits}) | cc;
        }
        `));
      this.eatPrefixes();
      return ast.stms(out);
    }
    vwbn(i) {
      return ast.stm();
    }
    vsbn(i) {
      return ast.stm();
    }
    vabs(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.abs", [src[i2]]));
    }
    vocp(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.ocp", [src[i2]]));
    }
    vneg(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.neg", [src[i2]]));
    }
    vsgn(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.sign", [src[i2]]));
    }
    vsat0(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.sat0", [src[i2]]));
    }
    vsat1(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.sat1", [src[i2]]));
    }
    vrsq(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.rsq", [src[i2]]));
    }
    vsin(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.sinv1", [src[i2]]));
    }
    vcos(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.cosv1", [src[i2]]));
    }
    vexp2(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.exp2", [src[i2]]));
    }
    vrexp2(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.rexp2", [src[i2]]));
    }
    vlog2(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.log2", [src[i2]]));
    }
    vsqrt(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.sqrt", [src[i2]]));
    }
    vasin(i) {
      return stms([
        this._vset2(i, (i2, src) => call("MathFloat.asinv1", [src[i2]]))
      ]);
    }
    vnsin(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.nsinv1", [src[i2]]));
    }
    vnrcp(i) {
      return this._vset2(i, (i2, src) => call("MathFloat.nrcp", [src[i2]]));
    }
    vmin(i) {
      return this._vset3(i, (i2, src, target) => call("MathFloat.min", [src[i2], target[i2]]));
    }
    vmax(i) {
      return this._vset3(i, (i2, src, target) => call("MathFloat.max", [src[i2], target[i2]]));
    }
    vdiv(i) {
      return this._vset3(i, (i2, src, target) => binop(src[i2], "/", target[i2]));
    }
    vadd(i) {
      return this._vset3(i, (i2, src, target) => binop(src[i2], "+", target[i2]));
    }
    vsub(i) {
      return this._vset3(i, (i2, src, target) => binop(src[i2], "-", target[i2]));
    }
    vscl(i) {
      return this._vset3(i, (i2, src, target) => binop(src[i2], "*", target[0]), 0, 0, 1);
    }
    vdot(i) {
      const vectorSize = i.ONE_TWO;
      return this._vset3(i, (i2, s, t) => {
        return this._aggregateV(imm_f(0), vectorSize, (sum, n) => binop(sum, "+", binop(s[n], "*", t[n])));
      }, 1, vectorSize, vectorSize);
    }
    vrot(i) {
      const vectorSize = i.ONE_TWO;
      const imm5 = i.IMM5;
      const cosIndex = BitUtils.extract(imm5, 0, 2);
      const sinIndex = BitUtils.extract(imm5, 2, 2);
      const negateSin = BitUtils.extractBool(imm5, 4);
      const dest = getVectorRegs(i.VD, i.ONE_TWO);
      return this._vset2(i, (i2, s) => {
        let sine = call("MathFloat.sinv1", [s[0]]);
        const cosine = call("MathFloat.cosv1", [s[0]]);
        if (negateSin)
          sine = unop("-", sine);
        if (i2 == cosIndex)
          return cosine;
        if (i2 == sinIndex)
          return sine;
        return sinIndex == cosIndex ? sine : imm32(0);
      }, vectorSize, 1);
    }
    vmmov(i) {
      const vectorSize = i.ONE_TWO;
      const dest = getMatrixRegs(i.VD, vectorSize);
      const src = readMatrix(i.VS, vectorSize);
      const result = setMatrix(dest, (column, row, index) => src[index]);
      this.eatPrefixes();
      return result;
    }
    vmmul(i) {
      const VectorSize2 = i.ONE_TWO;
      const dest = getMatrixRegs(i.VD, VectorSize2);
      const src = readMatrix(i.VS, VectorSize2);
      const target = readMatrix(i.VT, VectorSize2);
      const st = [];
      st.push(setMatrix(dest, (Column, Row, Index) => {
        let sum = imm_f(0);
        for (let n = 0; n < VectorSize2; n++) {
          sum = binop(sum, "+", binop(src[Column * VectorSize2 + n], "*", target[Row * VectorSize2 + n]));
        }
        return sum;
      }));
      st.push(call_stm(`state.${CpuStateFields.eatPrefixes}`, []));
      this.eatPrefixes();
      return stms(st);
    }
    "vt4444.q"(i) {
      return this._vtXXX_q(i, `${CpuStateFields._vt4444_step}`);
    }
    "vt5551.q"(i) {
      return this._vtXXX_q(i, `${CpuStateFields._vt5551_step}`);
    }
    "vt5650.q"(i) {
      return this._vtXXX_q(i, `${CpuStateFields._vt5650_step}`);
    }
    _vtXXX_q(i, func) {
      const size = i.ONE_TWO;
      if (size != 4)
        throw new Error("Not implemented _vtXXXX_q for VectorSize=" + size);
      const dest = getVectorRegs(i.VD, 2);
      const src = readVector_i(i.VS, 4);
      const result = setVector_i(dest, (index) => ast.call(`state.${func}`, [src[index * 2 + 0], src[index * 2 + 1]]));
      this.eatPrefixes();
      return result;
    }
    add(i) {
      return this.addu(i);
    }
    addu(i) {
      return assignGpr(i.rd, binop(gpr(i.rs), "+", gpr(i.rt)));
    }
    addi(i) {
      return this.addiu(i);
    }
    addiu(i) {
      return assignGpr(i.rt, binop(gpr(i.rs), "+", imm32(i.imm16)));
    }
    sub(i) {
      return this.subu(i);
    }
    subu(i) {
      return assignGpr(i.rd, binop(gpr(i.rs), "-", gpr(i.rt)));
    }
    sll(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), "<<", imm32(i.pos)));
    }
    sra(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), ">>", imm32(i.pos)));
    }
    srl(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), ">>>", imm32(i.pos)));
    }
    rotr(i) {
      return assignGpr(i.rd, call("BitUtils.rotr", [gpr(i.rt), imm32(i.pos)]));
    }
    sllv(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), "<<", binop(gpr(i.rs), "&", imm32(31))));
    }
    srav(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), ">>", binop(gpr(i.rs), "&", imm32(31))));
    }
    srlv(i) {
      return assignGpr(i.rd, binop(gpr(i.rt), ">>>", binop(gpr(i.rs), "&", imm32(31))));
    }
    rotrv(i) {
      return assignGpr(i.rd, call("BitUtils.rotr", [gpr(i.rt), gpr(i.rs)]));
    }
    bitrev(i) {
      return assignGpr(i.rd, call("BitUtils.bitrev32", [gpr(i.rt)]));
    }
    and(i) {
      return assignGpr(i.rd, binop(gpr(i.rs), "&", gpr(i.rt)));
    }
    or(i) {
      return assignGpr(i.rd, binop(gpr(i.rs), "|", gpr(i.rt)));
    }
    xor(i) {
      return assignGpr(i.rd, binop(gpr(i.rs), "^", gpr(i.rt)));
    }
    nor(i) {
      return assignGpr(i.rd, unop("~", binop(gpr(i.rs), "|", gpr(i.rt))));
    }
    andi(i) {
      return assignGpr(i.rt, binop(gpr(i.rs), "&", u_imm32(i.u_imm16)));
    }
    ori(i) {
      return assignGpr(i.rt, binop(gpr(i.rs), "|", u_imm32(i.u_imm16)));
    }
    xori(i) {
      return assignGpr(i.rt, binop(gpr(i.rs), "^", u_imm32(i.u_imm16)));
    }
    mflo(i) {
      return assignGpr(i.rd, lo());
    }
    mfhi(i) {
      return assignGpr(i.rd, hi());
    }
    mfic(i) {
      return assignGpr(i.rt, ic());
    }
    mtlo(i) {
      return assign(lo(), gpr(i.rs));
    }
    mthi(i) {
      return assign(hi(), gpr(i.rs));
    }
    mtic(i) {
      return assignIC(gpr(i.rt));
    }
    slt(i) {
      return assignGpr(i.rd, call(`state.${CpuStateFields.slt}`, [gpr(i.rs), gpr(i.rt)]));
    }
    sltu(i) {
      return assignGpr(i.rd, call(`state.${CpuStateFields.sltu}`, [gpr(i.rs), gpr(i.rt)]));
    }
    slti(i) {
      return assignGpr(i.rt, call(`state.${CpuStateFields.slt}`, [gpr(i.rs), imm32(i.imm16)]));
    }
    sltiu(i) {
      return assignGpr(i.rt, call(`state.${CpuStateFields.sltu}`, [gpr(i.rs), u_imm32(i.imm16)]));
    }
    movz(i) {
      return _if(binop(gpr(i.rt), "==", imm32(0)), assignGpr(i.rd, gpr(i.rs)));
    }
    movn(i) {
      return _if(binop(gpr(i.rt), "!=", imm32(0)), assignGpr(i.rd, gpr(i.rs)));
    }
    ext(i) {
      return assignGpr(i.rt, call("BitUtils.extract", [gpr(i.rs), imm32(i.pos), imm32(i.size_e)]));
    }
    ins(i) {
      return assignGpr(i.rt, call("BitUtils.insert", [gpr(i.rt), imm32(i.pos), imm32(i.size_i), gpr(i.rs)]));
    }
    clz(i) {
      return assignGpr(i.rd, call("BitUtils.clz", [gpr(i.rs)]));
    }
    clo(i) {
      return assignGpr(i.rd, call("BitUtils.clo", [gpr(i.rs)]));
    }
    seb(i) {
      return assignGpr(i.rd, call("BitUtils.seb", [gpr(i.rt)]));
    }
    seh(i) {
      return assignGpr(i.rd, call("BitUtils.seh", [gpr(i.rt)]));
    }
    wsbh(i) {
      return assignGpr(i.rd, call("BitUtils.wsbh", [gpr(i.rt)]));
    }
    wsbw(i) {
      return assignGpr(i.rd, call("BitUtils.wsbw", [gpr(i.rt)]));
    }
    _trace_state() {
      return stm(ast.call(`state.${CpuStateFields._trace_state}`, []));
    }
    "mov.s"(i) {
      return assignFpr(i.fd, fpr(i.fs));
    }
    "add.s"(i) {
      return assignFpr(i.fd, binop(fpr(i.fs), "+", fpr(i.ft)));
    }
    "sub.s"(i) {
      return assignFpr(i.fd, binop(fpr(i.fs), "-", fpr(i.ft)));
    }
    "mul.s"(i) {
      return assignFpr(i.fd, binop(fpr(i.fs), "*", fpr(i.ft)));
    }
    "div.s"(i) {
      return assignFpr(i.fd, binop(fpr(i.fs), "/", fpr(i.ft)));
    }
    "abs.s"(i) {
      return assignFpr(i.fd, call("Math.abs", [fpr(i.fs)]));
    }
    "sqrt.s"(i) {
      return assignFpr(i.fd, call("Math.sqrt", [fpr(i.fs)]));
    }
    "neg.s"(i) {
      return assignFpr(i.fd, unop("-", fpr(i.fs)));
    }
    min(i) {
      return assignGpr(i.rd, call(`state.${CpuStateFields.min}`, [gpr(i.rs), gpr(i.rt)]));
    }
    max(i) {
      return assignGpr(i.rd, call(`state.${CpuStateFields.max}`, [gpr(i.rs), gpr(i.rt)]));
    }
    div(i) {
      return stm(call(`state.${CpuStateFields.div}`, [gpr(i.rs), gpr(i.rt)]));
    }
    divu(i) {
      return stm(call(`state.${CpuStateFields.divu}`, [gpr(i.rs), gpr(i.rt)]));
    }
    mult(i) {
      return stm(call(`state.${CpuStateFields.mult}`, [gpr(i.rs), gpr(i.rt)]));
    }
    multu(i) {
      return stm(call(`state.${CpuStateFields.multu}`, [gpr(i.rs), gpr(i.rt)]));
    }
    madd(i) {
      return stm(call(`state.${CpuStateFields.madd}`, [gpr(i.rs), gpr(i.rt)]));
    }
    maddu(i) {
      return stm(call(`state.${CpuStateFields.maddu}`, [gpr(i.rs), gpr(i.rt)]));
    }
    msub(i) {
      return stm(call(`state.${CpuStateFields.msub}`, [gpr(i.rs), gpr(i.rt)]));
    }
    msubu(i) {
      return stm(call(`state.${CpuStateFields.msubu}`, [gpr(i.rs), gpr(i.rt)]));
    }
    cache(i) {
      return stm(call(`state.${CpuStateFields.cache}`, [gpr(i.rs), imm32(i.rt), imm32(i.imm16)]));
    }
    syscall(i) {
      return stm(call(`state.${CpuStateFields.syscall}`, [imm32(i.vsyscall)]));
    }
    break(i) {
      return stm(call(`state.${CpuStateFields.break}`, []));
    }
    dbreak(i) {
      return ast.debugger("dbreak");
    }
    _storePC(_pc) {
      return assign(pc(), u_imm32(_pc));
    }
    _branch(i, cond) {
      return new BranchFlagStm(cond, i.PC + i.imm16 * 4 + 4);
    }
    beq(i) {
      return this._branch(i, binop(gpr(i.rs), "==", gpr(i.rt)));
    }
    bne(i) {
      return this._branch(i, binop(gpr(i.rs), "!=", gpr(i.rt)));
    }
    bltz(i) {
      return this._branch(i, binop(gpr(i.rs), "<", imm32(0)));
    }
    blez(i) {
      return this._branch(i, binop(gpr(i.rs), "<=", imm32(0)));
    }
    bgtz(i) {
      return this._branch(i, binop(gpr(i.rs), ">", imm32(0)));
    }
    bgez(i) {
      return this._branch(i, binop(gpr(i.rs), ">=", imm32(0)));
    }
    beql(i) {
      return this.beq(i);
    }
    bnel(i) {
      return this.bne(i);
    }
    bltzl(i) {
      return this.bltz(i);
    }
    blezl(i) {
      return this.blez(i);
    }
    bgtzl(i) {
      return this.bgtz(i);
    }
    bgezl(i) {
      return this.bgez(i);
    }
    bltzal(i) {
      return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltz(i)]);
    }
    bltzall(i) {
      return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltzl(i)]);
    }
    bgezal(i) {
      return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgez(i)]);
    }
    bgezall(i) {
      return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgezl(i)]);
    }
    bc1t(i) {
      return this._branch(i, fcr31_cc());
    }
    bc1f(i) {
      return this._branch(i, unop("!", fcr31_cc()));
    }
    bc1tl(i) {
      return this.bc1t(i);
    }
    bc1fl(i) {
      return this.bc1f(i);
    }
    mfc1(i) {
      return assignGpr(i.rt, ast.fpr_i(i.fs));
    }
    mtc1(i) {
      return assignFpr_I(i.fs, ast.gpr(i.rt));
    }
    cfc1(i) {
      return stm(call(`state.${CpuStateFields._cfc1_impl}`, [imm32(i.rd), imm32(i.rt)]));
    }
    ctc1(i) {
      return stm(call(`state.${CpuStateFields._ctc1_impl}`, [imm32(i.rd), gpr(i.rt)]));
    }
    "trunc.w.s"(i) {
      return assignFpr_I(i.fd, call("MathFloat.trunc", [fpr(i.fs)]));
    }
    "round.w.s"(i) {
      return assignFpr_I(i.fd, call("MathFloat.round", [fpr(i.fs)]));
    }
    "ceil.w.s"(i) {
      return assignFpr_I(i.fd, call("MathFloat.ceil", [fpr(i.fs)]));
    }
    "floor.w.s"(i) {
      return assignFpr_I(i.fd, call("MathFloat.floor", [fpr(i.fs)]));
    }
    "cvt.s.w"(i) {
      return assignFpr(i.fd, fpr_i(i.fs));
    }
    "cvt.w.s"(i) {
      return assignFpr_I(i.fd, call(`state.${CpuStateFields._cvt_w_s_impl}`, [fpr(i.fs)]));
    }
    sb(i) {
      return stm(call(`memory.${MemoryFields.sb}`, [rs_imm16(i), gpr(i.rt)]));
    }
    sh(i) {
      return stm(call(`memory.${MemoryFields.sh}`, [rs_imm16(i), gpr(i.rt)]));
    }
    sw(i) {
      return stm(call(`memory.${MemoryFields.sw}`, [rs_imm16(i), gpr(i.rt)]));
    }
    swc1(i) {
      return stm(call(`memory.${MemoryFields.sw}`, [rs_imm16(i), fpr_i(i.ft)]));
    }
    swl(i) {
      return stm(call(`memory.${MemoryFields.swl}`, [rs_imm16(i), gpr(i.rt)]));
    }
    swr(i) {
      return stm(call(`memory.${MemoryFields.swr}`, [rs_imm16(i), gpr(i.rt)]));
    }
    lb(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lb}`, [rs_imm16(i)]));
    }
    lbu(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lbu}`, [rs_imm16(i)]));
    }
    lh(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lh}`, [rs_imm16(i)]));
    }
    lhu(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lhu}`, [rs_imm16(i)]));
    }
    lw(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lw}`, [rs_imm16(i)]));
    }
    lwc1(i) {
      return assignFpr_I(i.ft, call(`memory.${MemoryFields.lw}`, [rs_imm16(i)]));
    }
    lwl(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lwl}`, [rs_imm16(i), gpr(i.rt)]));
    }
    lwr(i) {
      return assignGpr(i.rt, call(`memory.${MemoryFields.lwr}`, [rs_imm16(i), gpr(i.rt)]));
    }
    _callstackPush(i) {
      return ast.stm();
    }
    _callstackPop(i) {
      return ast.stm();
    }
    j(i) {
      return stms([
        stm(assign(branchflag(), imm32(1))),
        stm(assign(branchpc(), u_imm32(i.jump_address)))
      ]);
    }
    jr(i) {
      const statements = [];
      statements.push(stm(assign(branchflag(), imm32(1))));
      statements.push(stm(assign(branchpc(), gpr(i.rs))));
      if (i.rs == 31) {
        statements.push(this._callstackPop(i));
      }
      return stms(statements);
    }
    _jrOpt(i) {
      return stms([stm(assign(branchpc(), gpr(i.rs)))]);
    }
    jal(i) {
      return stms([this.j(i), this._callstackPush(i), assignGpr(31, u_imm32(i.PC + 8))]);
    }
    jalr(i) {
      return stms([this.jr(i), this._callstackPush(i), assignGpr(i.rd, u_imm32(i.PC + 8))]);
    }
    _comp(i, fc02, fc3) {
      const fc_unordererd = (fc02 & 1) != 0;
      const fc_equal = (fc02 & 2) != 0;
      const fc_less = (fc02 & 4) != 0;
      const fc_inv_qnan = fc3 != 0;
      const s = fpr(i.fs).toJs();
      const t = fpr(i.ft).toJs();
      let parts = [];
      if (fc_equal)
        parts.push(`(${s} == ${t})`);
      if (fc_less)
        parts.push(`(${s} < ${t})`);
      if (parts.length == 0)
        parts = ["false"];
      return stm(ast.raw_stm(`state.${CpuStateFields.fcr31_cc} = (isNaN(${s}) || isNaN(${t})) ? ${fc_unordererd} : (${parts.join(" | ")})`));
    }
    "c.f.s"(i) {
      return this._comp(i, 0, 0);
    }
    "c.un.s"(i) {
      return this._comp(i, 1, 0);
    }
    "c.eq.s"(i) {
      return this._comp(i, 2, 0);
    }
    "c.ueq.s"(i) {
      return this._comp(i, 3, 0);
    }
    "c.olt.s"(i) {
      return this._comp(i, 4, 0);
    }
    "c.ult.s"(i) {
      return this._comp(i, 5, 0);
    }
    "c.ole.s"(i) {
      return this._comp(i, 6, 0);
    }
    "c.ule.s"(i) {
      return this._comp(i, 7, 0);
    }
    "c.sf.s"(i) {
      return this._comp(i, 0, 1);
    }
    "c.ngle.s"(i) {
      return this._comp(i, 1, 1);
    }
    "c.seq.s"(i) {
      return this._comp(i, 2, 1);
    }
    "c.ngl.s"(i) {
      return this._comp(i, 3, 1);
    }
    "c.lt.s"(i) {
      return this._comp(i, 4, 1);
    }
    "c.nge.s"(i) {
      return this._comp(i, 5, 1);
    }
    "c.le.s"(i) {
      return this._comp(i, 6, 1);
    }
    "c.ngt.s"(i) {
      return this._comp(i, 7, 1);
    }
  };
  var VCondition;
  (function(VCondition3) {
    VCondition3[VCondition3["FL"] = 0] = "FL";
    VCondition3[VCondition3["EQ"] = 1] = "EQ";
    VCondition3[VCondition3["LT"] = 2] = "LT";
    VCondition3[VCondition3["LE"] = 3] = "LE";
    VCondition3[VCondition3["TR"] = 4] = "TR";
    VCondition3[VCondition3["NE"] = 5] = "NE";
    VCondition3[VCondition3["GE"] = 6] = "GE";
    VCondition3[VCondition3["GT"] = 7] = "GT";
    VCondition3[VCondition3["EZ"] = 8] = "EZ";
    VCondition3[VCondition3["EN"] = 9] = "EN";
    VCondition3[VCondition3["EI"] = 10] = "EI";
    VCondition3[VCondition3["ES"] = 11] = "ES";
    VCondition3[VCondition3["NZ"] = 12] = "NZ";
    VCondition3[VCondition3["NN"] = 13] = "NN";
    VCondition3[VCondition3["NI"] = 14] = "NI";
    VCondition3[VCondition3["NS"] = 15] = "NS";
  })(VCondition || (VCondition = {}));

  // src/core/cpu/cpu_instruction.ts
  var Instruction = class {
    constructor(PC, IDATA) {
      this.PC = PC;
      this.IDATA = IDATA;
    }
    static fromMemoryAndPC(memory2, PC) {
      return new Instruction(PC, memory2.readInt32(PC));
    }
    extract(offset, length) {
      return BitUtils.extract(this.IDATA, offset, length);
    }
    extract_s(offset, length) {
      return BitUtils.extractSigned(this.IDATA, offset, length);
    }
    insert(offset, length, value) {
      this.IDATA = BitUtils.insert(this.IDATA, offset, length, value);
    }
    get rd() {
      return this.IDATA >> 11 & 31;
    }
    set rd(value) {
      this.insert(11, 5, value);
    }
    get rt() {
      return this.IDATA >> 16 & 31;
    }
    set rt(value) {
      this.insert(16, 5, value);
    }
    get rs() {
      return this.IDATA >> 21 & 31;
    }
    set rs(value) {
      this.insert(21, 5, value);
    }
    get fd() {
      return this.IDATA >> 6 & 31;
    }
    set fd(value) {
      this.insert(6, 5, value);
    }
    get fs() {
      return this.IDATA >> 11 & 31;
    }
    set fs(value) {
      this.insert(11, 5, value);
    }
    get ft() {
      return this.IDATA >> 16 & 31;
    }
    set ft(value) {
      this.insert(16, 5, value);
    }
    get VD() {
      return this.IDATA >> 0 & 127;
    }
    set VD(value) {
      this.insert(0, 7, value);
    }
    get VS() {
      return this.IDATA >> 8 & 127;
    }
    set VS(value) {
      this.insert(8, 7, value);
    }
    get VT() {
      return this.IDATA >> 16 & 127;
    }
    set VT(value) {
      this.insert(16, 7, value);
    }
    get VT5_1() {
      return this.VT5 | this.VT1 << 5;
    }
    set VT5_1(value) {
      this.VT5 = value;
      this.VT1 = value >>> 5;
    }
    get IMM14() {
      return this.extract_s(2, 14);
    }
    set IMM14(value) {
      this.insert(2, 14, value);
    }
    get ONE() {
      return this.IDATA >> 7 & 1;
    }
    set ONE(value) {
      this.insert(7, 1, value);
    }
    get TWO() {
      return this.IDATA >> 15 & 1;
    }
    set TWO(value) {
      this.insert(15, 1, value);
    }
    get ONE_TWO() {
      return 1 + 1 * this.ONE + 2 * this.TWO;
    }
    set ONE_TWO(value) {
      this.ONE = value - 1 >>> 0 & 1;
      this.TWO = value - 1 >>> 1 & 1;
    }
    get IMM8() {
      return this.extract(16, 8);
    }
    set IMM8(value) {
      this.insert(16, 8, value);
    }
    get IMM5() {
      return this.extract(16, 5);
    }
    set IMM5(value) {
      this.insert(16, 5, value);
    }
    get IMM3() {
      return this.extract(18, 3);
    }
    set IMM3(value) {
      this.insert(18, 3, value);
    }
    get IMM7() {
      return this.extract(0, 7);
    }
    set IMM7(value) {
      this.insert(0, 7, value);
    }
    get IMM4() {
      return this.extract(0, 4);
    }
    set IMM4(value) {
      this.insert(0, 4, value);
    }
    get VT1() {
      return this.extract(0, 1);
    }
    set VT1(value) {
      this.insert(0, 1, value);
    }
    get VT2() {
      return this.extract(0, 2);
    }
    set VT2(value) {
      this.insert(0, 2, value);
    }
    get VT5() {
      return this.extract(16, 5);
    }
    set VT5(value) {
      this.insert(16, 5, value);
    }
    get VT5_2() {
      return this.VT5 | this.VT2 << 5;
    }
    get IMM_HF() {
      return HalfFloat.toFloat(this.imm16);
    }
    get pos() {
      return this.lsb;
    }
    set pos(value) {
      this.lsb = value;
    }
    get size_e() {
      return this.msb + 1;
    }
    set size_e(value) {
      this.msb = value - 1;
    }
    get size_i() {
      return this.msb - this.lsb + 1;
    }
    set size_i(value) {
      this.msb = this.lsb + value - 1;
    }
    get lsb() {
      return this.IDATA >> 6 & 31;
    }
    set lsb(value) {
      this.insert(6, 5, value);
    }
    get msb() {
      return this.IDATA >> 11 & 31;
    }
    set msb(value) {
      this.insert(11, 5, value);
    }
    get vsyscall() {
      return this.IDATA >> 6 & 1048575;
    }
    set vsyscall(value) {
      this.insert(6, 20, value);
    }
    get imm16() {
      return this.IDATA << 16 >> 16;
    }
    set imm16(value) {
      this.insert(0, 16, value);
    }
    get u_imm16() {
      return this.IDATA & 65535;
    }
    set u_imm16(value) {
      this.insert(0, 16, value);
    }
    get u_imm26() {
      return this.IDATA & 67108863;
    }
    set u_imm26(value) {
      this.insert(0, 26, value);
    }
    get jump_bits() {
      return this.IDATA & 67108863;
    }
    set jump_bits(value) {
      this.insert(0, 26, value);
    }
    get jump_real() {
      return this.jump_bits * 4 >>> 0;
    }
    set jump_real(value) {
      this.jump_bits = value / 4 >>> 0;
    }
    set branch_address(value) {
      this.imm16 = (value - this.PC - 4) / 4;
    }
    set jump_address(value) {
      this.u_imm26 = value / 4;
    }
    get branch_address() {
      return this.PC + this.imm16 * 4 + 4;
    }
    get jump_address() {
      return this.u_imm26 * 4;
    }
  };
  var DecodedInstruction = class {
    constructor(instruction, type) {
      this.instruction = instruction;
      this.type = type;
    }
    get PC() {
      return this.instruction.PC;
    }
    get isUnconditional() {
      switch (this.type.name) {
        case "j":
        case "b":
          return true;
      }
      return false;
    }
    get isUnconditionalFixedJump() {
      return this.type.name == "j";
    }
    get targetAddress() {
      if (this.type.isRegister)
        return this.PC;
      if (this.type.isBranch)
        return this.instruction.branch_address;
      if (this.type.isJump)
        return this.instruction.jump_address;
      return this.PC + 4;
    }
  };

  // src/core/cpu/cpu_assembler.ts
  var Labels = class {
    constructor() {
      this.labels = {};
    }
  };
  var MipsAssemblerResult = class {
    constructor(entrypoint) {
      this.entrypoint = entrypoint;
    }
  };
  var MipsAssembler = class {
    constructor() {
      this.instructions = Instructions.instance;
    }
    assembleToMemory(memory2, startPC, lines) {
      const labels = new Labels();
      let entryPoint = startPC;
      for (let n = 0; n < 2; n++) {
        let PC = startPC;
        for (let line of lines) {
          switch (line.substr(0, 1)) {
            case ".":
              switch (line) {
                case ".entrypoint":
                  entryPoint = PC;
                  break;
                default:
                  throw new Error(`Invalid ${line}`);
              }
              break;
            case ":":
              labels.labels[line.substr(1)] = PC;
              break;
            default:
              const instructions = this.assemble(PC, line, labels);
              for (let instruction of instructions) {
                memory2.writeInt32(PC, instruction.IDATA);
                PC += 4;
              }
              break;
          }
        }
      }
      return new MipsAssemblerResult(entryPoint);
    }
    assemble(PC, line, labels) {
      if (labels == null)
        labels = new Labels();
      let matches = line.match(/^\s*(\w+)(.*)$/);
      if (matches == null)
        throw new Error(`Invalid assembly line '${line}'`);
      const instructionName = matches[1];
      const instructionArguments = matches[2].replace(/^\s+/, "").replace(/\s+$/, "");
      switch (instructionName) {
        case "nop":
          return this.assemble(PC, "sll r0, r0, 0");
        case "li":
          const parts = instructionArguments.split(",");
          return this.assemble(PC, `addiu ${parts[0]}, r0, ${parts[1]}`);
      }
      const instructionType = this.instructions.findByName(instructionName);
      const instruction = new Instruction(PC, instructionType.vm.value);
      const types = [];
      const formatPattern = instructionType.format.replace("(", "\\(").replace(")", "\\)").replace(/(%\w+)/g, (type) => {
        types.push(type);
        switch (type) {
          case "%J":
          case "%s":
          case "%d":
          case "%t":
            return "([$r]\\d+)";
          case "%i":
          case "%C":
          case "%c":
          case "%a":
            return "((?:0b|0x|\\-)?[0-9A-Fa-f_]+)";
          case "%j":
          case "%O":
            return "(\\w+)";
          default:
            throw new Error("MipsAssembler.Transform: Unknown type '" + type + "'");
        }
      }).replace(/\s+/g, "\\s*");
      const regex = new RegExp(`^${formatPattern}$`, "");
      matches = instructionArguments.match(regex);
      if (matches === null) {
        throw `Not matching ${instructionArguments} : ${regex} : ${instructionType.format}`;
      }
      for (let n = 0; n < types.length; n++) {
        const type = types[n];
        const match = matches[n + 1];
        this.update(instruction, type, match, labels);
      }
      return [instruction];
    }
    decodeRegister(name2) {
      if (name2.charAt(0) == "$")
        return parseInt(name2.substr(1));
      if (name2.charAt(0) == "r")
        return parseInt(name2.substr(1));
      throw `Invalid register "${name2}"`;
    }
    decodeInteger(str) {
      return parseIntFormat(str);
    }
    update(instruction, type, value, labels) {
      switch (type) {
        case "%J":
        case "%s":
          instruction.rs = this.decodeRegister(value);
          break;
        case "%d":
          instruction.rd = this.decodeRegister(value);
          break;
        case "%t":
          instruction.rt = this.decodeRegister(value);
          break;
        case "%a":
        case "%i":
          instruction.imm16 = this.decodeInteger(value);
          break;
        case "%C":
          instruction.vsyscall = this.decodeInteger(value);
          break;
        case "%c":
          instruction.vsyscall = this.decodeInteger(value);
          break;
        case "%O":
          instruction.branch_address = labels.labels[value];
          break;
        case "%j":
          instruction.jump_address = labels.labels[value];
          break;
        default:
          throw `MipsAssembler.Update: Unknown type '${type}' with value '${value}'`;
      }
    }
  };
  var MipsDisassembler = class {
    constructor() {
      this.instructions = Instructions.instance;
    }
    encodeRegister(index) {
      return `$${index}`;
    }
    disassemble(instruction) {
      if (instruction.IDATA == 0)
        return "nop";
      const instructionType = this.instructions.findByData(instruction.IDATA);
      const args = instructionType.format.replace(/(%\w+)/g, (type) => {
        switch (type) {
          case "%J":
          case "%s":
            return this.encodeRegister(instruction.rs);
          case "%d":
            return this.encodeRegister(instruction.rd);
          case "%t":
            return this.encodeRegister(instruction.rt);
          case "%i":
            return `${instruction.imm16}`;
          case "%I":
            return `${addressToHex(instruction.imm16 << 16)}`;
          case "%j":
            return `${addressToHex(instruction.jump_real)}`;
          case "%a":
            return `${instruction.pos}`;
          default:
            return `UNHANDLED[${type}]`;
        }
      });
      return `${instructionType.name} ${args}`;
    }
    disassembleMemory(memory2, PC) {
      return this.disassemble(Instruction.fromMemoryAndPC(memory2, PC));
    }
    disassembleMemoryWithAddress(memory2, PC) {
      return sprintf("0x%08X[0x%08X]: %s", PC, memory2.readInt32(PC), this.disassembleMemory(memory2, PC));
    }
    disassembleMemoryWithAddressArray(memory2, PC, count) {
      return xrange(0, count).map((n) => this.disassembleMemoryWithAddress(memory2, PC + n * 4));
    }
    dump(memory2, PC, count, print = (it) => console.log(it)) {
      for (const line of this.disassembleMemoryWithAddressArray(memory2, PC, count)) {
        print(line);
      }
    }
  };

  // src/util/AnsiEscapeCodes.ts
  var AnsiEscapeCodes;
  (function(AnsiEscapeCodes2) {
    AnsiEscapeCodes2["RESET"] = "[0m";
    AnsiEscapeCodes2["BLACK"] = "[30m";
    AnsiEscapeCodes2["RED"] = "[31m";
    AnsiEscapeCodes2["GREEN"] = "[32m";
    AnsiEscapeCodes2["YELLOW"] = "[33m";
    AnsiEscapeCodes2["BLUE"] = "[34m";
    AnsiEscapeCodes2["PURPLE"] = "[35m";
    AnsiEscapeCodes2["CYAN"] = "[36m";
    AnsiEscapeCodes2["WHITE"] = "[37m";
  })(AnsiEscapeCodes || (AnsiEscapeCodes = {}));

  // src/core/cpu/cpu_core.ts
  var DEBUG_FUNCGEN = false;
  var DEBUG_NATIVEFUNC = false;
  var BUILD_FUNC_ON_REFERENCED = true;
  var BaseCustomType = class {
    read(stream) {
      return stream.readUInt32LE();
    }
    write(stream, value) {
      stream.writeUInt32LE(value);
    }
    get length() {
      return 4;
    }
  };
  var MemoryType = class extends BaseCustomType {
  };
  var ThreadType = class extends BaseCustomType {
  };
  var BoolType = class extends BaseCustomType {
  };
  var VoidType = class extends BaseCustomType {
  };
  var BytesType = class extends BaseCustomType {
  };
  var CpuStateType = class extends BaseCustomType {
  };
  var FixedBytesType = class extends BaseCustomType {
    constructor(size) {
      super();
      this.size = size;
    }
  };
  var MemoryTypeType = new MemoryType();
  var ThreadTypeType = new ThreadType();
  var CpuStateTypeType = new CpuStateType();
  var BoolTypeType = new BoolType();
  var VoidTypeType = new VoidType();
  var BytesTypeType = new BytesType();
  var CpuSpecialAddresses;
  (function(CpuSpecialAddresses2) {
    CpuSpecialAddresses2[CpuSpecialAddresses2["EXIT_THREAD"] = 20148224] = "EXIT_THREAD";
    CpuSpecialAddresses2[CpuSpecialAddresses2["EXIT_INTERRUPT"] = 20148228] = "EXIT_INTERRUPT";
  })(CpuSpecialAddresses || (CpuSpecialAddresses = {}));
  var VfpuPrefixBase = class {
    constructor(vfrc, index) {
      this.vfrc = vfrc;
      this.index = index;
      this.enabled = false;
      this._info = 0;
    }
    _readInfo() {
      this._info = this.getInfo();
    }
    eat() {
      this.enabled = false;
    }
    getInfo() {
      return this.vfrc[this.index];
    }
    setInfo(info) {
      this.vfrc[this.index] = info;
      this.enabled = true;
    }
  };
  var NativeFunction = class {
    constructor() {
      this.name = "";
      this.nid = 0;
      this.firmwareVersion = 0;
    }
  };
  var SyscallManager = class {
    constructor(context) {
      this.context = context;
      this.calls = {};
      this.lastId = 1;
    }
    register(nativeFunction2) {
      return this.registerWithId(this.lastId++, nativeFunction2);
    }
    registerWithId(id, nativeFunction2) {
      this.calls[id] = nativeFunction2;
      return id;
    }
    getName(id) {
      const c = this.calls[id];
      if (c)
        return c.name;
      return `syscall_${id}`;
    }
    getNativeFunction(id) {
      return this.calls[id];
    }
    call(state, id) {
      const nativeFunction2 = this.calls[id];
      if (!nativeFunction2)
        throw `Can't call syscall ${this.getName(id)}: ${addressToHex(id)}"`;
      if (DEBUG_NATIVEFUNC) {
        console.log(`calling syscall ${addressToHex(id)}, ${id}, ${nativeFunction2.name} with cpustate:${state.id}`);
      }
      nativeFunction2.call(this.context, state);
    }
  };
  var VfpuPrefixRead = class extends VfpuPrefixBase {
    transformValues(input, output) {
      this._readInfo();
      const info = this._info;
      if (!this.enabled) {
        for (let n = 0; n < input.length; n++)
          output[n] = input[n];
      } else {
        for (let n = 0; n < input.length; n++) {
          const sourceIndex = info >> 0 + n * 2 & 3;
          const sourceAbsolute = info >> 8 + n * 1 & 1;
          const sourceConstant = info >> 12 + n * 1 & 1;
          const sourceNegate = info >> 16 + n * 1 & 1;
          let value;
          if (sourceConstant) {
            switch (sourceIndex) {
              case 0:
                value = sourceAbsolute ? 3 : 0;
                break;
              case 1:
                value = sourceAbsolute ? 1 / 3 : 1;
                break;
              case 2:
                value = sourceAbsolute ? 1 / 4 : 2;
                break;
              case 3:
                value = sourceAbsolute ? 1 / 6 : 1 / 2;
                break;
              default:
                throw new Error("Invalid operation");
            }
          } else {
            value = input[sourceIndex];
            if (sourceAbsolute)
              value = Math.abs(value);
          }
          if (sourceNegate)
            value = MathFloat.neg(value);
          output[n] = value;
        }
      }
    }
  };
  var VfpuPrefixWrite = class extends VfpuPrefixBase {
    storeTransformedValues(vfpr2, indices, values) {
      this._readInfo();
      const info = this._info;
      if (!this.enabled) {
        for (let n = 0; n < indices.length; n++) {
          vfpr2[indices[n]] = values[n];
        }
      } else {
        for (let n = 0; n < indices.length; n++) {
          const destinationSaturation = info >> 0 + n * 2 & 3;
          const destinationMask = info >> 8 + n * 1 & 1;
          if (destinationMask) {
          } else {
            let value = values[n];
            switch (destinationSaturation) {
              case 1:
                value = MathFloat.sat0(value);
                break;
              case 3:
                value = MathFloat.sat1(value);
                break;
              default:
                break;
            }
            vfpr2[indices[n]] = value;
          }
        }
      }
    }
  };
  var VFPU_CTRL;
  (function(VFPU_CTRL2) {
    VFPU_CTRL2[VFPU_CTRL2["SPREFIX"] = 0] = "SPREFIX";
    VFPU_CTRL2[VFPU_CTRL2["TPREFIX"] = 1] = "TPREFIX";
    VFPU_CTRL2[VFPU_CTRL2["DPREFIX"] = 2] = "DPREFIX";
    VFPU_CTRL2[VFPU_CTRL2["CC"] = 3] = "CC";
    VFPU_CTRL2[VFPU_CTRL2["INF4"] = 4] = "INF4";
    VFPU_CTRL2[VFPU_CTRL2["RSV5"] = 5] = "RSV5";
    VFPU_CTRL2[VFPU_CTRL2["RSV6"] = 6] = "RSV6";
    VFPU_CTRL2[VFPU_CTRL2["REV"] = 7] = "REV";
    VFPU_CTRL2[VFPU_CTRL2["RCX0"] = 8] = "RCX0";
    VFPU_CTRL2[VFPU_CTRL2["RCX1"] = 9] = "RCX1";
    VFPU_CTRL2[VFPU_CTRL2["RCX2"] = 10] = "RCX2";
    VFPU_CTRL2[VFPU_CTRL2["RCX3"] = 11] = "RCX3";
    VFPU_CTRL2[VFPU_CTRL2["RCX4"] = 12] = "RCX4";
    VFPU_CTRL2[VFPU_CTRL2["RCX5"] = 13] = "RCX5";
    VFPU_CTRL2[VFPU_CTRL2["RCX6"] = 14] = "RCX6";
    VFPU_CTRL2[VFPU_CTRL2["RCX7"] = 15] = "RCX7";
    VFPU_CTRL2[VFPU_CTRL2["MAX"] = 16] = "MAX";
  })(VFPU_CTRL || (VFPU_CTRL = {}));
  var VCondition2;
  (function(VCondition3) {
    VCondition3[VCondition3["FL"] = 0] = "FL";
    VCondition3[VCondition3["EQ"] = 1] = "EQ";
    VCondition3[VCondition3["LT"] = 2] = "LT";
    VCondition3[VCondition3["LE"] = 3] = "LE";
    VCondition3[VCondition3["TR"] = 4] = "TR";
    VCondition3[VCondition3["NE"] = 5] = "NE";
    VCondition3[VCondition3["GE"] = 6] = "GE";
    VCondition3[VCondition3["GT"] = 7] = "GT";
    VCondition3[VCondition3["EZ"] = 8] = "EZ";
    VCondition3[VCondition3["EN"] = 9] = "EN";
    VCondition3[VCondition3["EI"] = 10] = "EI";
    VCondition3[VCondition3["ES"] = 11] = "ES";
    VCondition3[VCondition3["NZ"] = 12] = "NZ";
    VCondition3[VCondition3["NN"] = 13] = "NN";
    VCondition3[VCondition3["NI"] = 14] = "NI";
    VCondition3[VCondition3["NS"] = 15] = "NS";
  })(VCondition2 || (VCondition2 = {}));
  var CpuConfig = class {
    constructor(interpreted = false) {
      this.interpreted = interpreted;
    }
  };
  var _CpuState = class extends Instruction {
    constructor(memory2, syscallManager, config) {
      super(0, 0);
      this.memory = memory2;
      this.syscallManager = syscallManager;
      this.config = config;
      this.id = _CpuState.lastId++;
      this.insideInterrupt = false;
      this.gpr_Buffer = new ArrayBuffer(32 * 4);
      this.gpr_f = new Float32Array(this.gpr_Buffer);
      this.jumpCall = null;
      this.temp = new Array(16);
      this.fpr_Buffer = new ArrayBuffer(32 * 4);
      this.fpr = new Float32Array(this.fpr_Buffer);
      this.fpr_i = new Int32Array(this.fpr_Buffer);
      this.vfpr_Buffer = new ArrayBuffer(128 * 4);
      this.vfpr = new Float32Array(this.vfpr_Buffer);
      this.vfpr_i = new Int32Array(this.vfpr_Buffer);
      this.vfprc = new Int32Array([0, 0, 0, 255, 0, 0, 0, 0, 1065353216, 1065353216, 1065353216, 1065353216, 1065353216, 1065353216, 1065353216, 1065353216]);
      this.vpfxs = new VfpuPrefixRead(this.vfprc, 0);
      this.vpfxt = new VfpuPrefixRead(this.vfprc, 1);
      this.vpfxd = new VfpuPrefixWrite(this.vfprc, 2);
      this.vector_vs = [0, 0, 0, 0];
      this.vector_vt = [0, 0, 0, 0];
      this.vector_vd = [0, 0, 0, 0];
      this.nPC = 4;
      this.PC = 0;
      this.IC = 0;
      this.LO = 0;
      this.HI = 0;
      this.thread = null;
      this.gpr = new Int32Array(this.gpr_Buffer);
      this.callstack = [];
      this.fcr31_rm = 0;
      this.fcr31_2_21 = 0;
      this.fcr31_25_7 = 0;
      this.fcr31_cc = false;
      this.fcr31_fs = false;
      this.fcr0 = 13137;
      this.cycles = 0;
      this.cycles2 = 0;
      this.syscallCount = 0;
      this.lastSyscallCalled = "";
      this.icache = new InstructionCache(memory2, syscallManager);
      this.fcr0 = 13137;
      this.fcr31 = 3584;
      this.vfpr.fill(NaN);
    }
    get interpreted() {
      return this.config.interpreted;
    }
    clone() {
      const that = new _CpuState(this.memory, this.syscallManager, this.config);
      that.icache = this.icache;
      that.copyRegistersFrom(this);
      return that;
    }
    throwInterruptBreakException() {
      throw new InterruptBreakException();
    }
    throwCpuBreakException() {
      this.thread.stop("CpuSpecialAddresses.EXIT_THREAD");
      this.throwEndCycles();
    }
    throwEndCycles() {
      throw new CpuBreakException();
    }
    setVfrCc(index, value) {
      if (value) {
        this.vfprc[3] |= 1 << index;
      } else {
        this.vfprc[3] &= ~(1 << index);
      }
    }
    vrnds() {
    }
    vrndi() {
      let v = 0;
      for (let n = 0; n < 4; n++) {
        v <<= 8;
        v |= Math.round(Math.random() * 255) & 255;
      }
      return v;
    }
    vrndf1() {
      return Math.random() * 2;
    }
    vrndf2() {
      return Math.random() * 4;
    }
    getVfrCc(index) {
      return (this.vfprc[3] & 1 << index) != 0;
    }
    vcmovtf(register, _true, vdRegs, vsRegs) {
      const vectorSize = vdRegs.length;
      this.loadVs_prefixed(vsRegs.map((reg) => this.vfpr[reg]));
      this.loadVdRegs(vdRegs);
      const compare2 = _true ? 1 : 0;
      const cc = this.vfprc[3];
      if (register < 6) {
        if ((cc >> register & 1) == compare2) {
          for (let n = 0; n < vectorSize; n++) {
            this.vector_vd[n] = this.vector_vs[n];
          }
        }
      }
      if (register == 6) {
        for (let n = 0; n < vectorSize; n++) {
          if ((cc >> n & 1) == compare2) {
            this.vector_vd[n] = this.vector_vs[n];
          }
        }
      } else {
      }
      this.storeVdRegsWithPrefix(vdRegs);
    }
    storeFloats(address, values) {
      for (let n = 0; n < values.length; n++) {
        this.memory.writeFloat32(address + n * 4, values[n]);
      }
    }
    setVpfxt(value) {
      this.vpfxt.setInfo(value);
    }
    setVpfxs(value) {
      this.vpfxs.setInfo(value);
    }
    setVpfxd(value) {
      this.vpfxd.setInfo(value);
    }
    get vfpumatrix0() {
      return this.getVfpumatrix(0);
    }
    get vfpumatrix1() {
      return this.getVfpumatrix(1);
    }
    get vfpumatrix2() {
      return this.getVfpumatrix(2);
    }
    get vfpumatrix3() {
      return this.getVfpumatrix(3);
    }
    get vfpumatrix4() {
      return this.getVfpumatrix(4);
    }
    get vfpumatrix5() {
      return this.getVfpumatrix(5);
    }
    get vfpumatrix6() {
      return this.getVfpumatrix(6);
    }
    get vfpumatrix7() {
      return this.getVfpumatrix(7);
    }
    eatPrefixes() {
      this.vpfxd.eat();
      this.vpfxt.eat();
      this.vpfxs.eat();
    }
    getVfpumatrix(index) {
      const values = [];
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          values.push(this.vfpr[r * 32 + index * 4 + c]);
        }
      }
      return values;
    }
    loadVdRegs(regs) {
      for (let n = 0; n < regs.length; n++) {
        this.vector_vd[n] = this.vfpr[regs[n]];
      }
    }
    storeVdRegsWithPrefix(regs) {
      this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
      this.vpfxd.eat();
      this.storeVdRegs(regs);
    }
    storeVdRegsWithPrefix1(regs) {
      this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
      this.vpfxd.eat();
      this.storeVdRegs(regs);
    }
    storeVdRegs(regs) {
      for (let n = 0; n < regs.length; n++)
        this.vfpr[regs[n]] = this.vector_vd[n];
    }
    loadVs_prefixed(values) {
      this.vpfxs.transformValues(values, this.vector_vs);
      this.vpfxs.eat();
    }
    loadVt_prefixed(values) {
      this.vpfxt.transformValues(values, this.vector_vt);
      this.vpfxt.eat();
    }
    storeVd_prefixed(indices, values) {
      this.vpfxd.storeTransformedValues(this.vfpr, indices, values);
      this.vpfxd.eat();
    }
    storeVd_prefixed_i(indices, values) {
      this.vpfxd.storeTransformedValues(this.vfpr_i, indices, values);
      this.vpfxd.eat();
    }
    vqmul0(s0, s1, s2, s3, t0, t1, t2, t3) {
      return MathVfpu.vqmul0(s0, s1, s2, s3, t0, t1, t2, t3);
    }
    vqmul1(s0, s1, s2, s3, t0, t1, t2, t3) {
      return MathVfpu.vqmul1(s0, s1, s2, s3, t0, t1, t2, t3);
    }
    vqmul2(s0, s1, s2, s3, t0, t1, t2, t3) {
      return MathVfpu.vqmul2(s0, s1, s2, s3, t0, t1, t2, t3);
    }
    vqmul3(s0, s1, s2, s3, t0, t1, t2, t3) {
      return MathVfpu.vqmul3(s0, s1, s2, s3, t0, t1, t2, t3);
    }
    vi2uc(x, y, z, w) {
      return MathVfpu.vi2uc(x, y, z, w);
    }
    vc2i(index, value) {
      return MathVfpu.vc2i(index, value);
    }
    vuc2i(index, value) {
      return MathVfpu.vuc2i(index, value);
    }
    vs2i(index, value) {
      return MathVfpu.vs2i(index, value);
    }
    vi2f(value, count) {
      return MathVfpu.vi2f(value, count);
    }
    vf2id(value, count) {
      return MathVfpu.vf2id(value, count);
    }
    vf2in(value, count) {
      return MathVfpu.vf2in(value, count);
    }
    vf2iu(value, count) {
      return MathVfpu.vf2iu(value, count);
    }
    vf2iz(value, count) {
      return MathVfpu.vf2iz(value, count);
    }
    vf2h() {
      debugger;
      return 0;
    }
    vh2f() {
      debugger;
      return 0;
    }
    _vt4444_step(i0, i1) {
      let o = 0;
      o |= (i0 >> 4 & 15) << 0;
      o |= (i0 >> 12 & 15) << 4;
      o |= (i0 >> 20 & 15) << 8;
      o |= (i0 >> 28 & 15) << 12;
      o |= (i1 >> 4 & 15) << 16;
      o |= (i1 >> 12 & 15) << 20;
      o |= (i1 >> 20 & 15) << 24;
      o |= (i1 >> 28 & 15) << 28;
      return o;
    }
    _vt5551_step(i0, i1) {
      let o = 0;
      o |= (i0 >> 3 & 31) << 0;
      o |= (i0 >> 11 & 31) << 5;
      o |= (i0 >> 19 & 31) << 10;
      o |= (i0 >> 31 & 1) << 15;
      o |= (i1 >> 3 & 31) << 16;
      o |= (i1 >> 11 & 31) << 21;
      o |= (i1 >> 19 & 31) << 26;
      o |= (i1 >> 31 & 1) << 31;
      return o;
    }
    _vt5650_step(i0, i1) {
      let o = 0;
      o |= (i0 >> 3 & 31) << 0;
      o |= (i0 >> 10 & 63) << 5;
      o |= (i0 >> 19 & 31) << 11;
      o |= (i1 >> 3 & 31) << 16;
      o |= (i1 >> 10 & 63) << 21;
      o |= (i1 >> 19 & 31) << 27;
      return o;
    }
    svl_q(address, r) {
      const k = 3 - (address >>> 2 & 3);
      address &= ~15;
      for (let n = k; n < 4; n++, address += 4)
        this.memory.sw(address, this.vfpr_i[r[n]]);
    }
    svr_q(address, r) {
      const k = 4 - (address >>> 2 & 3);
      for (let n = 0; n < k; n++, address += 4)
        this.memory.sw(address, this.vfpr_i[r[n]]);
    }
    lvl_q(address, r) {
      const k = 3 - (address >>> 2 & 3);
      address &= ~15;
      for (let n = k; n < 4; n++, address += 4)
        this.vfpr_i[r[n]] = this.memory.lw(address);
    }
    lvr_q(address, r) {
      const k = 4 - (address >>> 2 & 3);
      for (let n = 0; n < k; n++, address += 4)
        this.vfpr_i[r[n]] = this.memory.lw(address);
    }
    vfpuStore(indices, values) {
      for (let n = 0; n < indices.length; n++)
        this.vfpr[indices[n]] = values[n];
    }
    vfpuStore_i(indices, values) {
      for (let n = 0; n < indices.length; n++)
        this.vfpr_i[indices[n]] = values[n];
    }
    vfpuSetMatrix(m, values) {
      this.vfpr[0] = 0;
      throw new Error("Not implemented vfpuSetMatrix!");
    }
    vcmp(cond, vsValues, vtValues) {
      const vectorSize = vsValues.length;
      this.loadVs_prefixed(vsValues);
      this.loadVt_prefixed(vtValues);
      const s = this.vector_vs;
      const t = this.vector_vt;
      let cc = 0;
      let or_val = 0;
      let and_val = 1;
      let affected_bits = 1 << 4 | 1 << 5;
      for (let i = 0; i < vectorSize; i++) {
        let c = false;
        switch (cond) {
          case 0:
            c = false;
            break;
          case 1:
            c = s[i] == t[i];
            break;
          case 2:
            c = s[i] < t[i];
            break;
          case 3:
            c = s[i] <= t[i];
            break;
          case 4:
            c = true;
            break;
          case 5:
            c = s[i] != t[i];
            break;
          case 6:
            c = s[i] >= t[i];
            break;
          case 7:
            c = s[i] > t[i];
            break;
          case 8:
            c = s[i] === 0;
            break;
          case 9:
            c = MathFloat.isnan(s[i]);
            break;
          case 10:
            c = MathFloat.isinf(s[i]);
            break;
          case 11:
            c = MathFloat.isnanorinf(s[i]);
            break;
          case 12:
            c = s[i] != 0;
            break;
          case 13:
            c = !MathFloat.isnan(s[i]);
            break;
          case 14:
            c = !MathFloat.isinf(s[i]);
            break;
          case 15:
            c = !MathFloat.isnanorinf(s[i]);
            break;
        }
        const c_i = c ? 1 : 0;
        cc |= c_i << i;
        or_val |= c_i;
        and_val &= c_i;
        affected_bits |= 1 << i;
      }
      this.vfprc[3] = this.vfprc[3] & ~affected_bits | (cc | or_val << 4 | and_val << 5) & affected_bits;
      this.eatPrefixes();
    }
    setPC(pc2) {
      this.PC = pc2;
      this.nPC = pc2 + 4;
    }
    get RD() {
      return this.getGPR(this.rd);
    }
    set RD(value) {
      this.setGPR(this.rd, value);
    }
    get RS() {
      return this.getGPR(this.rs);
    }
    set RS(value) {
      this.setGPR(this.rs, value);
    }
    get RT() {
      return this.getGPR(this.rt);
    }
    set RT(value) {
      this.setGPR(this.rt, value);
    }
    get FD() {
      return this.fpr[this.fd];
    }
    set FD(value) {
      this.fpr[this.fd] = value;
    }
    get FS() {
      return this.fpr[this.fs];
    }
    set FS(value) {
      this.fpr[this.fs] = value;
    }
    get FT() {
      return this.fpr[this.ft];
    }
    set FT(value) {
      this.fpr[this.ft] = value;
    }
    get FD_I() {
      return this.fpr_i[this.fd];
    }
    set FD_I(value) {
      this.fpr_i[this.fd] = value;
    }
    get FS_I() {
      return this.fpr_i[this.fs];
    }
    set FS_I(value) {
      this.fpr_i[this.fs] = value;
    }
    get FT_I() {
      return this.fpr_i[this.ft];
    }
    set FT_I(value) {
      this.fpr_i[this.ft] = value;
    }
    get RS_IMM16() {
      return this.RS + this.imm16;
    }
    advance_pc(offset = 4) {
      this.jump_pc(this.nPC + offset);
    }
    dump_asm(address, count) {
      const disassembler = new MipsDisassembler();
      for (let n = 0; n < count; n++) {
        console.error(disassembler.disassembleMemoryWithAddress(this.memory, address + n * 4));
      }
    }
    jump_pc(address) {
      this.PC = this.nPC;
      this.nPC = address;
    }
    preserveRegisters(callback) {
      const temp = this.clone();
      try {
        callback();
      } finally {
        this.copyRegistersFrom(temp);
      }
    }
    copyRegistersFrom(other) {
      this.nPC = other.nPC;
      this.PC = other.PC;
      this.IC = other.IC;
      this.LO = other.LO;
      this.HI = other.HI;
      this.insideInterrupt = other.insideInterrupt;
      this.gpr.set(other.gpr);
      this.fpr.set(other.fpr);
      this.vfpr.set(other.vfpr);
      this.vfprc.set(other.vfprc);
    }
    setGPR(n, value) {
      if (n != 0)
        this.gpr[n] = value;
    }
    getGPR(n) {
      return this.gpr[n];
    }
    static GPR_access(base, n) {
      if (base == null)
        return `gpr[${n}]`;
      return base + `.gpr[${n}]`;
    }
    static GPR_require_castToInt() {
      return false;
    }
    get V0() {
      return this.getGPR(2);
    }
    set V0(value) {
      this.setGPR(2, value);
    }
    get V1() {
      return this.getGPR(3);
    }
    set V1(value) {
      this.setGPR(3, value);
    }
    get K0() {
      return this.getGPR(26);
    }
    set K0(value) {
      this.setGPR(26, value);
    }
    get GP() {
      return this.getGPR(28);
    }
    set GP(value) {
      this.setGPR(28, value);
    }
    get SP() {
      return this.getGPR(29);
    }
    set SP(value) {
      this.setGPR(29, value);
    }
    get FP() {
      return this.getGPR(30);
    }
    set FP(value) {
      this.setGPR(30, value);
    }
    get RA() {
      return this.getGPR(31);
    }
    set RA(value) {
      this.setGPR(31, value);
    }
    getRA() {
      return this.getGPR(31);
    }
    setRA(value) {
      this.setGPR(31, value);
    }
    callstackPush(PC) {
    }
    callstackPop() {
    }
    printCallstack(symbolLookup = null) {
      this.getCallstack().forEach((PC) => {
        let line = addressToHex(PC);
        if (symbolLookup) {
          line += ` : ${symbolLookup.getSymbolAt(PC)}`;
        }
        console.log(line);
      });
    }
    getCallstack() {
      return this.callstack.slice(0);
    }
    _trace_state() {
      console.info(this);
      throw "_trace_state";
    }
    get fcr31() {
      let value = 0;
      value = BitUtils.insert(value, 0, 2, this.fcr31_rm);
      value = BitUtils.insert(value, 2, 21, this.fcr31_2_21);
      value = BitUtils.insert(value, 23, 1, this.fcr31_cc ? 1 : 0);
      value = BitUtils.insert(value, 24, 1, this.fcr31_fs ? 1 : 0);
      value = BitUtils.insert(value, 25, 7, this.fcr31_25_7);
      return value;
    }
    set fcr31(value) {
      this.fcr31_rm = BitUtils.extract(value, 0, 2);
      this.fcr31_2_21 = BitUtils.extract(value, 2, 21);
      this.fcr31_cc = BitUtils.extract(value, 23, 1) != 0;
      this.fcr31_fs = BitUtils.extract(value, 24, 1) != 0;
      this.fcr31_25_7 = BitUtils.extract(value, 25, 7);
    }
    get fcr0_rev() {
      return BitUtils.extract(this.fcr0, 0, 8);
    }
    get fcr0_imp() {
      return BitUtils.extract(this.fcr0, 8, 24);
    }
    _cfc1_impl(d, t) {
      switch (d) {
        case 0:
          this.setGPR(t, this.fcr0);
          break;
        case 31:
          this.setGPR(t, this.fcr31);
          break;
        default:
          this.setGPR(t, 0);
          break;
      }
    }
    _ctc1_impl(d, t) {
      switch (d) {
        case 31:
          this.fcr31 = t;
          break;
      }
    }
    _comp_impl(s, t, fc_unordererd, fc_equal, fc_less, fc_inv_qnan) {
      if (isNaN(s) || isNaN(t)) {
        this.fcr31_cc = fc_unordererd;
      } else {
        const equal = fc_equal && s == t;
        const less = fc_less && s < t;
        this.fcr31_cc = less || equal;
      }
    }
    _cvt_w_s_impl(FS) {
      switch (this.fcr31_rm) {
        case 0:
          return MathFloat.rint(FS);
        case 1:
          return MathFloat.cast(FS);
        case 2:
          return MathFloat.ceil(FS);
        case 3:
          return MathFloat.floor(FS);
      }
      throw "RM has an invalid value!!";
    }
    cache(rs, type, offset) {
    }
    syscall(id) {
      this.syscallManager.call(this, id);
      this.checkCyclesSyscall(id);
    }
    min(a, b) {
      return (a | 0) < (b | 0) ? a : b;
    }
    max(a, b) {
      return (a | 0) > (b | 0) ? a : b;
    }
    slt(a, b) {
      return (a | 0) < (b | 0) ? 1 : 0;
    }
    sltu(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    div(rs, rt) {
      rs |= 0;
      rt |= 0;
      this.LO = rs / rt | 0;
      this.HI = rs % rt | 0;
    }
    divu(rs, rt) {
      rs >>>= 0;
      rt >>>= 0;
      this.LO = rs / rt | 0;
      this.HI = rs % rt | 0;
    }
    mult(rs, rt) {
      Math.imul32_64(rs, rt, _CpuState._mult_temp);
      this.LO = _CpuState._mult_temp[0];
      this.HI = _CpuState._mult_temp[1];
    }
    madd(rs, rt) {
      const a64 = Integer64.fromInt(rs);
      const b64 = Integer64.fromInt(rt);
      const result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
      this.HI = result.high;
      this.LO = result.low;
    }
    msub(rs, rt) {
      const a64 = Integer64.fromInt(rs);
      const b64 = Integer64.fromInt(rt);
      const result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
      this.HI = result.high;
      this.LO = result.low;
    }
    multu(rs, rt) {
      const info = Math.umul32_64(rs, rt, _CpuState._mult_temp);
      this.LO = info[0];
      this.HI = info[1];
    }
    maddu(rs, rt) {
      const a64 = Integer64.fromUnsignedInt(rs);
      const b64 = Integer64.fromUnsignedInt(rt);
      const result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
      this.HI = result.high;
      this.LO = result.low;
    }
    msubu(rs, rt) {
      const a64 = Integer64.fromUnsignedInt(rs);
      const b64 = Integer64.fromUnsignedInt(rt);
      const result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
      this.HI = result.high;
      this.LO = result.low;
    }
    getFunction(pc2) {
      return this.icache.getFunction(pc2, 0);
    }
    break() {
      this.throwEndCycles();
    }
    startThreadStep() {
      this.cycles = 0;
      this.cycles2 = 0;
      this.syscallCount = 0;
      this.lastSyscallCalled = "";
    }
    checkCycles(cycles) {
    }
    checkCyclesSyscall(id) {
    }
    int_unknown(name2) {
      this.advance_pc();
      const message = `${AnsiEscapeCodes.RED}Unimplemented instruction '${name2}'${AnsiEscapeCodes.RESET}`;
      console.error(message);
      throw new ProgramExitException(message);
    }
    int_lui() {
      this.RT = this.imm16 << 16;
      this.advance_pc();
    }
    int_add() {
      this.RD = this.RS + this.RT;
      this.advance_pc();
    }
    int_addu() {
      this.RD = this.RS + this.RT;
      this.advance_pc();
    }
    int_addi() {
      this.RT = this.RS + this.imm16;
      this.advance_pc();
    }
    int_addiu() {
      this.RT = this.RS + this.imm16;
      this.advance_pc();
    }
    int_sub() {
      this.RD = this.RS - this.RT;
      this.advance_pc();
    }
    int_subu() {
      this.RD = this.RS - this.RT;
      this.advance_pc();
    }
    int_sll() {
      this.RD = this.RT << this.pos;
      this.advance_pc();
    }
    int_sra() {
      this.RD = this.RT >> this.pos;
      this.advance_pc();
    }
    int_srl() {
      this.RD = this.RT >>> this.pos;
      this.advance_pc();
    }
    int_rotr() {
      this.RD = BitUtils.rotr(this.RT, this.pos);
      this.advance_pc();
    }
    int_sllv() {
      this.RD = this.RT << (this.RS & 31);
      this.advance_pc();
    }
    int_srav() {
      this.RD = this.RT >> (this.RS & 31);
      this.advance_pc();
    }
    int_srlv() {
      this.RD = this.RT >>> (this.RS & 31);
      this.advance_pc();
    }
    int_rotrv() {
      this.RD = BitUtils.rotr(this.RT, this.RS);
      this.advance_pc();
    }
    int_bitrev() {
      this.RD = BitUtils.bitrev32(this.RT);
      this.advance_pc();
    }
    int_and() {
      this.RD = this.RS & this.RT;
      this.advance_pc();
    }
    int_or() {
      this.RD = this.RS | this.RT;
      this.advance_pc();
    }
    int_xor() {
      this.RD = this.RS ^ this.RT;
      this.advance_pc();
    }
    int_nor() {
      this.RD = ~(this.RS | this.RT);
      this.advance_pc();
    }
    int_andi() {
      this.RT = this.RS & this.u_imm16;
      this.advance_pc();
    }
    int_ori() {
      this.RT = this.RS | this.u_imm16;
      this.advance_pc();
    }
    int_xori() {
      this.RT = this.RS ^ this.u_imm16;
      this.advance_pc();
    }
    int_mflo() {
      this.RD = this.LO;
      this.advance_pc();
    }
    int_mfhi() {
      this.RD = this.HI;
      this.advance_pc();
    }
    int_mfic() {
      this.RT = this.IC;
      this.advance_pc();
    }
    int_mtlo() {
      this.LO = this.RS;
      this.advance_pc();
    }
    int_mthi() {
      this.HI = this.RS;
      this.advance_pc();
    }
    int_mtic() {
      this.IC = this.RT;
      this.advance_pc();
    }
    int_slt() {
      this.RD = this.slt(this.RS, this.RT);
      this.advance_pc();
    }
    int_sltu() {
      this.RD = this.sltu(this.RS, this.RT);
      this.advance_pc();
    }
    int_slti() {
      this.RT = this.slt(this.RS, this.imm16);
      this.advance_pc();
    }
    int_sltiu() {
      this.RT = this.sltu(this.RS, this.imm16);
      this.advance_pc();
    }
    int_movz() {
      if (this.RT == 0) {
        this.RD = this.RS;
      }
      this.advance_pc();
    }
    int_movn() {
      if (this.RT != 0) {
        this.RD = this.RS;
      }
      this.advance_pc();
    }
    int_ext() {
      this.RT = BitUtils.extract(this.RS, this.pos, this.size_e);
      this.advance_pc();
    }
    int_ins() {
      this.RT = BitUtils.insert(this.RT, this.pos, this.size_i, this.RS);
      this.advance_pc();
    }
    int_clz() {
      this.RD = BitUtils.clz(this.RS);
      this.advance_pc();
    }
    int_clo() {
      this.RD = BitUtils.clo(this.RS);
      this.advance_pc();
    }
    int_seb() {
      this.RD = BitUtils.seb(this.RT);
      this.advance_pc();
    }
    int_seh() {
      this.RD = BitUtils.seh(this.RT);
      this.advance_pc();
    }
    int_wsbh() {
      this.RD = BitUtils.wsbh(this.RT);
      this.advance_pc();
    }
    int_wsbw() {
      this.RD = BitUtils.wsbw(this.RT);
      this.advance_pc();
    }
    int_min() {
      this.RD = this.min(this.RS, this.RT);
      this.advance_pc();
    }
    int_max() {
      this.RD = this.max(this.RS, this.RT);
      this.advance_pc();
    }
    int_div() {
      this.div(this.RS, this.RT);
      this.advance_pc();
    }
    int_divu() {
      this.divu(this.RS, this.RT);
      this.advance_pc();
    }
    int_mult() {
      this.mult(this.RS, this.RT);
      this.advance_pc();
    }
    int_multu() {
      this.multu(this.RS, this.RT);
      this.advance_pc();
    }
    int_madd() {
      this.madd(this.RS, this.RT);
      this.advance_pc();
    }
    int_maddu() {
      this.maddu(this.RS, this.RT);
      this.advance_pc();
    }
    int_msub() {
      this.msub(this.RS, this.RT);
      this.advance_pc();
    }
    int_msubu() {
      this.msubu(this.RS, this.RT);
      this.advance_pc();
    }
    int_cache() {
      this.cache(this.RS, this.RT, this.imm16);
      this.advance_pc();
    }
    int_syscall() {
      this.advance_pc();
      this.syscall(this.vsyscall);
    }
    int_break() {
      this.advance_pc();
      this.break();
    }
    int_dbreak() {
      debugger;
      this.advance_pc();
    }
    int_sb() {
      this.memory.sb(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_sh() {
      this.memory.sh(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_sw() {
      this.memory.sw(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_swc1() {
      this.memory.sw(this.RS_IMM16, this.FT_I);
      this.advance_pc();
    }
    int_swl() {
      this.memory.swl(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_swr() {
      this.memory.swr(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_lb() {
      this.RT = this.memory.lb(this.RS_IMM16);
      this.advance_pc();
    }
    int_lbu() {
      this.RT = this.memory.lbu(this.RS_IMM16);
      this.advance_pc();
    }
    int_lh() {
      this.RT = this.memory.lh(this.RS_IMM16);
      this.advance_pc();
    }
    int_lhu() {
      this.RT = this.memory.lhu(this.RS_IMM16);
      this.advance_pc();
    }
    int_lw() {
      this.RT = this.memory.lw(this.RS_IMM16);
      this.advance_pc();
    }
    int_lwc1() {
      this.FT_I = this.memory.lw(this.RS_IMM16);
      this.advance_pc();
    }
    int_lwl() {
      this.RT = this.memory.lwl(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int_lwr() {
      this.RT = this.memory.lwr(this.RS_IMM16, this.RT);
      this.advance_pc();
    }
    int__link() {
      this.RA = this.nPC + 4;
    }
    int__branchN(cond) {
      this.advance_pc(cond ? this.imm16 * 4 : 4);
    }
    int__branchN_likely(cond) {
      if (cond) {
        this.advance_pc(this.imm16 * 4);
      } else {
        this.PC = this.nPC + 4;
        this.nPC = this.PC + 4;
      }
    }
    int__j(link) {
      if (link) {
        this.RA = this.PC + 8;
      }
      this.jump_pc(this.jump_address);
    }
    int__jr(link) {
      const newAddress = this.PC & 4026531840 | this.RS & ~3;
      if (link) {
        this.RD = this.PC + 8;
      }
      this.jump_pc(newAddress);
    }
    int_beq() {
      this.int__branchN(this.RS == this.RT);
    }
    int_bne() {
      this.int__branchN(this.RS != this.RT);
    }
    int_bltz() {
      this.int__branchN(this.RS < 0);
    }
    int_blez() {
      this.int__branchN(this.RS <= 0);
    }
    int_bgtz() {
      this.int__branchN(this.RS > 0);
    }
    int_bgez() {
      this.int__branchN(this.RS >= 0);
    }
    int_beql() {
      this.int__branchN_likely(this.RS == this.RT);
    }
    int_bnel() {
      this.int__branchN_likely(this.RS != this.RT);
    }
    int_bltzl() {
      this.int__branchN_likely(this.RS < 0);
    }
    int_blezl() {
      this.int__branchN_likely(this.RS <= 0);
    }
    int_bgtzl() {
      this.int__branchN_likely(this.RS > 0);
    }
    int_bgezl() {
      this.int__branchN_likely(this.RS >= 0);
    }
    int_bltzal() {
      this.int__link();
      this.int__branchN(this.RS < 0);
    }
    int_bgezal() {
      this.int__link();
      this.int__branchN(this.RS >= 0);
    }
    int_bltzall() {
      this.int__link();
      this.int__branchN_likely(this.RS < 0);
    }
    int_bgezall() {
      this.int__link();
      this.int__branchN_likely(this.RS >= 0);
    }
    int_bc1t() {
      this.int__branchN(this.fcr31_cc);
    }
    int_bc1f() {
      this.int__branchN(!this.fcr31_cc);
    }
    int_bc1tl() {
      this.int__branchN_likely(this.fcr31_cc);
    }
    int_bc1fl() {
      this.int__branchN_likely(!this.fcr31_cc);
    }
    int_mfc1() {
      this.RT = this.FS_I;
      this.advance_pc();
    }
    int_mtc1() {
      this.FS_I = this.RT;
      this.advance_pc();
    }
    int_cfc1() {
      this._cfc1_impl(this.rd, this.rt);
      this.advance_pc();
    }
    int_ctc1() {
      this._ctc1_impl(this.rd, this.RT);
      this.advance_pc();
    }
    int_j() {
      this.int__j(false);
    }
    int_jr() {
      this.int__jr(false);
    }
    int_jal() {
      this.int__j(true);
    }
    int_jalr() {
      this.int__jr(true);
    }
    "int_mov.s"() {
      this.FD = this.FS;
      this.advance_pc();
    }
    "int_add.s"() {
      this.FD = this.FS + this.FT;
      this.advance_pc();
    }
    "int_sub.s"() {
      this.FD = this.FS - this.FT;
      this.advance_pc();
    }
    "int_mul.s"() {
      this.FD = this.FS * this.FT;
      this.advance_pc();
    }
    "int_div.s"() {
      this.FD = this.FS / this.FT;
      this.advance_pc();
    }
    "int_abs.s"() {
      this.FD = Math.abs(this.FS);
      this.advance_pc();
    }
    "int_sqrt.s"() {
      this.FD = Math.sqrt(this.FS);
      this.advance_pc();
    }
    "int_neg.s"() {
      this.FD = -this.FS;
      this.advance_pc();
    }
    "int_trunc.w.s"() {
      this.FD_I = MathFloat.trunc(this.FS);
      this.advance_pc();
    }
    "int_round.w.s"() {
      this.FD_I = MathFloat.round(this.FS);
      this.advance_pc();
    }
    "int_ceil.w.s"() {
      this.FD_I = MathFloat.ceil(this.FS);
      this.advance_pc();
    }
    "int_floor.w.s"() {
      this.FD_I = MathFloat.floor(this.FS);
      this.advance_pc();
    }
    "int_cvt.s.w"() {
      this.FD = this.FS_I;
      this.advance_pc();
    }
    "int_cvt.w.s"() {
      this.FD_I = this._cvt_w_s_impl(this.FS);
      this.advance_pc();
    }
    "int_c.f.s"() {
      return this.int__comp(0, 0);
    }
    "int_c.un.s"() {
      return this.int__comp(1, 0);
    }
    "int_c.eq.s"() {
      return this.int__comp(2, 0);
    }
    "int_c.ueq.s"() {
      return this.int__comp(3, 0);
    }
    "int_c.olt.s"() {
      return this.int__comp(4, 0);
    }
    "int_c.ult.s"() {
      return this.int__comp(5, 0);
    }
    "int_c.ole.s"() {
      return this.int__comp(6, 0);
    }
    "int_c.ule.s"() {
      return this.int__comp(7, 0);
    }
    "int_c.sf.s"() {
      return this.int__comp(0, 1);
    }
    "int_c.ngle.s"() {
      return this.int__comp(1, 1);
    }
    "int_c.seq.s"() {
      return this.int__comp(2, 1);
    }
    "int_c.ngl.s"() {
      return this.int__comp(3, 1);
    }
    "int_c.lt.s"() {
      return this.int__comp(4, 1);
    }
    "int_c.nge.s"() {
      return this.int__comp(5, 1);
    }
    "int_c.le.s"() {
      return this.int__comp(6, 1);
    }
    "int_c.ngt.s"() {
      return this.int__comp(7, 1);
    }
    int__comp(fc02, fc3) {
      const fc_unordererd = (fc02 & 1) != 0;
      const fc_equal = (fc02 & 2) != 0;
      const fc_less = (fc02 & 4) != 0;
      const fc_inv_qnan = fc3 != 0;
      const s = this.FS;
      const t = this.FT;
      let result = false;
      if (isNaN(s) || isNaN(t)) {
        result = result || fc_unordererd;
      } else {
        if (fc_equal)
          result = result || s == t;
        if (fc_less)
          result = result || s < t;
      }
      this.fcr31_cc = result;
      this.advance_pc();
    }
  };
  var CpuState = _CpuState;
  CpuState.lastId = 0;
  CpuState._mult_temp = new Int32Array(2);
  var ast2 = new MipsAstBuilder();
  var PspInstructionStm = class extends ANodeStm {
    constructor(di, code) {
      super();
      this.di = di;
      this.code = code;
      this.PC = di.PC;
    }
    toJs() {
      return `${this.code.toJs()} /* ${this.di.type.name} */`;
    }
    optimize() {
      return new PspInstructionStm(this.di, this.code.optimize());
    }
  };
  var CpuFunctionWithArgs = class {
    constructor(func, args) {
      this.func = func;
      this.args = args;
    }
  };
  var InvalidatableCpuFunction = class {
    constructor(PC, generator) {
      this.PC = PC;
      this.generator = generator;
      this.func = null;
    }
    invalidate() {
      this.func = null;
    }
    execute(state) {
      if (this.func == null)
        this.func = this.generator(this.PC, 0);
      state.checkCycles(0);
      this.func.func(state);
    }
  };
  var InstructionCache = class {
    constructor(memory2, syscallManager) {
      this.memory = memory2;
      this.syscallManager = syscallManager;
      this.cache = {};
      this.functions = {};
      this.examinedAddress = {};
      this.functionGenerator = new FunctionGenerator(memory2, syscallManager, this);
      this.createBind = this.create.bind(this);
    }
    invalidateAll() {
      for (let pc2 in this.examinedAddress) {
        delete this.examinedAddress[pc2];
      }
      for (let pc2 in this.cache) {
        this.cache[pc2].invalidate();
        delete this.functions[pc2];
      }
    }
    invalidateRange(from, to) {
      for (let pc2 = from; pc2 < to; pc2 += 4) {
        if (this.cache[pc2])
          this.cache[pc2].invalidate();
        delete this.examinedAddress[pc2];
        delete this.functions[pc2];
      }
    }
    create(address, level) {
      this.examinedAddress[address] = true;
      const info = this.functionGenerator.getFunctionInfo(address, level);
      let func = this.functions[info.start];
      if (func === void 0) {
        this.functions[info.start] = void 0;
        this.functions[info.start] = func = this.functionGenerator.getFunction(info, level);
        if (DEBUG_FUNCGEN) {
          console.log("****************************************");
          console.log("****************************************");
          console.log(func.info);
          console.log(func.code.code);
        }
      }
      return func.fargs;
    }
    getFunction(address, level) {
      address &= Memory.MASK;
      if (!this.cache[address]) {
        this.cache[address] = new InvalidatableCpuFunction(address, this.createBind);
      }
      if (BUILD_FUNC_ON_REFERENCED) {
      }
      return this.cache[address];
    }
  };
  var FunctionGeneratorResult = class {
    constructor(func, code, info, fargs) {
      this.func = func;
      this.code = code;
      this.info = info;
      this.fargs = fargs;
    }
  };
  var FunctionCode = class {
    constructor(code, args) {
      this.code = code;
      this.args = args;
    }
  };
  var FunctionGenerator = class {
    constructor(memory2, syscallManager, instructionCache) {
      this.memory = memory2;
      this.syscallManager = syscallManager;
      this.instructionCache = instructionCache;
      this.instructions = Instructions.instance;
      this.instructionAst = new InstructionAst();
      this.instructionUsageCount = {};
      this.enableJumpBranch = true;
    }
    getInstructionUsageCount() {
      const items = [];
      for (const key in this.instructionUsageCount) {
        const value = this.instructionUsageCount[key];
        items.push({name: key, count: value});
      }
      items.sort((a, b) => compareNumbers(a.count, b.count)).reverse();
      return items;
    }
    decodeInstruction(address) {
      const instruction = Instruction.fromMemoryAndPC(this.memory, address);
      const instructionType = this.getInstructionType(instruction);
      return new DecodedInstruction(instruction, instructionType);
    }
    getInstructionType(i) {
      return this.instructions.findByData(i.IDATA, i.PC);
    }
    generatePspInstruction(di) {
      return new PspInstructionStm(di, this.generateInstructionAstNode(di));
    }
    generateInstructionAstNode(di) {
      const instruction = di.instruction;
      const instructionType = di.type;
      const func = this.instructionAst[instructionType.name];
      if (func === void 0)
        throw sprintf("Not implemented '%s' at 0x%08X", instructionType, di.instruction.PC);
      return func.call(this.instructionAst, instruction, di);
    }
    create(address, level) {
      return this.getFunction(this.getFunctionInfo(address, level), level);
    }
    getFunction(info, level) {
      const start = performance.now();
      const code = this.getFunctionCode(info, level);
      try {
        const startHex = addressToHex(info.start);
        const func = new Function("args", `return function func_${startHex}(state) { "use strict"; ${code.code} }`)(code.args);
        const result = new FunctionGeneratorResult(func, code, info, new CpuFunctionWithArgs(func, code.args));
        const end = performance.now();
        const elapsed = end - start;
        if (elapsed >= 20)
          console.warn(`generated function ${startHex} in ${end - start} ms. ${addressToHex(info.min)}-${addressToHex(info.max)} : ${addressToHex(info.start)} : instructions:${(info.max - info.start) / 4}`);
        return result;
      } catch (e) {
        console.info("code:\n", code.code);
        console.info("args:\n", code.args);
        console.error(e);
        throw e;
      }
    }
    getFunctionInfo(address, level) {
      if (address == 20148224)
        return {start: address, min: address, max: address + 4, labels: {}};
      if (address == 20148228)
        return {start: address, min: address, max: address + 4, labels: {}};
      if (address == 0)
        throw new ProgramExitException("Trying to execute 0x00000000");
      const explored = {};
      const explore = [address];
      const info = {start: address, min: address, max: address, labels: {}};
      const MAX_EXPLORE = 2e4;
      let exploredCount = 0;
      function addToExplore(pc2) {
        if (explored[pc2])
          return;
        explored[pc2] = true;
        explore.push(pc2);
      }
      while (explore.length > 0) {
        const PC = explore.shift();
        const di = this.decodeInstruction(PC);
        const type = di.type;
        info.min = Math.min(info.min, PC);
        info.max = Math.max(info.max, PC + 4);
        if (++exploredCount >= MAX_EXPLORE) {
          let disassembler = new MipsDisassembler();
          disassembler.dump(this.memory, info.min, 4, console.error);
          console.error("...");
          disassembler.dump(this.memory, info.max - 4 * 4, 4, console.error);
          console.error(this);
          throw new ProgramExitException(`Function too big ${exploredCount}`);
        }
        let exploreNext = true;
        const exploreTarget = type.isBranch && !type.isRegister;
        if (type.isBreak)
          exploreNext = false;
        if (type.isJumpNoLink)
          exploreNext = false;
        if (di.isUnconditional)
          exploreNext = false;
        if (exploreTarget) {
          if (di.targetAddress >= info.min - 8) {
            info.labels[di.targetAddress] = true;
            if (exploreNext)
              info.labels[PC + 8] = true;
            addToExplore(di.targetAddress);
          }
        }
        if (exploreNext) {
          addToExplore(PC + 4);
        }
      }
      info.labels[info.start] = true;
      info.labels[info.min] = true;
      return info;
    }
    detectSyscallCall(pc2) {
      const di = this.decodeInstruction(pc2);
      const di2 = this.decodeInstruction(pc2 + 4);
      if (di.type.name == "jr" && di2.type.name == "syscall") {
        return di2.instruction.vsyscall;
      } else {
        return -1;
      }
    }
    getFunctionCode(info, level) {
      const args = {};
      if (info.start == 20148224)
        return new FunctionCode("state.throwCpuBreakException();", args);
      if (info.start == 20148228)
        return new FunctionCode("state.throwInterruptBreakException();", args);
      const state_PC = `state.${CpuStateFields.PC}`;
      const state_RA = `state.${CpuStateFields.RA}`;
      const state_jumpCall = `state.${CpuStateFields.jumpCall}`;
      const func = ast2.func(info.start, ast2.raw_stm(`let label = 0, BRANCHPC = 0, BRANCHFLAG = false, expectedRA = 0, doJumps = false; const memory = state.memory, gpr = state.gpr, gpr_f = state.gpr_f;`), ast2.raw_stm(`${state_jumpCall} = null; return;`), []);
      const labels = {};
      for (let labelPC in info.labels)
        labels[labelPC] = ast2.label(labelPC);
      if (info.min != info.start) {
        func.add(ast2.sjump(ast2.raw("true"), info.start));
      }
      if (info.max - info.min == 4) {
        const syscallId = this.detectSyscallCall(info.min);
        if (syscallId >= 0) {
          return new FunctionCode(`
					/* ${this.syscallManager.getName(syscallId)} at ${addressToHex(info.start)} */
					${state_PC} = ${state_RA}; ${state_jumpCall} = null;
					state.syscall(${syscallId});
					return;
					`, args);
        }
      }
      let cycles = 0;
      function createCycles(PC) {
        let out = ast2.raw(`${state_PC} = ${addressToHex(PC)}; state.${CpuStateFields.checkCycles}(${cycles});`);
        cycles = 0;
        return out;
      }
      for (let PC = info.min; PC <= info.max; PC += 4) {
        const di = this.decodeInstruction(PC);
        const type = di.type;
        const ins = this.generatePspInstruction(di);
        let delayedSlotInstruction;
        cycles++;
        if (labels[PC])
          func.add(labels[PC]);
        if (type.name == "syscall") {
          func.add(ast2.raw(`${state_PC} = ${PC + 4};`));
        }
        if (!type.hasDelayedBranch) {
          func.add(ins);
        } else {
          const di2 = this.decodeInstruction(PC + 4);
          delayedSlotInstruction = this.generatePspInstruction(di2);
          let isLikely = di.type.isLikely;
          const delayedCode = ast2.stm(di.type.isLikely ? ast2._if(ast2.branchflag(), delayedSlotInstruction) : delayedSlotInstruction);
          const targetAddress = di.targetAddress & Memory.MASK;
          const nextAddress = PC + 8 & Memory.MASK;
          const targetAddressHex = addressToHex(targetAddress);
          const nextAddressHex = addressToHex(nextAddress);
          if (type.name == "jal" || type.name == "j") {
            const cachefuncName = `cache_${addressToHex(targetAddress)}`;
            args[cachefuncName] = this.instructionCache.getFunction(targetAddress, level + 1);
            func.add(ast2.raw(`${state_PC} = ${targetAddressHex};`));
            if (type.name == "j") {
              func.add(delayedCode);
              if (labels[targetAddress]) {
                func.add(ast2.sjump(ast2.raw("true"), targetAddress));
              } else {
                func.add(ast2.raw(`${state_jumpCall} = args.${cachefuncName};`));
                func.add(ast2.raw(`return;`));
              }
            } else {
              func.add(ast2.raw(`expectedRA = ${state_RA} = ${nextAddressHex};`));
              func.add(delayedCode);
              func.add(ast2.raw(`args.${cachefuncName}.execute(state);`));
              func.add(ast2.raw(`if (${state_PC} != expectedRA) { doJumps = true; break loop_label; }`));
            }
          } else if (type.isJal) {
            const cachefuncName = `cachefunc_${addressToHex(PC)}`;
            args[cachefuncName] = null;
            const cacheaddrName = `cacheaddr_${addressToHex(PC)}`;
            args[cacheaddrName] = -1;
            func.add(ins);
            func.add(delayedCode);
            func.add(ast2.raw("if (BRANCHFLAG) {"));
            func.add(ast2.raw(`${state_PC} = BRANCHPC & ${Memory.MASK};`));
            func.add(ast2.raw(`expectedRA = ${state_RA};`));
            func.add(ast2.raw(`if (args.${cacheaddrName} != ${state_PC}) args.${cachefuncName} = state.${CpuStateFields.getFunction}(args.${cacheaddrName} = ${state_PC});`));
            func.add(ast2.raw(`args.${cachefuncName}.execute(state);`));
            func.add(ast2.raw(`while ((${state_PC} != expectedRA) && (${state_jumpCall} != null)) ${state_jumpCall}.execute(state);`));
            func.add(ast2.raw(`if (${state_PC} != expectedRA) { ${state_jumpCall} = null; return; }`));
            func.add(ast2.raw("}"));
          } else if (type.isJumpNoLink) {
            func.add(createCycles(PC));
            if (type.name == "jr") {
              func.add(delayedCode);
              func.add(ast2.raw(`${state_PC} = ${CpuState.GPR_access("state", di.instruction.rs)};`));
              func.add(ast2.raw(`${state_jumpCall} = null;`));
              func.add(ast2.raw(`return;`));
            } else if (type.name == "j") {
              func.add(ins);
              func.add(delayedCode);
              func.add(ast2.raw(`${state_jumpCall} = state.${CpuStateFields.getFunction}(${state_PC} = BRANCHPC);`));
              func.add(ast2.raw(`return;`));
            } else {
              debugger;
              throw new Error("Unexpected!");
            }
          } else {
            if (type.isFixedAddressJump && labels[targetAddress]) {
              let bf = ins.code;
              if (isLikely) {
                func.add(ast2.sjump(bf.cond, targetAddress, delayedSlotInstruction));
              } else {
                func.add(ins);
                func.add(delayedCode);
                func.add(ast2.sjump(ast2.raw("BRANCHFLAG"), targetAddress));
              }
              func.add(createCycles(nextAddress));
            } else {
              func.add(createCycles(PC));
              func.add(ins);
              func.add(delayedCode);
              func.add(ast2.raw(`if (BRANCHFLAG) {`));
              func.add(ast2.raw(`${state_PC} = ${targetAddressHex};`));
              func.add(ast2.raw(`${state_jumpCall} = state.${CpuStateFields.getFunction}(${state_PC});`));
              func.add(ast2.raw(`return;`));
              func.add(ast2.raw(`}`));
            }
          }
          PC += 4;
        }
      }
      const code = func.toJs();
      args.code = code + `
            if (doJumps) {
                while ((${state_PC} != expectedRA) && (${state_jumpCall} != null)) ${state_jumpCall}.execute(state);
                ${state_jumpCall} = null;
                return;
            }
        `;
      return new FunctionCode(code, args);
    }
  };
  function createNativeFunction(exportId, firmwareVersion, retvalIType, arcITypes, that, internalFunc, options, classname, name2) {
    options = options || {};
    let code = "";
    let V0 = CpuState.GPR_access("state", 2);
    let V1 = CpuState.GPR_access("state", 3);
    const args = [];
    const maxGprIndex = 12;
    let gprindex = 4;
    let fprindex = 0;
    function _readGpr32() {
      if (gprindex >= maxGprIndex) {
        let gpr_29 = CpuState.GPR_access("state", 29);
        return `memory.lw(${gpr_29} + ` + (maxGprIndex - gprindex++) * 4 + ")";
      } else {
        return CpuState.GPR_access("state", gprindex++);
      }
    }
    function readFpr32() {
      return `state.state.${CpuStateFields.fpr}[${fprindex++}]`;
    }
    function readGpr32_S() {
      return `(${_readGpr32()} | 0)`;
    }
    function readGpr32_U() {
      return `(${_readGpr32()} >>> 0)`;
    }
    function readGpr64() {
      gprindex = MathUtils.nextAligned(gprindex, 2);
      const gprLow = readGpr32_S();
      const gprHigh = readGpr32_S();
      return `Integer64.fromBits(${gprLow}, ${gprHigh})`;
    }
    if (arcITypes) {
      arcITypes.forEach((item) => {
        switch (item) {
          case Int32:
            args.push(`${readGpr32_S()} | 0`);
            break;
          case UInt32:
            args.push(`${readGpr32_U()} >>> 0`);
            break;
          case BoolTypeType:
            args.push(`${readGpr32_S()} != 0`);
            break;
          case Ptr:
            args.push(`state.${CpuStateFields.memory}.getPointerStream(${readGpr32_S()})`);
            break;
          case BytesTypeType:
            args.push(`state.${CpuStateFields.memory}.getPointerStream(${readGpr32_S()}, ${readGpr32_S()})`);
            break;
          case ThreadTypeType:
            args.push(`state.${CpuStateFields.thread}`);
            break;
          case CpuStateTypeType:
            args.push(`state`);
            break;
          case MemoryTypeType:
            args.push(`state.${CpuStateFields.memory}`);
            break;
          case StringzVariable:
            args.push(`state.${CpuStateFields.memory}.readStringz(${readGpr32_S()})`);
            break;
          case Int64:
            args.push(readGpr64());
            break;
          default:
            if (item instanceof FixedBytesType) {
              args.push(`state.${CpuStateFields.memory}.getPointerU8Array(${readGpr32_S()}, ${item.size})`);
            } else {
              throw new Error(`Invalid parameter type ${item.constructor.name}`);
            }
        }
      });
    }
    if (options.disableInsideInterrupt) {
      code += `if (state.${CpuStateFields.insideInterrupt}) return 0x80020064; 
`;
    }
    code += "let error = false;\n";
    if (DEBUG_NATIVEFUNC) {
      code += `console.info(state.${CpuStateFields.thread}.name, nativeFunction.name);`;
    }
    code += `let result = internalFunc(${args.join(", ")});
`;
    if (!options.doNotWait) {
      code += `
            if (PromiseFast.isPromise(result)) {
                ${DEBUG_NATIVEFUNC ? 'console.log("returned promise!");' : ""}
                state.${CpuStateFields.thread}.suspendUntilPromiseDone(PromiseFast.ensure(result), nativeFunction);
                state.${CpuStateFields.throwEndCycles}();
                //return state.thread.suspendUntilPromiseDone(result, nativeFunction);
            }
            if (result instanceof WaitingThreadInfo) {
                ${DEBUG_NATIVEFUNC ? 'console.log("returned WaitingThreadInfo!");' : ""}
                if (PromiseFast.isPromise(result.promise)) {
                    state.${CpuStateFields.thread}.suspendUntilDone(result);
                    state.${CpuStateFields.throwEndCycles}();
                } else {
                    result = result.promise;
                }
            }
        `;
    }
    if (retvalIType) {
      switch (retvalIType) {
        case VoidTypeType:
          break;
        case Int32:
        case UInt32:
          code += `${V0} = result | 0;
`;
          break;
        case BoolTypeType:
          code += `${V0} = result ? 1 : 0;
`;
          break;
        case Float32:
          code += "state.fpr[0] = result;\n";
          break;
        case Int64:
          code += "if (!error) {\n";
          code += `if (!(result instanceof Integer64)) { logger.info("FUNC:", nativeFunction); throw(new Error("Invalid long result. Expecting Integer64 but found '" + result + "'.")); }
`;
          code += `${V0} = result.low; ${V1} = result.high;
`;
          code += "} else {\n";
          code += `${V0} = result; ${V1} = 0;
`;
          code += "}\n";
          break;
        default:
          throw new Error(`Invalid return value "${retvalIType}"`);
      }
    }
    const nativeFunction2 = new NativeFunction();
    nativeFunction2.name = name2 ?? "unknown";
    nativeFunction2.nid = exportId;
    nativeFunction2.firmwareVersion = firmwareVersion;
    if (DEBUG_FUNCGEN) {
      console.log(code);
    }
    nativeFunction2.nativeCall = internalFunc.bind(that);
    const funcName = ensureValidFunctionName(`${classname}.${name2}.${addressToHex(nativeFunction2.nid)}`);
    nativeFunction2.call = new Function("logger", "internalFunc", "nativeFunction", `return function ${funcName}_wrapper(context, state) { "use strict"; /* ${addressToHex(nativeFunction2.nid)} ${classname}.${name2} */
${code} };`)(logger, nativeFunction2.nativeCall, nativeFunction2);
    return nativeFunction2;
  }
  function ensureValidFunctionName(name2) {
    const out = String(name2).replace(/\W/g, "_");
    return out.substr(0, 1).match(/\d/) ? `_${out}` : out;
  }
  var CpuStateFields = fields();

  // src/core/cpu/cpu_interpreter.ts
  var dummy = new CpuState(null, null, null);
  var switchCode = DecodingTable.createSwitch(Instructions.instance.instructionTypeList, (iname) => {
    const iiname = `int_${iname}`;
    const qname = JSON.stringify(iiname);
    if (dummy[iiname]) {
      return `state[${qname}](); return;`;
    } else {
      return `state.int_unknown(${qname}); return;`;
    }
  });
  var interpretCpuInstruction = eval(`(function switchFunction(state) {
    "use strict";
    const pc = state.PC
    const value = state.memory.lw(pc)
    state.IDATA = value
    ${switchCode}
})`);

  // src/core/cpu/cpu_executor.ts
  var CpuExecutor = class {
    static executeAtPC(state) {
      state.startThreadStep();
      try {
        if (state.interpreted) {
          while (true) {
            if (state.PC == CpuSpecialAddresses.EXIT_INTERRUPT)
              state.throwInterruptBreakException();
            if (state.PC == CpuSpecialAddresses.EXIT_THREAD)
              state.throwCpuBreakException();
            interpretCpuInstruction(state);
          }
        } else {
          while (true) {
            state.getFunction(state.PC).execute(state);
          }
        }
      } catch (e) {
        if (InterruptBreakException.is(e))
          return;
        throw e;
      }
    }
    static executeAtPCAsync(state) {
      state.startThreadStep();
      try {
        if (state.interpreted) {
          for (let n = 0; n < 1e5; n++) {
            if (state.PC == CpuSpecialAddresses.EXIT_INTERRUPT)
              state.throwInterruptBreakException();
            if (state.PC == CpuSpecialAddresses.EXIT_THREAD)
              state.throwCpuBreakException();
            interpretCpuInstruction(state);
          }
        } else {
          state.getFunction(state.PC).execute(state);
        }
      } catch (e) {
        if (CpuBreakException.is(e))
          return;
        if (InterruptBreakException.is(e))
          return;
        throw e;
      }
    }
  };

  // src/core/interrupt.ts
  var InterruptHandler = class {
    constructor(no) {
      this.no = no;
      this.enabled = false;
      this.address = 0;
      this.argument = 0;
      this.cpuState = null;
    }
  };
  var InterruptHandlers = class {
    constructor(pspInterrupt) {
      this.pspInterrupt = pspInterrupt;
      this.handlers = {};
    }
    get(handlerIndex) {
      if (!this.handlers[handlerIndex])
        this.handlers[handlerIndex] = new InterruptHandler(handlerIndex);
      return this.handlers[handlerIndex];
    }
    remove(handlerIndex) {
      delete this.handlers[handlerIndex];
    }
    has(handlerIndex) {
      return this.handlers[handlerIndex] !== void 0;
    }
  };
  var InterruptManager = class {
    constructor() {
      this.enabled = true;
      this.flags = 4294967295;
      this.interruptHandlers = {};
      this.event = new Signal0();
      this.queue = [];
    }
    suspend() {
      const currentFlags = this.flags;
      this.flags = 0;
      this.enabled = false;
      return currentFlags;
    }
    resume(value) {
      this.flags = value;
      this.enabled = true;
    }
    get(pspInterrupt) {
      if (!this.interruptHandlers[pspInterrupt])
        this.interruptHandlers[pspInterrupt] = new InterruptHandlers(pspInterrupt);
      return this.interruptHandlers[pspInterrupt];
    }
    interrupt(pspInterrupt) {
      const interrupt = this.get(pspInterrupt);
      const handlers = interrupt.handlers;
      for (let n in handlers) {
        const handler = handlers[n];
        if (handler.enabled) {
          this.queue.push(handler);
          this.execute(null);
        }
      }
    }
    execute(_state) {
      while (this.queue.length > 0) {
        const item = this.queue.shift();
        const state = item.cpuState ?? _state;
        state.preserveRegisters(() => {
          state.RA = CpuSpecialAddresses.EXIT_INTERRUPT;
          state.setGPR(4, item.no);
          state.setGPR(5, item.argument);
          state.insideInterrupt = true;
          state.setPC(item.address);
          state.startThreadStep();
          CpuExecutor.executeAtPC(state);
        });
      }
    }
  };
  var PspInterrupts;
  (function(PspInterrupts2) {
    PspInterrupts2[PspInterrupts2["PSP_GPIO_INT"] = 4] = "PSP_GPIO_INT";
    PspInterrupts2[PspInterrupts2["PSP_ATA_INT"] = 5] = "PSP_ATA_INT";
    PspInterrupts2[PspInterrupts2["PSP_UMD_INT"] = 6] = "PSP_UMD_INT";
    PspInterrupts2[PspInterrupts2["PSP_MSCM0_INT"] = 7] = "PSP_MSCM0_INT";
    PspInterrupts2[PspInterrupts2["PSP_WLAN_INT"] = 8] = "PSP_WLAN_INT";
    PspInterrupts2[PspInterrupts2["PSP_AUDIO_INT"] = 10] = "PSP_AUDIO_INT";
    PspInterrupts2[PspInterrupts2["PSP_I2C_INT"] = 12] = "PSP_I2C_INT";
    PspInterrupts2[PspInterrupts2["PSP_SIRCS_INT"] = 14] = "PSP_SIRCS_INT";
    PspInterrupts2[PspInterrupts2["PSP_SYSTIMER0_INT"] = 15] = "PSP_SYSTIMER0_INT";
    PspInterrupts2[PspInterrupts2["PSP_SYSTIMER1_INT"] = 16] = "PSP_SYSTIMER1_INT";
    PspInterrupts2[PspInterrupts2["PSP_SYSTIMER2_INT"] = 17] = "PSP_SYSTIMER2_INT";
    PspInterrupts2[PspInterrupts2["PSP_SYSTIMER3_INT"] = 18] = "PSP_SYSTIMER3_INT";
    PspInterrupts2[PspInterrupts2["PSP_THREAD0_INT"] = 19] = "PSP_THREAD0_INT";
    PspInterrupts2[PspInterrupts2["PSP_NAND_INT"] = 20] = "PSP_NAND_INT";
    PspInterrupts2[PspInterrupts2["PSP_DMACPLUS_INT"] = 21] = "PSP_DMACPLUS_INT";
    PspInterrupts2[PspInterrupts2["PSP_DMA0_INT"] = 22] = "PSP_DMA0_INT";
    PspInterrupts2[PspInterrupts2["PSP_DMA1_INT"] = 23] = "PSP_DMA1_INT";
    PspInterrupts2[PspInterrupts2["PSP_MEMLMD_INT"] = 24] = "PSP_MEMLMD_INT";
    PspInterrupts2[PspInterrupts2["PSP_GE_INT"] = 25] = "PSP_GE_INT";
    PspInterrupts2[PspInterrupts2["PSP_VBLANK_INT"] = 30] = "PSP_VBLANK_INT";
    PspInterrupts2[PspInterrupts2["PSP_MECODEC_INT"] = 31] = "PSP_MECODEC_INT";
    PspInterrupts2[PspInterrupts2["PSP_HPREMOTE_INT"] = 36] = "PSP_HPREMOTE_INT";
    PspInterrupts2[PspInterrupts2["PSP_MSCM1_INT"] = 60] = "PSP_MSCM1_INT";
    PspInterrupts2[PspInterrupts2["PSP_MSCM2_INT"] = 61] = "PSP_MSCM2_INT";
    PspInterrupts2[PspInterrupts2["PSP_THREAD1_INT"] = 65] = "PSP_THREAD1_INT";
    PspInterrupts2[PspInterrupts2["PSP_INTERRUPT_INT"] = 66] = "PSP_INTERRUPT_INT";
    PspInterrupts2[PspInterrupts2["PSP_NUMBER_INTERRUPTS"] = 67] = "PSP_NUMBER_INTERRUPTS";
  })(PspInterrupts || (PspInterrupts = {}));

  // src/core/audio.ts
  var Sample = class {
    constructor(left, right) {
      this.left = left;
      this.right = right;
    }
    set(left, right) {
      this.left = left;
      this.right = right;
      return this;
    }
    scale(leftScale, rightScale) {
      this.left *= leftScale;
      this.right *= rightScale;
    }
    addScaled(sample, leftScale, rightScale) {
      this.left += sample.left * leftScale;
      this.right += sample.right * rightScale;
    }
    GetNextSample() {
    }
  };
  var PspAudioChannel = class {
    constructor(id, audio) {
      this.id = id;
      this.audio = audio;
    }
    start() {
      this.audio.onStart.dispatch(this.id);
    }
    stop() {
      this.audio.onStop.dispatch(this.id);
    }
    playAsync(channels, data, leftVolume, rightVolume) {
      return this.audio.onPlayDataAsync.dispatchAsync(this.id, channels, data, leftVolume, rightVolume);
    }
  };
  var PspAudio = class {
    constructor() {
      this.lastId = 0;
      this.playingChannels = new SortedSet();
      this.onPlayDataAsync = new SignalPromise();
      this.onStart = new Signal1();
      this.onStop = new Signal1();
    }
    createChannel() {
      return new PspAudioChannel(this.lastId++, this);
    }
    register() {
      this.lastId = 0;
    }
    unregister() {
      this.playingChannels.forEach((channel) => {
        channel.stop();
      });
      this.lastId = 0;
    }
    startAsync() {
      this.register();
      return PromiseFast.resolve();
    }
    stopAsync() {
      this.unregister();
      return PromiseFast.resolve();
    }
    frame() {
    }
  };
  function convertS16ToF32(channels, input, leftVolume, rightVolume) {
    const output = new Float32Array(input.length * 2 / channels);
    const optimized = leftVolume == 1 && rightVolume == 1;
    switch (channels) {
      case 2: {
        if (optimized) {
          for (let n = 0; n < output.length; n++)
            output[n] = input[n] / 32767;
        } else {
          for (let n = 0; n < output.length; n += 2) {
            output[n + 0] = input[n + 0] / 32767 * leftVolume;
            output[n + 1] = input[n + 1] / 32767 * rightVolume;
          }
        }
        break;
      }
      case 1: {
        if (optimized) {
          for (let n = 0, m = 0; n < input.length; n++) {
            output[m++] = output[m++] = input[n] / 32767;
          }
        } else {
          for (let n = 0, m = 0; n < input.length; n++) {
            let sample = input[n] / 32767;
            output[m++] = sample * leftVolume;
            output[m++] = sample * rightVolume;
          }
        }
        break;
      }
    }
    return output;
  }

  // src/core/display.ts
  var BasePspDisplay = class {
    constructor() {
      this.address = Memory.DEFAULT_FRAME_ADDRESS;
      this.bufferWidth = 512;
      this.pixelFormat = PixelFormat.RGBA_8888;
      this.sync = 1;
    }
  };
  var console2 = logger.named("display");
  var _PspDisplay = class extends BasePspDisplay {
    constructor(memory2, interruptManager, canvas, webglcanvas) {
      super();
      this.memory = memory2;
      this.interruptManager = interruptManager;
      this.canvas = canvas;
      this.webglcanvas = webglcanvas;
      this.vblank = new Signal1();
      this.enabled = true;
      this._hcount = 0;
      this.startTime = 0;
      this.currentMs = 0;
      this.elapsedSeconds = 0;
      this.hcountTotal = 0;
      this.hcountCurrent = 0;
      this.vblankCount = 0;
      this.isInVblank = false;
      this.rowsLeftForVblank = 0;
      this.secondsLeftForVblank = 0;
      this.rowsLeftForVblankStart = 0;
      this.secondsLeftForVblankStart = 0;
      this.frameLastMs = 0;
      this.frameCccumulatedMs = 0;
      this.mustWaitVBlank = true;
      this.lastTimeVblank = 0;
      if (this.canvas) {
        console2.info("Canvas");
        this.context = this.canvas.getContext("2d");
        this.imageData = this.context.createImageData(512, 272);
        this.setEnabledDisplay(true);
      } else {
        console2.info("NO Canvas");
        this.context = null;
        this.setEnabledDisplay(false);
      }
    }
    getCurrentMs() {
      return performance.now();
    }
    updateTime() {
      this.currentMs = this.getCurrentMs();
      this.elapsedSeconds = (this.currentMs - this.startTime) / 1e3;
      this.hcountTotal = this.elapsedSeconds * _PspDisplay.HORIZONTAL_SYNC_HZ | 0;
      this.hcountCurrent = (this.elapsedSeconds % 1.00002 * _PspDisplay.HORIZONTAL_SYNC_HZ | 0) % _PspDisplay.NUMBER_OF_ROWS;
      this.vblankCount = this.elapsedSeconds * _PspDisplay.VERTICAL_SYNC_HZ | 0;
      if (this.hcountCurrent >= _PspDisplay.VSYNC_ROW) {
        this.isInVblank = true;
        this.rowsLeftForVblank = 0;
        this.rowsLeftForVblankStart = _PspDisplay.NUMBER_OF_ROWS - this.hcountCurrent + _PspDisplay.VSYNC_ROW;
      } else {
        this.isInVblank = false;
        this.rowsLeftForVblank = _PspDisplay.VSYNC_ROW - this.hcountCurrent;
        this.rowsLeftForVblankStart = this.rowsLeftForVblank;
      }
      this.secondsLeftForVblank = this.rowsLeftForVblank * _PspDisplay.HORIZONTAL_SECONDS;
      this.secondsLeftForVblankStart = this.rowsLeftForVblankStart * _PspDisplay.HORIZONTAL_SECONDS;
    }
    update() {
      if (!this.context || !this.imageData)
        return;
      if (!this.enabled)
        return;
      const imageData = this.imageData;
      const w8 = imageData.data;
      const w32 = ArrayBufferUtils.uint8ToUint32(w8);
      const baseAddress = this.address & 268435455;
      PixelConverter.decode(this.pixelFormat, this.memory.getPointerU8Array(baseAddress), w32, false);
      this.context.putImageData(imageData, 0, 0);
    }
    setEnabledDisplay(enable) {
      this.enabled = enable;
      if (this.canvas)
        this.canvas.style.display = enable ? "block" : "none";
      if (this.webglcanvas)
        this.webglcanvas.style.display = !enable ? "block" : "none";
    }
    register() {
      this.startTime = this.getCurrentMs();
      this.updateTime();
    }
    unregister() {
    }
    frame() {
      const MAX_SIMULATE_FRAMES = 2;
      const VBLANK_MS = 1e3 / _PspDisplay.VERTICAL_SYNC_HZ;
      const currentMs = this.getCurrentMs();
      if (this.frameLastMs == 0)
        this.frameLastMs = currentMs;
      const elapsedMs = currentMs - this.frameLastMs;
      this.frameLastMs = currentMs;
      this.frameCccumulatedMs += elapsedMs;
      this.frameCccumulatedMs = Math.min(this.frameCccumulatedMs, VBLANK_MS * MAX_SIMULATE_FRAMES);
      while (this.frameCccumulatedMs >= VBLANK_MS) {
        this.frameCccumulatedMs -= VBLANK_MS;
        this.updateTime();
        this.vblankCount++;
        this.update();
        this.vblank.dispatch(this.vblankCount);
        this.interruptManager.interrupt(PspInterrupts.PSP_VBLANK_INT);
      }
    }
    checkVblankThrottle() {
      const currentTime = performance.now();
      if (currentTime - this.lastTimeVblank >= _PspDisplay.VERTICAL_SECONDS * 1e3) {
        this.lastTimeVblank = currentTime;
        return true;
      }
      return false;
    }
    async waitVblankAsync(waiter) {
      this.updateTime();
      if (!this.mustWaitVBlank)
        return 0;
      if (this.checkVblankThrottle())
        return 0;
      return waiter.delayMicrosecondsAsync(this.secondsLeftForVblank * 1e6, true);
    }
    async waitVblankStartAsync(waiter) {
      this.updateTime();
      if (!this.mustWaitVBlank)
        return 0;
      if (this.checkVblankThrottle())
        return 0;
      return waiter.delayMicrosecondsAsync(this.secondsLeftForVblankStart * 1e6, true);
    }
  };
  var PspDisplay = _PspDisplay;
  PspDisplay.PROCESSED_PIXELS_PER_SECOND = 9e6;
  PspDisplay.CYCLES_PER_PIXEL = 1;
  PspDisplay.PIXELS_IN_A_ROW = 525;
  PspDisplay.VSYNC_ROW = 272;
  PspDisplay.NUMBER_OF_ROWS = 286;
  PspDisplay.HCOUNT_PER_VBLANK = 285.72;
  PspDisplay.HORIZONTAL_SYNC_HZ = _PspDisplay.PROCESSED_PIXELS_PER_SECOND * _PspDisplay.CYCLES_PER_PIXEL / _PspDisplay.PIXELS_IN_A_ROW;
  PspDisplay.HORIZONTAL_SECONDS = 1 / _PspDisplay.HORIZONTAL_SYNC_HZ;
  PspDisplay.VERTICAL_SYNC_HZ = _PspDisplay.HORIZONTAL_SYNC_HZ / _PspDisplay.HCOUNT_PER_VBLANK;
  PspDisplay.VERTICAL_SECONDS = 1 / _PspDisplay.VERTICAL_SYNC_HZ;

  // src/core/battery.ts
  var Battery = class {
    constructor() {
      this.charging = false;
      this.level = 0;
      this.lifetime = 0;
    }
    get isLowBattery() {
      return this.level < 0.22;
    }
    get chargingType() {
      return +this.charging;
    }
    get iconStatus() {
      const level = this.level;
      if (level < 0.15)
        return BatteryStatusEnum.VeryLow;
      if (level < 0.3)
        return BatteryStatusEnum.Low;
      if (level < 0.8)
        return BatteryStatusEnum.PartiallyFilled;
      return BatteryStatusEnum.FullyFilled;
    }
  };
  var ChargingEnum;
  (function(ChargingEnum2) {
    ChargingEnum2[ChargingEnum2["NotCharging"] = 0] = "NotCharging";
    ChargingEnum2[ChargingEnum2["Charging"] = 1] = "Charging";
  })(ChargingEnum || (ChargingEnum = {}));
  var BatteryStatusEnum;
  (function(BatteryStatusEnum2) {
    BatteryStatusEnum2[BatteryStatusEnum2["VeryLow"] = 0] = "VeryLow";
    BatteryStatusEnum2[BatteryStatusEnum2["Low"] = 1] = "Low";
    BatteryStatusEnum2[BatteryStatusEnum2["PartiallyFilled"] = 2] = "PartiallyFilled";
    BatteryStatusEnum2[BatteryStatusEnum2["FullyFilled"] = 3] = "FullyFilled";
  })(BatteryStatusEnum || (BatteryStatusEnum = {}));

  // src/core/controller.ts
  var PspController = class {
    constructor() {
      this.data = new SceCtrlData();
      this.latchSamplingCount = 0;
      this.contributors = [];
    }
    addContributor(contributor) {
      this.addContributors(contributor);
    }
    addContributors(...contributors) {
      this.contributors.push(...contributors);
      contributors.forEach((it) => it.register());
      return this;
    }
    register() {
    }
    unregister() {
      let contributor;
      while (contributor = this.contributors.pop()) {
        contributor.unregister();
      }
    }
    frame() {
      this.data.reset();
      for (const contributor of this.contributors) {
        contributor.computeFrame();
        this.data.setToMerge(this.data, contributor.data);
      }
    }
  };
  var SceCtrlData = class extends Struct {
    constructor() {
      super();
      this.timeStamp = 0;
      this.buttons = PspCtrlButtons.none;
      this.lx = 0;
      this.ly = 0;
      this._rsrv = new Int32Array(5);
      this.x = 0;
      this.y = 0;
    }
    reset(timeStamp = 0) {
      this.timeStamp = timeStamp;
      this.buttons = PspCtrlButtons.none;
      this.x = 0;
      this.y = 0;
    }
    setToMerge(l, r) {
      this.timeStamp = l.timeStamp;
      this.x = l.x + r.x;
      this.y = l.y + r.y;
      this.buttons = l.buttons | r.buttons;
    }
    copyFrom(other) {
      this.timeStamp = other.timeStamp;
      this.buttons = other.buttons;
      this.lx = other.lx;
      this.ly = other.ly;
    }
    get x() {
      return MathUtils.clampM1_1((this.lx / 255 - 0.5) * 2);
    }
    get y() {
      return MathUtils.clampM1_1((this.ly / 255 - 0.5) * 2);
    }
    set x(value) {
      this.lx = MathUtils.clamp0_255((value / 2 + 0.5) * 255);
    }
    set y(value) {
      this.ly = MathUtils.clamp0_255((value / 2 + 0.5) * 255);
    }
  };
  __decorate([
    StructUInt32
  ], SceCtrlData.prototype, "timeStamp", 2);
  __decorate([
    StructUInt32
  ], SceCtrlData.prototype, "buttons", 2);
  __decorate([
    StructInt8
  ], SceCtrlData.prototype, "lx", 2);
  __decorate([
    StructInt8
  ], SceCtrlData.prototype, "ly", 2);
  __decorate([
    StructStructArray(Int8, 6)
  ], SceCtrlData.prototype, "_rsrv", 2);
  var PspControllerContributor = class {
    constructor() {
      this.data = new SceCtrlData();
    }
    computeFrame() {
    }
    register() {
    }
    unregister() {
    }
  };
  var PspCtrlButtons;
  (function(PspCtrlButtons2) {
    PspCtrlButtons2[PspCtrlButtons2["none"] = 0] = "none";
    PspCtrlButtons2[PspCtrlButtons2["select"] = 1] = "select";
    PspCtrlButtons2[PspCtrlButtons2["start"] = 8] = "start";
    PspCtrlButtons2[PspCtrlButtons2["up"] = 16] = "up";
    PspCtrlButtons2[PspCtrlButtons2["right"] = 32] = "right";
    PspCtrlButtons2[PspCtrlButtons2["down"] = 64] = "down";
    PspCtrlButtons2[PspCtrlButtons2["left"] = 128] = "left";
    PspCtrlButtons2[PspCtrlButtons2["leftTrigger"] = 256] = "leftTrigger";
    PspCtrlButtons2[PspCtrlButtons2["rightTrigger"] = 512] = "rightTrigger";
    PspCtrlButtons2[PspCtrlButtons2["triangle"] = 4096] = "triangle";
    PspCtrlButtons2[PspCtrlButtons2["circle"] = 8192] = "circle";
    PspCtrlButtons2[PspCtrlButtons2["cross"] = 16384] = "cross";
    PspCtrlButtons2[PspCtrlButtons2["square"] = 32768] = "square";
    PspCtrlButtons2[PspCtrlButtons2["home"] = 65536] = "home";
    PspCtrlButtons2[PspCtrlButtons2["hold"] = 131072] = "hold";
    PspCtrlButtons2[PspCtrlButtons2["wirelessLanUp"] = 262144] = "wirelessLanUp";
    PspCtrlButtons2[PspCtrlButtons2["remote"] = 524288] = "remote";
    PspCtrlButtons2[PspCtrlButtons2["volumeUp"] = 1048576] = "volumeUp";
    PspCtrlButtons2[PspCtrlButtons2["volumeDown"] = 2097152] = "volumeDown";
    PspCtrlButtons2[PspCtrlButtons2["screen"] = 4194304] = "screen";
    PspCtrlButtons2[PspCtrlButtons2["note"] = 8388608] = "note";
    PspCtrlButtons2[PspCtrlButtons2["discPresent"] = 16777216] = "discPresent";
    PspCtrlButtons2[PspCtrlButtons2["memoryStickPresent"] = 33554432] = "memoryStickPresent";
  })(PspCtrlButtons || (PspCtrlButtons = {}));

  // src/hle/structs.ts
  var SeekAnchor;
  (function(SeekAnchor2) {
    SeekAnchor2[SeekAnchor2["Set"] = 0] = "Set";
    SeekAnchor2[SeekAnchor2["Cursor"] = 1] = "Cursor";
    SeekAnchor2[SeekAnchor2["End"] = 2] = "End";
  })(SeekAnchor || (SeekAnchor = {}));
  var SceMode;
  (function(SceMode2) {
  })(SceMode || (SceMode = {}));
  var IOFileModes;
  (function(IOFileModes2) {
    IOFileModes2[IOFileModes2["FormatMask"] = 56] = "FormatMask";
    IOFileModes2[IOFileModes2["SymbolicLink"] = 8] = "SymbolicLink";
    IOFileModes2[IOFileModes2["Directory"] = 16] = "Directory";
    IOFileModes2[IOFileModes2["File"] = 32] = "File";
    IOFileModes2[IOFileModes2["CanRead"] = 4] = "CanRead";
    IOFileModes2[IOFileModes2["CanWrite"] = 2] = "CanWrite";
    IOFileModes2[IOFileModes2["CanExecute"] = 1] = "CanExecute";
  })(IOFileModes || (IOFileModes = {}));
  var _ScePspDateTime = class extends Struct {
    constructor() {
      super(...arguments);
      this.year = 0;
      this.month = 0;
      this.day = 0;
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
      this.microseconds = 0;
    }
    static fromDate(date) {
      if (!date)
        date = new Date();
      const pspdate = new _ScePspDateTime();
      pspdate.year = date.getFullYear();
      pspdate.month = date.getMonth();
      pspdate.day = date.getDay();
      pspdate.hour = date.getHours();
      pspdate.minute = date.getMinutes();
      pspdate.second = date.getSeconds();
      pspdate.microseconds = date.getMilliseconds() * 1e3;
      return pspdate;
    }
    static fromTicks(ticks) {
      return _ScePspDateTime.fromDate(new Date(ticks.getNumber()));
    }
    getTotalMicroseconds() {
      return Integer64.fromNumber(Date.UTC(this.year + 1970, this.month - 1, this.day, this.hour, this.minute, this.second, this.microseconds / 1e3) * 1e3);
    }
  };
  var ScePspDateTime = _ScePspDateTime;
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "year", 2);
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "month", 2);
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "day", 2);
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "hour", 2);
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "minute", 2);
  __decorate([
    StructInt16
  ], ScePspDateTime.prototype, "second", 2);
  __decorate([
    StructInt32
  ], ScePspDateTime.prototype, "microseconds", 2);
  var SceIoStat = class extends Struct {
    constructor() {
      super(...arguments);
      this.mode = 0;
      this.attributes = 32;
      this.size = 0;
      this.timeCreation = new ScePspDateTime();
      this.timeLastAccess = new ScePspDateTime();
      this.timeLastModification = new ScePspDateTime();
      this.deviceDependentData = [0, 0, 0, 0, 0, 0];
    }
  };
  __decorate([
    StructInt32
  ], SceIoStat.prototype, "mode", 2);
  __decorate([
    StructInt32
  ], SceIoStat.prototype, "attributes", 2);
  __decorate([
    StructInt64
  ], SceIoStat.prototype, "size", 2);
  __decorate([
    StructMember(ScePspDateTime.struct)
  ], SceIoStat.prototype, "timeCreation", 2);
  __decorate([
    StructMember(ScePspDateTime.struct)
  ], SceIoStat.prototype, "timeLastAccess", 2);
  __decorate([
    StructMember(ScePspDateTime.struct)
  ], SceIoStat.prototype, "timeLastModification", 2);
  __decorate([
    StructStructArray(Int32, 6)
  ], SceIoStat.prototype, "deviceDependentData", 2);
  var HleIoDirent = class extends Struct {
    constructor() {
      super(...arguments);
      this.stat = new SceIoStat();
      this.name = "";
      this.privateData = 0;
      this.dummy = 0;
    }
  };
  __decorate([
    StructMember(SceIoStat.struct)
  ], HleIoDirent.prototype, "stat", 2);
  __decorate([
    StructStructStringz(256)
  ], HleIoDirent.prototype, "name", 2);
  __decorate([
    StructInt32
  ], HleIoDirent.prototype, "privateData", 2);
  __decorate([
    StructInt32
  ], HleIoDirent.prototype, "dummy", 2);
  var PspLanguages;
  (function(PspLanguages2) {
    PspLanguages2[PspLanguages2["JAPANESE"] = 0] = "JAPANESE";
    PspLanguages2[PspLanguages2["ENGLISH"] = 1] = "ENGLISH";
    PspLanguages2[PspLanguages2["FRENCH"] = 2] = "FRENCH";
    PspLanguages2[PspLanguages2["SPANISH"] = 3] = "SPANISH";
    PspLanguages2[PspLanguages2["GERMAN"] = 4] = "GERMAN";
    PspLanguages2[PspLanguages2["ITALIAN"] = 5] = "ITALIAN";
    PspLanguages2[PspLanguages2["DUTCH"] = 6] = "DUTCH";
    PspLanguages2[PspLanguages2["PORTUGUESE"] = 7] = "PORTUGUESE";
    PspLanguages2[PspLanguages2["RUSSIAN"] = 8] = "RUSSIAN";
    PspLanguages2[PspLanguages2["KOREAN"] = 9] = "KOREAN";
    PspLanguages2[PspLanguages2["TRADITIONAL_CHINESE"] = 10] = "TRADITIONAL_CHINESE";
    PspLanguages2[PspLanguages2["SIMPLIFIED_CHINESE"] = 11] = "SIMPLIFIED_CHINESE";
  })(PspLanguages || (PspLanguages = {}));
  var ButtonPreference;
  (function(ButtonPreference2) {
    ButtonPreference2[ButtonPreference2["JAP"] = 0] = "JAP";
    ButtonPreference2[ButtonPreference2["NA"] = 1] = "NA";
  })(ButtonPreference || (ButtonPreference = {}));

  // src/hle/config.ts
  var Config = class {
    constructor() {
      this.language = PspLanguages.ENGLISH;
      this.buttonPreference = ButtonPreference.NA;
      this.language = Config.detectLanguage();
    }
    static detectLanguage() {
      if (typeof navigator == "undefined")
        return PspLanguages.ENGLISH;
      if (!navigator.language)
        return PspLanguages.ENGLISH;
      switch (navigator.language.split(/[_\-]/g)[0]) {
        case "ja":
          return PspLanguages.JAPANESE;
        case "en":
          return PspLanguages.ENGLISH;
        case "fr":
          return PspLanguages.FRENCH;
        case "es":
          return PspLanguages.SPANISH;
        case "de":
          return PspLanguages.GERMAN;
        case "it":
          return PspLanguages.ITALIAN;
        case "nl":
          return PspLanguages.DUTCH;
        case "pt":
          return PspLanguages.PORTUGUESE;
        case "ru":
          return PspLanguages.RUSSIAN;
        case "ko":
          return PspLanguages.KOREAN;
        case "zh":
          return PspLanguages.TRADITIONAL_CHINESE;
        case "zh2":
          return PspLanguages.SIMPLIFIED_CHINESE;
        default:
          return PspLanguages.ENGLISH;
      }
    }
  };

  // src/hle/module/ExceptionManagerForKernel.ts
  var ExceptionManagerForKernel_exports = {};
  __export(ExceptionManagerForKernel_exports, {
    ExceptionManagerForKernel: () => ExceptionManagerForKernel
  });

  // src/hle/utils.ts
  function nativeFunction(exportId, firmwareVersion, options) {
    return (target, key, descriptor) => {
      if (typeof target.natives == "undefined")
        target.natives = [];
      if (typeof target.nativesParams == "undefined")
        target.nativesParams = {};
      if (typeof target.nativeRet == "undefined")
        target.nativeRet = {};
      if (!descriptor) {
        console.error("descriptor == null");
        console.error(target);
        console.error(key);
        console.error(descriptor);
      }
      target.natives.push((target2) => {
        return createNativeFunction(exportId, firmwareVersion, target2.nativeRet[key], target2.nativesParams[key], target2, descriptor.value, options, `${target2.constructor.name}`, key);
      });
      return descriptor;
    };
  }
  function param(type) {
    return (target, key, info) => {
      if (typeof info == "number") {
        const parameterIndex = info;
        if (typeof target.nativesParams == "undefined")
          target.nativesParams = {};
        if (!target.nativesParams[key])
          target.nativesParams[key] = [];
        target.nativesParams[key][parameterIndex] = type;
      } else {
        if (typeof target.nativeRet == "undefined")
          target.nativeRet = {};
        target.nativeRet[key] = type;
      }
    };
  }
  var VOID = param(VoidTypeType);
  var STRING = param(StringzVariable);
  var THREAD = param(ThreadTypeType);
  var CPUSTATE = param(CpuStateTypeType);
  var MEMORY = param(MemoryTypeType);
  var I64 = param(Int64);
  var F32 = param(Float32);
  var U32 = param(UInt32);
  var I32 = param(Int32);
  var BOOL = param(BoolTypeType);
  var PTR = param(Ptr);
  var BYTES = param(BytesTypeType);
  function FBYTES(size) {
    return param(new FixedBytesType(size));
  }

  // src/hle/module/ExceptionManagerForKernel.ts
  var ExceptionManagerForKernel = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelRegisterDefaultExceptionHandler(exceptionHandlerFunction) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(1448872718, 150),
    U32,
    __param(0, U32)
  ], ExceptionManagerForKernel.prototype, "sceKernelRegisterDefaultExceptionHandler", 1);

  // src/hle/module/InterruptManager.ts
  var InterruptManager_exports = {};
  __export(InterruptManager_exports, {
    InterruptManager: () => InterruptManager3
  });
  var InterruptManager3 = class {
    constructor(context) {
      this.context = context;
      this.context.display.vblank.add(() => {
      });
    }
    sceKernelRegisterSubIntrHandler(thread, interrupt, handlerIndex, callbackAddress, callbackArgument) {
      const interruptManager = this.context.interruptManager;
      const interruptHandler = interruptManager.get(interrupt).get(handlerIndex);
      console.info(`sceKernelRegisterSubIntrHandler: ${PspInterrupts[interrupt]}: ${handlerIndex}: ${addressToHex(callbackAddress)}: ${addressToHex(callbackArgument)}`);
      interruptHandler.address = callbackAddress;
      interruptHandler.argument = callbackArgument;
      interruptHandler.cpuState = thread.state;
      return 0;
    }
    sceKernelEnableSubIntr(interrupt, handlerIndex) {
      const interruptManager = this.context.interruptManager;
      if (interrupt >= PspInterrupts.PSP_NUMBER_INTERRUPTS)
        return -1;
      if (!interruptManager.get(interrupt).has(handlerIndex))
        return -1;
      interruptManager.get(interrupt).get(handlerIndex).enabled = true;
      return 0;
    }
    sceKernelReleaseSubIntrHandler(pspInterrupt, handlerIndex) {
      const interruptManager = this.context.interruptManager;
      if (pspInterrupt >= PspInterrupts.PSP_NUMBER_INTERRUPTS)
        return -1;
      if (!interruptManager.get(pspInterrupt).has(handlerIndex))
        return -1;
      interruptManager.get(pspInterrupt).get(handlerIndex).enabled = false;
      return 0;
    }
  };
  __decorate([
    nativeFunction(3389301433, 150),
    U32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32),
    __param(3, U32),
    __param(4, U32)
  ], InterruptManager3.prototype, "sceKernelRegisterSubIntrHandler", 1);
  __decorate([
    nativeFunction(4220396268, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], InterruptManager3.prototype, "sceKernelEnableSubIntr", 1);
  __decorate([
    nativeFunction(3592317281, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], InterruptManager3.prototype, "sceKernelReleaseSubIntrHandler", 1);

  // src/hle/module/KDebugForKernel.ts
  var KDebugForKernel_exports = {};
  __export(KDebugForKernel_exports, {
    KDebugForKernel: () => KDebugForKernel
  });
  var KDebugForKernel = class {
    constructor(context) {
      this.context = context;
    }
    Kprintf(format) {
      console.info(`Kprintf: ${format}`);
    }
  };
  __decorate([
    nativeFunction(2230546620, 150),
    VOID,
    __param(0, STRING)
  ], KDebugForKernel.prototype, "Kprintf", 1);

  // src/hle/module/Kernel_Library.ts
  var Kernel_Library_exports = {};
  __export(Kernel_Library_exports, {
    Kernel_Library: () => Kernel_Library
  });
  var Kernel_Library = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelCpuSuspendIntr() {
      return PromiseFast.resolve(this.context.interruptManager.suspend());
    }
    sceKernelCpuResumeIntr(thread, flags) {
      this.context.interruptManager.resume(flags);
      thread.sceKernelCpuResumeIntrCount++;
      if (thread.sceKernelCpuResumeIntrCount >= 3) {
        thread.sceKernelCpuResumeIntrCount = 0;
        return PromiseFast.resolve(0);
      } else {
        return PromiseFast.resolve(0);
      }
    }
    sceKernelMemset(address, value, size) {
      this.context.memory.memset(address, value, size);
      return address;
    }
    sceKernelMemcpy(dst, src, size) {
      this.context.memory.copy(src, dst, size);
      return dst;
    }
  };
  __decorate([
    nativeFunction(153708788, 150),
    U32
  ], Kernel_Library.prototype, "sceKernelCpuSuspendIntr", 1);
  __decorate([
    nativeFunction(1594938374, 150),
    U32,
    __param(0, THREAD),
    __param(1, U32)
  ], Kernel_Library.prototype, "sceKernelCpuResumeIntr", 1);
  __decorate([
    nativeFunction(2693393572, 150),
    U32,
    __param(0, U32),
    __param(1, I32),
    __param(2, I32)
  ], Kernel_Library.prototype, "sceKernelMemset", 1);
  __decorate([
    nativeFunction(406422826, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, I32)
  ], Kernel_Library.prototype, "sceKernelMemcpy", 1);

  // src/hle/module/LoadCoreForKernel.ts
  var LoadCoreForKernel_exports = {};
  __export(LoadCoreForKernel_exports, {
    LoadCoreForKernel: () => LoadCoreForKernel
  });
  var LoadCoreForKernel = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelIcacheClearAll() {
      this.context.currentInstructionCache.invalidateAll();
    }
    sceKernelFindModuleByUID(moduleID) {
      console.warn(`Not implemented sceKernelFindModuleByUID(${moduleID})`);
      return 0;
    }
  };
  __decorate([
    nativeFunction(3631717062, 150),
    VOID
  ], LoadCoreForKernel.prototype, "sceKernelIcacheClearAll", 1);
  __decorate([
    nativeFunction(3437535575, 150),
    I32,
    __param(0, I32)
  ], LoadCoreForKernel.prototype, "sceKernelFindModuleByUID", 1);

  // src/hle/module/LoadExecForUser.ts
  var LoadExecForUser_exports = {};
  __export(LoadExecForUser_exports, {
    LoadExecForUser: () => LoadExecForUser
  });
  var console3 = logger.named("module.LoadExecForUser");
  var LoadExecForUser = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelExitGame(thread, state) {
      console3.info("sceKernelExitGame");
      thread.stop("sceKernelExitGame");
      this.context.threadManager.exitGame(0);
      state.throwEndCycles();
      return 0;
    }
    sceKernelExitGame2(thread, state) {
      console3.info("Call stack:");
      state.printCallstack(this.context.symbolLookup);
      console3.info("sceKernelExitGame2");
      this.context.threadManager.exitGame(0);
      thread.stop("sceKernelExitGame2");
      state.throwEndCycles();
    }
    sceKernelRegisterExitCallback(callbackId) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(3173978260, 150),
    U32,
    __param(0, THREAD),
    __param(1, CPUSTATE)
  ], LoadExecForUser.prototype, "sceKernelExitGame", 1);
  __decorate([
    nativeFunction(89598559, 150),
    U32,
    __param(0, THREAD),
    __param(1, CPUSTATE)
  ], LoadExecForUser.prototype, "sceKernelExitGame2", 1);
  __decorate([
    nativeFunction(1254455619, 150),
    U32,
    __param(0, I32)
  ], LoadExecForUser.prototype, "sceKernelRegisterExitCallback", 1);

  // src/hle/module/ModuleMgrForUser.ts
  var ModuleMgrForUser_exports = {};
  __export(ModuleMgrForUser_exports, {
    ModuleMgrForUser: () => ModuleMgrForUser
  });
  var ModuleMgrForUser = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelStopModule() {
      return 0;
    }
    sceKernelUnloadModule(id) {
      return 0;
    }
    sceKernelSelfStopUnloadModule(unknown, argsize, argp, thread) {
      console.info("Call stack:");
      thread.state.printCallstack(this.context.symbolLookup);
      console.warn(sprintf("Not implemented ModuleMgrForUser.sceKernelSelfStopUnloadModule(%d, %d, %d)", unknown, argsize, argp));
      throw new Error("sceKernelSelfStopUnloadModule");
    }
    sceKernelStopUnloadSelfModule(argsize, argp, optionsAddress, thread) {
      throw new Error("sceKernelStopUnloadSelfModule");
    }
    sceKernelLoadModule(path, flags, sceKernelLMOption) {
      console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelLoadModule("%s", %d)', path, flags));
      return 143654912;
    }
    sceKernelStartModule(moduleId, argumentSize, argumentPointer, status, sceKernelSMOption) {
      console.warn(sprintf("Not implemented ModuleMgrForUser.sceKernelStartModule(%d, %d, %d)", moduleId, argumentSize, argumentPointer));
      return 0;
    }
    sceKernelGetModuleIdByAddress(address) {
      console.warn(sprintf("Not implemented ModuleMgrForUser.sceKernelGetModuleIdByAddress(%08X)", address));
      return 3;
    }
    sceKernelGetModuleId() {
      console.warn(sprintf("Not implemented ModuleMgrForUser.sceKernelGetModuleId()"));
      return 4;
    }
    sceKernelLoadModuleByID(fileId, flags, sceKernelLMOption) {
      console.warn(sprintf("Not implemented ModuleMgrForUser.sceKernelLoadModuleByID(%d, %08X)", fileId, flags));
      return 0;
    }
  };
  __decorate([
    nativeFunction(3523188778, 150),
    U32
  ], ModuleMgrForUser.prototype, "sceKernelStopModule", 1);
  __decorate([
    nativeFunction(772346282, 150),
    U32,
    __param(0, I32)
  ], ModuleMgrForUser.prototype, "sceKernelUnloadModule", 1);
  __decorate([
    nativeFunction(3598052280, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, THREAD)
  ], ModuleMgrForUser.prototype, "sceKernelSelfStopUnloadModule", 1);
  __decorate([
    nativeFunction(3424466585, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, THREAD)
  ], ModuleMgrForUser.prototype, "sceKernelStopUnloadSelfModule", 1);
  __decorate([
    nativeFunction(2541609862, 150),
    U32,
    __param(0, STRING),
    __param(1, U32),
    __param(2, PTR)
  ], ModuleMgrForUser.prototype, "sceKernelLoadModule", 1);
  __decorate([
    nativeFunction(1357955564, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, U32),
    __param(3, PTR),
    __param(4, PTR)
  ], ModuleMgrForUser.prototype, "sceKernelStartModule", 1);
  __decorate([
    nativeFunction(3635884327, 150),
    U32,
    __param(0, U32)
  ], ModuleMgrForUser.prototype, "sceKernelGetModuleIdByAddress", 1);
  __decorate([
    nativeFunction(4037174165, 150),
    U32
  ], ModuleMgrForUser.prototype, "sceKernelGetModuleId", 1);
  __decorate([
    nativeFunction(3086247448, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, PTR)
  ], ModuleMgrForUser.prototype, "sceKernelLoadModuleByID", 1);

  // src/hle/module/sceAtrac3plus.ts
  var sceAtrac3plus_exports = {};
  __export(sceAtrac3plus_exports, {
    sceAtrac3plus: () => sceAtrac3plus
  });

  // src/hle/SceKernelErrors.ts
  var SceKernelErrors;
  (function(SceKernelErrors2) {
    SceKernelErrors2[SceKernelErrors2["ERROR_OK"] = 0] = "ERROR_OK";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERROR"] = 2147614721] = "ERROR_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_NOTIMP"] = 2147614722] = "ERROR_NOTIMP";
    SceKernelErrors2[SceKernelErrors2["ERROR_ALREADY"] = 2147483680] = "ERROR_ALREADY";
    SceKernelErrors2[SceKernelErrors2["ERROR_BUSY"] = 2147483681] = "ERROR_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_OUT_OF_MEMORY"] = 2147483682] = "ERROR_OUT_OF_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_ID"] = 2147483904] = "ERROR_INVALID_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_NAME"] = 2147483905] = "ERROR_INVALID_NAME";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_INDEX"] = 2147483906] = "ERROR_INVALID_INDEX";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_POINTER"] = 2147483907] = "ERROR_INVALID_POINTER";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_SIZE"] = 2147483908] = "ERROR_INVALID_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_FLAG"] = 2147483909] = "ERROR_INVALID_FLAG";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_COMMAND"] = 2147483910] = "ERROR_INVALID_COMMAND";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_MODE"] = 2147483911] = "ERROR_INVALID_MODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_FORMAT"] = 2147483912] = "ERROR_INVALID_FORMAT";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_VALUE"] = 2147484158] = "ERROR_INVALID_VALUE";
    SceKernelErrors2[SceKernelErrors2["ERROR_INVALID_ARGUMENT"] = 2147484159] = "ERROR_INVALID_ARGUMENT";
    SceKernelErrors2[SceKernelErrors2["ERROR_BAD_FILE"] = 2147484169] = "ERROR_BAD_FILE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ACCESS_ERROR"] = 2147484173] = "ERROR_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_OPERATION_NOT_PERMITTED"] = 2147549185] = "ERROR_ERRNO_OPERATION_NOT_PERMITTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_NOT_FOUND"] = 2147549186] = "ERROR_ERRNO_FILE_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_OPEN_ERROR"] = 2147549187] = "ERROR_ERRNO_FILE_OPEN_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_IO_ERROR"] = 2147549189] = "ERROR_ERRNO_IO_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_ARG_LIST_TOO_LONG"] = 2147549191] = "ERROR_ERRNO_ARG_LIST_TOO_LONG";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_FILE_DESCRIPTOR"] = 2147549193] = "ERROR_ERRNO_INVALID_FILE_DESCRIPTOR";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_RESOURCE_UNAVAILABLE"] = 2147549195] = "ERROR_ERRNO_RESOURCE_UNAVAILABLE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NO_MEMORY"] = 2147549196] = "ERROR_ERRNO_NO_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NO_PERM"] = 2147549197] = "ERROR_ERRNO_NO_PERM";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_INVALID_ADDR"] = 2147549198] = "ERROR_ERRNO_FILE_INVALID_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_DEVICE_BUSY"] = 2147549200] = "ERROR_ERRNO_DEVICE_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_ALREADY_EXISTS"] = 2147549201] = "ERROR_ERRNO_FILE_ALREADY_EXISTS";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_CROSS_DEV_LINK"] = 2147549202] = "ERROR_ERRNO_CROSS_DEV_LINK";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_DEVICE_NOT_FOUND"] = 2147549203] = "ERROR_ERRNO_DEVICE_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NOT_A_DIRECTORY"] = 2147549204] = "ERROR_ERRNO_NOT_A_DIRECTORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_IS_DIRECTORY"] = 2147549205] = "ERROR_ERRNO_IS_DIRECTORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_ARGUMENT"] = 2147549206] = "ERROR_ERRNO_INVALID_ARGUMENT";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_TOO_MANY_OPEN_SYSTEM_FILES"] = 2147549208] = "ERROR_ERRNO_TOO_MANY_OPEN_SYSTEM_FILES";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_IS_TOO_BIG"] = 2147549211] = "ERROR_ERRNO_FILE_IS_TOO_BIG";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_DEVICE_NO_FREE_SPACE"] = 2147549212] = "ERROR_ERRNO_DEVICE_NO_FREE_SPACE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_READ_ONLY"] = 2147549214] = "ERROR_ERRNO_READ_ONLY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_CLOSED"] = 2147549216] = "ERROR_ERRNO_CLOSED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_PATH_TOO_LONG"] = 2147549220] = "ERROR_ERRNO_FILE_PATH_TOO_LONG";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_PROTOCOL"] = 2147549255] = "ERROR_ERRNO_FILE_PROTOCOL";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_DIRECTORY_IS_NOT_EMPTY"] = 2147549274] = "ERROR_ERRNO_DIRECTORY_IS_NOT_EMPTY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_TOO_MANY_SYMBOLIC_LINKS"] = 2147549276] = "ERROR_ERRNO_TOO_MANY_SYMBOLIC_LINKS";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_ADDR_IN_USE"] = 2147549282] = "ERROR_ERRNO_FILE_ADDR_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_CONNECTION_ABORTED"] = 2147549287] = "ERROR_ERRNO_CONNECTION_ABORTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_CONNECTION_RESET"] = 2147549288] = "ERROR_ERRNO_CONNECTION_RESET";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NO_FREE_BUF_SPACE"] = 2147549289] = "ERROR_ERRNO_NO_FREE_BUF_SPACE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_TIMEOUT"] = 2147549294] = "ERROR_ERRNO_FILE_TIMEOUT";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_IN_PROGRESS"] = 2147549303] = "ERROR_ERRNO_IN_PROGRESS";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_ALREADY"] = 2147549304] = "ERROR_ERRNO_ALREADY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NO_MEDIA"] = 2147549307] = "ERROR_ERRNO_NO_MEDIA";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_MEDIUM"] = 2147549308] = "ERROR_ERRNO_INVALID_MEDIUM";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_ADDRESS_NOT_AVAILABLE"] = 2147549309] = "ERROR_ERRNO_ADDRESS_NOT_AVAILABLE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_IS_ALREADY_CONNECTED"] = 2147549311] = "ERROR_ERRNO_IS_ALREADY_CONNECTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_NOT_CONNECTED"] = 2147549312] = "ERROR_ERRNO_NOT_CONNECTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FILE_QUOTA_EXCEEDED"] = 2147549316] = "ERROR_ERRNO_FILE_QUOTA_EXCEEDED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_FUNCTION_NOT_SUPPORTED"] = 2147594240] = "ERROR_ERRNO_FUNCTION_NOT_SUPPORTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_ADDR_OUT_OF_MAIN_MEM"] = 2147594241] = "ERROR_ERRNO_ADDR_OUT_OF_MAIN_MEM";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_UNIT_NUM"] = 2147594242] = "ERROR_ERRNO_INVALID_UNIT_NUM";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_FILE_SIZE"] = 2147594243] = "ERROR_ERRNO_INVALID_FILE_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_ERRNO_INVALID_FLAG"] = 2147594244] = "ERROR_ERRNO_INVALID_FLAG";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_CANNOT_BE_CALLED_FROM_INTERRUPT"] = 2147614820] = "ERROR_KERNEL_CANNOT_BE_CALLED_FROM_INTERRUPT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_INTERRUPTS_ALREADY_DISABLED"] = 2147614822] = "ERROR_KERNEL_INTERRUPTS_ALREADY_DISABLED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNKNOWN_UID"] = 2147614923] = "ERROR_KERNEL_UNKNOWN_UID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNMATCH_TYPE_UID"] = 2147614924] = "ERROR_KERNEL_UNMATCH_TYPE_UID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_EXIST_ID"] = 2147614925] = "ERROR_KERNEL_NOT_EXIST_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_FUNCTION_UID"] = 2147614926] = "ERROR_KERNEL_NOT_FOUND_FUNCTION_UID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ALREADY_HOLDER_UID"] = 2147614927] = "ERROR_KERNEL_ALREADY_HOLDER_UID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_HOLDER_UID"] = 2147614928] = "ERROR_KERNEL_NOT_HOLDER_UID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_PERMISSION"] = 2147614929] = "ERROR_KERNEL_ILLEGAL_PERMISSION";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_ARGUMENT"] = 2147614930] = "ERROR_KERNEL_ILLEGAL_ARGUMENT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_ADDR"] = 2147614931] = "ERROR_KERNEL_ILLEGAL_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMORY_AREA_OUT_OF_RANGE"] = 2147614932] = "ERROR_KERNEL_MEMORY_AREA_OUT_OF_RANGE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMORY_AREA_IS_OVERLAP"] = 2147614933] = "ERROR_KERNEL_MEMORY_AREA_IS_OVERLAP";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_PARTITION_ID"] = 2147614934] = "ERROR_KERNEL_ILLEGAL_PARTITION_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_PARTITION_IN_USE"] = 2147614935] = "ERROR_KERNEL_PARTITION_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE"] = 2147614936] = "ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK"] = 2147614937] = "ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_INHIBITED_RESIZE_MEMBLOCK"] = 2147614938] = "ERROR_KERNEL_INHIBITED_RESIZE_MEMBLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FAILED_RESIZE_MEMBLOCK"] = 2147614939] = "ERROR_KERNEL_FAILED_RESIZE_MEMBLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FAILED_ALLOC_HEAPBLOCK"] = 2147614940] = "ERROR_KERNEL_FAILED_ALLOC_HEAPBLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FAILED_ALLOC_HEAP"] = 2147614941] = "ERROR_KERNEL_FAILED_ALLOC_HEAP";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_CHUNK_ID"] = 2147614942] = "ERROR_KERNEL_ILLEGAL_CHUNK_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_CANNOT_FIND_CHUNK_NAME"] = 2147614943] = "ERROR_KERNEL_CANNOT_FIND_CHUNK_NAME";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NO_FREE_CHUNK"] = 2147614944] = "ERROR_KERNEL_NO_FREE_CHUNK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMBLOCK_FRAGMENTED"] = 2147614945] = "ERROR_KERNEL_MEMBLOCK_FRAGMENTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMBLOCK_CANNOT_JOINT"] = 2147614946] = "ERROR_KERNEL_MEMBLOCK_CANNOT_JOINT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMBLOCK_CANNOT_SEPARATE"] = 2147614947] = "ERROR_KERNEL_MEMBLOCK_CANNOT_SEPARATE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_ALIGNMENT_SIZE"] = 2147614948] = "ERROR_KERNEL_ILLEGAL_ALIGNMENT_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_DEVKIT_VER"] = 2147614949] = "ERROR_KERNEL_ILLEGAL_DEVKIT_VER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_LINK_ERROR"] = 2147615020] = "ERROR_KERNEL_MODULE_LINK_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_OBJECT_FORMAT"] = 2147615021] = "ERROR_KERNEL_ILLEGAL_OBJECT_FORMAT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNKNOWN_MODULE"] = 2147615022] = "ERROR_KERNEL_UNKNOWN_MODULE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNKNOWN_MODULE_FILE"] = 2147615023] = "ERROR_KERNEL_UNKNOWN_MODULE_FILE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FILE_READ_ERROR"] = 2147615024] = "ERROR_KERNEL_FILE_READ_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEMORY_IN_USE"] = 2147615025] = "ERROR_KERNEL_MEMORY_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_PARTITION_MISMATCH"] = 2147615026] = "ERROR_KERNEL_PARTITION_MISMATCH";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_ALREADY_STARTED"] = 2147615027] = "ERROR_KERNEL_MODULE_ALREADY_STARTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_NOT_STARTED"] = 2147615028] = "ERROR_KERNEL_MODULE_NOT_STARTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_ALREADY_STOPPED"] = 2147615029] = "ERROR_KERNEL_MODULE_ALREADY_STOPPED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_CANNOT_STOP"] = 2147615030] = "ERROR_KERNEL_MODULE_CANNOT_STOP";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_NOT_STOPPED"] = 2147615031] = "ERROR_KERNEL_MODULE_NOT_STOPPED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_CANNOT_REMOVE"] = 2147615032] = "ERROR_KERNEL_MODULE_CANNOT_REMOVE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_EXCLUSIVE_LOAD"] = 2147615033] = "ERROR_KERNEL_EXCLUSIVE_LOAD";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LIBRARY_IS_NOT_LINKED"] = 2147615034] = "ERROR_KERNEL_LIBRARY_IS_NOT_LINKED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LIBRARY_ALREADY_EXISTS"] = 2147615035] = "ERROR_KERNEL_LIBRARY_ALREADY_EXISTS";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LIBRARY_NOT_FOUND"] = 2147615036] = "ERROR_KERNEL_LIBRARY_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_LIBRARY_HEADER"] = 2147615037] = "ERROR_KERNEL_ILLEGAL_LIBRARY_HEADER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LIBRARY_IN_USE"] = 2147615038] = "ERROR_KERNEL_LIBRARY_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_ALREADY_STOPPING"] = 2147615039] = "ERROR_KERNEL_MODULE_ALREADY_STOPPING";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_OFFSET_VALUE"] = 2147615040] = "ERROR_KERNEL_ILLEGAL_OFFSET_VALUE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_POSITION_CODE"] = 2147615041] = "ERROR_KERNEL_ILLEGAL_POSITION_CODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_ACCESS_CODE"] = 2147615042] = "ERROR_KERNEL_ILLEGAL_ACCESS_CODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MODULE_MANAGER_BUSY"] = 2147615043] = "ERROR_KERNEL_MODULE_MANAGER_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_FLAG"] = 2147615044] = "ERROR_KERNEL_ILLEGAL_FLAG";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_CANNOT_GET_MODULE_LIST"] = 2147615045] = "ERROR_KERNEL_CANNOT_GET_MODULE_LIST";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_PROHIBIT_LOADMODULE_DEVICE"] = 2147615046] = "ERROR_KERNEL_PROHIBIT_LOADMODULE_DEVICE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_PROHIBIT_LOADEXEC_DEVICE"] = 2147615047] = "ERROR_KERNEL_PROHIBIT_LOADEXEC_DEVICE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNSUPPORTED_PRX_TYPE"] = 2147615048] = "ERROR_KERNEL_UNSUPPORTED_PRX_TYPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_PERMISSION_CALL"] = 2147615049] = "ERROR_KERNEL_ILLEGAL_PERMISSION_CALL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_CANNOT_GET_MODULE_INFO"] = 2147615050] = "ERROR_KERNEL_CANNOT_GET_MODULE_INFO";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_LOADEXEC_BUFFER"] = 2147615051] = "ERROR_KERNEL_ILLEGAL_LOADEXEC_BUFFER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_LOADEXEC_FILENAME"] = 2147615052] = "ERROR_KERNEL_ILLEGAL_LOADEXEC_FILENAME";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NO_EXIT_CALLBACK"] = 2147615053] = "ERROR_KERNEL_NO_EXIT_CALLBACK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MEDIA_CHANGED"] = 2147615054] = "ERROR_KERNEL_MEDIA_CHANGED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_CANNOT_USE_BETA_VER_MODULE"] = 2147615055] = "ERROR_KERNEL_CANNOT_USE_BETA_VER_MODULE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NO_MEMORY"] = 2147615120] = "ERROR_KERNEL_NO_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_ATTR"] = 2147615121] = "ERROR_KERNEL_ILLEGAL_ATTR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR"] = 2147615122] = "ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_PRIORITY"] = 2147615123] = "ERROR_KERNEL_ILLEGAL_PRIORITY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_STACK_SIZE"] = 2147615124] = "ERROR_KERNEL_ILLEGAL_STACK_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_MODE"] = 2147615125] = "ERROR_KERNEL_ILLEGAL_MODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_MASK"] = 2147615126] = "ERROR_KERNEL_ILLEGAL_MASK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_THREAD"] = 2147615127] = "ERROR_KERNEL_ILLEGAL_THREAD";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_THREAD"] = 2147615128] = "ERROR_KERNEL_NOT_FOUND_THREAD";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_SEMAPHORE"] = 2147615129] = "ERROR_KERNEL_NOT_FOUND_SEMAPHORE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_EVENT_FLAG"] = 2147615130] = "ERROR_KERNEL_NOT_FOUND_EVENT_FLAG";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_MESSAGE_BOX"] = 2147615131] = "ERROR_KERNEL_NOT_FOUND_MESSAGE_BOX";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_VPOOL"] = 2147615132] = "ERROR_KERNEL_NOT_FOUND_VPOOL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_FPOOL"] = 2147615133] = "ERROR_KERNEL_NOT_FOUND_FPOOL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_MESSAGE_PIPE"] = 2147615134] = "ERROR_KERNEL_NOT_FOUND_MESSAGE_PIPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_ALARM"] = 2147615135] = "ERROR_KERNEL_NOT_FOUND_ALARM";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_THREAD_EVENT_HANDLER"] = 2147615136] = "ERROR_KERNEL_NOT_FOUND_THREAD_EVENT_HANDLER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_CALLBACK"] = 2147615137] = "ERROR_KERNEL_NOT_FOUND_CALLBACK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_ALREADY_DORMANT"] = 2147615138] = "ERROR_KERNEL_THREAD_ALREADY_DORMANT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_ALREADY_SUSPEND"] = 2147615139] = "ERROR_KERNEL_THREAD_ALREADY_SUSPEND";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_IS_NOT_DORMANT"] = 2147615140] = "ERROR_KERNEL_THREAD_IS_NOT_DORMANT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_IS_NOT_SUSPEND"] = 2147615141] = "ERROR_KERNEL_THREAD_IS_NOT_SUSPEND";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_IS_NOT_WAIT"] = 2147615142] = "ERROR_KERNEL_THREAD_IS_NOT_WAIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_CAN_NOT_WAIT"] = 2147615143] = "ERROR_KERNEL_WAIT_CAN_NOT_WAIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_TIMEOUT"] = 2147615144] = "ERROR_KERNEL_WAIT_TIMEOUT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_CANCELLED"] = 2147615145] = "ERROR_KERNEL_WAIT_CANCELLED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_STATUS_RELEASED"] = 2147615146] = "ERROR_KERNEL_WAIT_STATUS_RELEASED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_STATUS_RELEASED_CALLBACK"] = 2147615147] = "ERROR_KERNEL_WAIT_STATUS_RELEASED_CALLBACK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_THREAD_IS_TERMINATED"] = 2147615148] = "ERROR_KERNEL_THREAD_IS_TERMINATED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_SEMA_ZERO"] = 2147615149] = "ERROR_KERNEL_SEMA_ZERO";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_SEMA_OVERFLOW"] = 2147615150] = "ERROR_KERNEL_SEMA_OVERFLOW";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_EVENT_FLAG_POLL_FAILED"] = 2147615151] = "ERROR_KERNEL_EVENT_FLAG_POLL_FAILED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_EVENT_FLAG_NO_MULTI_PERM"] = 2147615152] = "ERROR_KERNEL_EVENT_FLAG_NO_MULTI_PERM";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN"] = 2147615153] = "ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MESSAGEBOX_NO_MESSAGE"] = 2147615154] = "ERROR_KERNEL_MESSAGEBOX_NO_MESSAGE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MESSAGE_PIPE_FULL"] = 2147615155] = "ERROR_KERNEL_MESSAGE_PIPE_FULL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MESSAGE_PIPE_EMPTY"] = 2147615156] = "ERROR_KERNEL_MESSAGE_PIPE_EMPTY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_WAIT_DELETE"] = 2147615157] = "ERROR_KERNEL_WAIT_DELETE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_MEMBLOCK"] = 2147615158] = "ERROR_KERNEL_ILLEGAL_MEMBLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_MEMSIZE"] = 2147615159] = "ERROR_KERNEL_ILLEGAL_MEMSIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_SCRATCHPAD_ADDR"] = 2147615160] = "ERROR_KERNEL_ILLEGAL_SCRATCHPAD_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_SCRATCHPAD_IN_USE"] = 2147615161] = "ERROR_KERNEL_SCRATCHPAD_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_SCRATCHPAD_NOT_IN_USE"] = 2147615162] = "ERROR_KERNEL_SCRATCHPAD_NOT_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_TYPE"] = 2147615163] = "ERROR_KERNEL_ILLEGAL_TYPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_SIZE"] = 2147615164] = "ERROR_KERNEL_ILLEGAL_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_COUNT"] = 2147615165] = "ERROR_KERNEL_ILLEGAL_COUNT";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_FOUND_VTIMER"] = 2147615166] = "ERROR_KERNEL_NOT_FOUND_VTIMER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_VTIMER"] = 2147615167] = "ERROR_KERNEL_ILLEGAL_VTIMER";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ILLEGAL_KTLS"] = 2147615168] = "ERROR_KERNEL_ILLEGAL_KTLS";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_KTLS_IS_FULL"] = 2147615169] = "ERROR_KERNEL_KTLS_IS_FULL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_KTLS_IS_BUSY"] = 2147615170] = "ERROR_KERNEL_KTLS_IS_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_NOT_FOUND"] = 2147615171] = "ERROR_KERNEL_MUTEX_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_LOCKED"] = 2147615172] = "ERROR_KERNEL_MUTEX_LOCKED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_UNLOCKED"] = 2147615173] = "ERROR_KERNEL_MUTEX_UNLOCKED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_LOCK_OVERFLOW"] = 2147615174] = "ERROR_KERNEL_MUTEX_LOCK_OVERFLOW";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_UNLOCK_UNDERFLOW"] = 2147615175] = "ERROR_KERNEL_MUTEX_UNLOCK_UNDERFLOW";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MUTEX_RECURSIVE_NOT_ALLOWED"] = 2147615176] = "ERROR_KERNEL_MUTEX_RECURSIVE_NOT_ALLOWED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MESSAGEBOX_DUPLICATE_MESSAGE"] = 2147615177] = "ERROR_KERNEL_MESSAGEBOX_DUPLICATE_MESSAGE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_NOT_FOUND"] = 2147615178] = "ERROR_KERNEL_LWMUTEX_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_LOCKED"] = 2147615179] = "ERROR_KERNEL_LWMUTEX_LOCKED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_UNLOCKED"] = 2147615180] = "ERROR_KERNEL_LWMUTEX_UNLOCKED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_LOCK_OVERFLOW"] = 2147615181] = "ERROR_KERNEL_LWMUTEX_LOCK_OVERFLOW";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_UNLOCK_UNDERFLOW"] = 2147615182] = "ERROR_KERNEL_LWMUTEX_UNLOCK_UNDERFLOW";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_LWMUTEX_RECURSIVE_NOT_ALLOWED"] = 2147615183] = "ERROR_KERNEL_LWMUTEX_RECURSIVE_NOT_ALLOWED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_POWER_CANNOT_CANCEL"] = 2147615329] = "ERROR_KERNEL_POWER_CANNOT_CANCEL";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_TOO_MANY_OPEN_FILES"] = 2147615520] = "ERROR_KERNEL_TOO_MANY_OPEN_FILES";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NO_SUCH_DEVICE"] = 2147615521] = "ERROR_KERNEL_NO_SUCH_DEVICE";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_BAD_FILE_DESCRIPTOR"] = 2147615523] = "ERROR_KERNEL_BAD_FILE_DESCRIPTOR";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_UNSUPPORTED_OPERATION"] = 2147615525] = "ERROR_KERNEL_UNSUPPORTED_OPERATION";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOCWD"] = 2147615532] = "ERROR_KERNEL_NOCWD";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_FILENAME_TOO_LONG"] = 2147615533] = "ERROR_KERNEL_FILENAME_TOO_LONG";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_ASYNC_BUSY"] = 2147615529] = "ERROR_KERNEL_ASYNC_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NO_ASYNC_OP"] = 2147615530] = "ERROR_KERNEL_NO_ASYNC_OP";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_NOT_CACHE_ALIGNED"] = 2147615820] = "ERROR_KERNEL_NOT_CACHE_ALIGNED";
    SceKernelErrors2[SceKernelErrors2["ERROR_KERNEL_MAX_ERROR"] = 2147615821] = "ERROR_KERNEL_MAX_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_INVALID_STATUS"] = 2148597761] = "ERROR_UTILITY_INVALID_STATUS";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_INVALID_PARAM_ADDR"] = 2148597762] = "ERROR_UTILITY_INVALID_PARAM_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_IS_UNKNOWN"] = 2148597763] = "ERROR_UTILITY_IS_UNKNOWN";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_INVALID_PARAM_SIZE"] = 2148597764] = "ERROR_UTILITY_INVALID_PARAM_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_WRONG_TYPE"] = 2148597765] = "ERROR_UTILITY_WRONG_TYPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_UTILITY_MODULE_NOT_FOUND"] = 2148597766] = "ERROR_UTILITY_MODULE_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_NO_MEMSTICK"] = 2148598529] = "ERROR_SAVEDATA_LOAD_NO_MEMSTICK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_MEMSTICK_REMOVED"] = 2148598530] = "ERROR_SAVEDATA_LOAD_MEMSTICK_REMOVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_ACCESS_ERROR"] = 2148598533] = "ERROR_SAVEDATA_LOAD_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_DATA_BROKEN"] = 2148598534] = "ERROR_SAVEDATA_LOAD_DATA_BROKEN";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_NO_DATA"] = 2148598535] = "ERROR_SAVEDATA_LOAD_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_BAD_PARAMS"] = 2148598536] = "ERROR_SAVEDATA_LOAD_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_NO_UMD"] = 2148598537] = "ERROR_SAVEDATA_LOAD_NO_UMD";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_LOAD_INTERNAL_ERROR"] = 2148598537] = "ERROR_SAVEDATA_LOAD_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_NO_MEMSTICK"] = 2148598561] = "ERROR_SAVEDATA_RW_NO_MEMSTICK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_MEMSTICK_REMOVED"] = 2148598562] = "ERROR_SAVEDATA_RW_MEMSTICK_REMOVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_MEMSTICK_FULL"] = 2148598563] = "ERROR_SAVEDATA_RW_MEMSTICK_FULL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_MEMSTICK_PROTECTED"] = 2148598564] = "ERROR_SAVEDATA_RW_MEMSTICK_PROTECTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_ACCESS_ERROR"] = 2148598565] = "ERROR_SAVEDATA_RW_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_DATA_BROKEN"] = 2148598566] = "ERROR_SAVEDATA_RW_DATA_BROKEN";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_NO_DATA"] = 2148598567] = "ERROR_SAVEDATA_RW_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_BAD_PARAMS"] = 2148598568] = "ERROR_SAVEDATA_RW_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_FILE_NOT_FOUND"] = 2148598569] = "ERROR_SAVEDATA_RW_FILE_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_CAN_NOT_SUSPEND"] = 2148598570] = "ERROR_SAVEDATA_RW_CAN_NOT_SUSPEND";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_INTERNAL_ERROR"] = 2148598571] = "ERROR_SAVEDATA_RW_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_BAD_STATUS"] = 2148598572] = "ERROR_SAVEDATA_RW_BAD_STATUS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_RW_SECURE_FILE_FULL"] = 2148598573] = "ERROR_SAVEDATA_RW_SECURE_FILE_FULL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_NO_MEMSTICK"] = 2148598593] = "ERROR_SAVEDATA_DELETE_NO_MEMSTICK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_MEMSTICK_REMOVED"] = 2148598594] = "ERROR_SAVEDATA_DELETE_MEMSTICK_REMOVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_MEMSTICK_PROTECTED"] = 2148598596] = "ERROR_SAVEDATA_DELETE_MEMSTICK_PROTECTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_ACCESS_ERROR"] = 2148598597] = "ERROR_SAVEDATA_DELETE_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_DATA_BROKEN"] = 2148598598] = "ERROR_SAVEDATA_DELETE_DATA_BROKEN";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_NO_DATA"] = 2148598599] = "ERROR_SAVEDATA_DELETE_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_BAD_PARAMS"] = 2148598600] = "ERROR_SAVEDATA_DELETE_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_DELETE_INTERNAL_ERROR"] = 2148598603] = "ERROR_SAVEDATA_DELETE_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_NO_MEMSTICK"] = 2148598657] = "ERROR_SAVEDATA_SAVE_NO_MEMSTICK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_MEMSTICK_REMOVED"] = 2148598658] = "ERROR_SAVEDATA_SAVE_MEMSTICK_REMOVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_NO_SPACE"] = 2148598659] = "ERROR_SAVEDATA_SAVE_NO_SPACE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_MEMSTICK_PROTECTED"] = 2148598660] = "ERROR_SAVEDATA_SAVE_MEMSTICK_PROTECTED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_ACCESS_ERROR"] = 2148598661] = "ERROR_SAVEDATA_SAVE_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_BAD_PARAMS"] = 2148598664] = "ERROR_SAVEDATA_SAVE_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_NO_UMD"] = 2148598665] = "ERROR_SAVEDATA_SAVE_NO_UMD";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_WRONG_UMD"] = 2148598666] = "ERROR_SAVEDATA_SAVE_WRONG_UMD";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SAVE_INTERNAL_ERROR"] = 2148598667] = "ERROR_SAVEDATA_SAVE_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_NO_MEMSTICK"] = 2148598721] = "ERROR_SAVEDATA_SIZES_NO_MEMSTICK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_MEMSTICK_REMOVED"] = 2148598722] = "ERROR_SAVEDATA_SIZES_MEMSTICK_REMOVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_ACCESS_ERROR"] = 2148598725] = "ERROR_SAVEDATA_SIZES_ACCESS_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_DATA_BROKEN"] = 2148598726] = "ERROR_SAVEDATA_SIZES_DATA_BROKEN";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_NO_DATA"] = 2148598727] = "ERROR_SAVEDATA_SIZES_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_BAD_PARAMS"] = 2148598728] = "ERROR_SAVEDATA_SIZES_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAVEDATA_SIZES_INTERNAL_ERROR"] = 2148598731] = "ERROR_SAVEDATA_SIZES_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_NETPARAM_BAD_NETCONF"] = 2148599297] = "ERROR_NETPARAM_BAD_NETCONF";
    SceKernelErrors2[SceKernelErrors2["ERROR_NETPARAM_BAD_PARAM"] = 2148599300] = "ERROR_NETPARAM_BAD_PARAM";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_MODULE_BAD_ID"] = 2148599809] = "ERROR_NET_MODULE_BAD_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_MODULE_ALREADY_LOADED"] = 2148599810] = "ERROR_NET_MODULE_ALREADY_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_MODULE_NOT_LOADED"] = 2148599811] = "ERROR_NET_MODULE_NOT_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_AV_MODULE_BAD_ID"] = 2148600065] = "ERROR_AV_MODULE_BAD_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_AV_MODULE_ALREADY_LOADED"] = 2148600066] = "ERROR_AV_MODULE_ALREADY_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_AV_MODULE_NOT_LOADED"] = 2148600067] = "ERROR_AV_MODULE_NOT_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_MODULE_BAD_ID"] = 2148602113] = "ERROR_MODULE_BAD_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_MODULE_ALREADY_LOADED"] = 2148602114] = "ERROR_MODULE_ALREADY_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_MODULE_NOT_LOADED"] = 2148602115] = "ERROR_MODULE_NOT_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SCREENSHOT_CONT_MODE_NOT_INIT"] = 2148602409] = "ERROR_SCREENSHOT_CONT_MODE_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_UMD_NOT_READY"] = 2149646337] = "ERROR_UMD_NOT_READY";
    SceKernelErrors2[SceKernelErrors2["ERROR_UMD_LBA_OUT_OF_BOUNDS"] = 2149646338] = "ERROR_UMD_LBA_OUT_OF_BOUNDS";
    SceKernelErrors2[SceKernelErrors2["ERROR_UMD_NO_DISC"] = 2149646339] = "ERROR_UMD_NO_DISC";
    SceKernelErrors2[SceKernelErrors2["ERROR_MEMSTICK_DEVCTL_BAD_PARAMS"] = 2149712001] = "ERROR_MEMSTICK_DEVCTL_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_MEMSTICK_DEVCTL_TOO_MANY_CALLBACKS"] = 2149712002] = "ERROR_MEMSTICK_DEVCTL_TOO_MANY_CALLBACKS";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_CHANNEL_NOT_INIT"] = 2149974017] = "ERROR_AUDIO_CHANNEL_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_CHANNEL_BUSY"] = 2149974018] = "ERROR_AUDIO_CHANNEL_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_INVALID_CHANNEL"] = 2149974019] = "ERROR_AUDIO_INVALID_CHANNEL";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_PRIV_REQUIRED"] = 2149974020] = "ERROR_AUDIO_PRIV_REQUIRED";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_NO_CHANNELS_AVAILABLE"] = 2149974021] = "ERROR_AUDIO_NO_CHANNELS_AVAILABLE";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_OUTPUT_SAMPLE_DATA_SIZE_NOT_ALIGNED"] = 2149974022] = "ERROR_AUDIO_OUTPUT_SAMPLE_DATA_SIZE_NOT_ALIGNED";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_INVALID_FORMAT"] = 2149974023] = "ERROR_AUDIO_INVALID_FORMAT";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_CHANNEL_NOT_RESERVED"] = 2149974024] = "ERROR_AUDIO_CHANNEL_NOT_RESERVED";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_NOT_OUTPUT"] = 2149974025] = "ERROR_AUDIO_NOT_OUTPUT";
    SceKernelErrors2[SceKernelErrors2["ERROR_POWER_VMEM_IN_USE"] = 2150302208] = "ERROR_POWER_VMEM_IN_USE";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_RESOLVER_BAD_ID"] = 2151744520] = "ERROR_NET_RESOLVER_BAD_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_RESOLVER_ALREADY_STOPPED"] = 2151744522] = "ERROR_NET_RESOLVER_ALREADY_STOPPED";
    SceKernelErrors2[SceKernelErrors2["ERROR_NET_RESOLVER_INVALID_HOST"] = 2151744532] = "ERROR_NET_RESOLVER_INVALID_HOST";
    SceKernelErrors2[SceKernelErrors2["ERROR_WLAN_BAD_PARAMS"] = 2151746835] = "ERROR_WLAN_BAD_PARAMS";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTP_NOT_INIT"] = 2151878657] = "ERROR_HTTP_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTP_ALREADY_INIT"] = 2151878688] = "ERROR_HTTP_ALREADY_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTP_NO_MEMORY"] = 2151878775] = "ERROR_HTTP_NO_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTP_SYSTEM_COOKIE_NOT_LOADED"] = 2151878776] = "ERROR_HTTP_SYSTEM_COOKIE_NOT_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTP_INVALID_PARAMETER"] = 2151879166] = "ERROR_HTTP_INVALID_PARAMETER";
    SceKernelErrors2[SceKernelErrors2["ERROR_SSL_NOT_INIT"] = 2151895041] = "ERROR_SSL_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_SSL_ALREADY_INIT"] = 2151895072] = "ERROR_SSL_ALREADY_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_SSL_OUT_OF_MEMORY"] = 2151895074] = "ERROR_SSL_OUT_OF_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTPS_CERT_ERROR"] = 2151895136] = "ERROR_HTTPS_CERT_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTPS_HANDSHAKE_ERROR"] = 2151895137] = "ERROR_HTTPS_HANDSHAKE_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTPS_IO_ERROR"] = 2151895138] = "ERROR_HTTPS_IO_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTPS_INTERNAL_ERROR"] = 2151895139] = "ERROR_HTTPS_INTERNAL_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_HTTPS_PROXY_ERROR"] = 2151895140] = "ERROR_HTTPS_PROXY_ERROR";
    SceKernelErrors2[SceKernelErrors2["ERROR_SSL_INVALID_PARAMETER"] = 2151895550] = "ERROR_SSL_INVALID_PARAMETER";
    SceKernelErrors2[SceKernelErrors2["ERROR_WAVE_NOT_INIT"] = 2151940097] = "ERROR_WAVE_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_WAVE_FAILED_EXIT"] = 2151940098] = "ERROR_WAVE_FAILED_EXIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_WAVE_BAD_VOL"] = 2151940106] = "ERROR_WAVE_BAD_VOL";
    SceKernelErrors2[SceKernelErrors2["ERROR_WAVE_INVALID_CHANNEL"] = 2151940112] = "ERROR_WAVE_INVALID_CHANNEL";
    SceKernelErrors2[SceKernelErrors2["ERROR_WAVE_INVALID_SAMPLE_COUNT"] = 2151940113] = "ERROR_WAVE_INVALID_SAMPLE_COUNT";
    SceKernelErrors2[SceKernelErrors2["ERROR_FONT_INVALID_LIBID"] = 2152071170] = "ERROR_FONT_INVALID_LIBID";
    SceKernelErrors2[SceKernelErrors2["ERROR_FONT_INVALID_PARAMETER"] = 2152071171] = "ERROR_FONT_INVALID_PARAMETER";
    SceKernelErrors2[SceKernelErrors2["ERROR_FONT_TOO_MANY_OPEN_FONTS"] = 2152071177] = "ERROR_FONT_TOO_MANY_OPEN_FONTS";
    SceKernelErrors2[SceKernelErrors2["ERROR_MPEG_BAD_VERSION"] = 2153840642] = "ERROR_MPEG_BAD_VERSION";
    SceKernelErrors2[SceKernelErrors2["ERROR_MPEG_NO_MEMORY"] = 2153840674] = "ERROR_MPEG_NO_MEMORY";
    SceKernelErrors2[SceKernelErrors2["ERROR_MPEG_INVALID_ADDR"] = 2153840899] = "ERROR_MPEG_INVALID_ADDR";
    SceKernelErrors2[SceKernelErrors2["ERROR_MPEG_INVALID_VALUE"] = 2153841150] = "ERROR_MPEG_INVALID_VALUE";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_NOT_INITIALIZED"] = 2153861121] = "ERROR_PSMF_NOT_INITIALIZED";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_BAD_VERSION"] = 2153861122] = "ERROR_PSMF_BAD_VERSION";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_NOT_FOUND"] = 2153861157] = "ERROR_PSMF_NOT_FOUND";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_INVALID_ID"] = 2153861376] = "ERROR_PSMF_INVALID_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_INVALID_VALUE"] = 2153861630] = "ERROR_PSMF_INVALID_VALUE";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_INVALID_TIMESTAMP"] = 2153862400] = "ERROR_PSMF_INVALID_TIMESTAMP";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMF_INVALID_PSMF"] = 2153862401] = "ERROR_PSMF_INVALID_PSMF";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMFPLAYER_NOT_INITIALIZED"] = 2153865217] = "ERROR_PSMFPLAYER_NOT_INITIALIZED";
    SceKernelErrors2[SceKernelErrors2["ERROR_PSMFPLAYER_NO_MORE_DATA"] = 2153865228] = "ERROR_PSMFPLAYER_NO_MORE_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_MPEG_NO_DATA"] = 2153873409] = "ERROR_MPEG_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_AVC_VIDEO_FATAL"] = 2153938946] = "ERROR_AVC_VIDEO_FATAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_NO_ID"] = 2153971715] = "ERROR_ATRAC_NO_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_INVALID_CODEC"] = 2153971716] = "ERROR_ATRAC_INVALID_CODEC";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_BAD_ID"] = 2153971717] = "ERROR_ATRAC_BAD_ID";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_ALL_DATA_LOADED"] = 2153971721] = "ERROR_ATRAC_ALL_DATA_LOADED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_NO_DATA"] = 2153971728] = "ERROR_ATRAC_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_SECOND_BUFFER_NEEDED"] = 2153971730] = "ERROR_ATRAC_SECOND_BUFFER_NEEDED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED"] = 2153971746] = "ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_BUFFER_IS_EMPTY"] = 2153971747] = "ERROR_ATRAC_BUFFER_IS_EMPTY";
    SceKernelErrors2[SceKernelErrors2["ERROR_ATRAC_ALL_DATA_DECODED"] = 2153971748] = "ERROR_ATRAC_ALL_DATA_DECODED";
    SceKernelErrors2[SceKernelErrors2["ERROR_CODEC_AUDIO_FATAL"] = 2155806972] = "ERROR_CODEC_AUDIO_FATAL";
    SceKernelErrors2[SceKernelErrors2["FATAL_UMD_UNKNOWN_MEDIUM"] = 3223388164] = "FATAL_UMD_UNKNOWN_MEDIUM";
    SceKernelErrors2[SceKernelErrors2["FATAL_UMD_HARDWARE_FAILURE"] = 3223388165] = "FATAL_UMD_HARDWARE_FAILURE";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_INVALID_FREQUENCY"] = 2149974026] = "ERROR_AUDIO_INVALID_FREQUENCY";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_INVALID_VOLUME"] = 2149974027] = "ERROR_AUDIO_INVALID_VOLUME";
    SceKernelErrors2[SceKernelErrors2["ERROR_AUDIO_CHANNEL_ALREADY_RESERVED"] = 2150006786] = "ERROR_AUDIO_CHANNEL_ALREADY_RESERVED";
    SceKernelErrors2[SceKernelErrors2["PSP_AUDIO_ERROR_SRC_FORMAT_4"] = 2147483651] = "PSP_AUDIO_ERROR_SRC_FORMAT_4";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_API_FAIL"] = 2153971714] = "ATRAC_ERROR_API_FAIL";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_NO_ATRACID"] = 2153971715] = "ATRAC_ERROR_NO_ATRACID";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_INVALID_CODECTYPE"] = 2153971716] = "ATRAC_ERROR_INVALID_CODECTYPE";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_BAD_ATRACID"] = 2153971717] = "ATRAC_ERROR_BAD_ATRACID";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_ALL_DATA_LOADED"] = 2153971721] = "ATRAC_ERROR_ALL_DATA_LOADED";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_NO_DATA"] = 2153971728] = "ATRAC_ERROR_NO_DATA";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_SECOND_BUFFER_NEEDED"] = 2153971730] = "ATRAC_ERROR_SECOND_BUFFER_NEEDED";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_INCORRECT_READ_SIZE"] = 2153971731] = "ATRAC_ERROR_INCORRECT_READ_SIZE";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_ADD_DATA_IS_TOO_BIG"] = 2153971736] = "ATRAC_ERROR_ADD_DATA_IS_TOO_BIG";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_UNSET_PARAM"] = 2153971745] = "ATRAC_ERROR_UNSET_PARAM";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_SECOND_BUFFER_NOT_NEEDED"] = 2153971746] = "ATRAC_ERROR_SECOND_BUFFER_NOT_NEEDED";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_BUFFER_IS_EMPTY"] = 2153971747] = "ATRAC_ERROR_BUFFER_IS_EMPTY";
    SceKernelErrors2[SceKernelErrors2["ATRAC_ERROR_ALL_DATA_DECODED"] = 2153971748] = "ATRAC_ERROR_ALL_DATA_DECODED";
    SceKernelErrors2[SceKernelErrors2["PSP_SYSTEMPARAM_RETVAL"] = 2148598019] = "PSP_SYSTEMPARAM_RETVAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_VOICE"] = 2151809040] = "ERROR_SAS_INVALID_VOICE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_ADSR_CURVE_MODE"] = 2151809043] = "ERROR_SAS_INVALID_ADSR_CURVE_MODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_PARAMETER"] = 2151809044] = "ERROR_SAS_INVALID_PARAMETER";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_LOOP_POS"] = 2151809045] = "ERROR_SAS_INVALID_LOOP_POS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_VOICE_PAUSED"] = 2151809046] = "ERROR_SAS_VOICE_PAUSED";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_BUSY"] = 2151809072] = "ERROR_SAS_BUSY";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_NOT_INIT"] = 2151809280] = "ERROR_SAS_NOT_INIT";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_GRAIN"] = 2151809025] = "ERROR_SAS_INVALID_GRAIN";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_MAX_VOICES"] = 2151809026] = "ERROR_SAS_INVALID_MAX_VOICES";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_OUTPUT_MODE"] = 2151809027] = "ERROR_SAS_INVALID_OUTPUT_MODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_SAMPLE_RATE"] = 2151809028] = "ERROR_SAS_INVALID_SAMPLE_RATE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_ADDRESS"] = 2151809029] = "ERROR_SAS_INVALID_ADDRESS";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_VOICE_INDEX"] = 2151809040] = "ERROR_SAS_INVALID_VOICE_INDEX";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_NOISE_CLOCK"] = 2151809041] = "ERROR_SAS_INVALID_NOISE_CLOCK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_PITCH_VAL"] = 2151809042] = "ERROR_SAS_INVALID_PITCH_VAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_ADPCM_SIZE"] = 2151809044] = "ERROR_SAS_INVALID_ADPCM_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_LOOP_MODE"] = 2151809045] = "ERROR_SAS_INVALID_LOOP_MODE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_VOLUME_VAL"] = 2151809048] = "ERROR_SAS_INVALID_VOLUME_VAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_ADSR_VAL"] = 2151809049] = "ERROR_SAS_INVALID_ADSR_VAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_SIZE"] = 2151809050] = "ERROR_SAS_INVALID_SIZE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_FX_TYPE"] = 2151809056] = "ERROR_SAS_INVALID_FX_TYPE";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_FX_FEEDBACK"] = 2151809057] = "ERROR_SAS_INVALID_FX_FEEDBACK";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_FX_DELAY"] = 2151809058] = "ERROR_SAS_INVALID_FX_DELAY";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_INVALID_FX_VOLUME_VAL"] = 2151809059] = "ERROR_SAS_INVALID_FX_VOLUME_VAL";
    SceKernelErrors2[SceKernelErrors2["ERROR_SAS_ALREADY_INIT"] = 2151809281] = "ERROR_SAS_ALREADY_INIT";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_TAKEN_SLOT"] = 2147483680] = "PSP_POWER_ERROR_TAKEN_SLOT";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_SLOTS_FULL"] = 2147483682] = "PSP_POWER_ERROR_SLOTS_FULL";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_PRIVATE_SLOT"] = 2147483683] = "PSP_POWER_ERROR_PRIVATE_SLOT";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_EMPTY_SLOT"] = 2147483685] = "PSP_POWER_ERROR_EMPTY_SLOT";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_INVALID_CB"] = 2147483904] = "PSP_POWER_ERROR_INVALID_CB";
    SceKernelErrors2[SceKernelErrors2["PSP_POWER_ERROR_INVALID_SLOT"] = 2147483906] = "PSP_POWER_ERROR_INVALID_SLOT";
  })(SceKernelErrors || (SceKernelErrors = {}));

  // src/me/atrac3plus/Atrac3plusConstants.ts
  var _Atrac3plusConstants = class {
  };
  var Atrac3plusConstants = _Atrac3plusConstants;
  Atrac3plusConstants.AT3P_ERROR = -1;
  Atrac3plusConstants.CH_UNIT_MONO = 0;
  Atrac3plusConstants.CH_UNIT_STEREO = 1;
  Atrac3plusConstants.CH_UNIT_EXTENSION = 2;
  Atrac3plusConstants.CH_UNIT_TERMINATOR = 3;
  Atrac3plusConstants.ATRAC3P_POWER_COMP_OFF = 15;
  Atrac3plusConstants.ATRAC3P_SUBBANDS = 16;
  Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES = 128;
  Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES = _Atrac3plusConstants.ATRAC3P_SUBBANDS * _Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES;
  Atrac3plusConstants.ATRAC3P_PQF_FIR_LEN = 12;
  Atrac3plusConstants.AT3_MAGIC = 624;
  Atrac3plusConstants.AT3_PLUS_MAGIC = 65534;
  Atrac3plusConstants.RIFF_MAGIC = 1179011410;
  Atrac3plusConstants.WAVE_MAGIC = 1163280727;
  Atrac3plusConstants.FMT_CHUNK_MAGIC = 544501094;
  Atrac3plusConstants.FACT_CHUNK_MAGIC = 1952670054;
  Atrac3plusConstants.SMPL_CHUNK_MAGIC = 1819307379;
  Atrac3plusConstants.DATA_CHUNK_MAGIC = 1635017060;
  Atrac3plusConstants.ATRAC3_CONTEXT_READ_SIZE_OFFSET = 160;
  Atrac3plusConstants.ATRAC3_CONTEXT_REQUIRED_SIZE_OFFSET = 164;
  Atrac3plusConstants.ATRAC3_CONTEXT_DECODE_RESULT_OFFSET = 188;
  Atrac3plusConstants.PSP_ATRAC_ALLDATA_IS_ON_MEMORY = -1;
  Atrac3plusConstants.PSP_ATRAC_NONLOOP_STREAM_DATA_IS_ON_MEMORY = -2;
  Atrac3plusConstants.PSP_ATRAC_LOOP_STREAM_DATA_IS_ON_MEMORY = -3;
  Atrac3plusConstants.PSP_ATRAC_STATUS_NONLOOP_STREAM_DATA = 0;
  Atrac3plusConstants.PSP_ATRAC_STATUS_LOOP_STREAM_DATA = 1;
  Atrac3plusConstants.ATRAC_HEADER_HASH_LENGTH = 512;
  Atrac3plusConstants.ERROR_ATRAC_UNKNOWN_FORMAT = -2140995578;
  Atrac3plusConstants.ERROR_ATRAC_INVALID_SIZE = -2140995567;
  Atrac3plusConstants.PSP_CODEC_AT3PLUS = 4096;
  Atrac3plusConstants.PSP_CODEC_AT3 = 4097;
  Atrac3plusConstants.PSP_CODEC_MP3 = 4098;
  Atrac3plusConstants.PSP_CODEC_AAC = 4099;
  var CodecType;
  (function(CodecType2) {
    CodecType2[CodecType2["PSP_MODE_AT_3_PLUS"] = 4096] = "PSP_MODE_AT_3_PLUS";
    CodecType2[CodecType2["PSP_MODE_AT_3"] = 4097] = "PSP_MODE_AT_3";
  })(CodecType || (CodecType = {}));

  // src/me/atrac3plus/Atrac3PlusUtil.ts
  var log = logger.named("Atrac3PlusUtil");
  var Atrac3PlusUtil = class {
    static readUnaligned32(mem, addr) {
      mem.position = addr;
      return mem.readInt32LE();
    }
    static read8(mem, addr) {
      mem.position = addr;
      return mem.readUInt8LE();
    }
    static read16(mem, addr) {
      mem.position = addr;
      return mem.readUInt16LE();
    }
    static analyzeRiffFile(mem, addr, length, info) {
      let result = Atrac3plusConstants.ERROR_ATRAC_UNKNOWN_FORMAT;
      let currentAddr = addr;
      let bufferSize = length;
      info.atracEndSample = -1;
      info.numLoops = 0;
      info.inputFileDataOffset = 0;
      if (bufferSize < 12) {
        log.error("Atrac buffer too small %d".format(bufferSize));
        return Atrac3plusConstants.ERROR_ATRAC_INVALID_SIZE;
      }
      const magic = this.readUnaligned32(mem, currentAddr);
      const WAVEMagic = this.readUnaligned32(mem, currentAddr + 8);
      if (magic != Atrac3plusConstants.RIFF_MAGIC || WAVEMagic != Atrac3plusConstants.WAVE_MAGIC) {
        log.error("Not a RIFF/WAVE format!");
        return Atrac3plusConstants.ERROR_ATRAC_UNKNOWN_FORMAT;
      }
      info.inputFileSize = this.readUnaligned32(mem, currentAddr + 4) + 8;
      info.inputDataSize = info.inputFileSize;
      if (log.isTraceEnabled) {
        log.trace("FileSize 0x%X".format(info.inputFileSize));
      }
      currentAddr += 12;
      bufferSize -= 12;
      let foundData = false;
      while (bufferSize >= 8 && !foundData) {
        const chunkMagic = this.readUnaligned32(mem, currentAddr);
        const chunkSize = this.readUnaligned32(mem, currentAddr + 4);
        currentAddr += 8;
        bufferSize -= 8;
        switch (chunkMagic) {
          case Atrac3plusConstants.DATA_CHUNK_MAGIC: {
            foundData = true;
            info.inputFileDataOffset = currentAddr - addr;
            info.inputDataSize = chunkSize;
            if (log.isTraceEnabled) {
              log.trace("DATA Chunk: data offset=0x%X, data size=0x%X".format(info.inputFileDataOffset, info.inputDataSize));
            }
            break;
          }
          case Atrac3plusConstants.FMT_CHUNK_MAGIC: {
            if (chunkSize >= 16) {
              const compressionCode = this.read16(mem, currentAddr);
              info.atracChannels = this.read16(mem, currentAddr + 2);
              info.atracSampleRate = this.readUnaligned32(mem, currentAddr + 4);
              info.atracBitrate = this.readUnaligned32(mem, currentAddr + 8);
              info.atracBytesPerFrame = this.read16(mem, currentAddr + 12);
              const hiBytesPerSample = this.read16(mem, currentAddr + 14);
              const extraDataSize = this.read16(mem, currentAddr + 16);
              if (extraDataSize == 14) {
                info.atracCodingMode = this.read16(mem, currentAddr + 18 + 6);
              }
              if (log.isTraceEnabled) {
                log.trace("WAVE format: magic=0x%08X('%s'), chunkSize=%d, compressionCode=0x%04X, channels=%d, sampleRate=%d, bitrate=%d, bytesPerFrame=0x%X, hiBytesPerSample=%d, codingMode=%d".format(chunkMagic, this.getStringFromInt32(chunkMagic), chunkSize, compressionCode, info.atracChannels, info.atracSampleRate, info.atracBitrate, info.atracBytesPerFrame, hiBytesPerSample, info.atracCodingMode));
                let restChunk = "";
                for (let i = 16; i < chunkSize; i++) {
                  const b = this.read8(mem, currentAddr + i);
                  restChunk += " %02X".format(b);
                }
                if (restChunk.length > 0) {
                  if (log.isTraceEnabled) {
                    log.trace("Additional chunk data:%s".format(restChunk));
                  }
                }
              }
              if (compressionCode == Atrac3plusConstants.AT3_MAGIC) {
                result = Atrac3plusConstants.PSP_CODEC_AT3;
              } else if (compressionCode == Atrac3plusConstants.AT3_PLUS_MAGIC) {
                result = Atrac3plusConstants.PSP_CODEC_AT3PLUS;
              } else {
                return Atrac3plusConstants.ERROR_ATRAC_UNKNOWN_FORMAT;
              }
            }
            break;
          }
          case Atrac3plusConstants.FACT_CHUNK_MAGIC: {
            if (chunkSize >= 8) {
              info.atracEndSample = this.readUnaligned32(mem, currentAddr);
              if (info.atracEndSample > 0) {
                info.atracEndSample -= 1;
              }
              if (chunkSize >= 12) {
                info.atracSampleOffset = this.readUnaligned32(mem, currentAddr + 8);
              } else {
                info.atracSampleOffset = this.readUnaligned32(mem, currentAddr + 4);
              }
              if (log.isTraceEnabled) {
                log.trace("FACT Chunk: chunkSize=%d, endSample=0x%X, sampleOffset=0x%X".format(chunkSize, info.atracEndSample, info.atracSampleOffset));
              }
            }
            break;
          }
          case Atrac3plusConstants.SMPL_CHUNK_MAGIC: {
            if (chunkSize >= 36) {
              const checkNumLoops = this.readUnaligned32(mem, currentAddr + 28);
              if (chunkSize >= 36 + checkNumLoops * 24) {
                info.numLoops = checkNumLoops;
                info.loops = ArrayUtils.create(info.numLoops, (_) => new LoopInfo());
                let loopInfoAddr = currentAddr + 36;
                for (let i = 0; i < info.numLoops; i++) {
                  const loop = info.loops[i];
                  info.loops[i] = loop;
                  loop.cuePointID = this.readUnaligned32(mem, loopInfoAddr);
                  loop.type = this.readUnaligned32(mem, loopInfoAddr + 4);
                  loop.startSample = this.readUnaligned32(mem, loopInfoAddr + 8) - info.atracSampleOffset;
                  loop.endSample = this.readUnaligned32(mem, loopInfoAddr + 12) - info.atracSampleOffset;
                  loop.fraction = this.readUnaligned32(mem, loopInfoAddr + 16);
                  loop.playCount = this.readUnaligned32(mem, loopInfoAddr + 20);
                  if (log.isTraceEnabled) {
                    log.trace("Loop #%d: %s".format(i, loop.toString()));
                  }
                  loopInfoAddr += 24;
                }
              }
            }
            break;
          }
        }
        if (chunkSize > bufferSize) {
          break;
        }
        currentAddr += chunkSize;
        bufferSize -= chunkSize;
      }
      for (const loop of info.loops) {
        if (loop.endSample > info.atracEndSample) {
          loop.endSample = info.atracEndSample;
        }
      }
      return result;
    }
    static getStringFromInt32(chunkMagic) {
      return String.fromCharCode(chunkMagic.extract8(0), chunkMagic.extract8(8), chunkMagic.extract8(16), chunkMagic.extract8(24));
    }
  };
  var LoopInfo = class {
    constructor() {
      this.cuePointID = 0;
      this.type = 0;
      this.startSample = 0;
      this.endSample = 0;
      this.fraction = 0;
      this.playCount = 0;
    }
    toString() {
      return sprintf("LoopInfo[cuePointID %d, type %d, startSample 0x%X, endSample 0x%X, fraction %d, playCount %d]", this.cuePointID, this.type, this.startSample, this.endSample, this.fraction, this.playCount);
    }
  };
  var AtracFileInfo = class {
    constructor(atracBitrate = 64, atracChannels = 2, atracSampleRate = 44100, atracBytesPerFrame = 560, atracEndSample = 0, atracSampleOffset = 0, atracCodingMode = 0, inputFileDataOffset = 0, inputFileSize = 0, inputDataSize = 0, loopNum = 0, numLoops = 0, loops = []) {
      this.atracBitrate = atracBitrate;
      this.atracChannels = atracChannels;
      this.atracSampleRate = atracSampleRate;
      this.atracBytesPerFrame = atracBytesPerFrame;
      this.atracEndSample = atracEndSample;
      this.atracSampleOffset = atracSampleOffset;
      this.atracCodingMode = atracCodingMode;
      this.inputFileDataOffset = inputFileDataOffset;
      this.inputFileSize = inputFileSize;
      this.inputDataSize = inputDataSize;
      this.loopNum = loopNum;
      this.numLoops = numLoops;
      this.loops = loops;
    }
  };

  // src/me/atrac3plus/Atrac3PlusDtos.ts
  function BooleanArray(size) {
    return ArrayUtils.create(size, (_) => false);
  }
  function FloatArray(size) {
    return new Float32Array(size);
  }
  function arrayOf(...values) {
    return values;
  }
  var WaveEnvelope = class {
    constructor() {
      this.hasStartPoint = false;
      this.hasStopPoint = false;
      this.startPos = 0;
      this.stopPos = 0;
    }
    clear() {
      this.hasStartPoint = false;
      this.hasStopPoint = false;
      this.startPos = 0;
      this.stopPos = 0;
    }
    copy(from) {
      this.hasStartPoint = from.hasStartPoint;
      this.hasStopPoint = from.hasStopPoint;
      this.startPos = from.startPos;
      this.stopPos = from.stopPos;
    }
  };
  var AtracGainInfo = class {
    constructor() {
      this.numPoints = 0;
      this.levCode = new Int32Array(7);
      this.locCode = new Int32Array(7);
    }
    clear() {
      this.numPoints = 0;
      for (let i = 0; i < 6; i++) {
        this.levCode[i] = 0;
        this.locCode[i] = 0;
      }
    }
    copy(from) {
      this.numPoints = from.numPoints;
      this.levCode.set(from.levCode);
      this.locCode.set(from.locCode);
    }
  };
  var Channel = class {
    constructor(chNum) {
      this.chNum = chNum;
      this.numCodedVals = 0;
      this.fillMode = 0;
      this.splitPoint = 0;
      this.tableType = 0;
      this.quWordlen = new Int32Array(32);
      this.quSfIdx = new Int32Array(32);
      this.quTabIdx = new Int32Array(32);
      this.spectrum = new Int32Array(2048);
      this.powerLevs = new Int32Array(5);
      this.wndShapeHist = ArrayUtils.create(2, (_) => ArrayUtils.create(Atrac3plusConstants.ATRAC3P_SUBBANDS, (_2) => false));
      this.wndShape = this.wndShapeHist[0];
      this.wndShapePrev = this.wndShapeHist[1];
      this.gainDataHist = ArrayUtils.create(2, (_) => ArrayUtils.create(Atrac3plusConstants.ATRAC3P_SUBBANDS, (_2) => new AtracGainInfo()));
      this.gainData = this.gainDataHist[0];
      this.gainDataPrev = this.gainDataHist[1];
      this.numGainSubbands = 0;
      this.tonesInfoHist = ArrayUtils.create(2, (_) => ArrayUtils.create(Atrac3plusConstants.ATRAC3P_SUBBANDS, (_2) => new WavesData()));
      this.tonesInfo = this.tonesInfoHist[0];
      this.tonesInfoPrev = this.tonesInfoHist[1];
    }
  };
  var WaveParam = class {
    constructor() {
      this.freqIndex = 0;
      this.ampSf = 0;
      this.ampIndex = 0;
      this.phaseIndex = 0;
    }
    clear() {
      this.freqIndex = 0;
      this.ampSf = 0;
      this.ampIndex = 0;
      this.phaseIndex = 0;
    }
  };
  var WavesData = class {
    constructor() {
      this.pendEnv = new WaveEnvelope();
      this.currEnv = new WaveEnvelope();
      this.numWavs = 0;
      this.startIndex = 0;
    }
    clear() {
      this.pendEnv.clear();
      this.currEnv.clear();
      this.numWavs = 0;
      this.startIndex = 0;
    }
    copy(from) {
      this.pendEnv.copy(from.pendEnv);
      this.currEnv.copy(from.currEnv);
      this.numWavs = from.numWavs;
      this.startIndex = from.startIndex;
    }
  };
  var WaveSynthParams = class {
    constructor() {
      this.tonesPresent = false;
      this.amplitudeMode = 0;
      this.numToneBands = 0;
      this.toneSharing = BooleanArray(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      this.toneMaster = BooleanArray(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      this.phaseShift = BooleanArray(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      this.tonesIndex = 0;
      this.waves = ArrayUtils.create(48, (_) => new WaveParam());
    }
  };
  var Context = class {
    constructor() {
      this.br = void 0;
      this.dsp = void 0;
      this.channelUnits = new Array(16);
      this.numChannelBlocks = 2;
      this.outputChannels = 0;
      this.gaincCtx = void 0;
      this.mdctCtx = void 0;
      this.ipqfDctCtx = void 0;
      this.samples = ArrayUtils.create(2, (_) => new Float32Array(Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES));
      this.mdctBuf = ArrayUtils.create(2, (_) => new Float32Array(Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES + Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES));
      this.timeBuf = ArrayUtils.create(2, (_) => new Float32Array(Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES));
      this.outpBuf = ArrayUtils.create(2, (_) => new Float32Array(Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES));
    }
  };
  var ChannelUnitContext = class {
    constructor() {
      this.unitType = 0;
      this.numQuantUnits = 0;
      this.numSubbands = 0;
      this.usedQuantUnits = 0;
      this.numCodedSubbands = 0;
      this.muteFlag = false;
      this.useFullTable = false;
      this.noisePresent = false;
      this.noiseLevelIndex = 0;
      this.noiseTableIndex = 0;
      this.swapChannels = BooleanArray(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      this.negateCoeffs = BooleanArray(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      this.channels = arrayOf(new Channel(0), new Channel(1));
      this.waveSynthHist = arrayOf(new WaveSynthParams(), new WaveSynthParams());
      this.wavesInfo = this.waveSynthHist[0];
      this.wavesInfoPrev = this.waveSynthHist[1];
      this.ipqfCtx = arrayOf(new IPQFChannelContext(), new IPQFChannelContext());
      this.prevBuf = ArrayUtils.create(2, (_) => FloatArray(Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES));
    }
  };
  var IPQFChannelContext = class {
    constructor() {
      this.buf1 = ArrayUtils.create(Atrac3plusConstants.ATRAC3P_PQF_FIR_LEN * 2, (_) => FloatArray(8));
      this.buf2 = ArrayUtils.create(Atrac3plusConstants.ATRAC3P_PQF_FIR_LEN * 2, (_) => FloatArray(8));
      this.pos = 0;
    }
  };

  // src/me/MeUtils.ts
  var log2 = logger.named("MeUtils");
  var MemoryUtils = class {
    static arraycopyI(src, srcPos, dst, dstPos, length) {
      dst.set(src.subarray(srcPos, srcPos + length), dstPos);
    }
    static arraycopyF(src, srcPos, dst, dstPos, length) {
      dst.set(src.subarray(srcPos, srcPos + length), dstPos);
    }
    static arraycopyA(src, srcPos, dst, dstPos, length) {
      const overlapping = src === dst && dstPos > srcPos;
      if (overlapping) {
        let n = length;
        while (--n >= 0)
          dst[dstPos + n] = src[srcPos + n];
      } else {
        for (let n = 0; n < length; n++) {
          dst[dstPos + n] = src[srcPos + n];
        }
      }
    }
  };
  var CodecUtils = class {
    static convertSampleFloatToInt16(sample) {
      return Math.min(Math.max(Math.floor(sample * 32768 + 0.5), -32768), 32767) & 65535;
    }
    static writeOutput(samples, output, numberOfSamples, decodedChannels, outputChannels) {
      const samples0 = samples[0];
      switch (outputChannels) {
        case 1: {
          for (let i = 0; i < numberOfSamples; i++) {
            output.writeInt16LE(this.convertSampleFloatToInt16(samples0[i]));
          }
          break;
        }
        case 2: {
          if (decodedChannels == 1) {
            for (let i = 0; i < numberOfSamples; i++) {
              const sample = this.convertSampleFloatToInt16(samples0[i]);
              output.writeInt16LE(sample);
              output.writeInt16LE(sample);
            }
          } else {
            const samples1 = samples[1];
            for (let i = 0; i < numberOfSamples; i++) {
              output.writeInt16LE(this.convertSampleFloatToInt16(samples0[i]));
              output.writeInt16LE(this.convertSampleFloatToInt16(samples1[i]));
            }
          }
          break;
        }
      }
    }
    static avLog2(n) {
      return n == 0 ? 0 : 31 - Math.clz32(n);
    }
  };
  var BitReader = class {
    constructor(mem, addr, size) {
      this.mem = mem;
      this.addr = addr;
      this.size = size;
      this.initialAddr = this.addr;
      this.initialSize = this.size;
      this.bits = 0;
      this.value = 0;
      this.direction = 1;
    }
    get bitsLeft() {
      return (this.size << 3) + this.bits;
    }
    get bytesRead() {
      let bytesRead = this.addr - this.initialAddr;
      if (this.bits == 8)
        bytesRead--;
      return bytesRead;
    }
    get bitsRead() {
      return (this.addr - this.initialAddr) * 8 - this.bits;
    }
    readBool() {
      return this.read1() != 0;
    }
    read1() {
      if (this.bits <= 0) {
        this.value = this.mem.read8(this.addr);
        this.addr += this.direction;
        this.size--;
        this.bits = 8;
      }
      const bit = this.value >> 7;
      this.bits--;
      this.value = this.value << 1 & 255;
      return bit;
    }
    read(n) {
      let read;
      if (n <= this.bits) {
        read = this.value >> 8 - n;
        this.bits -= n;
        this.value = this.value << n & 255;
      } else {
        read = 0;
        while (n > 0) {
          read = (read << 1) + this.read1();
          n--;
        }
      }
      return read;
    }
    readByte() {
      if (this.bits == 8) {
        this.bits = 0;
        return this.value;
      }
      if (this.bits > 0) {
        this.skip(this.bits);
      }
      const read = this.mem.read8(this.addr);
      this.addr += this.direction;
      this.size--;
      return read;
    }
    peek(n) {
      const read = this.read(n);
      this.skip(-n);
      return read;
    }
    skip(n) {
      this.bits -= n;
      if (n >= 0) {
        while (this.bits < 0) {
          this.addr += this.direction;
          this.size--;
          this.bits += 8;
        }
      } else {
        while (this.bits > 8) {
          this.addr -= this.direction;
          this.size++;
          this.bits -= 8;
        }
      }
      if (this.bits > 0) {
        this.value = this.mem.read8(this.addr - this.direction);
        this.value = this.value << 8 - this.bits & 255;
      }
    }
    seek(n) {
      this.addr = this.initialAddr + n;
      this.size = this.initialSize - n;
      this.bits = 0;
    }
    setDirection(direction) {
      this.direction = direction;
      this.bits = 0;
    }
    byteAlign() {
      if (this.bits > 0 && this.bits < 8) {
        this.skip(this.bits);
      }
    }
    toString() {
      return sprintf("BitReader addr=0x%08X, bits=%d, size=0x%X, bits read %d", this.addr, this.bits, this.size, this.bitsRead);
    }
  };
  var Dct32 = class {
    static BF(_val, a, b, c, s) {
      const tmp0 = _val[a] + _val[b];
      const tmp1 = _val[a] - _val[b];
      _val[a] = tmp0;
      _val[b] = tmp1 * c * (1 << s);
    }
    static BF0(tab, tabOffset, _val, a, b, c, s) {
      const tmp0 = tab[tabOffset + a] + tab[tabOffset + b];
      const tmp1 = tab[tabOffset + a] - tab[tabOffset + b];
      _val[a] = tmp0;
      _val[b] = tmp1 * c * (1 << s);
    }
    static BF1(_val, a, b, c, d) {
      this.BF(_val, a, b, this.COS4_0, 1);
      this.BF(_val, c, d, -this.COS4_0, 1);
      _val[c] += _val[d];
    }
    static BF2(_val, a, b, c, d) {
      this.BF(_val, a, b, this.COS4_0, 1);
      this.BF(_val, c, d, -this.COS4_0, 1);
      _val[c] += _val[d];
      _val[a] += _val[c];
      _val[c] += _val[b];
      _val[b] += _val[d];
    }
    static ADD(_val, a, b) {
      _val[a] += _val[b];
    }
    static dct32(out, outOffset, tab, tabOffset) {
      const _val = new Float32Array(32);
      this.BF0(tab, tabOffset, _val, 0, 31, this.COS0_0, 1);
      this.BF0(tab, tabOffset, _val, 15, 16, this.COS0_15, 5);
      this.BF(_val, 0, 15, this.COS1_0, 1);
      this.BF(_val, 16, 31, -this.COS1_0, 1);
      this.BF0(tab, tabOffset, _val, 7, 24, this.COS0_7, 1);
      this.BF0(tab, tabOffset, _val, 8, 23, this.COS0_8, 1);
      this.BF(_val, 7, 8, this.COS1_7, 4);
      this.BF(_val, 23, 24, -this.COS1_7, 4);
      this.BF(_val, 0, 7, this.COS2_0, 1);
      this.BF(_val, 8, 15, -this.COS2_0, 1);
      this.BF(_val, 16, 23, this.COS2_0, 1);
      this.BF(_val, 24, 31, -this.COS2_0, 1);
      this.BF0(tab, tabOffset, _val, 3, 28, this.COS0_3, 1);
      this.BF0(tab, tabOffset, _val, 12, 19, this.COS0_12, 2);
      this.BF(_val, 3, 12, this.COS1_3, 1);
      this.BF(_val, 19, 28, -this.COS1_3, 1);
      this.BF0(tab, tabOffset, _val, 4, 27, this.COS0_4, 1);
      this.BF0(tab, tabOffset, _val, 11, 20, this.COS0_11, 2);
      this.BF(_val, 4, 11, this.COS1_4, 1);
      this.BF(_val, 20, 27, -this.COS1_4, 1);
      this.BF(_val, 3, 4, this.COS2_3, 3);
      this.BF(_val, 11, 12, -this.COS2_3, 3);
      this.BF(_val, 19, 20, this.COS2_3, 3);
      this.BF(_val, 27, 28, -this.COS2_3, 3);
      this.BF(_val, 0, 3, this.COS3_0, 1);
      this.BF(_val, 4, 7, -this.COS3_0, 1);
      this.BF(_val, 8, 11, this.COS3_0, 1);
      this.BF(_val, 12, 15, -this.COS3_0, 1);
      this.BF(_val, 16, 19, this.COS3_0, 1);
      this.BF(_val, 20, 23, -this.COS3_0, 1);
      this.BF(_val, 24, 27, this.COS3_0, 1);
      this.BF(_val, 28, 31, -this.COS3_0, 1);
      this.BF0(tab, tabOffset, _val, 1, 30, this.COS0_1, 1);
      this.BF0(tab, tabOffset, _val, 14, 17, this.COS0_14, 3);
      this.BF(_val, 1, 14, this.COS1_1, 1);
      this.BF(_val, 17, 30, -this.COS1_1, 1);
      this.BF0(tab, tabOffset, _val, 6, 25, this.COS0_6, 1);
      this.BF0(tab, tabOffset, _val, 9, 22, this.COS0_9, 1);
      this.BF(_val, 6, 9, this.COS1_6, 2);
      this.BF(_val, 22, 25, -this.COS1_6, 2);
      this.BF(_val, 1, 6, this.COS2_1, 1);
      this.BF(_val, 9, 14, -this.COS2_1, 1);
      this.BF(_val, 17, 22, this.COS2_1, 1);
      this.BF(_val, 25, 30, -this.COS2_1, 1);
      this.BF0(tab, tabOffset, _val, 2, 29, this.COS0_2, 1);
      this.BF0(tab, tabOffset, _val, 13, 18, this.COS0_13, 3);
      this.BF(_val, 2, 13, this.COS1_2, 1);
      this.BF(_val, 18, 29, -this.COS1_2, 1);
      this.BF0(tab, tabOffset, _val, 5, 26, this.COS0_5, 1);
      this.BF0(tab, tabOffset, _val, 10, 21, this.COS0_10, 1);
      this.BF(_val, 5, 10, this.COS1_5, 2);
      this.BF(_val, 21, 26, -this.COS1_5, 2);
      this.BF(_val, 2, 5, this.COS2_2, 1);
      this.BF(_val, 10, 13, -this.COS2_2, 1);
      this.BF(_val, 18, 21, this.COS2_2, 1);
      this.BF(_val, 26, 29, -this.COS2_2, 1);
      this.BF(_val, 1, 2, this.COS3_1, 2);
      this.BF(_val, 5, 6, -this.COS3_1, 2);
      this.BF(_val, 9, 10, this.COS3_1, 2);
      this.BF(_val, 13, 14, -this.COS3_1, 2);
      this.BF(_val, 17, 18, this.COS3_1, 2);
      this.BF(_val, 21, 22, -this.COS3_1, 2);
      this.BF(_val, 25, 26, this.COS3_1, 2);
      this.BF(_val, 29, 30, -this.COS3_1, 2);
      this.BF1(_val, 0, 1, 2, 3);
      this.BF2(_val, 4, 5, 6, 7);
      this.BF1(_val, 8, 9, 10, 11);
      this.BF2(_val, 12, 13, 14, 15);
      this.BF1(_val, 16, 17, 18, 19);
      this.BF2(_val, 20, 21, 22, 23);
      this.BF1(_val, 24, 25, 26, 27);
      this.BF2(_val, 28, 29, 30, 31);
      this.ADD(_val, 8, 12);
      this.ADD(_val, 12, 10);
      this.ADD(_val, 10, 14);
      this.ADD(_val, 14, 9);
      this.ADD(_val, 9, 13);
      this.ADD(_val, 13, 11);
      this.ADD(_val, 11, 15);
      out[outOffset + 0] = _val[0];
      out[outOffset + 16] = _val[1];
      out[outOffset + 8] = _val[2];
      out[outOffset + 24] = _val[3];
      out[outOffset + 4] = _val[4];
      out[outOffset + 20] = _val[5];
      out[outOffset + 12] = _val[6];
      out[outOffset + 28] = _val[7];
      out[outOffset + 2] = _val[8];
      out[outOffset + 18] = _val[9];
      out[outOffset + 10] = _val[10];
      out[outOffset + 26] = _val[11];
      out[outOffset + 6] = _val[12];
      out[outOffset + 22] = _val[13];
      out[outOffset + 14] = _val[14];
      out[outOffset + 30] = _val[15];
      this.ADD(_val, 24, 28);
      this.ADD(_val, 28, 26);
      this.ADD(_val, 26, 30);
      this.ADD(_val, 30, 25);
      this.ADD(_val, 25, 29);
      this.ADD(_val, 29, 27);
      this.ADD(_val, 27, 31);
      out[outOffset + 1] = _val[16] + _val[24];
      out[outOffset + 17] = _val[17] + _val[25];
      out[outOffset + 9] = _val[18] + _val[26];
      out[outOffset + 25] = _val[19] + _val[27];
      out[outOffset + 5] = _val[20] + _val[28];
      out[outOffset + 21] = _val[21] + _val[29];
      out[outOffset + 13] = _val[22] + _val[30];
      out[outOffset + 29] = _val[23] + _val[31];
      out[outOffset + 3] = _val[24] + _val[20];
      out[outOffset + 19] = _val[25] + _val[21];
      out[outOffset + 11] = _val[26] + _val[22];
      out[outOffset + 27] = _val[27] + _val[23];
      out[outOffset + 7] = _val[28] + _val[18];
      out[outOffset + 23] = _val[29] + _val[19];
      out[outOffset + 15] = _val[30] + _val[17];
      out[outOffset + 31] = _val[31];
    }
  };
  Dct32.COS0_0 = 0.5006029982351963 / 2;
  Dct32.COS0_1 = 0.5054709598975436 / 2;
  Dct32.COS0_2 = 0.5154473099226246 / 2;
  Dct32.COS0_3 = 0.5310425910897841 / 2;
  Dct32.COS0_4 = 0.5531038960344445 / 2;
  Dct32.COS0_5 = 0.5829349682061339 / 2;
  Dct32.COS0_6 = 0.6225041230356648 / 2;
  Dct32.COS0_7 = 0.6748083414550058 / 2;
  Dct32.COS0_8 = 0.7445362710022985 / 2;
  Dct32.COS0_9 = 0.839349645415527 / 2;
  Dct32.COS0_10 = 0.9725682378619607 / 2;
  Dct32.COS0_11 = 1.1694399334328849 / 4;
  Dct32.COS0_12 = 1.4841646163141662 / 4;
  Dct32.COS0_13 = 2.0577810099534117 / 8;
  Dct32.COS0_14 = 3.407608418468719 / 8;
  Dct32.COS0_15 = 10.190008123548056 / 32;
  Dct32.COS1_0 = 0.5024192861881557 / 2;
  Dct32.COS1_1 = 0.5224986149396889 / 2;
  Dct32.COS1_2 = 0.5669440348163577 / 2;
  Dct32.COS1_3 = 0.6468217833599901 / 2;
  Dct32.COS1_4 = 0.7881546234512502 / 2;
  Dct32.COS1_5 = 1.0606776859903475 / 4;
  Dct32.COS1_6 = 1.722447098238334 / 4;
  Dct32.COS1_7 = 5.101148618689164 / 16;
  Dct32.COS2_0 = 0.5097955791041592 / 2;
  Dct32.COS2_1 = 0.6013448869350453 / 2;
  Dct32.COS2_2 = 0.8999762231364157 / 2;
  Dct32.COS2_3 = 2.5629154477415064 / 8;
  Dct32.COS3_0 = 0.541196100146197 / 2;
  Dct32.COS3_1 = 1.3065629648763766 / 4;
  Dct32.COS4_0 = 0.7071067811865476 / 2;
  var SineWin = class {
    static sineWindowInit(window2) {
      const n = window2.length;
      for (let i = 0; i < n; i++) {
        window2[i] = Math.sin((i + 0.5) * (Math.PI / (2 * n)));
      }
    }
    static initFfSineWindows() {
      this.sineWindowInit(this.ff_sine_64);
      this.sineWindowInit(this.ff_sine_128);
      this.sineWindowInit(this.ff_sine_512);
      this.sineWindowInit(this.ff_sine_1024);
    }
  };
  SineWin.ff_sine_64 = new Float32Array(64);
  SineWin.ff_sine_128 = new Float32Array(128);
  SineWin.ff_sine_512 = new Float32Array(512);
  SineWin.ff_sine_1024 = new Float32Array(1024);
  var FloatDSP = class {
    static vectorFmul(dst, dstOffset, src0, src0Offset, src1, src1Offset, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] = src0[src0Offset + i] * src1[src1Offset + i];
      }
    }
    static vectorFmacScalar(dst, dstOffset, src, srcOffset, mul, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] += src[srcOffset + i] * mul;
      }
    }
    static vectorFmulScalar(dst, dstOffset, src, srcOffset, mul, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] = src[srcOffset + i] * mul;
      }
    }
    static vectorDmulScalar(dst, dstOffset, src, srcOffset, mul, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] = src[srcOffset + i] * mul;
      }
    }
    static vectorFmulWindow(dst, dstOffset, src0, src0Offset, src1, src1Offset, win, winOffset, len) {
      dstOffset += len;
      winOffset += len;
      src0Offset += len;
      let i = -len;
      let j = len - 1;
      while (i < 0) {
        const s0 = src0[src0Offset + i];
        const s1 = src1[src1Offset + j];
        const wi = win[winOffset + i];
        const wj = win[winOffset + j];
        dst[dstOffset + i] = s0 * wj - s1 * wi;
        dst[dstOffset + j] = s0 * wi + s1 * wj;
        i++;
        j--;
      }
    }
    static vectorFmulAdd(dst, dstOffset, src0, src0Offset, src1, src1Offset, src2, src2Offset, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] = src0[src0Offset + i] * src1[src1Offset + i] + src2[src2Offset + i];
      }
    }
    static vectorFmulReverse(dst, dstOffset, src0, src0Offset, src1, src1Offset, len) {
      for (let i = 0; i < len; i++) {
        dst[dstOffset + i] = src0[src0Offset + i] * src1[src1Offset + len - 1 - i];
      }
    }
    static butterflies(v1, v1Offset, v2, v2Offset, len) {
      for (let i = 0; i < len; i++) {
        const t = v1[v1Offset + i] - v2[v2Offset + i];
        v1[v1Offset + i] += v2[v2Offset + i];
        v2[v2Offset + i] = t;
      }
    }
    static scalarproduct(v1, v1Offset, v2, v2Offset, len) {
      let p = 0;
      for (let i = 0; i < len; i++) {
        p += v1[v1Offset + i] * v2[v2Offset + i];
      }
      return p;
    }
  };
  var VLCcode = class {
    constructor() {
      this.bits = 0;
      this.symbol = 0;
      this.code = 0;
    }
    compareTo(o) {
      return (this.code >>> 1) - (o.code >>> 1);
    }
  };
  var VLC = class {
    constructor() {
      this.bits = 0;
      this.tableSize = 0;
      this.tableAllocated = 0;
    }
    initVLCSparse3(bits, codes, symbols) {
      return this.initVLCSparse(bits.length, codes.length, bits, codes, symbols);
    }
    initVLCSparse(nbBits, nbCodes, bits, codes, symbols) {
      const buf = new Array(nbCodes + 1);
      this.bits = nbBits;
      let j = 0;
      for (let i = 0; i < nbCodes; i++) {
        const vlCcode = new VLCcode();
        buf[j] = vlCcode;
        vlCcode.bits = bits[i];
        if (vlCcode.bits <= nbBits) {
          continue;
        }
        if (vlCcode.bits > 3 * nbBits || vlCcode.bits > 32) {
          log2.error("Too long VLC (%d) in initVLC".format(vlCcode.bits));
          return -1;
        }
        vlCcode.code = codes[i];
        if (vlCcode.code >= 1 << vlCcode.bits) {
          log2.error("Invalid code in initVLC");
          return -1;
        }
        vlCcode.code = vlCcode.code << 32 - vlCcode.bits;
        if (symbols != null) {
          vlCcode.symbol = symbols[i];
        } else {
          vlCcode.symbol = i;
        }
        j++;
      }
      this.Arrays_sort(buf, 0, j);
      for (let i = 0; i < nbCodes; i++) {
        const vlCcode = new VLCcode();
        buf[j] = vlCcode;
        vlCcode.bits = bits[i];
        if (!(vlCcode.bits != 0 && vlCcode.bits <= nbBits)) {
          continue;
        }
        vlCcode.code = codes[i];
        vlCcode.code = vlCcode.code << 32 - vlCcode.bits;
        if (symbols != null) {
          vlCcode.symbol = symbols[i];
        } else {
          vlCcode.symbol = i;
        }
        j++;
      }
      nbCodes = j;
      return this.buildTable(nbBits, nbCodes, buf, 0);
    }
    Arrays_sort(buf, fromIndex, toIndex) {
      const sorted = buf.slice(fromIndex, toIndex).sort((a, b) => a.compareTo(b));
      MemoryUtils.arraycopyA(sorted, 0, buf, fromIndex, toIndex - fromIndex);
    }
    buildTable(tableNbBits, nbCodes, codes, codeOffset) {
      const tableSize = 1 << tableNbBits;
      if (tableNbBits > 30) {
        return -1;
      }
      const tableIndex = this.allocTable(tableSize);
      if (tableIndex < 0) {
        return tableIndex;
      }
      {
        var i = 0;
        while (i < nbCodes) {
          var n = codes[codeOffset + i].bits;
          var code = codes[codeOffset + i].code;
          const symbol = codes[codeOffset + i].symbol;
          if (n <= tableNbBits) {
            var j = code >>> 32 - tableNbBits;
            const nb = 1 << tableNbBits - n;
            const inc = 1;
            for (let k = 0; k < nb; k++) {
              const bits = this.table[tableIndex + j][1];
              if (bits != 0 && bits != n) {
                log2.error("incorrect codes");
                return -1;
              }
              this.table[tableIndex + j][1] = n;
              this.table[tableIndex + j][0] = symbol;
              j += inc;
            }
          } else {
            n -= tableNbBits;
            const codePrefix = code >>> 32 - tableNbBits;
            let subtableBits = n;
            codes[codeOffset + i].bits = n;
            codes[codeOffset + i].code = code << tableNbBits;
            let k;
            k = i + 1;
            while (k < nbCodes) {
              n = codes[codeOffset + k].bits - tableNbBits;
              if (n <= 0) {
                break;
              }
              code = codes[codeOffset + k].code;
              if (code >>> 32 - tableNbBits != codePrefix) {
                break;
              }
              codes[codeOffset + k].bits = n;
              codes[codeOffset + k].code = code << tableNbBits;
              subtableBits = Math.max(subtableBits, n);
              k++;
            }
            subtableBits = Math.min(subtableBits, tableNbBits);
            this.table[tableIndex + codePrefix][1] = -subtableBits;
            const index = this.buildTable(subtableBits, k - i, codes, codeOffset + i);
            if (index < 0) {
              return index;
            }
            this.table[tableIndex + codePrefix][0] = index;
            i = k - 1;
          }
          i++;
        }
      }
      for (let i2 = 0; i2 < tableSize; i2++) {
        if (this.table[tableIndex + i2][1] == 0) {
          this.table[tableIndex + i2][0] = -1;
        }
      }
      return tableIndex;
    }
    allocTable(size) {
      const index = this.tableSize;
      this.tableSize += size;
      this.tableAllocated = this.tableSize;
      const newTable = ArrayUtils.create(this.tableAllocated, (_) => new Int32Array(2));
      if (this.table != null) {
        for (let i = 0; i < index; i++) {
          newTable[i][0] = this.table[i][0];
          newTable[i][1] = this.table[i][1];
        }
      }
      this.table = newTable;
      return index;
    }
    getVLC2(br, maxDepth = 1) {
      let nbBits;
      let index = br.peek(this.bits);
      if (index < 0)
        throw new Error(`Invalid index ${index}`);
      let code = this.table[index][0];
      let n = this.table[index][1];
      if (maxDepth > 1 && n < 0) {
        br.skip(this.bits);
        nbBits = -n;
        index = br.peek(nbBits) + code;
        code = this.table[index][0];
        n = this.table[index][1];
        if (maxDepth > 2 && n < 0) {
          br.skip(nbBits);
          nbBits = -n;
          index = br.peek(nbBits) + code;
          code = this.table[index][0];
          n = this.table[index][1];
        }
      }
      br.skip(n);
      return code;
    }
  };
  var _FFT = class {
    constructor() {
      this.nbits = 0;
      this.inverse = false;
      this.revtab = new Int32Array(0);
      this.tmpBuf = new Float32Array(0);
      this.mdctSize = 0;
      this.mdctBits = 0;
      this.tcos = new Float32Array(0);
      this.tsin = new Float32Array(0);
      this.TEMP_FLOAT4 = new Float32Array(4);
    }
    copy(that) {
      this.nbits = that.nbits;
      this.inverse = that.inverse;
      this.copyI(this.revtab, that.revtab);
      this.copyF(this.tmpBuf, that.tmpBuf);
      this.mdctSize = that.mdctSize;
      this.mdctBits = that.mdctBits;
      this.copyF(this.tcos, that.tcos);
      this.copyF(this.tsin, that.tsin);
    }
    copyI(dst, src) {
      dst.set(src);
    }
    copyF(dst, src) {
      dst.set(src);
    }
    fftInit(nbits, inverse) {
      if (nbits < 2 || nbits > 16) {
        this.revtab = new Int32Array(0);
        this.tmpBuf = new Float32Array(0);
        return -1;
      }
      this.nbits = nbits;
      this.inverse = inverse;
      const n = 1 << nbits;
      this.revtab = new Int32Array(n);
      this.tmpBuf = new Float32Array(n * 2);
      _FFT.initFfCosTabs(_FFT.ff_cos_16, 16);
      _FFT.initFfCosTabs(_FFT.ff_cos_32, 32);
      _FFT.initFfCosTabs(_FFT.ff_cos_64, 64);
      _FFT.initFfCosTabs(_FFT.ff_cos_128, 128);
      _FFT.initFfCosTabs(_FFT.ff_cos_256, 256);
      _FFT.initFfCosTabs(_FFT.ff_cos_512, 512);
      for (let i = 0; i < n; i++) {
        this.revtab[-_FFT.splitRadixPermutation(i, n, inverse) & n - 1] = i;
      }
      return 0;
    }
    mdctInit(nbits, inverse, scale) {
      const n = 1 << nbits;
      this.mdctBits = nbits;
      this.mdctSize = n;
      const n4 = n >> 2;
      const ret = this.fftInit(this.mdctBits - 2, inverse);
      if (ret < 0) {
        return ret;
      }
      this.tcos = new Float32Array(n4);
      this.tsin = new Float32Array(n4);
      const theta = 1 / 8 + (scale < 0 ? n4 : 0);
      scale = Math.sqrt(Math.abs(scale));
      for (let i = 0; i < n4; i++) {
        const alpha = 2 * Math.PI * (i + theta) / n;
        this.tcos[i] = -Math.cos(alpha) * scale;
        this.tsin[i] = -Math.sin(alpha) * scale;
      }
      return 0;
    }
    imdctCalc(output, outputOffset, input, inputOffset) {
      const n = 1 << this.mdctBits;
      const n2 = n >> 1;
      const n4 = n >> 2;
      this.imdctHalf(output, outputOffset + n4, input, inputOffset);
      for (let k = 0; k < n4; k++) {
        output[outputOffset + k] = -output[outputOffset + n2 - k - 1];
        output[outputOffset + n - k - 1] = output[outputOffset + n2 + k];
      }
    }
    imdctHalf(output, outputOffset, input, inputOffset) {
      const n = 1 << this.mdctBits;
      const n2 = n >> 1;
      const n4 = n >> 2;
      const n8 = n >> 3;
      let in1 = 0;
      let in2 = n2 - 1;
      for (let k = 0; k < n4; k++) {
        const j = this.revtab[k];
        _FFT.CMUL(output, outputOffset + j * 2, outputOffset + j * 2 + 1, input[inputOffset + in2], input[inputOffset + in1], this.tcos[k], this.tsin[k]);
        in1 += 2;
        in2 -= 2;
      }
      this.fftCalcFloat(output, outputOffset);
      const r = this.TEMP_FLOAT4;
      for (let i = 0; i < n8; i++) {
        const offset0 = outputOffset + (n8 - i - 1) * 2 + 0 | 0;
        const offset1 = outputOffset + (n8 - i - 1) * 2 + 1 | 0;
        const offset2 = outputOffset + (n8 + i) * 2 + 0 | 0;
        const offset3 = outputOffset + (n8 + i) * 2 + 1 | 0;
        _FFT.CMUL(r, 0, 3, output[offset1], output[offset0], this.tsin[n8 - i - 1], this.tcos[n8 - i - 1]);
        _FFT.CMUL(r, 2, 1, output[offset3], output[offset2], this.tsin[n8 + i], this.tcos[n8 + i]);
        output[offset0] = r[0];
        output[offset1] = r[1];
        output[offset2] = r[2];
        output[offset3] = r[3];
      }
    }
    fft4(z, o) {
      const t3 = z[o + 0] - z[o + 2];
      const t1 = z[o + 0] + z[o + 2];
      const t8 = z[o + 6] - z[o + 4];
      const t6 = z[o + 6] + z[o + 4];
      z[o + 4] = t1 - t6;
      z[o + 0] = t1 + t6;
      const t4 = z[o + 1] - z[o + 3];
      const t2 = z[o + 1] + z[o + 3];
      const t7 = z[o + 5] - z[o + 7];
      const t5 = z[o + 5] + z[o + 7];
      z[o + 7] = t4 - t8;
      z[o + 3] = t4 + t8;
      z[o + 6] = t3 - t7;
      z[o + 2] = t3 + t7;
      z[o + 5] = t2 - t5;
      z[o + 1] = t2 + t5;
    }
    fft8(z, o) {
      this.fft4(z, o);
      let t1 = z[o + 8] + z[o + 10];
      z[o + 10] = z[o + 8] - z[o + 10];
      let t2 = z[o + 9] + z[o + 11];
      z[o + 11] = z[o + 9] - z[o + 11];
      let t5 = z[o + 12] + z[o + 14];
      z[o + 14] = z[o + 12] - z[o + 14];
      let t6 = z[o + 13] + z[o + 15];
      z[o + 15] = z[o + 13] - z[o + 15];
      let t3 = t5 - t1;
      t5 = t5 + t1;
      z[o + 8] = z[o + 0] - t5;
      z[o + 0] = z[o + 0] + t5;
      z[o + 13] = z[o + 5] - t3;
      z[o + 5] = z[o + 5] + t3;
      var t4 = t2 - t6;
      t6 = t2 + t6;
      z[o + 12] = z[o + 4] - t4;
      z[o + 4] = z[o + 4] + t4;
      z[o + 9] = z[o + 1] - t6;
      z[o + 1] = z[o + 1] + t6;
      t1 = z[o + 10] * _FFT.sqrthalf + z[o + 11] * _FFT.sqrthalf;
      t2 = -z[o + 10] * _FFT.sqrthalf + z[o + 11] * _FFT.sqrthalf;
      t5 = z[o + 14] * _FFT.sqrthalf - z[o + 15] * _FFT.sqrthalf;
      t6 = z[o + 14] * _FFT.sqrthalf + z[o + 15] * _FFT.sqrthalf;
      t3 = t5 - t1;
      t5 = t5 + t1;
      z[o + 10] = z[o + 2] - t5;
      z[o + 2] = z[o + 2] + t5;
      z[o + 15] = z[o + 7] - t3;
      z[o + 7] = z[o + 7] + t3;
      t4 = t2 - t6;
      t6 = t2 + t6;
      z[o + 14] = z[o + 6] - t4;
      z[o + 6] = z[o + 6] + t4;
      z[o + 11] = z[o + 3] - t6;
      z[o + 3] = z[o + 3] + t6;
    }
    pass(z, o, cos, n) {
      let o0 = o;
      let o1 = o + 2 * n * 2;
      let o2 = o + 4 * n * 2;
      let o3 = o + 6 * n * 2;
      let wre = 0;
      let wim = 2 * n;
      n--;
      let t1 = z[o2 + 0];
      let t2 = z[o2 + 1];
      let t5 = z[o3 + 0];
      let t6 = z[o3 + 1];
      let t3 = t5 - t1;
      t5 = t5 + t1;
      z[o2 + 0] = z[o0 + 0] - t5;
      z[o0 + 0] = z[o0 + 0] + t5;
      z[o3 + 1] = z[o1 + 1] - t3;
      z[o1 + 1] = z[o1 + 1] + t3;
      var t4 = t2 - t6;
      t6 = t2 + t6;
      z[o3 + 0] = z[o1 + 0] - t4;
      z[o1 + 0] = z[o1 + 0] + t4;
      z[o2 + 1] = z[o0 + 1] - t6;
      z[o0 + 1] = z[o0 + 1] + t6;
      t1 = z[o2 + 2] * cos[wre + 1] + z[o2 + 3] * cos[wim - 1];
      t2 = -z[o2 + 2] * cos[wim - 1] + z[o2 + 3] * cos[wre + 1];
      t5 = z[o3 + 2] * cos[wre + 1] - z[o3 + 3] * cos[wim - 1];
      t6 = z[o3 + 2] * cos[wim - 1] + z[o3 + 3] * cos[wre + 1];
      t3 = t5 - t1;
      t5 = t5 + t1;
      z[o2 + 2] = z[o0 + 2] - t5;
      z[o0 + 2] = z[o0 + 2] + t5;
      z[o3 + 3] = z[o1 + 3] - t3;
      z[o1 + 3] = z[o1 + 3] + t3;
      t4 = t2 - t6;
      t6 = t2 + t6;
      z[o3 + 2] = z[o1 + 2] - t4;
      z[o1 + 2] = z[o1 + 2] + t4;
      z[o2 + 3] = z[o0 + 3] - t6;
      z[o0 + 3] = z[o0 + 3] + t6;
      do {
        o0 += 4;
        o1 += 4;
        o2 += 4;
        o3 += 4;
        wre += 2;
        wim -= 2;
        t1 = z[o2 + 0] * cos[wre] + z[o2 + 1] * cos[wim];
        t2 = -z[o2 + 0] * cos[wim] + z[o2 + 1] * cos[wre];
        t5 = z[o3 + 0] * cos[wre] - z[o3 + 1] * cos[wim];
        t6 = z[o3 + 0] * cos[wim] + z[o3 + 1] * cos[wre];
        t3 = t5 - t1;
        t5 = t5 + t1;
        z[o2 + 0] = z[o0 + 0] - t5;
        z[o0 + 0] = z[o0 + 0] + t5;
        z[o3 + 1] = z[o1 + 1] - t3;
        z[o1 + 1] = z[o1 + 1] + t3;
        t4 = t2 - t6;
        t6 = t2 + t6;
        z[o3 + 0] = z[o1 + 0] - t4;
        z[o1 + 0] = z[o1 + 0] + t4;
        z[o2 + 1] = z[o0 + 1] - t6;
        z[o0 + 1] = z[o0 + 1] + t6;
        t1 = z[o2 + 2] * cos[wre + 1] + z[o2 + 3] * cos[wim - 1];
        t2 = -z[o2 + 2] * cos[wim - 1] + z[o2 + 3] * cos[wre + 1];
        t5 = z[o3 + 2] * cos[wre + 1] - z[o3 + 3] * cos[wim - 1];
        t6 = z[o3 + 2] * cos[wim - 1] + z[o3 + 3] * cos[wre + 1];
        t3 = t5 - t1;
        t5 = t5 + t1;
        z[o2 + 2] = z[o0 + 2] - t5;
        z[o0 + 2] = z[o0 + 2] + t5;
        z[o3 + 3] = z[o1 + 3] - t3;
        z[o1 + 3] = z[o1 + 3] + t3;
        t4 = t2 - t6;
        t6 = t2 + t6;
        z[o3 + 2] = z[o1 + 2] - t4;
        z[o1 + 2] = z[o1 + 2] + t4;
        z[o2 + 3] = z[o0 + 3] - t6;
        z[o0 + 3] = z[o0 + 3] + t6;
      } while (--n != 0);
    }
    fft16(z, o) {
      this.fft8(z, o);
      this.fft4(z, o + 16);
      this.fft4(z, o + 24);
      this.pass(z, o, _FFT.ff_cos_16, 2);
    }
    fft32(z, o) {
      this.fft16(z, o);
      this.fft8(z, o + 32);
      this.fft8(z, o + 48);
      this.pass(z, o, _FFT.ff_cos_32, 4);
    }
    fft64(z, o) {
      this.fft32(z, o);
      this.fft16(z, o + 64);
      this.fft16(z, o + 96);
      this.pass(z, o, _FFT.ff_cos_64, 8);
    }
    fft128(z, o) {
      this.fft64(z, o);
      this.fft32(z, o + 128);
      this.fft32(z, o + 192);
      this.pass(z, o, _FFT.ff_cos_128, 16);
    }
    fft256(z, o) {
      this.fft128(z, o);
      this.fft64(z, o + 256);
      this.fft64(z, o + 384);
      this.pass(z, o, _FFT.ff_cos_256, 32);
    }
    fft512(z, o) {
      this.fft256(z, o);
      this.fft128(z, o + 512);
      this.fft128(z, o + 768);
      this.pass(z, o, _FFT.ff_cos_512, 64);
    }
    fftCalcFloat(z, o) {
      switch (this.nbits) {
        case 2:
          return this.fft4(z, 0);
        case 3:
          return this.fft8(z, o);
        case 4:
          return this.fft16(z, 0);
        case 5:
          return this.fft32(z, 0);
        case 6:
          return this.fft64(z, o);
        case 7:
          return this.fft128(z, o);
        case 8:
          return this.fft256(z, 0);
        case 9:
          return this.fft512(z, 0);
        default:
          log2.error("FFT nbits=%d not implemented".format(this.nbits));
      }
    }
    mdctCalc(output, outputOffset, input, inputOffset) {
      const n = 1 << this.mdctBits;
      const n2 = n >> 1;
      const n4 = n >> 2;
      const n8 = n >> 3;
      const n3 = 3 * n4;
      for (let i = 0; i < n8; i++) {
        {
          const re = -input[inputOffset + 2 * i + n3] - input[inputOffset + n3 - 1 - 2 * i];
          const im = -input[inputOffset + n4 + 2 * i] + input[inputOffset + n4 - 1 - 2 * i];
          const j = this.revtab[i];
          _FFT.CMUL(output, outputOffset + 2 * j + 0, outputOffset + 2 * j + 1, re, im, -this.tcos[i], this.tsin[i]);
        }
        {
          const re = input[inputOffset + 2 * i] - input[inputOffset + n2 - 1 - 2 * i];
          const im = -input[inputOffset + n2 + 2 * i] - input[inputOffset + n - 1 - 2 * i];
          const j = this.revtab[n8 + i];
          _FFT.CMUL(output, outputOffset + 2 * j + 0, outputOffset + 2 * j + 1, re, im, -this.tcos[n8 + i], this.tsin[n8 + i]);
        }
      }
      this.fftCalcFloat(output, outputOffset);
      const r = this.TEMP_FLOAT4;
      for (let i = 0; i < n8; i++) {
        const offset0 = outputOffset + (n8 - i - 1) * 2 + 0 | 0;
        const offset1 = outputOffset + (n8 - i - 1) * 2 + 1 | 0;
        const offset2 = outputOffset + (n8 + i) * 2 + 0 | 0;
        const offset4 = outputOffset + (n8 + i) * 2 + 1 | 0;
        _FFT.CMUL(r, 3, 0, output[offset0], output[offset1], -this.tsin[n8 - i - 1], -this.tcos[n8 - i - 1]);
        _FFT.CMUL(r, 1, 2, output[offset2], output[offset4], -this.tsin[n8 + i], -this.tcos[n8 + i]);
        output[offset0] = r[0];
        output[offset1] = r[1];
        output[offset2] = r[2];
        output[offset4] = r[3];
      }
    }
    static initFfCosTabs(tab, m) {
      const freq = 2 * Math.PI / m;
      for (let i = 0; i <= m / 4; i++) {
        tab[i] = Math.cos(i * freq);
      }
      for (let i = 1; i < m / 4; i++) {
        tab[m / 2 - i] = tab[i];
      }
    }
    static splitRadixPermutation(i, n, inverse) {
      if (n <= 2) {
        return i & 1;
      }
      let m = n >> 1;
      if ((i & m) == 0) {
        return this.splitRadixPermutation(i, m, inverse) * 2;
      }
      m = m >> 1;
      return this.splitRadixPermutation(i, m, inverse) * 4 + (inverse == ((i & m) == 0) ? 1 : -1);
    }
    static CMUL(d, dre, dim, are, aim, bre, bim) {
      d[dre] = are * bre - aim * bim;
      d[dim] = are * bim + aim * bre;
    }
  };
  var FFT = _FFT;
  FFT.M_SQRT1_2 = 0.7071067811865476;
  FFT.sqrthalf = _FFT.M_SQRT1_2;
  FFT.ff_cos_16 = new Float32Array(16 / 2);
  FFT.ff_cos_32 = new Float32Array(32 / 2);
  FFT.ff_cos_64 = new Float32Array(64 / 2);
  FFT.ff_cos_128 = new Float32Array(128 / 2);
  FFT.ff_cos_256 = new Float32Array(256 / 2);
  FFT.ff_cos_512 = new Float32Array(512 / 2);

  // src/me/atrac3plus/Atrac.ts
  var Atrac = class {
    constructor() {
      this.gainTab1 = new Float32Array(16);
      this.gainTab2 = new Float32Array(31);
      this.id2expOffset = 0;
      this.locScale = 0;
      this.locSize = 0;
    }
    initGainCompensation(id2expOffset, locScale) {
      this.locScale = locScale;
      this.locSize = 1 << locScale;
      this.id2expOffset = id2expOffset;
      for (let i = 0; i <= 15; i++) {
        this.gainTab1[i] = 2 ** (id2expOffset - i);
      }
      for (let i = -15; i <= 15; i++) {
        this.gainTab2[i + 15] = 2 ** (-1 / this.locSize * i);
      }
    }
    gainCompensation(_in, inOffset, prev, prevOffset, gcNow, gcNext, numSamples, out, outOffset) {
      const gcScale = gcNext.numPoints != 0 ? this.gainTab1[gcNext.levCode[0]] : 1;
      if (gcNow.numPoints == 0) {
        for (let pos = 0; pos < numSamples; pos++) {
          out[outOffset + pos] = _in[inOffset + pos] * gcScale + prev[prevOffset + pos];
        }
      } else {
        let pos = 0;
        for (let i = 0; i < gcNow.numPoints; i++) {
          const lastpos = gcNow.locCode[i] << this.locScale;
          let lev = this.gainTab1[gcNow.levCode[i]];
          const gainInc = this.gainTab2[(i + 1 < gcNow.numPoints ? gcNow.levCode[i + 1] : this.id2expOffset) - gcNow.levCode[i] + 15];
          while (pos < lastpos) {
            out[outOffset + pos] = (_in[inOffset + pos] * gcScale + prev[prevOffset + pos]) * lev;
            pos++;
          }
          while (pos < lastpos + this.locSize) {
            out[outOffset + pos] = (_in[inOffset + pos] * gcScale + prev[prevOffset + pos]) * lev;
            lev *= gainInc;
            pos++;
          }
        }
        while (pos < numSamples) {
          out[outOffset + pos] = _in[inOffset + pos] * gcScale + prev[prevOffset + pos];
          pos++;
        }
      }
      MemoryUtils.arraycopyF(_in, inOffset + numSamples, prev, prevOffset, numSamples);
    }
    static generateTables() {
      if (this.ff_atrac_sf_table[63] == 0) {
        for (let i = 0; i <= 63; i++) {
          this.ff_atrac_sf_table[i] = 2 ** ((i - 15) / 3);
        }
      }
      if (this.qmf_window[47] == 0) {
        for (let i = 0; i <= 23; i++) {
          const s = this.qmf_48tap_half[i] * 2;
          this.qmf_window[i] = s;
          this.qmf_window[47 - i] = s;
        }
      }
    }
    static iqmf(inlo, inloOffset, inhi, inhiOffset, nIn, out, outOffset, delayBuf, temp) {
      let i = 0;
      MemoryUtils.arraycopyF(delayBuf, 0, temp, 0, 46);
      {
        while (i < nIn) {
          temp[46 + 2 * i + 0] = inlo[inloOffset + i] + inhi[inhiOffset + i];
          temp[46 + 2 * i + 1] = inlo[inloOffset + i] - inhi[inhiOffset + i];
          temp[46 + 2 * i + 2] = inlo[inloOffset + i + 1] + inhi[inhiOffset + i + 1];
          temp[46 + 2 * i + 3] = inlo[inloOffset + i + 1] - inhi[inhiOffset + i + 1];
          i += 2;
        }
      }
      let p1 = 0;
      for (let j = nIn; j >= 1; i--) {
        let s1 = 0;
        let s2 = 0;
        let i2 = 0;
        while (i2 < 48) {
          s1 += temp[p1 + i2] * this.qmf_window[i2];
          s2 += temp[p1 + i2 + 1] * this.qmf_window[i2 + 1];
          i2 += 2;
        }
        out[outOffset + 0] = s2;
        out[outOffset + 1] = s1;
        p1 += 2;
        outOffset += 2;
      }
      MemoryUtils.arraycopyF(temp, nIn * 2, delayBuf, 0, 46);
    }
  };
  Atrac.ff_atrac_sf_table = new Float32Array(64);
  Atrac.qmf_window = new Float32Array(48);
  Atrac.qmf_48tap_half = new Float32Array([-1461907e-11, -9205479e-11, -56157569e-12, 30117269e-11, 2422519e-10, -85293897e-11, -5205574e-10, 0.0020340169, 78333891e-11, -0.0042153862, -75614988e-11, 0.0078402944, -61169922e-12, -0.01344162, 0.0024626821, 0.021736089, -7801671e-9, -0.034090221, 0.01880949, 0.054326009, -0.043596379, -0.099384367, 0.13207909, 0.46424159]);

  // src/me/atrac3plus/Atrac3plusDsp.ts
  function intArrayOf(...values) {
    return new Int32Array(values);
  }
  function floatArrayOf(...values) {
    return new Float32Array(values);
  }
  function arrayOf2(...values) {
    return values;
  }
  var TWOPI = 2 * Math.PI;
  var TEMP_idctIn = new Float32Array(Atrac3plusConstants.ATRAC3P_SUBBANDS);
  var TEMP_idctOut = new Float32Array(Atrac3plusConstants.ATRAC3P_SUBBANDS);
  var TEMP_pwcsp = new Float32Array(Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
  var _Atrac3plusDsp = class {
    initImdct(mdctCtx) {
      SineWin.initFfSineWindows();
      mdctCtx.mdctInit(8, true, -1);
    }
    powerCompensation(ctx, chIndex, sp, rngIndex, sb) {
      const pwcsp = TEMP_pwcsp;
      let gcv = 0;
      const swapCh = ctx.unitType == Atrac3plusConstants.CH_UNIT_STEREO && ctx.swapChannels[sb] ? 1 : 0;
      const channel1 = ctx.channels[chIndex ^ swapCh];
      if (channel1.powerLevs[_Atrac3plusDsp.subband_to_powgrp[sb]] == Atrac3plusConstants.ATRAC3P_POWER_COMP_OFF) {
        return;
      }
      for (let i = 0; i < Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES; i++) {
        pwcsp[i] = _Atrac3plusDsp.noise_tab[rngIndex++ & 1023];
      }
      const g1 = channel1.gainData[sb];
      const g2 = channel1.gainDataPrev[sb];
      const gainLev = g1.numPoints > 0 ? 6 - g1.levCode[0] : 0;
      for (let i = 0; i < g2.numPoints; i++)
        gcv = Math.max(gcv, gainLev - (g2.levCode[i] - 6));
      for (let i = 0; i < g1.numPoints; i++)
        gcv = Math.max(gcv, 6 - g1.levCode[i]);
      const grpLev = _Atrac3plusDsp.pwc_levs[channel1.powerLevs[_Atrac3plusDsp.subband_to_powgrp[sb]]] / (1 << gcv);
      const qu_from = _Atrac3plusDsp.subband_to_qu[sb] + (sb == 0 ? 2 : 0);
      const qu_until = _Atrac3plusDsp.subband_to_qu[sb + 1];
      for (let qu = qu_from; qu < qu_until; qu++) {
        const channel = ctx.channels[chIndex];
        if (channel.quWordlen[qu] <= 0)
          continue;
        const quLev = _Atrac3plusDsp.ff_atrac3p_sf_tab[channel.quSfIdx[qu]] * _Atrac3plusDsp.ff_atrac3p_mant_tab[channel.quWordlen[qu]] / (1 << channel.quWordlen[qu]) * grpLev;
        const dst = _Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
        const nsp = _Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu + 1] - _Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
        for (let i = 0; i < nsp; i++) {
          sp[dst + i] += pwcsp[i] * quLev;
        }
      }
    }
    imdct(mdctCtx, _in, inOffset, out, outOffset, windId, sb) {
      if ((sb & 1) != 0) {
        for (let i = 0; i < Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES / 2; i++) {
          const tmp = _in[inOffset + i];
          _in[inOffset + i] = _in[inOffset + Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES - 1 - i];
          _in[inOffset + Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES - 1 - i] = tmp;
        }
      }
      mdctCtx.imdctCalc(out, outOffset, _in, inOffset);
      if ((windId & 2) != 0) {
        out.fill(0, outOffset, outOffset + 32);
        FloatDSP.vectorFmul(out, outOffset + 32, out, outOffset + 32, SineWin.ff_sine_64, 0, 64);
      } else {
        FloatDSP.vectorFmul(out, outOffset, out, outOffset, SineWin.ff_sine_128, 0, _Atrac3plusDsp.ATRAC3P_MDCT_SIZE / 2);
      }
      if ((windId & 1) != 0) {
        FloatDSP.vectorFmulReverse(out, outOffset + 160, out, outOffset + 160, SineWin.ff_sine_64, 0, 64);
        out.fill(0, outOffset + 224, outOffset + 224 + 32);
      } else {
        FloatDSP.vectorFmulReverse(out, outOffset + 128, out, outOffset + 128, SineWin.ff_sine_128, 0, _Atrac3plusDsp.ATRAC3P_MDCT_SIZE / 2);
      }
    }
    wavesSynth(synthParams, wavesInfo, envelope, phaseShift, regOffset, out) {
      let waveParam = wavesInfo.startIndex;
      let wn = 0;
      while (wn < wavesInfo.numWavs) {
        const waveParam1 = synthParams.waves[waveParam];
        const amp = _Atrac3plusDsp.amp_sf_tab[waveParam1.ampSf] * (synthParams.amplitudeMode == 0 ? (waveParam1.ampIndex + 1) / 15.13 : 1);
        const inc = waveParam1.freqIndex;
        let pos = _Atrac3plusDsp.DEQUANT_PHASE(waveParam1.phaseIndex) - (regOffset ^ 128) * (inc & 2047);
        for (let i = 0; i < 128; i++) {
          out[i] += _Atrac3plusDsp.sine_table[pos] * amp;
          pos = pos + (inc & 2047);
        }
        wn++;
        waveParam++;
      }
      if (phaseShift) {
        for (let i = 0; i < 128; i++) {
          out[i] = -out[i];
        }
      }
      if (envelope.hasStartPoint) {
        const pos = (envelope.startPos << 2) - regOffset;
        if (pos > 0 && pos <= 128) {
          out.fill(0, 0, pos);
          if (!envelope.hasStopPoint || envelope.startPos != envelope.stopPos) {
            out[pos + 0] *= _Atrac3plusDsp.hann_window[0];
            out[pos + 1] *= _Atrac3plusDsp.hann_window[32];
            out[pos + 2] *= _Atrac3plusDsp.hann_window[64];
            out[pos + 3] *= _Atrac3plusDsp.hann_window[96];
          }
        }
      }
      if (envelope.hasStopPoint) {
        const pos = envelope.stopPos + (1 << 2) - regOffset;
        if (pos > 0 && pos <= 128) {
          out[pos - 4] *= _Atrac3plusDsp.hann_window[96];
          out[pos - 3] *= _Atrac3plusDsp.hann_window[64];
          out[pos - 2] *= _Atrac3plusDsp.hann_window[32];
          out[pos - 1] *= _Atrac3plusDsp.hann_window[0];
          out.fill(0, pos, 128);
        }
      }
    }
    generateTones(ctx, chNum, sb, out, outOffset) {
      const wavreg1 = new Float32Array(128);
      const wavreg2 = new Float32Array(128);
      const channel = ctx.channels[chNum];
      const tonesNow = channel.tonesInfoPrev[sb];
      const tonesNext = channel.tonesInfo[sb];
      if (tonesNext.pendEnv.hasStartPoint && tonesNext.pendEnv.startPos < tonesNext.pendEnv.stopPos) {
        tonesNext.currEnv.hasStartPoint = true;
        tonesNext.currEnv.startPos = tonesNext.pendEnv.startPos + 32;
      } else if (tonesNow.pendEnv.hasStartPoint) {
        tonesNext.currEnv.hasStartPoint = true;
        tonesNext.currEnv.startPos = tonesNow.pendEnv.startPos;
      } else {
        tonesNext.currEnv.hasStartPoint = false;
        tonesNext.currEnv.startPos = 0;
      }
      if (tonesNow.pendEnv.hasStopPoint && tonesNow.pendEnv.stopPos >= tonesNext.currEnv.startPos) {
        tonesNext.currEnv.hasStopPoint = true;
        tonesNext.currEnv.stopPos = tonesNow.pendEnv.stopPos;
      } else if (tonesNext.pendEnv.hasStopPoint) {
        tonesNext.currEnv.hasStopPoint = true;
        tonesNext.currEnv.stopPos = tonesNext.pendEnv.stopPos + 32;
      } else {
        tonesNext.currEnv.hasStopPoint = false;
        tonesNext.currEnv.stopPos = 64;
      }
      const reg1EnvNonzero = tonesNow.currEnv.stopPos >= 32;
      const reg2EnvNonzero = tonesNext.currEnv.startPos < 32;
      if (tonesNow.numWavs > 0 && reg1EnvNonzero) {
        this.wavesSynth(ctx.wavesInfoPrev, tonesNow, tonesNow.currEnv, ctx.wavesInfoPrev.phaseShift[sb] && chNum > 0, 128, wavreg1);
      }
      if (tonesNext.numWavs > 0 && reg2EnvNonzero) {
        this.wavesSynth(ctx.wavesInfo, tonesNext, tonesNext.currEnv, ctx.wavesInfo.phaseShift[sb] && chNum > 0, 0, wavreg2);
      }
      if (tonesNow.numWavs > 0 && tonesNext.numWavs > 0 && reg1EnvNonzero && reg2EnvNonzero) {
        FloatDSP.vectorFmul(wavreg1, 0, wavreg1, 0, _Atrac3plusDsp.hann_window, 128, 128);
        FloatDSP.vectorFmul(wavreg2, 0, wavreg2, 0, _Atrac3plusDsp.hann_window, 0, 128);
      } else {
        if (tonesNow.numWavs > 0 && !tonesNow.currEnv.hasStopPoint) {
          FloatDSP.vectorFmul(wavreg1, 0, wavreg1, 0, _Atrac3plusDsp.hann_window, 128, 128);
        }
        if (tonesNext.numWavs > 0 && !tonesNext.currEnv.hasStartPoint) {
          FloatDSP.vectorFmul(wavreg2, 0, wavreg2, 0, _Atrac3plusDsp.hann_window, 0, 128);
        }
      }
      for (let i = 0; i < 128; i++) {
        out[outOffset + i] += wavreg1[i] + wavreg2[i];
      }
    }
    ipqf(dctCtx, hist, _in, out) {
      out.fill(0, 0, Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES);
      const ATRAC3P_SUBBAND_SAMPLES = Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES;
      const ATRAC3P_SUBBANDS = Atrac3plusConstants.ATRAC3P_SUBBANDS;
      const ATRAC3P_PQF_FIR_LEN = Atrac3plusConstants.ATRAC3P_PQF_FIR_LEN;
      const mod23_lut = _Atrac3plusDsp.mod23_lut;
      const ipqf_coeffs1 = _Atrac3plusDsp.ipqf_coeffs1;
      const ipqf_coeffs2 = _Atrac3plusDsp.ipqf_coeffs2;
      const hist_buf1 = hist.buf1;
      const hist_buf2 = hist.buf2;
      const idctIn = TEMP_idctIn;
      const idctOut = TEMP_idctOut;
      for (let s = 0; s < ATRAC3P_SUBBAND_SAMPLES; s++) {
        for (let sb = 0; sb < ATRAC3P_SUBBANDS; sb++) {
          idctIn[sb] = _in[sb * ATRAC3P_SUBBAND_SAMPLES + s];
        }
        dctCtx.imdctHalf(idctOut, 0, idctIn, 0);
        {
          const buf1 = hist_buf1[hist.pos];
          const buf2 = hist_buf2[hist.pos];
          for (let i = 0; i < 8; i++) {
            buf1[i] = idctOut[i + 8];
            buf2[i] = idctOut[7 - i];
          }
        }
        {
          let posNow = hist.pos;
          const s16 = s * 16;
          for (let t = 0; t < ATRAC3P_PQF_FIR_LEN; t++) {
            const posNext = mod23_lut[posNow + 2];
            const buf1 = hist_buf1[posNow];
            const buf2 = hist_buf2[posNext];
            const coefs1 = ipqf_coeffs1[t];
            const coefs2 = ipqf_coeffs2[t];
            for (let i = 0; i < 8; i++) {
              out[s16 + i + 0] += buf1[i] * coefs1[i] + buf2[i] * coefs2[i];
              out[s16 + i + 8] += buf1[7 - i] * coefs1[i + 8] + buf2[7 - i] * coefs2[i + 8];
            }
            posNow = mod23_lut[posNext + 2];
          }
        }
        hist.pos = mod23_lut[hist.pos];
      }
    }
    static DEQUANT_PHASE(ph) {
      return (ph & 31) << 6;
    }
    static initWaveSynth() {
      for (let i = 0; i < 2048; i++) {
        this.sine_table[i] = Math.sin(TWOPI * i / 2048);
      }
      for (let i = 0; i < 256; i++) {
        this.hann_window[i] = (1 - Math.cos(TWOPI * i / 256)) * 0.5;
      }
      for (let i = 0; i < 64; i++) {
        this.amp_sf_tab[i] = 2 ** ((i - 3) / 4);
      }
    }
  };
  var Atrac3plusDsp = _Atrac3plusDsp;
  Atrac3plusDsp.ATRAC3P_MDCT_SIZE = Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES * 2;
  Atrac3plusDsp.sine_table = new Float32Array(2048);
  Atrac3plusDsp.hann_window = new Float32Array(256);
  Atrac3plusDsp.amp_sf_tab = new Float32Array(64);
  Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos = intArrayOf(0, 16, 32, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 288, 320, 352, 384, 448, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1664, 1792, 1920, 2048);
  Atrac3plusDsp.ff_atrac3p_sf_tab = floatArrayOf(0.027852058, 0.0350914, 0.044212341, 0.055704117, 0.0701828, 0.088424683, 0.11140823, 0.1403656, 0.17684937, 0.22281647, 0.2807312, 0.35369873, 0.44563293, 0.5614624, 0.70739746, 0.89126587, 1.1229248, 1.4147949, 1.7825317, 2.2458496, 2.8295898, 3.5650635, 4.4916992, 5.6591797, 7.130127, 8.9833984, 11.318359, 14.260254, 17.966797, 22.636719, 28.520508, 35.933594, 45.273438, 57.041016, 71.867188, 90.546875, 114.08203, 143.73438, 181.09375, 228.16406, 287.46875, 362.1875, 456.32812, 574.9375, 724.375, 912.65625, 1149.875, 1448.75, 1825.3125, 2299.75, 2897.5, 3650.625, 4599.5, 5795, 7301.25, 9199, 11590, 14602.5, 18398, 23180, 29205, 36796, 46360, 58410);
  Atrac3plusDsp.ff_atrac3p_mant_tab = floatArrayOf(0, 0.74801636, 0.44882202, 0.32058716, 0.20400238, 0.1496048, 0.07239151, 0.035619736);
  Atrac3plusDsp.subband_to_powgrp = intArrayOf(0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4);
  Atrac3plusDsp.noise_tab = floatArrayOf(-0.01358032, -0.05593872, 0.01696777, -0.14871216, -0.26412964, -0.09893799, 0.25723267, 0.02008057, -0.72235107, -0.44351196, -0.2298584, 0.16833496, 0.46902466, 0.05917358, -0.15179443, 0.41299438, -0.01287842, 0.13360596, 0.43557739, -0.0953064, -0.58422852, 0.39266968, -0.08343506, -0.25604248, 0.22848511, 0.26013184, -0.65588379, 0.17288208, -0.08673096, -0.05203247, 0.07299805, -0.28665161, -0.35806274, 0.06552124, -0.09387207, 0.21099854, -0.28347778, -0.72402954, 0.05050659, -0.10635376, -0.1885376, 0.29724121, 0.20703125, -0.2979126, -0.37634277, 0.47970581, -0.09976196, 0.32641602, -0.29248047, -0.28237915, 0.26028442, -0.36157227, 0.22042847, -0.03222656, -0.37268066, -0.03759766, 0.09909058, 0.23284912, 0.19320679, 0.14453125, -0.02139282, -0.19702148, 0.31533813, -0.16741943, 0.35031128, -0.35656738, -0.6612854, -701904e-8, 0.20898438, 0.26837158, -0.33706665, -0.04568481, 0.12600708, 0.10284424, 0.07321167, -0.18280029, 0.38101196, 0.2130127, 0.04541016, 0.01156616, -0.26391602, -0.02346802, -0.22125244, 0.29760742, -0.36233521, -0.31314087, -0.13967896, -0.11276245, -0.19433594, 0.34490967, 0.0234375, 0.21963501, -0.027771, -0.67678833, -0.08999634, 0.14233398, -0.27697754, 0.51422119, -0.05047607, 0.48327637, 0.37167358, -0.60806274, 0.18728638, -0.1519165, 637817e-8, 0.02832031, -0.15618896, 0.60644531, 0.21826172, 0.06384277, -0.31863403, 0.08816528, 0.15447998, -0.07015991, -0.08154297, -0.40966797, -0.39785767, -0.11709595, 0.22052002, 0.18466187, -0.1725769, 0.03759766, -0.06195068, 43335e-7, 0.12176514, 0.34011841, 0.25610352, -0.052948, 0.41033936, 0.16854858, -0.76187134, 0.13845825, -0.19418335, -0.21524048, -0.44412231, -0.081604, -0.2819519, -0.01873779, 0.15524292, -0.37438965, -0.4486084, 0.43096924, -0.24746704, 0.49856567, 0.14859009, 0.3815918, 0.20541382, -0.39175415, -0.6585083, -0.43716431, 0.13037109, -0.05111694, 0.39956665, 0.21447754, -0.0486145, 0.33654785, 0.105896, -0.88085938, -0.30822754, 0.38577271, 0.30047607, 0.3883667, 0.09118652, -0.36477661, -0.01641846, -0.23031616, 0.2605896, 0.18859863, -0.21868896, -0.17861938, -0.29754639, 0.09777832, 0.10806274, -0.51605225, 76294e-8, 0.13259888, 0.11090088, -0.24084473, 0.24957275, 0.01379395, -0.04141235, -0.04937744, 0.57394409, 0.27410889, 0.27587891, 0.45013428, -0.32592773, 0.11160278, -970459e-8, 0.29092407, 0.03356934, -0.70925903, 0.04882812, 0.43499756, 0.07720947, -0.27554321, -0.01742554, -0.08413696, -0.0402832, -0.52850342, -0.07330322, 0.05181885, 0.21362305, -0.18765259, 0.07058716, -0.03009033, 0.32662964, 0.27023315, -0.2800293, 0.1756897, 0.03338623, 0.3024292, -0.03921509, 0.32174683, -0.23733521, 0.08575439, -0.38269043, 0.09194946, -0.0723877, 0.17941284, -0.51278687, -0.25146484, 0.19790649, -0.19195557, 0.16549683, 0.42456055, 0.39129639, -0.02868652, 0.17980957, 0.24902344, -0.76583862, -0.20959473, 0.61013794, 0.37011719, 0.36859131, -0.04486084, 0.10678101, -0.15994263, -0.05328369, 0.28463745, -0.06420898, -0.36987305, -0.28009033, -0.11764526, 0.04312134, -0.0803833, 0.04885864, -0.03067017, -42725e-8, 0.34289551, -98877e-7, 0.34838867, 0.32516479, -0.16271973, 0.38269043, 0.03240967, 0.12417603, -0.14331055, -0.34902954, -0.18325806, 0.29421997, 0.44284058, 0.75170898, -0.67245483, -0.12176514, 0.27914429, -0.29806519, 0.19863892, 0.3008728, 0.22680664, -0.36633301, -0.3253479, -0.57553101, -0.16641235, 0.43811035, 0.08331299, 0.15942383, 0.26516724, -0.24240112, -0.11761475, -0.16827393, -0.14260864, 0.46343994, 0.11804199, -0.55514526, -0.02520752, -0.14309692, 448608e-8, 0.02749634, -0.30545044, 0.70965576, 0.45108032, 0.66439819, -0.68255615, -0.12496948, 0.09146118, -0.21109009, -0.23791504, 0.79943848, -0.35205078, -0.24963379, 0.18719482, -0.1907959, 0.07458496, 0.07623291, -0.28781128, -0.37121582, -0.19580078, -0.01773071, -0.16717529, 0.13040161, 0.14672852, 0.42379761, 0.03582764, 0.11431885, 0.05145264, 0.44702148, 0.08963013, 0.01367188, -0.54519653, -0.12692261, 0.21176147, 0.04925537, 0.30670166, -0.11029053, 0.19555664, -0.27740479, 0.23043823, 0.1555481, -0.19299316, -0.2572937, 0.17800903, -0.03579712, -0.05065918, -0.06933594, -0.09500122, -0.07821655, 0.2388916, -0.31900024, 0.0307312, -415039e-8, 0.61315918, 0.37176514, -0.13442993, -0.15536499, -0.19216919, -0.3789978, 0.19992065, 0.02630615, -0.12573242, 0.25927734, -0.0244751, 0.29629517, -0.40731812, -0.17333984, 0.24310303, -0.1060791, 0.14828491, 0.08792114, -0.18743896, -0.0557251, -0.04833984, 0.10473633, -0.2902832, -0.67687988, -0.28170776, -0.41687012, 0.05413818, -0.23284912, 0.09555054, -0.08969116, -0.15112305, 0.12738037, 0.35986328, 0.28948975, 0.30691528, 0.23956299, 0.06973267, -0.3119812, -0.18450928, 0.22280884, -0.21600342, 0.23522949, -0.6184082, -0.13012695, 0.26412964, 0.47320557, -0.2644043, 0.38757324, 0.17352295, -0.26104736, -0.25866699, -0.1227417, -0.29733276, 0.07687378, 0.18588257, -0.08880615, 0.31185913, 0.0531311, -0.1088562, -0.14901733, -0.22323608, -0.08538818, 0.19812012, 0.19732666, -0.18927002, 0.29058838, 0.2555542, -0.48599243, 0.18768311, 0.01345825, 0.34887695, 0.21530151, 0.19857788, 0.18661499, -0.01394653, -0.09063721, -0.38781738, 0.27160645, -0.20379639, -0.32119751, -0.2388916, 0.27096558, 0.24951172, 0.07922363, 0.07479858, -0.50946045, 0.10220337, 0.58364868, -0.19503784, -0.18560791, -0.01165771, 0.47195435, 0.2243042, -0.38635254, -0.037323, -0.09179688, 0.06991577, 0.15106201, 0.20605469, -0.05969238, -0.41821289, 0.12231445, -0.04672241, -0.05117798, -0.11523438, -0.51849365, -0.04077148, 0.44284058, -0.64086914, 0.17019653, 0.02236938, 0.22848511, -0.23214722, -0.32354736, -0.14068604, -0.29690552, -0.19891357, 0.02774048, -0.20965576, -0.52191162, -0.19299316, -0.07290649, 0.49053955, -0.22302246, 0.056427, 0.13122559, -0.20819092, -0.83590698, -0.08181763, 0.26797485, -91553e-8, -0.09457397, 0.17089844, -0.27020264, 0.30270386, 0.05496216, 0.09564209, -0.08590698, 0.02130127, 0.35931396, 0.21728516, -0.15396118, -0.05053711, 0.02719116, 0.1630249, 0.43212891, 0.10229492, -0.40820312, 0.21646118, 0.08435059, -0.1114502, -0.39962769, -0.05618286, -0.10223389, -0.60839844, 0.33724976, -0.06341553, -0.47369385, -0.32852173, 0.0524292, 0.1963501, -0.19137573, -0.67901611, 0.1618042, 0.05133057, -0.22283936, 0.09646606, 0.2428894, -0.45007324, 0.08804321, 0.14053345, 0.22619629, -0.01000977, 0.36355591, -0.19863892, -0.3036499, -0.24118042, -0.57461548, 0.26498413, 0.04345703, -0.09796143, -0.47714233, -0.23739624, 0.18737793, 0.08926392, -0.0279541, 305176e-8, -0.08700562, -0.38711548, 0.03222656, 0.10940552, -0.41906738, -0.01620483, -0.47061157, 0.37985229, -0.21624756, 0.47976685, -0.20046997, -0.62533569, -0.26907349, -0.02877808, 671387e-8, -0.29071045, -0.24685669, -0.15722656, -0.26055908, 0.29968262, 0.28225708, -0.08990479, -0.16748047, -0.46759033, -0.25067139, -0.25183105, -0.45932007, 0.05828857, 0.29006958, 0.23840332, -0.17974854, 0.26931763, 0.10696411, -0.06848145, -0.17126465, -0.10522461, -0.55386353, -0.42306519, -0.07608032, 0.24380493, 0.38586426, 0.16882324, 0.26751709, 0.17303467, 0.35809326, -0.22094727, -0.30703735, -0.28497314, -0.04321289, 0.15219116, -0.17071533, -0.39334106, 0.03439331, -0.10809326, -0.3059082, 0.26449585, -0.0741272, 0.13638306, -0.01062012, 0.27996826, 0.04397583, -0.05557251, -0.56933594, 0.03363037, -949097e-8, 0.52642822, -0.44329834, 0.28308105, -0.05499268, -0.23312378, -0.29870605, -0.05123901, 0.26831055, -0.35238647, -0.30993652, 0.34646606, -0.19775391, 0.44595337, 0.13769531, 0.45358276, 0.19961548, 0.42681885, 0.15722656, 128174e-8, 0.23757935, 0.40988159, 0.25164795, -732422e-8, -0.12405396, -0.4342041, -402832e-8, 0.34243774, 0.36264038, 0.18807983, -0.09301758, -0.10296631, 0.05532837, -0.31652832, 0.14337158, 0.35040283, 0.32540894, 0.05728149, -0.12030029, -0.25942993, -0.203125, -0.16491699, -0.46051025, -0.08004761, 0.50772095, 0.16168213, 0.28439331, 0.08105469, -0.19104004, 0.38589478, -0.16400146, -0.25454712, 0.20281982, -0.20730591, -0.06311035, 0.32937622, 0.15032959, -0.05340576, 0.30487061, -0.1164856, 0.38009644, -0.20062256, 0.43466187, 0.01150513, 0.35754395, -0.13146973, 0.67489624, 0.05212402, 0.27914429, -0.39431763, 0.75308228, -0.13366699, 0.24453735, 0.42248535, -0.65905762, -546265e-8, -0.03491211, -0.13659668, -0.08294678, -0.45666504, 0.2718811, 0.12731934, 0.61148071, 0.10449219, -0.2883606, 91553e-8, 0.2461853, 0.13119507, 0.05685425, 0.17355347, 0.42034912, 0.08514404, 0.24536133, 0.18951416, -0.19107056, -0.15036011, 0.02334595, 0.54986572, 0.32321167, -0.16104126, -0.0305481, 0.4359436, 0.1730957, 0.61053467, 0.24731445, 0.33334351, 0.15240479, 0.15588379, 0.36425781, -0.30407715, -0.13302612, 427246e-8, 0.04171753, -0.33178711, 0.34216309, -0.12463379, -0.02764893, 0.05905151, -0.31436157, 0.16531372, 0.34542847, -0.03292847, 0.12527466, -0.12313843, -0.13171387, 0.0475769, -0.45095825, -0.19085693, 0.35342407, -0.23239136, -0.34387207, 0.11264038, -0.15740967, 0.05273438, 0.74942017, 0.21505737, 0.08514404, -0.42391968, -0.1953125, 0.35293579, 0.25305176, 0.15731812, -0.70324707, -0.21591187, 0.35604858, 0.1413269, 0.11724854, 0.15853882, -0.24597168, 0.07019043, 0.02127075, 0.12658691, 0.06390381, -0.1229248, 0.15441895, -0.47640991, 0.06195068, 0.58981323, -0.15151978, -0.03604126, -0.45059204, -0.01672363, -0.4699707, 0.25750732, 0.18084717, 0.06661987, 0.13253784, 0.67828369, 0.1137085, 0.11325073, -0.04611206, -0.07791138, -0.365448, -0.06747437, -0.31594849, 0.16131592, 0.41983032, 0.11071777, -0.36889648, 0.30963135, -0.37875366, 0.58508301, 393677e-8, 0.12338257, 0.03424072, -0.21728516, -0.12838745, -0.46981812, 0.0586853, -0.25015259, 0.27407837, 0.65240479, -0.34429932, -0.15179443, 0.14056396, 0.33505249, 0.28826904, 0.09921265, 0.34390259, 0.13656616, -0.23608398, 863647e-8, 0.02627563, -0.19119263, 0.19775391, -0.07214355, 0.07809448, 0.0345459, -0.03417969, 33569e-8, -0.23095703, 0.18673706, 0.0579834, 0.03814697, -0.04318237, 0.05487061, 0.08633423, 0.55950928, -0.06347656, 0.10333252, 0.25305176, 0.05853271, 0.12246704, -0.25543213, -0.34262085, -0.36437988, -0.21304321, -0.05093384, 0.027771, 0.07620239, -0.2121582, -0.09326172, 0.19021606, -0.40579224, -0.01193237, 0.19845581, -0.35336304, -0.07397461, 0.2010498, 0.08615112, -0.4437561, 0.11419678, 0.24453735, -0.16555786, -0.05081177, -0.0140686, 0.27893066, -0.18692017, 0.07473755, 0.03451538, -0.39733887, 0.21548462, -0.2253418, -0.39651489, -0.04989624, -0.57662964, 0.06390381, 0.62020874, -0.13470459, 0.04345703, -0.21862793, -0.02789307, 0.51696777, -0.27587891, 0.39004517, 0.09857178, -738525e-8, 0.31317139, 48828e-8, -0.46572876, 0.2953186, -0.10009766, -0.27856445, 0.03594971, 0.25048828, -0.74584961, -0.25350952, -0.03302002, 0.31188965, 0.01571655, 0.46710205, 0.21591187, 0.07260132, -0.42132568, -0.53900146, -0.13674927, -0.16571045, -0.34454346, 0.12359619, -0.11184692, 967407e-8, 0.34576416, -0.05761719, 0.34848022, 0.17645264, -0.39395142, 0.10339355, 0.18215942, 0.20697021, 0.59109497, -0.11560059, -0.07385254, 0.10397339, 0.35437012, -0.2286377, 0.01794434, 0.17559814, -0.17495728, 0.12142944, 0.10928345, -1, -0.01379395, 0.21237183, -0.27035522, 0.27319336, -0.3706665, 0.4135437, -0.40054321, 689697e-8, 0.26321411, 0.39266968, 0.65298462, 0.41625977, -0.13909912, 0.78375244, -0.30941772, 0.20169067, -0.39367676, 0.94021606, -0.24066162, 0.05557251, -0.24533081, -0.05444336, -0.76754761, -0.1937561, -0.1104126, -0.17532349, 0.1600647, 0.0218811, 0.1746521, -0.04342651, -0.56777954, -0.40988159, 0.26687622, 0.11700439, -344849e-8, -0.05395508, 0.37426758, -0.40719604, -0.15032959, -0.01660156, 0.04196167, -0.04559326, -0.12969971, 0.12011719, 0.084198, -0.11199951, 0.35174561, 0.10275269, -0.25686646, 0.48446655, 0.03225708, 0.28408813, -0.18701172, 0.36282349, -0.0328064, 0.32302856, 0.17233276, 0.48269653, 0.31112671, -0.04946899, 0.12774658, 0.52685547, 0.10211182, 0.05953979, 0.05999756, 0.20144653, 744629e-8, 0.27316284, 0.24377441, 0.39672852, 0.01702881, -0.35513306, 0.11364746, -0.13555908, 0.48880005, -0.1541748, -0.0914917, -0.02615356, 0.46246338, -0.72250366, 0.22332764, 0.23849487, -0.25686646, -0.08514404, -0.02062988, -0.34494019, -0.02297974, -0.80386353, -0.08074951, -0.12689209, -0.06896973, 0.24099731, -0.35650635, -0.09558105, 0.2925415, 0.23132324, -0.16726685, 0, -0.24237061, 0.30899048, 0.29504395, -0.20898438, 0.17059326, -0.07672119, -0.14395142, 0.0557251, 0.20602417, -0.51550293, -0.03167725, -0.48840332, -0.20425415, 0.14144897, 0.07275391, -0.76669312, -0.22488403, 0.20651245, 0.03259277, 85449e-8, 0.03039551, 0.47555542, 0.3835144);
  Atrac3plusDsp.pwc_levs = floatArrayOf(3.96875, 3.15625, 2.5, 2, 1.59375, 1.25, 1, 0.78125, 0.625, 0.5, 0.40625, 0.3125, 0.25, 0.1875, 0.15625, 0);
  Atrac3plusDsp.subband_to_qu = intArrayOf(0, 8, 12, 16, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32);
  Atrac3plusDsp.mod23_lut = intArrayOf(23, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0);
  Atrac3plusDsp.ipqf_coeffs1 = arrayOf2(floatArrayOf(-58336207e-14, -80604229e-14, -42005411e-14, -44400572e-15, 3226247e-14, 3530856e-14, 12660377e-15, 10516783e-12, -11838618e-12, 6005389e-13, 14333754e-13, 23108685e-13, 32569742e-13, 46192422e-13, 63894258e-13, 70302972e-13), floatArrayOf(-91622824e-13, -10502935e-12, -79212787e-13, -41712024e-13, -26336629e-13, -15432918e-13, -57168614e-14, 18111954e-13, 23530851e-12, 2780562e-11, 32302323e-12, 36968919e-12, 41575615e-12, 45337845e-12, 46043948e-12, 48585582e-12), floatArrayOf(-64464548e-12, -68306952e-12, -73081472e-12, -7612785e-11, -74850752e-12, -70208509e-12, -62285151e-12, -58270442e-12, -56296329e-12, -49888811e-12, -35615325e-12, -18532943e-12, 16657353e-13, 2610587e-11, 53397067e-12, 8079566e-11), floatArrayOf(-54488552e-11, -52537228e-11, -49731287e-11, -45778e-8, -40612387e-11, -34301577e-11, -26866337e-11, -18248901e-11, -84307925e-12, 25081157e-12, 14135583e-11, 26649953e-11, 39945057e-11, 53928449e-11, 68422867e-11, 83093712e-11), floatArrayOf(-0.0014771431, -1283227e-9, -0.0010566821, -79780724e-11, -50782406e-11, -18855913e-11, 15771533e-11, 52769453e-11, 91862219e-11, 1326357e-9, 0.0017469483, 0.0021754825, 0.0026067684, 0.0030352892, 0.0034549395, 0.0038591374), floatArrayOf(-0.0022995141, -1443546e-9, -49266568e-11, 55068987e-11, 1682895e-9, 0.0028992873, 0.0041943151, 0.0055614738, 0.0069935122, 0.0084823566, 0.010018963, 0.011593862, 0.013196872, 0.014817309, 0.016444042, 0.018065533), floatArrayOf(-0.034426283, -0.034281436, -0.033992987, -0.033563249, -0.032995768, -0.032295227, -0.031467363, -0.030518902, -0.02945766, -0.028291954, -0.027031265, -0.025685543, -0.024265358, -0.022781773, -0.021246184, -0.019670162), floatArrayOf(-0.0030586775, -0.0037203205, -0.0042847847, -0.0047529764, -0.0051268316, -0.0054091476, -0.0056034233, -5714261e-9, -0.0057445862, -0.0057025906, -0.0055920109, -0.0054194843, -0.0051914565, -0.0049146507, -0.0045959447, -0.0042418269), floatArrayOf(-0.0016376863, -0.0017651899, -0.0018608454, -0.0019252141, -0.0019593791, -0.0019653172, -0.0019450618, -0.0018990048, -183808e-8, -0.0017501717, -0.0016481078, -0.0015320742, -0.0014046903, -0.0012685474, -1125814e-9, -97943726e-11), floatArrayOf(-55432378e-11, -55472925e-11, -54783461e-11, -53276919e-11, -51135791e-11, -48466062e-11, -45358928e-11, -42499689e-11, -36942671e-11, -3392619e-10, -30001783e-11, -25986304e-11, -2197204e-10, -18116167e-11, -14691355e-11, -11279432e-11), floatArrayOf(-64147389e-12, -6174868e-11, -54267788e-12, -47133824e-12, -42927582e-12, -39477309e-12, -36340745e-12, -29687517e-12, -49787737e-12, -41577889e-12, -33864744e-12, -26534748e-12, -19841305e-12, -14789486e-12, -13131184e-12, -99198869e-13), floatArrayOf(-62990207e-13, -72701259e-13, -11984052e-12, -17348082e-12, -19907106e-12, -21348773e-12, -21961965e-12, -12203576e-12, -10840992e-12, 46299544e-14, 52588763e-14, 27792686e-14, -23649704e-14, -10897784e-13, -9171448e-13, -522682e-12));
  Atrac3plusDsp.ipqf_coeffs2 = arrayOf2(floatArrayOf(522682e-12, 9171448e-13, 10897784e-13, 23649704e-14, -27792686e-14, -52588763e-14, -46299544e-14, 10840992e-12, -12203576e-12, -21961965e-12, -21348773e-12, -19907106e-12, -17348082e-12, -11984052e-12, -72701259e-13, -62990207e-13), floatArrayOf(99198869e-13, 13131184e-12, 14789486e-12, 19841305e-12, 26534748e-12, 33864744e-12, 41577889e-12, 49787737e-12, -29687517e-12, -36340745e-12, -39477309e-12, -42927582e-12, -47133824e-12, -54267788e-12, -6174868e-11, -64147389e-12), floatArrayOf(11279432e-11, 14691355e-11, 18116167e-11, 2197204e-10, 25986304e-11, 30001783e-11, 3392619e-10, 36942671e-11, -42499689e-11, -45358928e-11, -48466062e-11, -51135791e-11, -53276919e-11, -54783461e-11, -55472925e-11, -55432378e-11), floatArrayOf(97943726e-11, 1125814e-9, 0.0012685474, 0.0014046903, 0.0015320742, 0.0016481078, 0.0017501717, 183808e-8, -0.0018990048, -0.0019450618, -0.0019653172, -0.0019593791, -0.0019252141, -0.0018608454, -0.0017651899, -0.0016376863), floatArrayOf(0.0042418269, 0.0045959447, 0.0049146507, 0.0051914565, 0.0054194843, 0.0055920109, 0.0057025906, 0.0057445862, -5714261e-9, -0.0056034233, -0.0054091476, -0.0051268316, -0.0047529764, -0.0042847847, -0.0037203205, -0.0030586775), floatArrayOf(0.019670162, 0.021246184, 0.022781773, 0.024265358, 0.025685543, 0.027031265, 0.028291954, 0.02945766, -0.030518902, -0.031467363, -0.032295227, -0.032995768, -0.033563249, -0.033992987, -0.034281436, -0.034426283), floatArrayOf(-0.018065533, -0.016444042, -0.014817309, -0.013196872, -0.011593862, -0.010018963, -0.0084823566, -0.0069935122, 0.0055614738, 0.0041943151, 0.0028992873, 1682895e-9, 55068987e-11, -49266568e-11, -1443546e-9, -0.0022995141), floatArrayOf(-0.0038591374, -0.0034549395, -0.0030352892, -0.0026067684, -0.0021754825, -0.0017469483, -1326357e-9, -91862219e-11, 52769453e-11, 15771533e-11, -18855913e-11, -50782406e-11, -79780724e-11, -0.0010566821, -1283227e-9, -0.0014771431), floatArrayOf(-83093712e-11, -68422867e-11, -53928449e-11, -39945057e-11, -26649953e-11, -14135583e-11, -25081157e-12, 84307925e-12, -18248901e-11, -26866337e-11, -34301577e-11, -40612387e-11, -45778e-8, -49731287e-11, -52537228e-11, -54488552e-11), floatArrayOf(-8079566e-11, -53397067e-12, -2610587e-11, -16657353e-13, 18532943e-12, 35615325e-12, 49888811e-12, 56296329e-12, -58270442e-12, -62285151e-12, -70208509e-12, -74850752e-12, -7612785e-11, -73081472e-12, -68306952e-12, -64464548e-12), floatArrayOf(-48585582e-12, -46043948e-12, -45337845e-12, -41575615e-12, -36968919e-12, -32302323e-12, -2780562e-11, -23530851e-12, 18111954e-13, -57168614e-14, -15432918e-13, -26336629e-13, -41712024e-13, -79212787e-13, -10502935e-12, -91622824e-13), floatArrayOf(-70302972e-13, -63894258e-13, -46192422e-13, -32569742e-13, -23108685e-13, -14333754e-13, -6005389e-13, 11838618e-12, 10516783e-12, 12660377e-15, 3530856e-14, 3226247e-14, -44400572e-15, -42005411e-14, -80604229e-14, -58336207e-14));

  // src/me/atrac3plus/Atrac3plusData1.ts
  function intArrayOf2(...values) {
    return new Int32Array(values);
  }
  function arrayOf3(...values) {
    return values;
  }
  var Atrac3pSpecCodeTab = class {
    constructor(groupSize, numCoeffs, bits, is_signed, redirect, cb, xlat) {
      this.groupSize = groupSize;
      this.numCoeffs = numCoeffs;
      this.bits = bits;
      this.is_signed = is_signed;
      this.redirect = redirect;
      this.cb = cb;
      this.xlat = xlat;
    }
    get isSigned() {
      return this.is_signed != 0;
    }
  };
  var huff_a01_cb = intArrayOf2(1, 12, 1, 0, 0, 1, 7, 0, 19, 5, 13, 21, 6, 8);
  var huff_a01_xlat = intArrayOf2(0, 3, 64, 192, 16, 48, 4, 12, 1, 80, 208, 112, 240, 196, 20, 52, 76, 28, 60, 65, 193, 49, 5, 13, 195, 19, 7, 15, 68, 204, 17, 67, 51, 84, 116, 220, 252, 113, 21, 77, 205, 29, 211, 199, 55, 63, 212, 244, 92, 124, 81, 209, 241, 69, 197, 53, 221, 61, 83, 115, 243, 71, 23, 119, 79, 207, 31, 85, 245, 125, 215, 95, 255, 213, 117, 93, 253, 87, 247, 223, 127);
  var huff_a02_cb = intArrayOf2(2, 12, 1, 0, 4, 11, 0, 1, 29, 6, 20, 7, 2);
  var huff_a02_xlat = intArrayOf2(0, 64, 16, 4, 1, 80, 68, 20, 84, 65, 17, 81, 5, 69, 21, 85, 144, 128, 32, 96, 132, 148, 36, 100, 8, 72, 24, 88, 129, 145, 33, 133, 149, 101, 9, 73, 25, 89, 2, 66, 18, 82, 6, 70, 22, 86, 136, 97, 37, 41, 105, 90, 160, 164, 152, 40, 104, 161, 165, 137, 153, 169, 130, 146, 34, 98, 150, 38, 102, 10, 74, 26, 168, 134, 166, 138, 154, 42, 106, 162, 170);
  var huff_a03_cb = intArrayOf2(3, 9, 1, 8, 0, 13, 18, 7, 2);
  var huff_a03_xlat = intArrayOf2(0, 8, 56, 1, 9, 57, 7, 15, 63, 16, 48, 17, 49, 2, 10, 58, 5, 6, 14, 62, 23, 55, 24, 40, 25, 41, 42, 50, 3, 11, 51, 59, 13, 21, 61, 22, 30, 54, 31, 47, 18, 26, 19, 43, 29, 53, 46, 27, 45);
  var huff_a04_cb = intArrayOf2(2, 3, 2, 4);
  var huff_a04_xlat = intArrayOf2(1, 2, 0, 3, 4, 5);
  var huff_a05_cb = intArrayOf2(3, 12, 1, 3, 5, 8, 12, 23, 72, 68, 31, 2);
  var huff_a05_xlat = intArrayOf2(0, 16, 240, 1, 17, 241, 15, 31, 255, 32, 224, 225, 2, 242, 14, 30, 47, 48, 208, 33, 18, 34, 226, 3, 13, 46, 238, 254, 239, 64, 192, 49, 193, 209, 50, 210, 19, 35, 227, 243, 4, 244, 12, 28, 29, 45, 237, 253, 62, 222, 63, 223, 80, 96, 112, 144, 160, 176, 65, 81, 97, 113, 145, 161, 177, 66, 98, 146, 162, 194, 51, 195, 211, 20, 36, 52, 212, 228, 5, 21, 245, 6, 22, 38, 230, 246, 7, 23, 231, 247, 9, 25, 41, 249, 10, 26, 42, 234, 250, 11, 27, 251, 44, 60, 220, 236, 252, 61, 77, 205, 221, 78, 110, 126, 174, 206, 79, 95, 111, 127, 159, 175, 191, 207, 82, 114, 178, 67, 83, 99, 115, 147, 163, 179, 68, 100, 116, 148, 164, 180, 196, 37, 53, 165, 197, 213, 229, 54, 70, 182, 198, 214, 39, 55, 71, 183, 199, 215, 57, 73, 89, 201, 217, 233, 58, 74, 90, 202, 218, 43, 59, 75, 107, 123, 219, 235, 76, 92, 108, 124, 156, 172, 204, 93, 109, 125, 157, 173, 189, 94, 158, 190, 84, 69, 85, 101, 117, 149, 181, 86, 102, 118, 150, 166, 87, 103, 151, 167, 105, 121, 169, 185, 106, 122, 154, 170, 186, 91, 155, 171, 187, 203, 188, 119, 153);
  var huff_a06_cb = intArrayOf2(2, 6, 1, 3, 2, 6, 4);
  var huff_a06_xlat = intArrayOf2(1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 10, 11, 12, 15);
  var huff_a07_cb = intArrayOf2(2, 10, 1, 2, 2, 2, 6, 14, 21, 13, 2);
  var huff_a07_xlat = intArrayOf2(0, 1, 63, 2, 62, 3, 61, 4, 5, 6, 58, 59, 60, 7, 8, 9, 10, 26, 27, 28, 36, 37, 38, 54, 55, 56, 57, 11, 12, 13, 14, 15, 16, 25, 29, 30, 31, 33, 34, 35, 39, 47, 48, 49, 50, 51, 52, 53, 17, 18, 19, 20, 21, 22, 23, 41, 42, 43, 44, 45, 46, 24, 40);
  var huff_a11_cb = intArrayOf2(1, 11, 1, 0, 0, 0, 8, 1, 18, 9, 22, 10, 12);
  var huff_a11_xlat = intArrayOf2(0, 64, 192, 16, 48, 4, 12, 1, 3, 208, 80, 112, 240, 196, 52, 76, 204, 28, 65, 193, 49, 5, 13, 67, 195, 19, 7, 15, 68, 20, 116, 220, 60, 17, 29, 51, 55, 84, 212, 244, 92, 124, 252, 209, 113, 241, 21, 53, 77, 205, 221, 61, 211, 115, 71, 199, 23, 119, 63, 81, 69, 197, 85, 83, 243, 79, 207, 31, 255, 213, 117, 245, 93, 125, 253, 87, 215, 247, 95, 223, 127);
  var huff_a12_cb = intArrayOf2(5, 10, 16, 11, 32, 19, 1, 2);
  var huff_a12_xlat = intArrayOf2(0, 64, 16, 80, 4, 68, 20, 84, 1, 65, 17, 81, 5, 69, 21, 85, 144, 148, 88, 145, 149, 25, 89, 6, 70, 22, 86, 128, 96, 132, 36, 100, 164, 8, 72, 24, 104, 129, 33, 97, 161, 133, 37, 101, 165, 9, 73, 153, 105, 169, 2, 66, 18, 82, 150, 38, 102, 26, 90, 32, 160, 136, 152, 40, 168, 137, 41, 130, 146, 34, 98, 134, 166, 10, 74, 154, 106, 170, 162, 138, 42);
  var huff_a13_cb = intArrayOf2(1, 10, 1, 0, 0, 4, 2, 2, 9, 15, 12, 4);
  var huff_a13_xlat = intArrayOf2(0, 8, 56, 1, 7, 57, 15, 9, 63, 16, 48, 49, 2, 58, 6, 14, 62, 23, 24, 40, 17, 41, 10, 50, 3, 11, 59, 5, 13, 61, 22, 31, 55, 25, 18, 26, 42, 19, 51, 21, 53, 30, 46, 54, 47, 27, 43, 29, 45);
  var huff_a14_cb = intArrayOf2(2, 11, 1, 0, 4, 3, 5, 16, 28, 34, 26, 4);
  var huff_a14_xlat = intArrayOf2(0, 16, 240, 1, 15, 241, 31, 255, 32, 224, 17, 2, 14, 48, 80, 176, 208, 33, 225, 18, 242, 3, 5, 11, 13, 30, 254, 47, 239, 64, 192, 49, 81, 177, 193, 209, 34, 82, 226, 19, 243, 4, 21, 245, 27, 235, 251, 12, 29, 253, 46, 94, 238, 63, 95, 191, 223, 65, 50, 66, 178, 210, 35, 83, 179, 227, 20, 36, 228, 244, 37, 53, 213, 229, 43, 59, 219, 28, 44, 188, 236, 252, 45, 189, 237, 62, 78, 190, 222, 79, 207, 194, 51, 67, 195, 211, 52, 68, 84, 180, 212, 69, 85, 197, 75, 203, 60, 76, 92, 204, 220, 61, 77, 93, 205, 221, 206, 196, 181, 91, 187);
  var huff_a15_cb = intArrayOf2(5, 11, 9, 12, 16, 44, 98, 42, 4);
  var huff_a15_xlat = intArrayOf2(0, 16, 240, 1, 17, 241, 15, 31, 255, 32, 224, 33, 225, 2, 18, 242, 14, 30, 254, 47, 239, 48, 208, 49, 209, 34, 226, 3, 19, 243, 13, 29, 253, 46, 238, 63, 223, 64, 96, 112, 144, 160, 192, 65, 193, 50, 66, 194, 210, 35, 51, 211, 227, 4, 20, 36, 228, 244, 6, 22, 246, 7, 9, 10, 26, 250, 12, 28, 44, 236, 252, 45, 61, 221, 237, 62, 78, 206, 222, 79, 207, 80, 176, 81, 97, 113, 145, 161, 177, 82, 98, 114, 146, 162, 178, 67, 83, 99, 115, 147, 163, 195, 52, 68, 100, 164, 196, 212, 5, 21, 37, 53, 213, 229, 245, 38, 54, 70, 198, 214, 230, 23, 39, 55, 199, 215, 231, 247, 25, 41, 57, 201, 217, 233, 249, 42, 58, 74, 90, 202, 218, 234, 11, 27, 43, 59, 203, 219, 235, 251, 60, 76, 108, 124, 156, 172, 188, 204, 220, 77, 93, 109, 125, 157, 173, 189, 205, 94, 110, 126, 158, 174, 190, 95, 111, 127, 159, 175, 191, 179, 84, 116, 148, 180, 69, 85, 101, 117, 149, 165, 181, 197, 86, 102, 118, 150, 166, 182, 71, 87, 103, 167, 183, 73, 89, 105, 169, 185, 106, 122, 154, 170, 186, 75, 91, 107, 123, 155, 171, 187, 92, 119, 151, 121, 153);
  var huff_a16_cb = intArrayOf2(2, 12, 1, 1, 2, 2, 5, 7, 21, 54, 85, 62, 16);
  var huff_a16_xlat = intArrayOf2(0, 1, 16, 17, 33, 18, 32, 49, 2, 34, 19, 48, 65, 50, 3, 35, 20, 36, 64, 81, 97, 209, 225, 66, 82, 210, 51, 67, 211, 4, 52, 5, 21, 37, 22, 29, 45, 30, 46, 80, 96, 208, 224, 240, 113, 129, 241, 98, 114, 226, 242, 83, 99, 227, 243, 68, 84, 212, 228, 244, 53, 69, 85, 213, 229, 245, 6, 38, 54, 214, 7, 23, 39, 55, 215, 24, 40, 28, 13, 61, 77, 93, 109, 141, 14, 62, 78, 94, 15, 31, 47, 63, 95, 112, 128, 144, 192, 145, 161, 177, 193, 130, 146, 162, 194, 115, 131, 147, 163, 195, 100, 116, 132, 148, 164, 196, 101, 117, 133, 70, 86, 102, 198, 230, 246, 71, 87, 231, 247, 8, 56, 72, 88, 104, 216, 232, 248, 9, 25, 41, 57, 89, 217, 233, 249, 26, 42, 58, 218, 234, 250, 27, 43, 219, 235, 251, 12, 44, 60, 220, 236, 125, 157, 173, 189, 205, 110, 126, 142, 158, 174, 190, 206, 79, 111, 127, 143, 175, 160, 178, 179, 180, 149, 165, 181, 197, 118, 134, 150, 166, 182, 103, 119, 135, 151, 199, 120, 136, 152, 200, 73, 105, 121, 137, 153, 201, 10, 74, 90, 106, 122, 202, 11, 59, 75, 91, 107, 203, 76, 92, 108, 124, 140, 156, 172, 188, 204, 252, 221, 237, 253, 222, 238, 254, 159, 191, 207, 223, 239, 255, 176, 167, 183, 168, 184, 169, 185, 138, 154, 170, 186, 123, 139, 155, 171, 187);
  var huff_a17_cb = intArrayOf2(3, 9, 3, 2, 5, 7, 17, 23, 6);
  var huff_a17_xlat = intArrayOf2(0, 1, 63, 2, 62, 3, 4, 59, 60, 61, 5, 6, 7, 8, 56, 57, 58, 9, 10, 11, 12, 13, 14, 26, 27, 36, 37, 38, 50, 51, 52, 53, 54, 55, 15, 16, 17, 18, 19, 20, 21, 25, 28, 29, 30, 31, 33, 34, 35, 39, 43, 44, 45, 46, 47, 48, 49, 22, 23, 24, 40, 41, 42);
  var huff_a21_cb = intArrayOf2(1, 12, 1, 0, 0, 2, 6, 0, 7, 21, 15, 17, 8, 4);
  var huff_a21_xlat = intArrayOf2(0, 64, 192, 16, 48, 4, 12, 1, 3, 208, 112, 52, 28, 13, 19, 7, 80, 240, 68, 196, 20, 116, 76, 204, 220, 60, 65, 193, 17, 49, 5, 29, 67, 195, 51, 55, 15, 84, 244, 252, 209, 113, 21, 77, 205, 221, 211, 115, 71, 199, 119, 63, 212, 92, 124, 81, 241, 69, 197, 85, 53, 61, 83, 243, 23, 79, 207, 31, 255, 117, 245, 93, 125, 215, 247, 95, 223, 213, 253, 87, 127);
  var huff_a22_cb = intArrayOf2(2, 9, 1, 4, 0, 4, 3, 8, 3, 2);
  var huff_a22_xlat = intArrayOf2(0, 8, 56, 1, 7, 9, 57, 15, 63, 16, 2, 6, 48, 17, 49, 10, 58, 14, 23, 55, 50, 22, 62, 18, 54);
  var huff_a23_cb = intArrayOf2(3, 9, 5, 0, 4, 6, 10, 16, 8);
  var huff_a23_xlat = intArrayOf2(0, 8, 56, 1, 7, 9, 57, 15, 63, 16, 48, 2, 58, 6, 14, 24, 40, 17, 49, 10, 3, 5, 62, 23, 55, 25, 41, 18, 42, 50, 11, 51, 59, 13, 21, 61, 22, 30, 54, 31, 47, 26, 19, 27, 43, 29, 45, 53, 46);
  var huff_a24_cb = intArrayOf2(2, 4, 3, 1, 2);
  var huff_a25_cb = intArrayOf2(2, 4, 1, 5, 2);
  var huff_a25_xlat = intArrayOf2(1, 0, 2, 3, 4, 5, 6, 7);
  var huff_a26_cb = intArrayOf2(4, 11, 3, 4, 12, 15, 34, 83, 75, 30);
  var huff_a26_xlat = intArrayOf2(0, 1, 17, 16, 33, 18, 34, 32, 48, 49, 65, 2, 50, 3, 19, 35, 51, 20, 36, 64, 81, 97, 66, 82, 67, 83, 4, 52, 68, 21, 37, 53, 22, 38, 80, 96, 113, 129, 209, 98, 114, 130, 210, 99, 115, 211, 84, 100, 5, 69, 85, 101, 6, 54, 70, 86, 23, 39, 55, 71, 24, 40, 56, 25, 29, 45, 61, 30, 112, 128, 144, 208, 224, 145, 161, 177, 193, 225, 241, 146, 162, 194, 226, 242, 131, 147, 163, 195, 227, 243, 116, 132, 148, 164, 196, 212, 228, 244, 117, 133, 149, 213, 229, 102, 118, 134, 214, 230, 7, 87, 103, 119, 215, 8, 72, 88, 104, 216, 9, 41, 57, 73, 89, 105, 26, 42, 58, 74, 27, 43, 28, 44, 60, 76, 13, 77, 93, 109, 125, 141, 14, 46, 62, 78, 94, 110, 31, 47, 63, 79, 95, 160, 176, 192, 240, 178, 179, 180, 165, 181, 197, 245, 150, 166, 182, 198, 246, 135, 151, 167, 183, 199, 231, 247, 120, 136, 152, 168, 200, 232, 248, 121, 137, 153, 201, 217, 233, 249, 10, 90, 106, 122, 138, 218, 234, 250, 11, 59, 75, 91, 107, 123, 139, 219, 12, 92, 108, 124, 140, 156, 220, 157, 173, 189, 205, 126, 142, 158, 174, 190, 15, 111, 127, 143, 159, 175, 184, 169, 185, 154, 170, 186, 202, 155, 171, 187, 203, 235, 251, 172, 188, 204, 236, 252, 221, 237, 253, 206, 222, 238, 254, 191, 207, 223, 239, 255);
  var huff_a27_cb = intArrayOf2(4, 8, 3, 14, 10, 20, 16);
  var huff_a27_xlat = intArrayOf2(0, 2, 3, 1, 5, 6, 7, 9, 54, 55, 56, 58, 59, 60, 61, 62, 63, 4, 8, 10, 11, 12, 14, 49, 52, 53, 57, 13, 15, 16, 17, 18, 19, 22, 23, 25, 26, 30, 39, 43, 44, 45, 46, 47, 48, 50, 51, 20, 21, 24, 27, 28, 29, 31, 33, 34, 35, 36, 37, 38, 40, 41, 42);
  var huff_a31_cb = intArrayOf2(1, 6, 1, 0, 3, 1, 0, 4);
  var huff_a31_xlat = intArrayOf2(0, 4, 12, 1, 3, 5, 13, 7, 15);
  var huff_a32_cb = intArrayOf2(1, 11, 1, 0, 0, 2, 2, 6, 12, 18, 19, 15, 6);
  var huff_a32_xlat = intArrayOf2(0, 64, 1, 16, 4, 128, 80, 32, 20, 5, 2, 144, 96, 68, 84, 36, 8, 24, 65, 17, 21, 9, 6, 160, 132, 148, 100, 164, 72, 88, 40, 81, 33, 69, 85, 37, 25, 18, 22, 10, 26, 104, 168, 129, 145, 97, 161, 133, 149, 101, 165, 73, 89, 41, 105, 66, 82, 70, 86, 42, 136, 152, 137, 153, 169, 130, 146, 34, 98, 134, 38, 102, 74, 90, 106, 162, 150, 166, 138, 154, 170);
  var huff_a33_cb = intArrayOf2(3, 12, 1, 1, 13, 1, 14, 28, 33, 81, 32, 52);
  var huff_a33_xlat = intArrayOf2(0, 16, 64, 80, 4, 68, 20, 84, 1, 65, 17, 81, 5, 69, 21, 85, 144, 32, 148, 100, 24, 33, 149, 25, 105, 2, 82, 6, 70, 22, 128, 96, 132, 212, 36, 8, 72, 88, 104, 129, 145, 97, 133, 37, 101, 165, 9, 73, 89, 41, 66, 18, 86, 150, 166, 10, 23, 27, 208, 196, 116, 244, 136, 200, 40, 161, 113, 197, 213, 117, 153, 185, 77, 29, 45, 109, 34, 98, 102, 74, 26, 154, 106, 142, 94, 67, 35, 7, 71, 87, 107, 192, 160, 224, 112, 176, 164, 228, 52, 180, 152, 216, 168, 56, 120, 12, 76, 28, 92, 156, 108, 124, 193, 209, 225, 49, 229, 53, 181, 245, 137, 169, 121, 249, 13, 205, 157, 221, 173, 61, 125, 130, 194, 146, 210, 226, 114, 242, 134, 214, 230, 118, 182, 138, 90, 218, 234, 250, 78, 30, 158, 238, 3, 19, 83, 151, 183, 11, 75, 139, 91, 155, 235, 123, 15, 79, 31, 95, 159, 47, 63, 191, 232, 184, 248, 140, 44, 60, 252, 177, 201, 217, 233, 57, 93, 237, 189, 162, 50, 38, 54, 42, 170, 186, 14, 46, 110, 131, 195, 147, 99, 179, 167, 55, 48, 240, 204, 220, 172, 236, 188, 241, 141, 253, 178, 198, 246, 202, 58, 122, 206, 222, 174, 62, 126, 190, 254, 211, 163, 227, 51, 115, 243, 135, 199, 215, 39, 103, 231, 119, 247, 203, 219, 43, 171, 59, 187, 251, 143, 207, 223, 111, 175, 239, 127, 255);
  var huff_a34_cb = intArrayOf2(1, 5, 1, 1, 1, 1, 2);
  var huff_a34_xlat = intArrayOf2(1, 0, 2, 3, 4, 5);
  var huff_a35_cb = intArrayOf2(2, 10, 1, 0, 2, 3, 6, 19, 9, 75, 110);
  var huff_a35_xlat = intArrayOf2(0, 240, 15, 16, 1, 255, 32, 224, 17, 241, 14, 31, 48, 64, 208, 33, 225, 2, 18, 34, 226, 242, 3, 19, 30, 46, 62, 238, 254, 47, 239, 210, 67, 243, 4, 13, 45, 61, 63, 223, 80, 96, 112, 144, 176, 49, 65, 145, 161, 193, 209, 66, 162, 194, 35, 51, 227, 36, 52, 180, 212, 244, 5, 21, 69, 229, 22, 54, 86, 166, 198, 214, 246, 87, 199, 247, 9, 41, 73, 89, 105, 249, 10, 42, 58, 74, 218, 234, 250, 11, 43, 171, 235, 251, 12, 28, 44, 60, 76, 92, 204, 220, 252, 29, 77, 109, 189, 205, 237, 253, 78, 110, 206, 222, 127, 160, 192, 81, 97, 113, 177, 50, 82, 98, 114, 146, 178, 83, 99, 115, 147, 163, 179, 195, 211, 20, 68, 84, 100, 116, 148, 164, 196, 228, 37, 53, 85, 101, 117, 149, 165, 181, 197, 213, 245, 6, 38, 70, 102, 118, 150, 182, 230, 7, 23, 39, 55, 71, 103, 119, 151, 167, 183, 215, 231, 25, 57, 121, 153, 169, 185, 201, 217, 233, 26, 90, 106, 122, 154, 170, 186, 202, 27, 59, 75, 91, 107, 123, 155, 187, 203, 219, 108, 124, 156, 172, 188, 236, 93, 125, 157, 173, 221, 94, 126, 158, 174, 190, 79, 95, 111, 159, 175, 191, 207);
  var huff_a36_cb = intArrayOf2(3, 12, 1, 3, 5, 5, 13, 27, 69, 96, 35, 2);
  var huff_a36_xlat = intArrayOf2(0, 16, 1, 17, 32, 33, 2, 18, 34, 49, 65, 50, 19, 35, 48, 64, 81, 66, 3, 51, 67, 4, 20, 36, 52, 21, 37, 80, 97, 113, 209, 82, 98, 114, 210, 83, 99, 211, 68, 84, 100, 5, 53, 69, 85, 22, 38, 54, 70, 23, 39, 29, 45, 61, 96, 112, 208, 129, 145, 161, 193, 225, 241, 130, 146, 194, 226, 242, 115, 131, 227, 243, 116, 132, 196, 212, 228, 244, 101, 117, 133, 213, 229, 6, 86, 102, 214, 230, 7, 55, 71, 87, 103, 215, 231, 24, 40, 56, 72, 88, 216, 25, 41, 42, 28, 44, 13, 77, 93, 109, 125, 141, 157, 30, 46, 62, 78, 94, 110, 126, 31, 47, 63, 128, 144, 160, 192, 224, 240, 177, 162, 178, 147, 163, 179, 195, 148, 164, 180, 149, 165, 181, 197, 245, 118, 134, 150, 166, 198, 246, 119, 135, 151, 167, 199, 247, 8, 104, 120, 136, 152, 200, 232, 248, 9, 57, 73, 89, 105, 121, 137, 217, 233, 249, 10, 26, 58, 74, 90, 106, 218, 234, 250, 27, 43, 59, 75, 91, 219, 235, 251, 12, 60, 76, 92, 108, 124, 140, 156, 220, 236, 173, 189, 205, 221, 237, 14, 142, 158, 174, 190, 15, 79, 95, 111, 127, 143, 159, 175, 176, 182, 183, 168, 184, 153, 169, 185, 201, 122, 138, 154, 170, 186, 202, 11, 107, 123, 139, 155, 203, 172, 188, 204, 252, 253, 206, 222, 238, 254, 191, 207, 223, 239, 255, 171, 187);
  var huff_a37_cb = intArrayOf2(4, 8, 7, 6, 8, 22, 20);
  var huff_a37_xlat = intArrayOf2(0, 1, 2, 3, 61, 62, 63, 4, 5, 6, 58, 59, 60, 7, 8, 9, 10, 54, 55, 56, 57, 11, 12, 13, 14, 15, 16, 25, 26, 27, 28, 29, 30, 35, 36, 37, 38, 48, 49, 50, 51, 52, 53, 17, 18, 19, 20, 21, 22, 23, 24, 31, 33, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47);
  var huff_a41_cb = intArrayOf2(1, 12, 1, 0, 0, 6, 2, 0, 0, 0, 19, 9, 24, 20);
  var huff_a41_xlat = intArrayOf2(0, 64, 192, 16, 48, 4, 12, 1, 3, 80, 208, 112, 240, 196, 52, 76, 204, 28, 65, 193, 49, 5, 13, 67, 195, 19, 7, 15, 68, 20, 116, 220, 60, 17, 29, 51, 55, 84, 212, 244, 92, 124, 252, 209, 113, 241, 197, 21, 53, 77, 205, 221, 61, 211, 115, 71, 199, 23, 119, 31, 63, 81, 69, 85, 213, 117, 245, 93, 125, 253, 83, 243, 87, 215, 247, 79, 207, 95, 223, 127, 255);
  var huff_a42_cb = intArrayOf2(3, 10, 1, 2, 13, 1, 31, 13, 16, 4);
  var huff_a42_xlat = intArrayOf2(0, 64, 1, 16, 80, 4, 68, 20, 84, 65, 17, 81, 5, 69, 21, 85, 89, 128, 144, 32, 96, 132, 148, 36, 100, 8, 72, 24, 88, 129, 145, 33, 97, 133, 149, 37, 101, 9, 73, 25, 2, 66, 18, 82, 6, 70, 22, 86, 160, 164, 104, 161, 165, 153, 41, 105, 150, 102, 74, 26, 90, 136, 152, 40, 137, 169, 130, 146, 34, 98, 134, 38, 166, 10, 154, 42, 106, 168, 162, 138, 170);
  var huff_a43_cb = intArrayOf2(2, 4, 2, 3, 2);
  var huff_a43_xlat = intArrayOf2(0, 7, 1, 2, 6, 3, 5);
  var huff_a44_cb = intArrayOf2(4, 10, 5, 4, 12, 17, 47, 24, 12);
  var huff_a44_xlat = intArrayOf2(0, 16, 240, 1, 15, 17, 241, 31, 255, 32, 224, 33, 225, 2, 18, 242, 14, 30, 254, 47, 239, 48, 80, 208, 209, 34, 226, 3, 19, 243, 13, 29, 45, 253, 46, 238, 63, 223, 64, 176, 192, 49, 65, 81, 177, 193, 50, 178, 194, 210, 35, 179, 211, 227, 4, 20, 228, 244, 5, 21, 213, 229, 245, 11, 27, 43, 59, 235, 251, 12, 28, 44, 252, 61, 93, 237, 62, 78, 94, 190, 222, 79, 95, 191, 207, 66, 82, 51, 83, 195, 36, 180, 212, 37, 53, 197, 75, 203, 219, 60, 76, 92, 220, 236, 77, 189, 205, 221, 206, 67, 52, 68, 84, 196, 69, 85, 181, 91, 187, 188, 204);
  var huff_a45_cb = intArrayOf2(2, 4, 2, 2, 4);
  var huff_a45_xlat = intArrayOf2(1, 2, 0, 3, 4, 5, 6, 7);
  var huff_a46_cb = intArrayOf2(5, 9, 1, 16, 31, 36, 172);
  var huff_a46_xlat = intArrayOf2(2, 0, 48, 33, 49, 65, 97, 18, 34, 66, 98, 67, 83, 36, 69, 38, 39, 16, 64, 176, 1, 17, 129, 50, 82, 114, 146, 3, 19, 51, 99, 20, 52, 84, 100, 116, 5, 21, 37, 53, 85, 101, 6, 70, 86, 87, 103, 136, 32, 81, 145, 209, 242, 35, 131, 147, 4, 68, 132, 148, 117, 133, 197, 54, 102, 150, 182, 7, 55, 151, 8, 40, 56, 72, 104, 9, 105, 121, 10, 42, 27, 155, 44, 77, 80, 96, 112, 128, 144, 160, 192, 208, 224, 240, 113, 161, 177, 193, 225, 241, 130, 162, 178, 194, 210, 226, 115, 163, 179, 195, 211, 227, 243, 164, 180, 196, 212, 228, 244, 149, 165, 181, 213, 229, 245, 22, 118, 134, 166, 198, 214, 230, 246, 23, 71, 119, 135, 167, 183, 199, 215, 231, 247, 24, 88, 120, 152, 168, 184, 200, 216, 232, 248, 25, 41, 57, 73, 89, 137, 153, 169, 185, 201, 217, 233, 249, 26, 58, 74, 90, 106, 122, 138, 154, 170, 186, 202, 218, 234, 250, 11, 43, 59, 75, 91, 107, 123, 139, 171, 187, 203, 219, 235, 251, 12, 28, 60, 76, 92, 108, 124, 140, 156, 172, 188, 204, 220, 236, 252, 13, 29, 45, 61, 93, 109, 125, 141, 157, 173, 189, 205, 221, 237, 253, 14, 30, 46, 62, 78, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 254, 15, 31, 47, 63, 79, 95, 111, 127, 143, 159, 175, 191, 207, 223, 239, 255);
  var huff_a47_cb = intArrayOf2(4, 9, 5, 12, 9, 12, 15, 10);
  var huff_a47_xlat = intArrayOf2(0, 1, 2, 62, 63, 3, 4, 5, 6, 8, 54, 56, 57, 58, 59, 60, 61, 7, 9, 10, 11, 12, 13, 14, 53, 55, 15, 16, 17, 18, 19, 20, 21, 36, 37, 39, 42, 52, 22, 25, 28, 35, 38, 40, 41, 43, 45, 46, 47, 48, 49, 50, 51, 23, 24, 26, 27, 29, 30, 31, 33, 34, 44);
  var huff_a51_cb = intArrayOf2(2, 11, 1, 0, 6, 2, 6, 18, 4, 26, 6, 12);
  var huff_a51_xlat = intArrayOf2(0, 64, 192, 48, 4, 1, 3, 16, 12, 208, 112, 52, 28, 13, 7, 80, 240, 68, 196, 20, 76, 204, 60, 65, 193, 17, 49, 5, 67, 195, 19, 51, 15, 116, 220, 29, 55, 84, 212, 244, 92, 124, 252, 209, 113, 241, 197, 21, 53, 77, 205, 221, 61, 83, 211, 115, 71, 199, 23, 119, 79, 31, 63, 81, 69, 85, 243, 207, 255, 213, 117, 245, 93, 125, 253, 87, 215, 247, 95, 223, 127);
  var huff_a52_cb = intArrayOf2(1, 10, 1, 0, 2, 2, 0, 4, 3, 8, 3, 2);
  var huff_a52_xlat = intArrayOf2(0, 8, 56, 1, 7, 9, 57, 15, 63, 16, 2, 6, 48, 17, 49, 10, 58, 14, 23, 55, 50, 22, 62, 18, 54);
  var huff_a53_xlat = intArrayOf2(0, 1, 2, 6, 7, 3, 5);
  var huff_a54_cb = intArrayOf2(4, 9, 4, 7, 12, 19, 21, 58);
  var huff_a54_xlat = intArrayOf2(0, 1, 15, 31, 16, 224, 240, 17, 241, 47, 255, 32, 33, 225, 2, 18, 242, 3, 243, 14, 46, 254, 63, 48, 64, 208, 193, 209, 34, 194, 51, 227, 12, 204, 13, 29, 45, 253, 30, 62, 94, 239, 192, 82, 178, 210, 67, 195, 211, 36, 69, 245, 75, 91, 251, 28, 61, 189, 221, 238, 191, 207, 223, 80, 176, 49, 65, 81, 177, 50, 66, 226, 19, 35, 83, 179, 4, 20, 52, 68, 84, 180, 196, 212, 228, 244, 5, 21, 37, 53, 85, 181, 197, 213, 229, 11, 27, 43, 59, 187, 203, 219, 235, 44, 60, 76, 92, 188, 220, 236, 252, 77, 93, 205, 237, 78, 190, 206, 222, 79, 95);
  var huff_a55_cb = intArrayOf2(1, 6, 1, 1, 1, 0, 3, 2);
  var huff_a55_xlat = intArrayOf2(0, 1, 2, 3, 6, 7, 4, 5);
  var huff_a56_cb = intArrayOf2(3, 7, 1, 8, 6, 8, 8);
  var huff_a56_xlat = intArrayOf2(4, 0, 1, 2, 3, 28, 29, 30, 31, 5, 6, 7, 24, 25, 27, 8, 9, 14, 19, 21, 22, 23, 26, 10, 11, 12, 13, 15, 17, 18, 20);
  var huff_a57_cb = intArrayOf2(3, 9, 1, 5, 7, 8, 16, 22, 4);
  var huff_a57_xlat = intArrayOf2(0, 1, 2, 61, 62, 63, 3, 4, 5, 6, 58, 59, 60, 7, 8, 9, 10, 54, 55, 56, 57, 11, 12, 13, 14, 15, 26, 27, 28, 36, 37, 38, 49, 50, 51, 52, 53, 16, 17, 18, 19, 20, 21, 23, 24, 25, 29, 30, 31, 33, 34, 35, 39, 43, 44, 45, 46, 47, 48, 22, 40, 41, 42);
  var huff_a61_cb = intArrayOf2(2, 11, 1, 0, 8, 0, 1, 16, 10, 29, 12, 4);
  var huff_a61_xlat = intArrayOf2(0, 64, 192, 16, 48, 4, 12, 1, 3, 112, 80, 208, 240, 68, 196, 20, 52, 76, 28, 60, 49, 5, 13, 19, 7, 15, 116, 204, 220, 252, 65, 193, 17, 67, 195, 51, 84, 212, 244, 92, 124, 81, 209, 113, 241, 69, 197, 21, 53, 77, 205, 29, 61, 83, 211, 115, 243, 71, 199, 23, 55, 79, 207, 31, 63, 85, 213, 117, 245, 93, 221, 253, 87, 215, 119, 247, 255, 125, 95, 223, 127);
  var huff_a62_cb = intArrayOf2(3, 8, 5, 2, 2, 9, 5, 2);
  var huff_a62_xlat = intArrayOf2(0, 8, 56, 1, 7, 57, 15, 9, 63, 16, 48, 49, 2, 58, 6, 14, 23, 55, 17, 10, 50, 22, 62, 18, 54);
  var huff_a63_cb = intArrayOf2(3, 11, 1, 1, 10, 4, 16, 29, 46, 75, 74);
  var huff_a63_xlat = intArrayOf2(0, 64, 16, 80, 4, 68, 20, 1, 65, 5, 69, 85, 84, 17, 81, 21, 128, 144, 96, 36, 100, 164, 72, 97, 149, 37, 165, 2, 66, 82, 22, 86, 32, 132, 148, 24, 88, 129, 145, 133, 101, 9, 73, 25, 89, 153, 41, 105, 121, 93, 18, 98, 6, 70, 134, 102, 26, 90, 106, 71, 23, 192, 160, 224, 196, 212, 116, 8, 120, 12, 76, 28, 92, 209, 33, 225, 113, 197, 229, 117, 181, 137, 189, 146, 34, 150, 166, 54, 10, 74, 138, 154, 42, 122, 222, 110, 67, 19, 83, 35, 7, 119, 75, 27, 155, 107, 47, 208, 48, 112, 228, 52, 244, 200, 152, 40, 104, 168, 232, 56, 184, 248, 156, 44, 108, 124, 161, 177, 213, 53, 201, 217, 169, 233, 57, 185, 249, 205, 29, 45, 173, 125, 194, 210, 162, 178, 242, 198, 38, 118, 182, 218, 170, 234, 58, 250, 14, 78, 46, 126, 190, 254, 3, 131, 99, 163, 179, 135, 87, 151, 215, 39, 11, 139, 91, 43, 171, 207, 31, 159, 127, 191, 176, 240, 180, 136, 216, 140, 204, 220, 172, 236, 60, 188, 252, 193, 49, 241, 245, 13, 77, 141, 157, 221, 109, 237, 61, 253, 130, 226, 50, 114, 214, 230, 246, 202, 186, 142, 206, 30, 94, 158, 174, 238, 62, 195, 147, 211, 227, 51, 115, 243, 199, 103, 167, 231, 55, 183, 247, 203, 219, 235, 59, 123, 187, 251, 15, 79, 143, 95, 223, 111, 175, 239, 63, 255);
  var huff_a64_cb = intArrayOf2(4, 9, 1, 7, 12, 36, 63, 2);
  var huff_a64_xlat = intArrayOf2(0, 16, 32, 224, 240, 2, 14, 239, 48, 1, 17, 33, 49, 241, 18, 242, 30, 238, 223, 255, 64, 192, 208, 209, 225, 34, 50, 66, 210, 226, 3, 19, 35, 179, 195, 227, 243, 228, 5, 245, 43, 12, 252, 29, 45, 189, 221, 253, 46, 78, 222, 254, 15, 31, 47, 63, 80, 176, 65, 81, 177, 193, 82, 178, 194, 51, 67, 83, 211, 4, 20, 36, 52, 68, 84, 180, 196, 212, 244, 21, 37, 53, 69, 85, 181, 197, 213, 229, 11, 27, 59, 75, 91, 187, 203, 219, 235, 251, 28, 44, 60, 76, 92, 188, 204, 220, 236, 13, 61, 77, 93, 205, 237, 62, 94, 190, 206, 79, 207, 95, 191);
  var huff_a65_cb = intArrayOf2(2, 7, 3, 0, 1, 3, 4, 4);
  var huff_a65_xlat = intArrayOf2(0, 1, 15, 14, 2, 3, 13, 4, 6, 10, 12, 5, 7, 9, 11);
  var huff_a66_cb = intArrayOf2(2, 10, 1, 2, 2, 6, 8, 6, 3, 1, 2);
  var huff_a66_xlat = intArrayOf2(0, 1, 31, 2, 30, 3, 4, 15, 17, 28, 29, 5, 6, 7, 8, 24, 25, 26, 27, 9, 10, 11, 21, 22, 23, 12, 19, 20, 13, 14, 18);
  var huff_a67_cb = intArrayOf2(2, 9, 1, 1, 3, 4, 6, 13, 25, 10);
  var huff_a67_xlat = intArrayOf2(0, 1, 2, 62, 63, 3, 4, 60, 61, 5, 6, 7, 57, 58, 59, 8, 9, 10, 11, 12, 13, 26, 38, 52, 53, 54, 55, 56, 14, 15, 16, 17, 18, 19, 25, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 39, 45, 46, 47, 48, 49, 50, 51, 20, 21, 22, 23, 24, 40, 41, 42, 43, 44);
  var huff_a71_cb = intArrayOf2(1, 3, 1, 1, 2);
  var huff_a72_cb = intArrayOf2(2, 11, 1, 0, 4, 8, 3, 8, 24, 17, 12, 4);
  var huff_a72_xlat = intArrayOf2(0, 64, 16, 4, 1, 80, 68, 20, 84, 65, 17, 5, 21, 81, 69, 85, 128, 144, 32, 100, 8, 25, 2, 6, 96, 132, 148, 36, 72, 24, 88, 129, 145, 33, 97, 133, 149, 37, 101, 9, 73, 89, 66, 18, 82, 70, 22, 86, 160, 164, 152, 40, 104, 161, 165, 153, 41, 105, 150, 38, 102, 10, 74, 26, 90, 136, 168, 137, 169, 130, 146, 34, 98, 134, 166, 42, 106, 162, 138, 154, 170);
  var huff_a73_cb = intArrayOf2(2, 10, 1, 1, 5, 2, 8, 7, 13, 8, 4);
  var huff_a73_xlat = intArrayOf2(0, 8, 56, 1, 57, 7, 15, 9, 63, 16, 48, 49, 2, 58, 6, 14, 23, 17, 10, 50, 13, 22, 62, 55, 24, 40, 25, 41, 18, 42, 3, 59, 5, 21, 30, 31, 47, 26, 11, 43, 51, 53, 61, 46, 54, 19, 27, 29, 45);
  var huff_a74_cb = intArrayOf2(1, 12, 1, 0, 0, 4, 0, 4, 5, 9, 30, 45, 21, 2);
  var huff_a74_xlat = intArrayOf2(0, 16, 240, 1, 15, 17, 241, 31, 255, 32, 224, 2, 242, 14, 33, 225, 18, 226, 30, 46, 254, 47, 239, 48, 80, 176, 192, 208, 49, 177, 209, 34, 210, 3, 19, 227, 243, 244, 5, 229, 245, 11, 27, 12, 13, 29, 45, 253, 62, 238, 63, 95, 223, 64, 65, 81, 193, 50, 66, 82, 178, 194, 35, 51, 179, 195, 211, 4, 20, 36, 212, 228, 21, 37, 197, 213, 43, 59, 235, 251, 28, 44, 60, 92, 236, 252, 61, 93, 221, 237, 78, 94, 190, 206, 222, 79, 191, 207, 67, 83, 52, 84, 180, 196, 53, 69, 85, 181, 75, 91, 203, 219, 76, 188, 204, 220, 77, 189, 205, 68, 187);
  var huff_a75_cb = intArrayOf2(2, 6, 1, 3, 3, 4, 4);
  var huff_a75_xlat = intArrayOf2(0, 1, 14, 15, 2, 3, 13, 4, 6, 10, 12, 5, 7, 9, 11);
  var huff_a76_cb = intArrayOf2(3, 12, 1, 3, 4, 8, 10, 36, 60, 78, 48, 8);
  var huff_a76_xlat = intArrayOf2(0, 16, 1, 17, 32, 33, 2, 18, 48, 49, 65, 34, 3, 19, 35, 20, 64, 81, 97, 50, 66, 51, 4, 36, 21, 22, 80, 96, 208, 113, 129, 209, 225, 241, 82, 98, 114, 210, 67, 83, 99, 211, 52, 68, 84, 5, 37, 53, 69, 6, 38, 54, 23, 39, 24, 13, 29, 45, 61, 30, 46, 31, 112, 128, 224, 240, 145, 161, 193, 130, 146, 194, 226, 242, 115, 131, 147, 227, 243, 100, 116, 132, 212, 228, 244, 85, 101, 213, 229, 245, 70, 86, 102, 214, 7, 55, 71, 87, 8, 40, 56, 72, 25, 41, 57, 26, 42, 27, 28, 44, 60, 77, 93, 109, 14, 62, 78, 94, 15, 47, 63, 79, 144, 160, 176, 192, 177, 162, 178, 163, 179, 195, 148, 164, 180, 196, 117, 133, 149, 165, 197, 118, 134, 150, 230, 246, 103, 119, 135, 215, 231, 247, 88, 104, 120, 136, 216, 232, 248, 9, 73, 89, 105, 217, 233, 249, 10, 58, 74, 90, 218, 234, 11, 43, 59, 75, 219, 12, 76, 92, 108, 220, 125, 141, 157, 173, 189, 205, 110, 126, 142, 158, 174, 190, 95, 111, 127, 143, 159, 175, 181, 166, 182, 198, 151, 167, 199, 152, 168, 184, 200, 121, 137, 153, 169, 185, 201, 106, 122, 138, 154, 170, 202, 250, 91, 107, 123, 139, 203, 235, 251, 124, 140, 156, 172, 188, 236, 252, 221, 237, 253, 206, 222, 238, 254, 191, 207, 223, 183, 186, 155, 171, 187, 204, 239, 255);
  var huff_b01_cb = intArrayOf2(1, 12, 1, 0, 0, 2, 6, 0, 11, 13, 12, 24, 4, 8);
  var huff_b01_xlat = intArrayOf2(0, 1, 3, 64, 192, 16, 48, 4, 12, 80, 208, 112, 240, 52, 28, 5, 13, 19, 7, 15, 68, 196, 20, 76, 204, 60, 65, 193, 17, 49, 67, 195, 51, 84, 116, 220, 252, 113, 21, 77, 29, 211, 199, 55, 63, 212, 244, 92, 124, 81, 209, 241, 69, 197, 85, 53, 205, 221, 61, 83, 115, 243, 71, 23, 119, 79, 207, 31, 255, 245, 125, 215, 95, 213, 117, 93, 253, 87, 247, 223, 127);
  var huff_b02_cb = intArrayOf2(1, 12, 1, 0, 0, 4, 0, 8, 4, 9, 19, 13, 13, 10);
  var huff_b02_xlat = intArrayOf2(0, 64, 16, 4, 1, 80, 68, 20, 84, 65, 17, 5, 21, 128, 81, 69, 85, 144, 32, 96, 36, 8, 24, 9, 2, 6, 132, 148, 100, 72, 88, 129, 145, 33, 97, 149, 37, 101, 25, 89, 66, 18, 70, 22, 86, 160, 164, 40, 104, 133, 165, 73, 41, 105, 82, 10, 26, 90, 136, 152, 161, 137, 153, 169, 34, 98, 150, 38, 102, 74, 106, 168, 130, 146, 162, 134, 166, 138, 154, 42, 170);
  var huff_b03_cb = intArrayOf2(1, 9, 1, 0, 0, 4, 0, 5, 12, 13, 14);
  var huff_b03_xlat = intArrayOf2(0, 8, 56, 1, 7, 48, 9, 57, 15, 63, 16, 24, 40, 49, 2, 58, 3, 5, 6, 14, 23, 55, 17, 25, 41, 10, 50, 11, 59, 13, 21, 61, 62, 31, 47, 18, 26, 42, 19, 27, 43, 51, 29, 45, 53, 22, 30, 46, 54);
  var huff_b04_cb = intArrayOf2(2, 11, 1, 0, 4, 4, 5, 9, 30, 45, 21, 2);
  var huff_b04_xlat = intArrayOf2(0, 16, 240, 1, 15, 17, 241, 31, 255, 32, 224, 2, 242, 14, 33, 225, 18, 226, 30, 46, 254, 47, 239, 48, 80, 176, 192, 208, 49, 177, 209, 34, 210, 3, 19, 227, 243, 244, 5, 229, 245, 11, 27, 12, 13, 29, 45, 253, 62, 238, 63, 95, 223, 64, 65, 81, 193, 50, 66, 82, 178, 194, 35, 51, 179, 195, 211, 4, 20, 36, 212, 228, 21, 37, 197, 213, 43, 59, 235, 251, 28, 44, 60, 92, 236, 252, 61, 93, 221, 237, 78, 94, 190, 206, 222, 79, 191, 207, 67, 83, 52, 84, 180, 196, 53, 69, 85, 181, 75, 91, 203, 219, 76, 188, 204, 220, 77, 189, 205, 68, 187);
  var huff_b05_cb = intArrayOf2(3, 11, 1, 4, 4, 4, 12, 30, 73, 75, 22);
  var huff_b05_xlat = intArrayOf2(0, 16, 240, 1, 15, 17, 241, 31, 255, 32, 224, 2, 14, 48, 208, 33, 225, 18, 242, 3, 13, 30, 254, 47, 239, 64, 96, 112, 144, 160, 192, 49, 209, 34, 50, 210, 226, 19, 35, 227, 243, 4, 6, 7, 9, 10, 12, 29, 45, 253, 46, 62, 238, 63, 223, 80, 176, 65, 81, 97, 113, 145, 161, 177, 193, 66, 98, 114, 146, 162, 194, 51, 147, 163, 211, 20, 36, 228, 244, 5, 21, 245, 22, 38, 214, 230, 246, 23, 39, 215, 231, 247, 25, 41, 57, 233, 249, 26, 42, 234, 250, 11, 27, 251, 28, 44, 236, 252, 61, 125, 157, 221, 237, 78, 110, 126, 158, 174, 206, 222, 79, 95, 111, 127, 159, 175, 191, 207, 82, 178, 67, 83, 99, 115, 179, 195, 52, 68, 100, 116, 148, 164, 180, 196, 212, 37, 53, 101, 117, 149, 165, 213, 229, 54, 70, 86, 102, 166, 182, 198, 55, 71, 87, 183, 199, 73, 89, 105, 185, 201, 217, 58, 74, 90, 106, 170, 186, 202, 218, 43, 59, 107, 123, 155, 171, 219, 235, 60, 76, 108, 124, 156, 172, 204, 220, 77, 93, 109, 173, 189, 205, 94, 190, 84, 69, 85, 181, 197, 118, 150, 103, 119, 151, 167, 121, 153, 169, 122, 154, 75, 91, 187, 203, 92, 188);
  var huff_b07_cb = intArrayOf2(3, 9, 3, 2, 4, 8, 23, 13, 10);
  var huff_b07_xlat = intArrayOf2(0, 1, 63, 2, 62, 3, 4, 60, 61, 5, 6, 7, 8, 56, 57, 58, 59, 9, 10, 11, 12, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 51, 52, 53, 54, 55, 13, 14, 15, 16, 17, 18, 19, 45, 46, 47, 48, 49, 50, 20, 21, 22, 23, 24, 40, 41, 42, 43, 44);
  var huff_b12_cb = intArrayOf2(3, 10, 1, 3, 12, 0, 30, 9, 18, 8);
  var huff_b12_xlat = intArrayOf2(0, 64, 4, 1, 16, 80, 68, 20, 84, 65, 17, 81, 5, 69, 21, 85, 128, 144, 32, 96, 132, 148, 36, 100, 8, 72, 24, 129, 145, 97, 133, 149, 37, 101, 9, 73, 25, 89, 2, 66, 18, 82, 6, 70, 22, 86, 164, 88, 104, 33, 165, 41, 105, 26, 90, 160, 136, 152, 40, 161, 137, 153, 169, 146, 34, 98, 134, 150, 38, 102, 10, 74, 106, 168, 130, 162, 166, 138, 154, 42, 170);
  var huff_b14_cb = intArrayOf2(1, 12, 1, 0, 0, 4, 0, 3, 5, 16, 28, 34, 26, 4);
  var huff_b14_xlat = intArrayOf2(0, 16, 240, 1, 15, 241, 31, 255, 32, 224, 17, 2, 14, 48, 80, 176, 208, 33, 225, 18, 242, 3, 5, 11, 13, 30, 254, 47, 239, 64, 192, 49, 81, 177, 193, 209, 34, 82, 226, 19, 243, 4, 21, 245, 27, 235, 251, 12, 29, 253, 46, 94, 238, 63, 95, 191, 223, 65, 50, 66, 178, 210, 35, 83, 179, 227, 20, 36, 228, 244, 37, 53, 213, 229, 43, 59, 219, 28, 44, 188, 236, 252, 45, 189, 237, 62, 78, 190, 222, 79, 207, 194, 51, 67, 195, 211, 52, 68, 84, 180, 212, 69, 85, 197, 75, 203, 60, 76, 92, 204, 220, 61, 77, 93, 205, 221, 206, 196, 181, 91, 187);
  var huff_b16_cb = intArrayOf2(4, 12, 4, 4, 9, 13, 37, 76, 72, 39, 2);
  var huff_b16_xlat = intArrayOf2(0, 16, 1, 17, 32, 33, 2, 18, 48, 49, 65, 34, 50, 3, 19, 35, 20, 64, 81, 97, 66, 82, 51, 67, 4, 36, 52, 21, 37, 22, 80, 96, 112, 113, 129, 209, 225, 98, 114, 130, 210, 83, 99, 115, 211, 68, 84, 5, 53, 69, 85, 6, 38, 54, 7, 23, 39, 55, 24, 40, 25, 29, 45, 61, 30, 46, 31, 128, 144, 208, 224, 240, 145, 161, 177, 193, 241, 146, 162, 178, 194, 226, 242, 131, 147, 163, 195, 227, 243, 100, 116, 132, 148, 212, 228, 244, 101, 117, 133, 213, 229, 70, 86, 102, 118, 214, 230, 71, 87, 103, 215, 8, 56, 72, 88, 9, 41, 57, 73, 10, 26, 42, 58, 27, 43, 12, 28, 44, 60, 13, 77, 93, 109, 125, 14, 62, 78, 94, 110, 15, 47, 63, 79, 160, 176, 192, 179, 164, 180, 196, 149, 165, 181, 197, 245, 134, 150, 166, 182, 198, 246, 119, 135, 151, 167, 199, 231, 247, 104, 120, 136, 152, 216, 232, 248, 89, 105, 121, 137, 217, 233, 249, 74, 90, 106, 122, 218, 234, 11, 59, 75, 91, 219, 235, 76, 92, 108, 124, 140, 220, 141, 157, 173, 189, 205, 126, 142, 158, 174, 190, 95, 111, 127, 143, 159, 183, 168, 184, 200, 153, 169, 185, 201, 138, 154, 170, 186, 202, 250, 107, 123, 139, 155, 171, 187, 203, 251, 156, 172, 188, 204, 236, 252, 221, 237, 253, 206, 222, 238, 254, 175, 191, 207, 223, 239, 255);
  var huff_b26_cb = intArrayOf2(3, 12, 2, 2, 4, 5, 11, 26, 67, 78, 51, 10);
  var huff_b26_xlat = intArrayOf2(0, 1, 16, 17, 32, 33, 2, 18, 48, 49, 34, 3, 19, 64, 65, 81, 50, 66, 35, 51, 4, 20, 36, 21, 80, 97, 113, 209, 225, 82, 98, 210, 67, 83, 211, 52, 68, 5, 37, 53, 6, 22, 38, 23, 24, 29, 45, 61, 30, 46, 96, 112, 128, 208, 224, 240, 129, 145, 161, 193, 241, 114, 130, 146, 194, 226, 242, 99, 115, 227, 243, 84, 100, 116, 212, 228, 244, 69, 85, 101, 213, 229, 245, 54, 70, 86, 214, 230, 7, 39, 55, 71, 215, 8, 40, 56, 25, 41, 26, 27, 28, 44, 13, 77, 93, 109, 125, 14, 62, 78, 94, 110, 15, 31, 47, 63, 79, 144, 160, 192, 177, 162, 178, 131, 147, 163, 179, 195, 132, 148, 164, 196, 117, 133, 149, 197, 102, 118, 134, 150, 198, 246, 87, 103, 119, 231, 247, 72, 88, 104, 120, 216, 232, 248, 9, 57, 73, 89, 217, 233, 249, 10, 42, 58, 74, 218, 234, 11, 43, 59, 219, 235, 12, 60, 76, 92, 108, 220, 141, 157, 173, 189, 205, 126, 142, 158, 174, 190, 206, 95, 111, 127, 143, 159, 175, 176, 180, 165, 181, 166, 182, 135, 151, 167, 183, 199, 136, 152, 168, 200, 105, 121, 137, 153, 169, 201, 90, 106, 122, 154, 202, 250, 75, 91, 107, 123, 203, 251, 124, 140, 156, 172, 188, 204, 236, 252, 221, 237, 253, 222, 238, 254, 191, 207, 223, 239, 184, 185, 138, 170, 186, 139, 155, 171, 187, 255);
  var huff_b32_cb = intArrayOf2(2, 11, 1, 0, 4, 6, 7, 10, 22, 11, 16, 4);
  var huff_b32_xlat = intArrayOf2(0, 64, 16, 4, 1, 80, 68, 20, 65, 17, 5, 128, 84, 81, 69, 21, 85, 2, 144, 32, 96, 132, 36, 8, 24, 9, 18, 6, 160, 148, 100, 72, 88, 129, 145, 33, 97, 133, 149, 37, 101, 73, 25, 89, 66, 82, 70, 22, 86, 10, 164, 40, 104, 161, 165, 41, 105, 38, 74, 26, 90, 136, 152, 168, 137, 153, 169, 130, 146, 34, 98, 134, 150, 102, 154, 42, 106, 162, 166, 138, 170);
  var huff_b33_cb = intArrayOf2(2, 12, 1, 0, 0, 4, 11, 8, 28, 92, 97, 13, 2);
  var huff_b33_xlat = intArrayOf2(0, 64, 16, 4, 1, 80, 68, 20, 84, 65, 17, 81, 5, 69, 21, 85, 32, 149, 101, 73, 89, 82, 70, 22, 128, 144, 96, 132, 148, 36, 100, 164, 8, 72, 24, 88, 129, 145, 33, 97, 133, 37, 9, 25, 105, 2, 66, 18, 6, 86, 90, 87, 208, 116, 104, 92, 193, 213, 165, 229, 117, 181, 245, 153, 217, 169, 233, 121, 185, 249, 29, 93, 157, 221, 109, 173, 237, 125, 189, 253, 130, 146, 210, 98, 150, 214, 38, 102, 166, 230, 118, 182, 246, 10, 74, 26, 154, 218, 42, 106, 170, 234, 122, 186, 250, 94, 158, 222, 110, 174, 238, 126, 190, 254, 3, 19, 83, 23, 151, 215, 103, 167, 231, 119, 183, 247, 91, 155, 219, 107, 171, 235, 123, 187, 251, 95, 159, 223, 111, 175, 239, 127, 191, 255, 192, 160, 224, 48, 196, 212, 228, 52, 180, 244, 136, 200, 152, 216, 40, 168, 232, 56, 120, 184, 248, 12, 76, 28, 156, 220, 108, 172, 236, 124, 188, 252, 209, 161, 225, 49, 113, 177, 241, 197, 53, 137, 201, 41, 57, 13, 77, 141, 205, 45, 61, 34, 162, 226, 114, 178, 242, 134, 198, 54, 138, 202, 58, 14, 78, 142, 206, 30, 46, 62, 67, 131, 147, 211, 35, 99, 163, 227, 115, 179, 243, 7, 71, 135, 199, 39, 55, 75, 139, 203, 27, 43, 59, 79, 143, 207, 31, 112, 176, 240, 140, 204, 44, 60, 194, 50, 195, 15, 47, 63, 51, 11);
  var huff_b35_cb = intArrayOf2(1, 12, 1, 0, 0, 0, 4, 6, 6, 14, 42, 63, 59, 30);
  var huff_b35_xlat = intArrayOf2(0, 16, 240, 1, 15, 17, 241, 2, 14, 31, 255, 32, 224, 33, 242, 254, 239, 48, 208, 225, 18, 34, 226, 3, 13, 29, 30, 46, 238, 47, 223, 64, 96, 112, 144, 160, 176, 192, 49, 113, 145, 193, 209, 50, 210, 19, 227, 243, 4, 5, 6, 7, 23, 247, 9, 25, 10, 26, 250, 12, 28, 45, 237, 253, 62, 126, 222, 63, 111, 127, 159, 175, 207, 80, 65, 81, 97, 161, 177, 98, 114, 146, 162, 194, 35, 51, 99, 115, 147, 163, 211, 20, 36, 52, 212, 228, 244, 21, 245, 22, 38, 214, 230, 246, 39, 55, 71, 231, 41, 57, 201, 217, 233, 249, 42, 234, 11, 27, 251, 44, 124, 236, 252, 61, 77, 109, 125, 221, 78, 94, 110, 158, 174, 206, 79, 95, 66, 82, 178, 67, 179, 195, 68, 100, 116, 148, 164, 37, 53, 101, 117, 149, 165, 229, 54, 70, 102, 118, 150, 166, 182, 198, 87, 167, 183, 199, 215, 89, 169, 185, 58, 74, 106, 202, 218, 43, 59, 107, 155, 171, 219, 235, 60, 108, 156, 172, 204, 220, 93, 157, 173, 189, 205, 190, 191, 83, 84, 180, 196, 69, 85, 181, 197, 213, 86, 103, 119, 151, 73, 105, 121, 153, 90, 122, 154, 170, 186, 75, 91, 123, 187, 203, 76, 92, 188);
  var huff_b37_cb = intArrayOf2(1, 11, 1, 0, 2, 0, 2, 2, 6, 17, 14, 13, 6);
  var huff_b37_xlat = intArrayOf2(0, 1, 63, 2, 62, 3, 61, 4, 5, 6, 58, 59, 60, 7, 8, 9, 10, 25, 26, 27, 28, 29, 34, 35, 37, 38, 39, 55, 56, 57, 11, 13, 14, 15, 30, 31, 33, 36, 49, 50, 51, 52, 53, 54, 12, 16, 17, 18, 19, 21, 41, 43, 44, 45, 46, 47, 48, 20, 22, 23, 24, 40, 42);
  var huff_b41_cb = intArrayOf2(1, 12, 1, 0, 0, 1, 7, 0, 20, 4, 10, 24, 2, 12);
  var huff_b41_xlat = intArrayOf2(0, 1, 64, 192, 16, 48, 4, 12, 3, 80, 208, 112, 240, 196, 20, 52, 76, 28, 60, 193, 17, 49, 5, 13, 195, 19, 51, 7, 15, 68, 204, 65, 67, 84, 116, 220, 252, 113, 21, 77, 29, 55, 63, 212, 244, 92, 124, 81, 209, 241, 69, 197, 53, 205, 221, 61, 83, 211, 115, 243, 71, 199, 23, 119, 79, 207, 31, 85, 255, 213, 117, 245, 93, 125, 253, 87, 215, 247, 95, 223, 127);
  var huff_b42_cb = intArrayOf2(1, 9, 1, 0, 1, 3, 2, 3, 7, 4, 4);
  var huff_b42_xlat = intArrayOf2(0, 7, 8, 56, 1, 57, 15, 16, 9, 63, 48, 49, 2, 58, 6, 14, 23, 17, 10, 62, 55, 18, 50, 22, 54);
  var huff_b43_cb = intArrayOf2(2, 9, 1, 1, 3, 4, 9, 15, 12, 4);
  var huff_b43_xlat = intArrayOf2(0, 7, 8, 56, 1, 9, 57, 15, 63, 16, 48, 49, 2, 58, 6, 14, 23, 55, 24, 40, 17, 25, 41, 10, 3, 11, 59, 5, 13, 61, 62, 31, 47, 18, 26, 42, 50, 19, 51, 21, 53, 22, 30, 46, 54, 27, 43, 29, 45);
  var huff_b47_cb = intArrayOf2(2, 9, 1, 1, 3, 4, 6, 14, 22, 12);
  var huff_b47_xlat = intArrayOf2(0, 1, 2, 62, 63, 3, 4, 60, 61, 5, 6, 7, 57, 58, 59, 8, 9, 10, 11, 12, 26, 27, 37, 38, 52, 53, 54, 55, 56, 13, 14, 15, 16, 17, 18, 25, 28, 29, 30, 31, 33, 34, 35, 36, 39, 46, 47, 48, 49, 50, 51, 19, 20, 21, 22, 23, 24, 40, 41, 42, 43, 44, 45);
  var huff_b52_cb = intArrayOf2(1, 9, 1, 0, 1, 3, 2, 3, 7, 4, 4);
  var huff_b52_xlat = intArrayOf2(0, 1, 8, 56, 7, 57, 15, 48, 9, 63, 16, 49, 2, 58, 6, 14, 23, 17, 10, 62, 55, 18, 50, 22, 54);
  var huff_b53_cb = intArrayOf2(1, 5, 1, 1, 1, 0, 4);
  var huff_b53_xlat = intArrayOf2(0, 7, 1, 2, 3, 5, 6);
  var huff_b56_cb = intArrayOf2(1, 9, 1, 0, 2, 0, 2, 4, 11, 9, 2);
  var huff_b56_xlat = intArrayOf2(0, 1, 31, 2, 30, 3, 4, 13, 29, 5, 6, 7, 14, 15, 17, 18, 19, 26, 27, 28, 8, 9, 12, 20, 21, 22, 23, 24, 25, 10, 11);
  var huff_b62_cb = intArrayOf2(1, 12, 1, 0, 0, 2, 3, 5, 12, 14, 18, 15, 9, 2);
  var huff_b62_xlat = intArrayOf2(0, 64, 1, 16, 4, 2, 128, 80, 144, 5, 6, 32, 96, 68, 20, 84, 36, 8, 24, 65, 17, 21, 9, 160, 132, 148, 100, 164, 40, 81, 69, 85, 25, 18, 22, 10, 26, 72, 88, 104, 129, 145, 33, 97, 133, 149, 37, 101, 73, 89, 41, 105, 66, 70, 86, 136, 152, 168, 161, 165, 153, 169, 82, 34, 38, 102, 74, 90, 42, 106, 137, 130, 146, 98, 134, 150, 166, 138, 170, 162, 154);
  var huff_b63_cb = intArrayOf2(1, 5, 1, 1, 1, 0, 4);
  var huff_b63_xlat = intArrayOf2(0, 1, 7, 2, 3, 5, 6);
  var huff_b64_cb = intArrayOf2(1, 5, 1, 1, 1, 1, 2);
  var huff_b64_xlat = intArrayOf2(1, 0, 2, 5, 3, 4);
  var huff_b65_cb = intArrayOf2(1, 12, 1, 0, 0, 2, 2, 2, 6, 12, 34, 92, 54, 20);
  var huff_b65_xlat = intArrayOf2(0, 240, 1, 16, 15, 17, 241, 32, 224, 2, 14, 31, 255, 208, 33, 225, 18, 242, 7, 10, 13, 30, 254, 47, 239, 48, 112, 144, 160, 192, 113, 145, 193, 209, 50, 146, 226, 3, 19, 99, 4, 6, 230, 231, 247, 9, 25, 57, 250, 12, 28, 221, 237, 253, 46, 126, 158, 63, 159, 64, 80, 96, 176, 49, 65, 97, 161, 177, 34, 66, 114, 162, 178, 194, 210, 35, 51, 115, 163, 195, 211, 227, 243, 20, 36, 52, 68, 116, 212, 228, 5, 37, 69, 101, 149, 165, 22, 38, 70, 118, 166, 182, 198, 214, 246, 23, 39, 55, 71, 103, 167, 215, 41, 105, 185, 217, 233, 249, 26, 42, 58, 154, 202, 218, 234, 11, 27, 59, 107, 235, 251, 44, 108, 236, 252, 29, 45, 77, 109, 157, 173, 62, 78, 110, 174, 206, 238, 79, 95, 111, 223, 81, 82, 98, 67, 147, 179, 84, 148, 164, 244, 21, 117, 181, 229, 245, 54, 86, 102, 150, 87, 119, 73, 89, 169, 201, 74, 90, 106, 122, 170, 186, 43, 75, 123, 155, 171, 219, 60, 76, 124, 156, 172, 188, 204, 61, 93, 125, 189, 205, 94, 190, 222, 191, 207, 83, 100, 180, 196, 53, 85, 197, 213, 151, 183, 199, 121, 153, 91, 187, 203, 92, 220, 127, 175);
  var huff_b66_cb = intArrayOf2(1, 12, 1, 0, 0, 3, 0, 3, 3, 10, 40, 85, 61, 50);
  var huff_b66_xlat = intArrayOf2(0, 16, 1, 17, 33, 2, 18, 32, 34, 19, 48, 49, 65, 209, 225, 50, 82, 3, 35, 45, 64, 80, 96, 128, 208, 224, 81, 97, 241, 66, 98, 210, 226, 242, 51, 67, 195, 211, 227, 4, 20, 212, 244, 37, 53, 22, 23, 247, 216, 28, 60, 13, 29, 61, 93, 14, 30, 46, 126, 47, 192, 240, 113, 129, 145, 193, 114, 130, 146, 178, 194, 83, 99, 115, 147, 163, 243, 36, 68, 100, 132, 164, 180, 5, 21, 149, 213, 6, 38, 54, 70, 150, 214, 230, 246, 7, 39, 55, 215, 231, 8, 24, 40, 56, 232, 248, 9, 25, 41, 233, 249, 10, 26, 202, 218, 234, 11, 27, 219, 235, 251, 44, 76, 92, 124, 140, 77, 109, 141, 157, 253, 62, 94, 110, 142, 158, 238, 15, 31, 63, 79, 95, 111, 127, 207, 112, 161, 162, 131, 179, 52, 116, 196, 228, 85, 101, 133, 165, 197, 229, 245, 86, 102, 118, 134, 166, 198, 87, 103, 119, 151, 167, 72, 136, 152, 73, 89, 121, 153, 58, 74, 138, 186, 250, 43, 123, 12, 172, 188, 204, 236, 125, 173, 189, 221, 78, 190, 206, 254, 143, 159, 175, 191, 223, 239, 255, 144, 160, 176, 177, 84, 148, 69, 117, 181, 182, 71, 135, 183, 199, 88, 104, 120, 168, 184, 200, 57, 105, 137, 169, 185, 201, 217, 42, 90, 106, 122, 154, 170, 59, 75, 91, 107, 139, 155, 171, 187, 203, 108, 156, 220, 252, 205, 237, 174, 222);
  var huff_b67_cb = intArrayOf2(2, 9, 1, 2, 1, 4, 7, 10, 26, 12);
  var huff_b67_xlat = intArrayOf2(0, 1, 63, 62, 2, 3, 60, 61, 4, 5, 6, 7, 57, 58, 59, 8, 9, 10, 11, 12, 52, 53, 54, 55, 56, 13, 14, 15, 16, 17, 18, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 46, 47, 48, 49, 50, 51, 19, 20, 21, 22, 23, 24, 40, 41, 42, 43, 44, 45);
  var huff_b71_cb = intArrayOf2(1, 12, 1, 0, 0, 1, 7, 0, 19, 5, 13, 23, 0, 12);
  var huff_b71_xlat = intArrayOf2(0, 3, 64, 192, 16, 48, 4, 12, 1, 80, 208, 112, 240, 196, 20, 52, 76, 28, 60, 193, 17, 49, 5, 13, 19, 51, 7, 15, 68, 204, 65, 67, 195, 84, 116, 220, 252, 241, 197, 21, 29, 83, 199, 55, 79, 63, 212, 244, 92, 124, 81, 209, 113, 69, 85, 53, 77, 205, 221, 61, 211, 115, 243, 71, 23, 119, 207, 31, 255, 213, 117, 245, 93, 125, 253, 87, 215, 247, 95, 223, 127);
  var huff_b73_cb = intArrayOf2(1, 11, 1, 0, 0, 0, 1, 4, 9, 4, 103, 110, 24);
  var huff_b73_xlat = intArrayOf2(0, 64, 16, 4, 1, 5, 80, 20, 84, 65, 17, 81, 69, 21, 85, 68, 149, 106, 3, 128, 192, 144, 208, 148, 212, 36, 100, 88, 145, 161, 133, 213, 37, 101, 165, 229, 117, 181, 245, 25, 89, 153, 217, 105, 169, 233, 121, 185, 249, 77, 93, 157, 221, 109, 173, 237, 125, 189, 253, 2, 66, 82, 6, 70, 22, 86, 150, 214, 38, 102, 166, 230, 118, 182, 246, 26, 90, 154, 218, 170, 234, 122, 186, 250, 94, 158, 222, 110, 174, 238, 126, 190, 254, 7, 71, 87, 151, 215, 103, 167, 231, 119, 183, 247, 91, 155, 219, 107, 171, 235, 123, 187, 251, 95, 159, 223, 111, 175, 239, 127, 191, 255, 32, 96, 112, 176, 240, 132, 196, 164, 228, 116, 180, 244, 8, 136, 24, 152, 216, 104, 168, 232, 120, 184, 248, 28, 92, 156, 220, 108, 172, 236, 60, 124, 188, 252, 129, 209, 33, 97, 225, 113, 177, 241, 197, 53, 9, 73, 137, 201, 41, 57, 13, 141, 205, 29, 45, 61, 146, 210, 34, 98, 162, 226, 114, 178, 242, 134, 198, 54, 10, 74, 138, 202, 42, 58, 14, 78, 142, 206, 30, 46, 62, 19, 83, 147, 211, 99, 163, 227, 115, 179, 243, 135, 199, 23, 39, 55, 11, 75, 139, 203, 27, 43, 59, 15, 79, 143, 207, 31, 47, 63, 160, 224, 48, 52, 72, 200, 40, 56, 12, 76, 140, 204, 44, 193, 49, 130, 194, 18, 50, 67, 131, 195, 35, 51);
  var huff_b74_cb = intArrayOf2(1, 6, 1, 0, 2, 2, 2, 4);
  var huff_b74_xlat = intArrayOf2(0, 1, 15, 2, 14, 5, 13, 3, 4, 11, 12);
  var huff_b75_cb = intArrayOf2(2, 12, 1, 4, 0, 0, 0, 8, 11, 24, 53, 64, 60);
  var huff_b75_xlat = intArrayOf2(0, 16, 240, 1, 15, 32, 224, 17, 241, 2, 14, 31, 255, 208, 33, 225, 18, 242, 3, 13, 30, 254, 47, 239, 48, 64, 96, 112, 144, 160, 192, 49, 209, 34, 226, 19, 243, 4, 6, 7, 9, 12, 29, 253, 46, 238, 63, 223, 80, 176, 65, 97, 113, 145, 161, 193, 50, 98, 114, 146, 162, 210, 35, 211, 227, 20, 244, 5, 22, 38, 230, 246, 23, 39, 231, 247, 25, 41, 249, 10, 26, 42, 250, 11, 28, 44, 252, 45, 61, 237, 62, 78, 126, 158, 222, 79, 111, 127, 159, 175, 207, 81, 177, 66, 82, 178, 194, 51, 99, 115, 147, 163, 179, 195, 36, 52, 116, 164, 212, 228, 21, 37, 101, 149, 229, 245, 54, 214, 55, 71, 199, 215, 57, 89, 185, 201, 217, 233, 58, 106, 218, 234, 27, 43, 155, 171, 235, 251, 108, 124, 156, 172, 236, 77, 109, 125, 157, 173, 189, 221, 94, 110, 174, 206, 95, 67, 83, 68, 84, 100, 148, 180, 196, 53, 69, 85, 117, 165, 181, 197, 213, 70, 86, 102, 118, 150, 166, 182, 198, 87, 103, 119, 151, 167, 183, 73, 105, 121, 153, 169, 74, 90, 122, 154, 170, 186, 202, 59, 75, 91, 107, 123, 187, 203, 219, 60, 76, 92, 188, 204, 220, 93, 205, 190, 191);
  var huff_b77_cb = intArrayOf2(2, 11, 1, 0, 4, 6, 10, 12, 7, 15, 4, 4);
  var huff_b77_xlat = intArrayOf2(0, 1, 2, 62, 63, 3, 4, 5, 59, 60, 61, 6, 7, 8, 9, 10, 54, 55, 56, 57, 58, 11, 12, 13, 14, 15, 16, 47, 49, 50, 51, 52, 53, 17, 18, 19, 20, 45, 46, 48, 21, 22, 23, 24, 25, 26, 27, 37, 38, 39, 40, 41, 42, 43, 44, 28, 29, 30, 35, 31, 33, 34, 36);
  var atrac3p_spectra_tabs = arrayOf3(new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_a01_cb, huff_a01_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a02_cb, huff_a02_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a03_cb, huff_a03_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a04_cb, huff_a04_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a05_cb, huff_a05_xlat), new Atrac3pSpecCodeTab(1, 1, 4, 0, -1, huff_a06_cb, huff_a06_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a07_cb, huff_a07_xlat), new Atrac3pSpecCodeTab(4, 4, 2, 1, -1, huff_a11_cb, huff_a11_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a12_cb, huff_a12_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a13_cb, huff_a13_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a14_cb, huff_a14_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a15_cb, huff_a15_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_a16_cb, huff_a16_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a17_cb, huff_a17_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_a21_cb, huff_a21_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a22_cb, huff_a22_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a23_cb, huff_a23_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a24_cb, null), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a25_cb, huff_a25_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_a26_cb, huff_a26_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a27_cb, huff_a27_xlat), new Atrac3pSpecCodeTab(1, 2, 2, 1, -1, huff_a31_cb, huff_a31_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a32_cb, huff_a32_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a33_cb, huff_a33_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a34_cb, huff_a34_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a35_cb, huff_a35_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_a36_cb, huff_a36_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a37_cb, huff_a37_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_a41_cb, huff_a41_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a42_cb, huff_a42_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 1, -1, huff_a43_cb, huff_a43_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a44_cb, huff_a44_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a45_cb, huff_a45_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_a46_cb, huff_a46_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a47_cb, huff_a47_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_a51_cb, huff_a51_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a52_cb, huff_a52_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 1, -1, huff_a43_cb, huff_a53_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a54_cb, huff_a54_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_a55_cb, huff_a55_xlat), new Atrac3pSpecCodeTab(1, 1, 5, 1, -1, huff_a56_cb, huff_a56_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a57_cb, huff_a57_xlat), new Atrac3pSpecCodeTab(2, 4, 2, 1, -1, huff_a61_cb, huff_a61_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a62_cb, huff_a62_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_a63_cb, huff_a63_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a64_cb, huff_a64_xlat), new Atrac3pSpecCodeTab(1, 1, 4, 1, -1, huff_a65_cb, huff_a65_xlat), new Atrac3pSpecCodeTab(1, 1, 5, 1, -1, huff_a66_cb, huff_a66_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_a67_cb, huff_a67_xlat), new Atrac3pSpecCodeTab(1, 2, 1, 0, -1, huff_a71_cb, null), new Atrac3pSpecCodeTab(2, 4, 2, 0, -1, huff_a72_cb, huff_a72_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_a73_cb, huff_a73_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_a74_cb, huff_a74_xlat), new Atrac3pSpecCodeTab(1, 1, 4, 1, -1, huff_a75_cb, huff_a75_xlat), new Atrac3pSpecCodeTab(2, 2, 4, 0, -1, huff_a76_cb, huff_a76_xlat), new Atrac3pSpecCodeTab(4, 1, 6, 1, 6, null, null), new Atrac3pSpecCodeTab(4, 4, 2, 1, -1, huff_b01_cb, huff_b01_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_b02_cb, huff_b02_xlat), new Atrac3pSpecCodeTab(4, 2, 3, 1, -1, huff_b03_cb, huff_b03_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_b04_cb, huff_b04_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_b05_cb, huff_b05_xlat), new Atrac3pSpecCodeTab(1, 1, 4, 0, 5, null, null), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_b07_cb, huff_b07_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, 14, null, null), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_b12_cb, huff_b12_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, 9, null, null), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_b14_cb, huff_b14_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, 11, null, null), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_b16_cb, huff_b16_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, 6, null, null), new Atrac3pSpecCodeTab(4, 4, 2, 1, 28, null, null), new Atrac3pSpecCodeTab(4, 4, 2, 0, 22, null, null), new Atrac3pSpecCodeTab(1, 2, 3, 1, 2, null, null), new Atrac3pSpecCodeTab(1, 2, 4, 1, 31, null, null), new Atrac3pSpecCodeTab(2, 2, 4, 1, 60, null, null), new Atrac3pSpecCodeTab(2, 2, 4, 0, -1, huff_b26_cb, huff_b26_xlat), new Atrac3pSpecCodeTab(4, 1, 6, 1, 6, null, null), new Atrac3pSpecCodeTab(1, 4, 2, 1, 35, null, null), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_b32_cb, huff_b32_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_b33_cb, huff_b33_xlat), new Atrac3pSpecCodeTab(2, 2, 4, 1, 59, null, null), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_b35_cb, huff_b35_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, 75, null, null), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_b37_cb, huff_b37_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_b41_cb, huff_b41_xlat), new Atrac3pSpecCodeTab(4, 2, 3, 1, -1, huff_b42_cb, huff_b42_xlat), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_b43_cb, huff_b43_xlat), new Atrac3pSpecCodeTab(4, 2, 4, 1, 66, null, null), new Atrac3pSpecCodeTab(1, 1, 3, 0, 32, null, null), new Atrac3pSpecCodeTab(1, 2, 4, 0, 12, null, null), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_b47_cb, huff_b47_xlat), new Atrac3pSpecCodeTab(2, 4, 2, 1, 42, null, null), new Atrac3pSpecCodeTab(1, 2, 3, 1, -1, huff_b52_cb, huff_b52_xlat), new Atrac3pSpecCodeTab(4, 1, 3, 1, -1, huff_b53_cb, huff_b53_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, 17, null, null), new Atrac3pSpecCodeTab(1, 1, 3, 0, 39, null, null), new Atrac3pSpecCodeTab(1, 1, 5, 1, -1, huff_b56_cb, huff_b56_xlat), new Atrac3pSpecCodeTab(2, 1, 6, 1, 62, null, null), new Atrac3pSpecCodeTab(1, 4, 2, 1, 28, null, null), new Atrac3pSpecCodeTab(1, 4, 2, 0, -1, huff_b62_cb, huff_b62_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 1, -1, huff_b63_cb, huff_b63_xlat), new Atrac3pSpecCodeTab(1, 1, 3, 0, -1, huff_b64_cb, huff_b64_xlat), new Atrac3pSpecCodeTab(4, 2, 4, 1, -1, huff_b65_cb, huff_b65_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 0, -1, huff_b66_cb, huff_b66_xlat), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_b67_cb, huff_b67_xlat), new Atrac3pSpecCodeTab(1, 4, 2, 1, -1, huff_b71_cb, huff_b71_xlat), new Atrac3pSpecCodeTab(4, 4, 2, 0, 78, null, null), new Atrac3pSpecCodeTab(4, 4, 2, 0, -1, huff_b73_cb, huff_b73_xlat), new Atrac3pSpecCodeTab(1, 1, 4, 1, -1, huff_b74_cb, huff_b74_xlat), new Atrac3pSpecCodeTab(1, 2, 4, 1, -1, huff_b75_cb, huff_b75_xlat), new Atrac3pSpecCodeTab(1, 1, 5, 1, 47, null, null), new Atrac3pSpecCodeTab(1, 1, 6, 1, -1, huff_b77_cb, huff_b77_xlat));
  var Atrac3plusData1 = class {
  };
  Atrac3plusData1.atrac3p_spectra_tabs = atrac3p_spectra_tabs;

  // src/me/atrac3plus/Atrac3plusData2.ts
  function intArrayOf3(...values) {
    return new Int32Array(values);
  }
  function arrayOf4(...values) {
    return values;
  }
  var Atrac3plusData2 = class {
  };
  Atrac3plusData2.atrac3p_wl_huff_code1 = intArrayOf3(0, 2, 3);
  Atrac3plusData2.atrac3p_wl_huff_bits1 = intArrayOf3(1, 2, 2);
  Atrac3plusData2.atrac3p_wl_huff_xlat1 = intArrayOf3(0, 1, 7);
  Atrac3plusData2.atrac3p_wl_huff_code2 = intArrayOf3(0, 4, 5, 6, 7);
  Atrac3plusData2.atrac3p_wl_huff_bits2 = intArrayOf3(1, 3, 3, 3, 3);
  Atrac3plusData2.atrac3p_wl_huff_xlat2 = intArrayOf3(0, 1, 2, 6, 7);
  Atrac3plusData2.atrac3p_wl_huff_code3 = intArrayOf3(0, 4, 12, 30, 31, 13, 14, 5);
  Atrac3plusData2.atrac3p_wl_huff_bits3 = intArrayOf3(1, 3, 4, 5, 5, 4, 4, 3);
  Atrac3plusData2.atrac3p_wl_huff_code4 = intArrayOf3(0, 4, 12, 13, 30, 31, 14, 5);
  Atrac3plusData2.atrac3p_wl_huff_bits4 = intArrayOf3(1, 3, 4, 4, 5, 5, 4, 3);
  Atrac3plusData2.atrac3p_sf_huff_code1 = intArrayOf3(0, 2, 3, 4, 5, 12, 13, 224, 225, 226, 227, 228, 229, 230, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511);
  Atrac3plusData2.atrac3p_sf_huff_bits1 = intArrayOf3(2, 3, 3, 3, 3, 4, 4, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9);
  Atrac3plusData2.atrac3p_sf_huff_xlat1 = intArrayOf3(0, 1, 61, 62, 63, 2, 60, 3, 4, 5, 6, 57, 58, 59, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56);
  Atrac3plusData2.atrac3p_sf_huff_xlat2 = intArrayOf3(0, 1, 2, 62, 63, 3, 61, 4, 5, 6, 57, 58, 59, 60, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56);
  Atrac3plusData2.atrac3p_sf_huff_code2 = intArrayOf3(0, 4, 24, 25, 112, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 228, 113, 26, 27, 5);
  Atrac3plusData2.atrac3p_sf_huff_bits2 = intArrayOf3(1, 3, 5, 5, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 7, 5, 5, 3);
  Atrac3plusData2.atrac3p_sf_huff_code3 = intArrayOf3(0, 2, 3, 24, 25, 112, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 113, 114, 26, 27, 4, 5);
  Atrac3plusData2.atrac3p_sf_huff_bits3 = intArrayOf3(2, 3, 3, 5, 5, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 5, 5, 3, 3);
  Atrac3plusData2.atrac3p_sf_huff_code4 = intArrayOf3(0, 2, 3, 4, 5, 12, 13, 56, 57, 58, 59, 60, 0, 61, 62, 63);
  Atrac3plusData2.atrac3p_sf_huff_bits4 = intArrayOf3(2, 3, 3, 3, 3, 4, 4, 6, 6, 6, 6, 6, 0, 6, 6, 6);
  Atrac3plusData2.atrac3p_sf_huff_xlat4 = intArrayOf3(0, 1, 13, 14, 15, 2, 12, 3, 4, 5, 6, 7, 8, 9, 10, 11);
  Atrac3plusData2.atrac3p_sf_huff_xlat5 = intArrayOf3(0, 1, 2, 14, 15, 3, 13, 4, 5, 6, 7, 9, 8, 10, 11, 12);
  Atrac3plusData2.atrac3p_sf_huff_code5 = intArrayOf3(0, 4, 12, 28, 120, 121, 122, 123, 0, 124, 125, 126, 127, 29, 13, 5);
  Atrac3plusData2.atrac3p_sf_huff_bits5 = intArrayOf3(1, 3, 4, 5, 7, 7, 7, 7, 0, 7, 7, 7, 7, 5, 4, 3);
  Atrac3plusData2.atrac3p_sf_huff_code6 = intArrayOf3(0, 2, 3, 12, 28, 60, 124, 125, 0, 126, 127, 61, 29, 13, 4, 5);
  Atrac3plusData2.atrac3p_sf_huff_bits6 = intArrayOf3(2, 3, 3, 4, 5, 6, 7, 7, 0, 7, 7, 6, 5, 4, 3, 3);
  Atrac3plusData2.atrac3p_ct_huff_code1 = intArrayOf3(0, 2, 6, 7);
  Atrac3plusData2.atrac3p_ct_huff_bits1 = intArrayOf3(1, 2, 3, 3);
  Atrac3plusData2.atrac3p_ct_huff_code2 = intArrayOf3(0, 2, 3, 4, 5, 6, 14, 15);
  Atrac3plusData2.atrac3p_ct_huff_bits2 = intArrayOf3(2, 3, 3, 3, 3, 3, 4, 4);
  Atrac3plusData2.atrac3p_ct_huff_xlat1 = intArrayOf3(0, 1, 2, 3, 6, 7, 4, 5);
  Atrac3plusData2.atrac3p_ct_huff_code3 = intArrayOf3(0, 4, 10, 11, 12, 13, 14, 15);
  Atrac3plusData2.atrac3p_ct_huff_bits3 = intArrayOf3(1, 3, 4, 4, 4, 4, 4, 4);
  Atrac3plusData2.atrac3p_wl_weights = arrayOf4(intArrayOf3(5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0), intArrayOf3(5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(6, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));
  Atrac3plusData2.atrac3p_sf_weights = arrayOf4(intArrayOf3(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15), intArrayOf3(0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10));
  Atrac3plusData2.atrac3p_qu_num_to_seg = intArrayOf3(0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9);
  Atrac3plusData2.atrac3p_qu_to_subband = intArrayOf3(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
  Atrac3plusData2.atrac3p_subband_to_num_powgrps = intArrayOf3(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5);
  Atrac3plusData2.atrac3p_wl_shapes = arrayOf4(arrayOf4(intArrayOf3(0, 0, 0, 0, 0, 0, 0, -2, -1), intArrayOf3(0, 0, 0, 0, 0, 0, 0, -5, -1), intArrayOf3(0, 0, 0, -7, 0, 0, 0, 0, 0), intArrayOf3(0, 0, 0, 0, 0, -7, 0, 0, 0), intArrayOf3(0, 0, 0, 0, 0, 0, -5, 0, 0), intArrayOf3(0, 0, 0, 0, -5, 0, 0, 0, 0), intArrayOf3(-7, -7, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(0, -7, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(-2, -2, -5, 0, 0, 0, 0, 0, 0), intArrayOf3(0, 0, 0, -2, -5, 0, 0, 0, 0), intArrayOf3(0, 0, 0, 0, 0, -2, -5, 0, 0), intArrayOf3(0, 0, 0, -5, 0, 0, 0, 0, 0), intArrayOf3(0, -2, -7, -2, 0, 0, 0, 0, 0), intArrayOf3(0, 0, 0, 0, -2, -5, 0, 0, 0), intArrayOf3(0, 0, 0, -5, -5, 0, 0, 0, 0), intArrayOf3(0, 0, 0, -5, -2, 0, 0, 0, 0)), arrayOf4(intArrayOf3(-1, -5, -3, -2, -1, -1, 0, 0, 0), intArrayOf3(-2, -5, -3, -3, -2, -1, -1, 0, 0), intArrayOf3(0, -1, -1, -1, 0, 0, 0, 0, 0), intArrayOf3(-1, -3, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(-1, -2, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(-1, -3, -1, 0, 0, 0, 0, 1, 1), intArrayOf3(-1, -5, -3, -3, -2, -1, 0, 0, 0), intArrayOf3(-1, -1, -4, -2, -2, -1, -1, 0, 0), intArrayOf3(-1, -1, -3, -2, -3, -1, -1, -1, 0), intArrayOf3(-1, -4, -2, -3, -1, 0, 0, 0, 0), intArrayOf3(0, -1, -2, -2, -1, -1, 0, 0, 0), intArrayOf3(0, -2, -1, 0, 0, 0, 0, 0, 0), intArrayOf3(-1, -1, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(-1, -1, -3, -2, -2, -1, -1, -1, 0), intArrayOf3(0, 0, 0, 0, 0, 0, 0, 0, 0), intArrayOf3(0, -1, -3, -2, -2, -1, -1, -1, 0)), arrayOf4(intArrayOf3(-1, -2, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -1, 1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -2, 1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -2, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(-1, -1, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(0, 0, -1, 0, 1, 1, 1, 1, 1), intArrayOf3(-1, -1, 1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, 0, -1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -1, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(-1, -1, -1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, 0, 0, 0, 1, 1, 1, 1, 1), intArrayOf3(0, 0, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -1, -1, 1, 1, 1, 1, 1, 1), intArrayOf3(0, 1, 0, 1, 1, 1, 1, 1, 1), intArrayOf3(0, -3, -2, 1, 1, 1, 1, 2, 2), intArrayOf3(-3, -5, -3, 2, 2, 2, 2, 2, 2)), arrayOf4(intArrayOf3(-1, -2, 0, 2, 2, 2, 2, 2, 2), intArrayOf3(-1, -2, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(0, -2, 0, 2, 2, 2, 2, 2, 2), intArrayOf3(-1, 0, 1, 2, 2, 2, 2, 2, 2), intArrayOf3(0, 0, 1, 2, 2, 2, 2, 2, 2), intArrayOf3(0, -2, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(0, -1, 1, 2, 2, 2, 2, 2, 2), intArrayOf3(-1, -1, 0, 2, 2, 2, 2, 2, 2), intArrayOf3(-1, -1, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(-1, -2, -1, 2, 2, 2, 2, 2, 2), intArrayOf3(0, -1, 0, 2, 2, 2, 2, 2, 2), intArrayOf3(1, 1, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(0, 1, 2, 2, 2, 2, 2, 2, 2), intArrayOf3(1, 0, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(0, 0, 0, 1, 2, 2, 2, 2, 2), intArrayOf3(-1, -1, -1, 1, 2, 2, 2, 2, 2)), arrayOf4(intArrayOf3(0, 1, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(1, 1, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(-1, 0, 1, 2, 3, 3, 3, 3, 3), intArrayOf3(0, 0, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(-1, 0, 1, 3, 3, 3, 3, 3, 3), intArrayOf3(0, 0, 1, 3, 3, 3, 3, 3, 3), intArrayOf3(1, 2, 3, 3, 3, 3, 3, 3, 3), intArrayOf3(1, 2, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(0, 1, 1, 3, 3, 3, 3, 3, 3), intArrayOf3(0, 0, 1, 2, 3, 3, 3, 3, 3), intArrayOf3(-1, 1, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(-1, 0, 2, 3, 3, 3, 3, 3, 3), intArrayOf3(2, 2, 3, 3, 3, 3, 3, 3, 3), intArrayOf3(1, 1, 3, 3, 3, 3, 3, 3, 3), intArrayOf3(0, 2, 3, 3, 3, 3, 3, 3, 3), intArrayOf3(0, 1, 1, 2, 3, 3, 3, 3, 3)), arrayOf4(intArrayOf3(0, 1, 2, 3, 4, 4, 4, 4, 4), intArrayOf3(1, 2, 3, 4, 4, 4, 4, 4, 4), intArrayOf3(0, 0, 2, 3, 4, 4, 4, 4, 4), intArrayOf3(1, 1, 2, 4, 4, 4, 4, 4, 4), intArrayOf3(0, 1, 2, 4, 4, 4, 4, 4, 4), intArrayOf3(-1, 0, 1, 3, 4, 4, 4, 4, 4), intArrayOf3(0, 0, 1, 3, 4, 4, 4, 4, 4), intArrayOf3(1, 1, 2, 3, 4, 4, 4, 4, 4), intArrayOf3(0, 1, 1, 3, 4, 4, 4, 4, 4), intArrayOf3(2, 2, 3, 4, 4, 4, 4, 4, 4), intArrayOf3(1, 1, 3, 4, 4, 4, 4, 4, 4), intArrayOf3(1, 2, 2, 4, 4, 4, 4, 4, 4), intArrayOf3(-1, 0, 2, 3, 4, 4, 4, 4, 4), intArrayOf3(0, 1, 3, 4, 4, 4, 4, 4, 4), intArrayOf3(1, 2, 2, 3, 4, 4, 4, 4, 4), intArrayOf3(0, 2, 3, 4, 4, 4, 4, 4, 4)), arrayOf4(intArrayOf3(1, 2, 3, 4, 5, 5, 5, 5, 5), intArrayOf3(0, 1, 2, 3, 4, 5, 5, 5, 5), intArrayOf3(0, 1, 2, 3, 5, 5, 5, 5, 5), intArrayOf3(1, 1, 3, 4, 5, 5, 5, 5, 5), intArrayOf3(1, 1, 2, 4, 5, 5, 5, 5, 5), intArrayOf3(1, 2, 2, 4, 5, 5, 5, 5, 5), intArrayOf3(1, 1, 2, 3, 5, 5, 5, 5, 5), intArrayOf3(2, 2, 3, 4, 5, 5, 5, 5, 5), intArrayOf3(0, 1, 2, 4, 5, 5, 5, 5, 5), intArrayOf3(2, 2, 3, 5, 5, 5, 5, 5, 5), intArrayOf3(1, 2, 3, 5, 5, 5, 5, 5, 5), intArrayOf3(0, 1, 3, 4, 5, 5, 5, 5, 5), intArrayOf3(1, 2, 2, 3, 5, 5, 5, 5, 5), intArrayOf3(2, 3, 4, 5, 5, 5, 5, 5, 5), intArrayOf3(0, 2, 3, 4, 5, 5, 5, 5, 5), intArrayOf3(1, 1, 1, 3, 4, 5, 5, 5, 5)), arrayOf4(intArrayOf3(1, 2, 3, 4, 5, 5, 5, 6, 6), intArrayOf3(1, 2, 3, 4, 5, 6, 6, 6, 6), intArrayOf3(2, 3, 4, 5, 6, 6, 6, 6, 6), intArrayOf3(1, 2, 3, 4, 6, 6, 6, 6, 6), intArrayOf3(2, 2, 3, 4, 5, 5, 5, 6, 6), intArrayOf3(1, 2, 3, 4, 5, 5, 6, 6, 6), intArrayOf3(2, 2, 3, 4, 6, 6, 6, 6, 6), intArrayOf3(2, 2, 3, 4, 5, 6, 6, 6, 6), intArrayOf3(2, 2, 4, 5, 6, 6, 6, 6, 6), intArrayOf3(2, 2, 3, 5, 6, 6, 6, 6, 6), intArrayOf3(1, 2, 3, 5, 6, 6, 6, 6, 6), intArrayOf3(2, 3, 3, 5, 6, 6, 6, 6, 6), intArrayOf3(1, 2, 4, 5, 6, 6, 6, 6, 6), intArrayOf3(2, 2, 3, 4, 5, 5, 6, 6, 6), intArrayOf3(2, 3, 3, 4, 6, 6, 6, 6, 6), intArrayOf3(1, 3, 4, 5, 6, 6, 6, 6, 6)));
  Atrac3plusData2.atrac3p_sf_shapes = arrayOf4(intArrayOf3(-3, -2, -1, 0, 3, 5, 6, 8, 40), intArrayOf3(-3, -2, 0, 1, 7, 9, 11, 13, 20), intArrayOf3(-1, 0, 0, 1, 6, 8, 10, 13, 41), intArrayOf3(0, 0, 0, 2, 5, 5, 6, 8, 14), intArrayOf3(0, 0, 0, 2, 6, 7, 8, 11, 47), intArrayOf3(0, 0, 1, 2, 5, 7, 8, 10, 32), intArrayOf3(0, 0, 1, 3, 8, 10, 12, 14, 47), intArrayOf3(0, 0, 2, 4, 9, 10, 12, 14, 40), intArrayOf3(0, 0, 3, 5, 9, 10, 12, 14, 22), intArrayOf3(0, 1, 3, 5, 10, 14, 18, 22, 31), intArrayOf3(0, 2, 5, 6, 10, 10, 10, 12, 46), intArrayOf3(0, 2, 5, 7, 12, 14, 15, 18, 44), intArrayOf3(1, 1, 4, 5, 7, 7, 8, 9, 15), intArrayOf3(1, 2, 2, 2, 4, 5, 7, 9, 26), intArrayOf3(1, 2, 2, 3, 6, 7, 7, 8, 47), intArrayOf3(1, 2, 2, 3, 6, 8, 10, 13, 22), intArrayOf3(1, 3, 4, 7, 13, 17, 21, 24, 41), intArrayOf3(1, 4, 0, 4, 10, 12, 13, 14, 17), intArrayOf3(2, 3, 3, 3, 6, 8, 10, 13, 48), intArrayOf3(2, 3, 3, 4, 9, 12, 14, 17, 47), intArrayOf3(2, 3, 3, 5, 10, 12, 14, 17, 25), intArrayOf3(2, 3, 5, 7, 8, 9, 9, 9, 13), intArrayOf3(2, 3, 5, 9, 16, 21, 25, 28, 33), intArrayOf3(2, 4, 5, 8, 12, 14, 17, 19, 26), intArrayOf3(2, 4, 6, 8, 12, 13, 13, 15, 20), intArrayOf3(2, 4, 7, 12, 20, 26, 30, 32, 35), intArrayOf3(3, 3, 5, 6, 12, 14, 16, 19, 34), intArrayOf3(3, 4, 4, 5, 7, 9, 10, 11, 48), intArrayOf3(3, 4, 5, 6, 8, 9, 10, 11, 16), intArrayOf3(3, 5, 5, 5, 7, 9, 10, 13, 35), intArrayOf3(3, 5, 5, 7, 10, 12, 13, 15, 49), intArrayOf3(3, 5, 7, 7, 8, 7, 9, 12, 21), intArrayOf3(3, 5, 7, 8, 12, 14, 15, 15, 24), intArrayOf3(3, 5, 7, 10, 16, 21, 24, 27, 44), intArrayOf3(3, 5, 8, 14, 21, 26, 28, 29, 42), intArrayOf3(3, 6, 10, 13, 18, 19, 20, 22, 27), intArrayOf3(3, 6, 11, 16, 24, 27, 28, 29, 31), intArrayOf3(4, 5, 4, 3, 4, 6, 8, 11, 18), intArrayOf3(4, 6, 5, 6, 9, 10, 12, 14, 20), intArrayOf3(4, 6, 7, 6, 6, 6, 7, 8, 46), intArrayOf3(4, 6, 7, 9, 13, 16, 18, 20, 48), intArrayOf3(4, 6, 7, 9, 14, 17, 20, 23, 31), intArrayOf3(4, 6, 9, 11, 14, 15, 15, 17, 21), intArrayOf3(4, 8, 13, 20, 27, 32, 35, 36, 38), intArrayOf3(5, 6, 6, 4, 5, 6, 7, 6, 6), intArrayOf3(5, 7, 7, 8, 9, 9, 10, 12, 49), intArrayOf3(5, 8, 9, 9, 10, 11, 12, 13, 42), intArrayOf3(5, 8, 10, 12, 15, 16, 17, 19, 42), intArrayOf3(5, 8, 12, 17, 26, 31, 32, 33, 44), intArrayOf3(5, 9, 13, 16, 20, 22, 23, 23, 35), intArrayOf3(6, 8, 8, 7, 6, 5, 6, 8, 15), intArrayOf3(6, 8, 8, 8, 9, 10, 12, 16, 24), intArrayOf3(6, 8, 8, 9, 10, 10, 11, 11, 13), intArrayOf3(6, 8, 10, 13, 19, 21, 24, 26, 32), intArrayOf3(6, 9, 10, 11, 13, 13, 14, 16, 49), intArrayOf3(7, 9, 9, 10, 13, 14, 16, 19, 27), intArrayOf3(7, 10, 12, 13, 16, 16, 17, 17, 27), intArrayOf3(7, 10, 12, 14, 17, 19, 20, 22, 48), intArrayOf3(8, 9, 10, 9, 10, 11, 11, 11, 19), intArrayOf3(8, 11, 12, 12, 13, 13, 13, 13, 17), intArrayOf3(8, 11, 13, 14, 16, 17, 19, 20, 27), intArrayOf3(8, 12, 17, 22, 26, 28, 29, 30, 33), intArrayOf3(10, 14, 16, 19, 21, 22, 22, 24, 28), intArrayOf3(10, 15, 17, 18, 21, 22, 23, 25, 43));
  Atrac3plusData2.atrac3p_ct_restricted_to_full = arrayOf4(arrayOf4(intArrayOf3(0, 5, 4, 1), intArrayOf3(0, 1, 2, 3), intArrayOf3(3, 0, 4, 2), intArrayOf3(4, 0, 1, 2), intArrayOf3(1, 0, 4, 3), intArrayOf3(3, 0, 2, 1), intArrayOf3(0, 3, 1, 2)), arrayOf4(intArrayOf3(4, 0, 1, 2), intArrayOf3(0, 3, 2, 1), intArrayOf3(0, 1, 2, 3), intArrayOf3(0, 1, 2, 4), intArrayOf3(0, 1, 2, 3), intArrayOf3(1, 4, 2, 0), intArrayOf3(0, 1, 2, 3)));
  Atrac3plusData2.atrac3p_huff_gain_npoints1_cb = intArrayOf3(1, 7, 1, 1, 1, 1, 1, 1, 2);
  Atrac3plusData2.atrac3p_huff_gain_npoints2_xlat = intArrayOf3(0, 1, 7, 2, 6, 3, 4, 5);
  Atrac3plusData2.atrac3p_huff_gain_lev1_cb = intArrayOf3(1, 7, 1, 0, 2, 2, 1, 2, 8);
  Atrac3plusData2.atrac3p_huff_gain_lev1_xlat = intArrayOf3(7, 5, 8, 6, 9, 4, 10, 11, 0, 1, 2, 3, 12, 13, 14, 15);
  Atrac3plusData2.atrac3p_huff_gain_lev2_cb = intArrayOf3(1, 9, 1, 1, 1, 1, 1, 0, 2, 0, 8);
  Atrac3plusData2.atrac3p_huff_gain_lev2_xlat = intArrayOf3(15, 14, 1, 13, 2, 3, 12, 4, 5, 6, 7, 8, 9, 10, 11);
  Atrac3plusData2.atrac3p_huff_gain_lev3_cb = intArrayOf3(1, 9, 1, 0, 3, 1, 1, 0, 2, 0, 8);
  Atrac3plusData2.atrac3p_huff_gain_lev3_xlat = intArrayOf3(0, 1, 14, 15, 2, 13, 3, 12, 4, 5, 6, 7, 8, 9, 10, 11);
  Atrac3plusData2.atrac3p_huff_gain_lev4_cb = intArrayOf3(1, 9, 1, 1, 1, 1, 1, 0, 1, 2, 8);
  Atrac3plusData2.atrac3p_huff_gain_lev4_xlat = intArrayOf3(0, 1, 15, 14, 2, 13, 3, 12, 4, 5, 6, 7, 8, 9, 10, 11);
  Atrac3plusData2.atrac3p_huff_gain_loc1_cb = intArrayOf3(2, 8, 1, 2, 4, 4, 4, 0, 16);
  Atrac3plusData2.atrac3p_huff_gain_loc1_xlat = intArrayOf3(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);
  Atrac3plusData2.atrac3p_huff_gain_loc2_cb = intArrayOf3(3, 8, 5, 3, 2, 3, 2, 16);
  Atrac3plusData2.atrac3p_huff_gain_loc2_xlat = intArrayOf3(2, 3, 4, 5, 6, 1, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);
  Atrac3plusData2.atrac3p_huff_gain_loc3_cb = intArrayOf3(2, 6, 1, 0, 2, 11, 18);
  Atrac3plusData2.atrac3p_huff_gain_loc3_xlat = intArrayOf3(0, 1, 31, 2, 3, 4, 5, 6, 7, 26, 27, 28, 29, 30, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);
  Atrac3plusData2.atrac3p_huff_gain_loc4_cb = intArrayOf3(4, 6, 3, 23, 6);
  Atrac3plusData2.atrac3p_huff_gain_loc4_xlat = intArrayOf3(0, 28, 29, 1, 2, 3, 4, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 5, 6, 7, 8, 9, 10);
  Atrac3plusData2.atrac3p_huff_gain_loc5_cb = intArrayOf3(1, 7, 1, 0, 0, 3, 2, 6, 20);
  Atrac3plusData2.atrac3p_huff_gain_loc5_xlat = intArrayOf3(0, 1, 2, 31, 3, 4, 5, 6, 7, 8, 29, 30, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28);
  Atrac3plusData2.atrac3p_huff_tonebands_cb = intArrayOf3(1, 6, 1, 0, 1, 2, 4, 8);
  Atrac3plusData2.atrac3p_huff_numwavs1_cb = intArrayOf3(1, 7, 1, 1, 1, 1, 1, 1, 2);
  Atrac3plusData2.atrac3p_huff_numwavs2_cb = intArrayOf3(1, 6, 1, 1, 1, 1, 0, 4);
  Atrac3plusData2.atrac3p_huff_numwavs2_xlat = intArrayOf3(0, 1, 7, 2, 3, 4, 5, 6);
  Atrac3plusData2.atrac3p_huff_wav_ampsf1_cb = intArrayOf3(4, 8, 10, 8, 6, 0, 8);
  Atrac3plusData2.atrac3p_huff_wav_ampsf1_xlat = intArrayOf3(8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 18, 19, 20, 21, 22, 4, 23, 24, 25, 26, 27, 0, 1, 2, 3, 28, 29, 30, 31);
  Atrac3plusData2.atrac3p_huff_wav_ampsf2_cb = intArrayOf3(4, 8, 11, 5, 6, 6, 4);
  Atrac3plusData2.atrac3p_huff_wav_ampsf2_xlat = intArrayOf3(18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 14, 15, 16, 17, 29, 9, 10, 11, 12, 13, 30, 4, 5, 6, 7, 8, 31, 0, 1, 2, 3);
  Atrac3plusData2.atrac3p_huff_wav_ampsf3_cb = intArrayOf3(2, 8, 1, 3, 3, 1, 4, 4, 16);
  Atrac3plusData2.atrac3p_huff_wav_ampsf3_xlat = intArrayOf3(0, 1, 2, 31, 3, 29, 30, 4, 5, 6, 27, 28, 7, 24, 25, 26, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23);
  Atrac3plusData2.atrac3p_huff_freq_cb = intArrayOf3(1, 11, 1, 0, 0, 2, 2, 0, 9, 9, 29, 104, 100);
  Atrac3plusData2.atrac3p_huff_freq_xlat = intArrayOf3(0, 1, 255, 2, 254, 3, 4, 5, 6, 7, 8, 251, 252, 253, 9, 10, 11, 12, 246, 247, 248, 249, 250, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 243, 244, 245, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193);

  // src/me/atrac3plus/ChannelUnit.ts
  function intArrayOf4(...values) {
    return new Int32Array(values);
  }
  function arrayOf5(...values) {
    return values;
  }
  var log3 = logger.named("Atrac3plus.ChannelUnit");
  var _ChannelUnit = class {
    constructor() {
      this.ctx = new ChannelUnitContext();
      this.dsp = void 0;
      this.numChannels = 0;
    }
    get numCtValues() {
      if (!this.br.readBool()) {
        return this.ctx.usedQuantUnits;
      }
      const numCodedVals = this.br.read(5);
      if (numCodedVals > this.ctx.usedQuantUnits) {
        log3.error("Invalid number of code table indexes: %d".format(numCodedVals));
        return Atrac3plusConstants.AT3P_ERROR;
      }
      return numCodedVals;
    }
    setBitReader(br) {
      this.br = br;
    }
    setDsp(dsp) {
      this.dsp = dsp;
    }
    setNumChannels(numChannels) {
      this.numChannels = numChannels;
    }
    decode() {
      let ret;
      this.ctx.numQuantUnits = this.br.read(5) + 1;
      if (this.ctx.numQuantUnits > 28 && this.ctx.numQuantUnits < 32) {
        log3.error("Invalid number of quantization units: %d".format(this.ctx.numQuantUnits));
        return Atrac3plusConstants.AT3P_ERROR;
      }
      this.ctx.muteFlag = this.br.readBool();
      ret = this.decodeQuantWordlen();
      if (ret < 0) {
        return ret;
      }
      this.ctx.numSubbands = Atrac3plusData2.atrac3p_qu_to_subband[this.ctx.numQuantUnits - 1] + 1;
      this.ctx.numCodedSubbands = this.ctx.usedQuantUnits > 0 ? Atrac3plusData2.atrac3p_qu_to_subband[this.ctx.usedQuantUnits - 1] + 1 : 0;
      ret = this.decodeScaleFactors();
      if (ret < 0) {
        return ret;
      }
      ret = this.decodeCodeTableIndexes();
      if (ret < 0) {
        return ret;
      }
      this.decodeSpectrum();
      if (this.numChannels == 2) {
        this.getSubbandFlags(this.ctx.swapChannels, this.ctx.numCodedSubbands);
        this.getSubbandFlags(this.ctx.negateCoeffs, this.ctx.numCodedSubbands);
      }
      this.decodeWindowShape();
      ret = this.decodeGaincData();
      if (ret < 0) {
        return ret;
      }
      ret = this.decodeTonesInfo();
      if (ret < 0) {
        return ret;
      }
      this.ctx.noisePresent = this.br.readBool();
      if (this.ctx.noisePresent) {
        this.ctx.noiseLevelIndex = this.br.read(4);
        this.ctx.noiseTableIndex = this.br.read(4);
      }
      return 0;
    }
    numCodedUnits(chan) {
      chan.fillMode = this.br.read(2);
      if (chan.fillMode == 0) {
        chan.numCodedVals = this.ctx.numQuantUnits;
      } else {
        chan.numCodedVals = this.br.read(5);
        if (chan.numCodedVals > this.ctx.numQuantUnits) {
          log3.error("Invalid number of transmitted units");
          return Atrac3plusConstants.AT3P_ERROR;
        }
        if (chan.fillMode == 3) {
          chan.splitPoint = this.br.read(2) + (chan.chNum << 1) + 1;
        }
      }
      return 0;
    }
    getDelta(deltaBits) {
      return deltaBits <= 0 ? 0 : this.br.read(deltaBits);
    }
    unpackVqShape(startVal, shapeVec, dst, numValues) {
      if (numValues > 0) {
        dst[0] = startVal;
        dst[1] = startVal;
        dst[2] = startVal;
        for (let i = 3; i < numValues; i++) {
          dst[i] = startVal - shapeVec[Atrac3plusData2.atrac3p_qu_num_to_seg[i] - 1];
        }
      }
    }
    unpackSfVqShape(dst, numValues) {
      const startVal = this.br.read(6);
      this.unpackVqShape(startVal, Atrac3plusData2.atrac3p_sf_shapes[this.br.read(6)], dst, numValues);
    }
    addWordlenWeights(chan, weightIdx) {
      const weigthsTab = Atrac3plusData2.atrac3p_wl_weights[chan.chNum * 3 + weightIdx - 1];
      for (let i = 0; i < this.ctx.numQuantUnits; i++) {
        chan.quWordlen[i] += weigthsTab[i];
        if (chan.quWordlen[i] < 0 || chan.quWordlen[i] > 7) {
          log3.error("WL index out of range pos=%d, val=%d".format(i, chan.quWordlen[i]));
          return Atrac3plusConstants.AT3P_ERROR;
        }
      }
      return 0;
    }
    decodeChannelWordlen(chNum) {
      let ret;
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      let weightIdx = 0;
      chan.fillMode = 0;
      switch (this.br.read(2)) {
        case 0: {
          for (let i = 0; i < this.ctx.numQuantUnits; i++) {
            chan.quWordlen[i] = this.br.read(3);
          }
          break;
        }
        case 1: {
          if (chNum > 0) {
            ret = this.numCodedUnits(chan);
            if (ret < 0) {
              return ret;
            }
            if (chan.numCodedVals > 0) {
              const vlcTab = _ChannelUnit.wl_vlc_tabs[this.br.read(2)];
              for (let i = 0; i < chan.numCodedVals; i++) {
                const delta = vlcTab.getVLC2(this.br);
                chan.quWordlen[i] = refChan.quWordlen[i] + delta & 7;
              }
            }
          } else {
            weightIdx = this.br.read(2);
            ret = this.numCodedUnits(chan);
            if (ret < 0) {
              return ret;
            }
            if (chan.numCodedVals > 0) {
              const pos = this.br.read(5);
              if (pos > chan.numCodedVals) {
                log3.error("WL mode 1: invalid position %d".format(pos));
                return Atrac3plusConstants.AT3P_ERROR;
              }
              const deltaBits = this.br.read(2);
              const minVal = this.br.read(3);
              for (let i = 0; i < pos; i++) {
                chan.quWordlen[i] = this.br.read(3);
              }
              for (let i = pos; i < chan.numCodedVals; i++) {
                chan.quWordlen[i] = minVal + this.getDelta(deltaBits) & 7;
              }
            }
          }
          break;
        }
        case 2: {
          ret = this.numCodedUnits(chan);
          if (ret < 0) {
            return ret;
          }
          if (chNum > 0 && chan.numCodedVals > 0) {
            const vlcTab = _ChannelUnit.wl_vlc_tabs[this.br.read(2)];
            let delta = vlcTab.getVLC2(this.br);
            chan.quWordlen[0] = refChan.quWordlen[0] + delta & 7;
            for (let i = 1; i < chan.numCodedVals; i++) {
              const diff = refChan.quWordlen[i] - refChan.quWordlen[i - 1];
              delta = vlcTab.getVLC2(this.br);
              chan.quWordlen[i] = chan.quWordlen[i - 1] + diff + delta & 7;
            }
          } else if (chan.numCodedVals > 0) {
            const flag = this.br.readBool();
            const vlcTab = _ChannelUnit.wl_vlc_tabs[this.br.read(1)];
            const startVal = this.br.read(3);
            this.unpackVqShape(startVal, Atrac3plusData2.atrac3p_wl_shapes[startVal][this.br.read(4)], chan.quWordlen, chan.numCodedVals);
            if (!flag) {
              for (let i = 0; i < chan.numCodedVals; i++) {
                const delta = vlcTab.getVLC2(this.br);
                chan.quWordlen[i] = chan.quWordlen[i] + delta & 7;
              }
            } else {
              let i;
              i = 0;
              while (i < (chan.numCodedVals & -2)) {
                if (!this.br.readBool()) {
                  chan.quWordlen[i] = chan.quWordlen[i] + vlcTab.getVLC2(this.br) & 7;
                  chan.quWordlen[i + 1] = chan.quWordlen[i + 1] + vlcTab.getVLC2(this.br) & 7;
                }
                i += 2;
              }
              if ((chan.numCodedVals & 1) != 0) {
                chan.quWordlen[i] = chan.quWordlen[i] + vlcTab.getVLC2(this.br) & 7;
              }
            }
          }
          break;
        }
        case 3: {
          weightIdx = this.br.read(2);
          ret = this.numCodedUnits(chan);
          if (ret < 0) {
            return ret;
          }
          if (chan.numCodedVals > 0) {
            const vlcTab = _ChannelUnit.wl_vlc_tabs[this.br.read(2)];
            chan.quWordlen[0] = this.br.read(3);
            for (let i = 1; i < chan.numCodedVals; i++) {
              const delta = vlcTab.getVLC2(this.br);
              chan.quWordlen[i] = chan.quWordlen[i - 1] + delta & 7;
            }
          }
          break;
        }
      }
      if (chan.fillMode == 2) {
        for (let i = chan.numCodedVals; i < this.ctx.numQuantUnits; i++) {
          chan.quWordlen[i] = chNum > 0 ? this.br.read1() : 1;
        }
      } else if (chan.fillMode == 3) {
        const pos = chNum > 0 ? chan.numCodedVals + chan.splitPoint : this.ctx.numQuantUnits - chan.splitPoint;
        for (let i = chan.numCodedVals; i < pos; i++) {
          chan.quWordlen[i] = 1;
        }
      }
      return weightIdx != 0 ? this.addWordlenWeights(chan, weightIdx) : 0;
    }
    substractSfWeights(chan, wtabIdx) {
      const weigthsTab = Atrac3plusData2.atrac3p_sf_weights[wtabIdx - 1];
      for (let i = 0; i < this.ctx.usedQuantUnits; i++) {
        chan.quSfIdx[i] -= weigthsTab[i];
        if (chan.quSfIdx[i] < 0 || chan.quSfIdx[i] > 63) {
          log3.error("SF index out of range pos=%d, val=%d".format(i, chan.quSfIdx[i]));
          return Atrac3plusConstants.AT3P_ERROR;
        }
      }
      return 0;
    }
    decodeChannelSfIdx(chNum) {
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      let weightIdx = 0;
      chan.fillMode = 0;
      switch (this.br.read(2)) {
        case 0: {
          for (let i = 0; i < this.ctx.usedQuantUnits; i++) {
            chan.quSfIdx[i] = this.br.read(6);
          }
          break;
        }
        case 1: {
          if (chNum > 0) {
            const vlcTab = _ChannelUnit.sf_vlc_tabs[this.br.read(2)];
            for (let i = 0; i < this.ctx.usedQuantUnits; i++) {
              const delta = vlcTab.getVLC2(this.br);
              chan.quSfIdx[i] = refChan.quSfIdx[i] + delta & 63;
            }
          } else {
            weightIdx = this.br.read(2);
            if (weightIdx == 3) {
              this.unpackSfVqShape(chan.quSfIdx, this.ctx.usedQuantUnits);
              const numLongVals = this.br.read(5);
              const deltaBits = this.br.read(2);
              const minVal = this.br.read(4) - 7;
              for (let i = 0; i < numLongVals; i++) {
                chan.quSfIdx[i] = chan.quSfIdx[i] + this.br.read(4) - 7 & 63;
              }
              for (let i = numLongVals; i < this.ctx.usedQuantUnits; i++) {
                chan.quSfIdx[i] = chan.quSfIdx[i] + minVal + this.getDelta(deltaBits) & 63;
              }
            } else {
              const numLongVals = this.br.read(5);
              const deltaBits = this.br.read(3);
              const minVal = this.br.read(6);
              if (numLongVals > this.ctx.usedQuantUnits || deltaBits == 7) {
                log3.error("SF mode 1: invalid parameters".format());
                return Atrac3plusConstants.AT3P_ERROR;
              }
              for (let i = 0; i < numLongVals; i++) {
                chan.quSfIdx[i] = this.br.read(6);
              }
              for (let i = numLongVals; i < this.ctx.usedQuantUnits; i++) {
                chan.quSfIdx[i] = minVal + this.getDelta(deltaBits) & 63;
              }
            }
          }
          break;
        }
        case 2: {
          if (chNum > 0) {
            const vlcTab = _ChannelUnit.sf_vlc_tabs[this.br.read(2)];
            let delta = vlcTab.getVLC2(this.br);
            chan.quSfIdx[0] = refChan.quSfIdx[0] + delta & 63;
            for (let i = 1; i < this.ctx.usedQuantUnits; i++) {
              const diff = refChan.quSfIdx[i] - refChan.quSfIdx[i - 1];
              delta = vlcTab.getVLC2(this.br);
              chan.quSfIdx[i] = chan.quSfIdx[i - 1] + diff + delta & 63;
            }
          } else if (chan.numCodedVals > 0) {
            const vlcTab = _ChannelUnit.sf_vlc_tabs[this.br.read(2) + 4];
            this.unpackSfVqShape(chan.quSfIdx, this.ctx.usedQuantUnits);
            for (let i = 0; i < this.ctx.usedQuantUnits; i++) {
              const delta = vlcTab.getVLC2(this.br);
              chan.quSfIdx[i] = chan.quSfIdx[i] + BitUtils.signExtend(delta, 4) & 63;
            }
          }
          break;
        }
        case 3: {
          if (chNum > 0) {
            for (let i = 0; i < this.ctx.usedQuantUnits; i++) {
              chan.quSfIdx[i] = refChan.quSfIdx[i];
            }
          } else {
            weightIdx = this.br.read(2);
            const vlcSel = this.br.read(2);
            let vlcTab = _ChannelUnit.sf_vlc_tabs[vlcSel];
            if (weightIdx == 3) {
              vlcTab = _ChannelUnit.sf_vlc_tabs[vlcSel + 4];
              this.unpackSfVqShape(chan.quSfIdx, this.ctx.usedQuantUnits);
              let diff = this.br.read(4) + 56 & 63;
              chan.quSfIdx[0] = chan.quSfIdx[0] + diff & 63;
              for (let i = 1; i < this.ctx.usedQuantUnits; i++) {
                const delta = vlcTab.getVLC2(this.br);
                diff = diff + BitUtils.signExtend(delta, 4) & 63;
                chan.quSfIdx[i] = diff + chan.quSfIdx[i] & 63;
              }
            } else {
              chan.quSfIdx[0] = this.br.read(6);
              for (let i = 1; i < this.ctx.usedQuantUnits; i++) {
                const delta = vlcTab.getVLC2(this.br);
                chan.quSfIdx[i] = chan.quSfIdx[i - 1] + delta & 63;
              }
            }
          }
          break;
        }
      }
      return weightIdx != 0 && weightIdx < 3 ? this.substractSfWeights(chan, weightIdx) : 0;
    }
    decodeQuantWordlen() {
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        this.ctx.channels[chNum].quWordlen.fill(0);
        const ret = this.decodeChannelWordlen(chNum);
        if (ret < 0) {
          return ret;
        }
      }
      let i;
      i = this.ctx.numQuantUnits - 1;
      while (i >= 0) {
        if (this.ctx.channels[0].quWordlen[i] != 0 || this.numChannels == 2 && this.ctx.channels[1].quWordlen[i] != 0) {
          break;
        }
        i--;
      }
      this.ctx.usedQuantUnits = i + 1;
      return 0;
    }
    decodeScaleFactors() {
      if (this.ctx.usedQuantUnits == 0) {
        return 0;
      }
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        this.ctx.channels[chNum].quSfIdx.fill(0);
        const ret = this.decodeChannelSfIdx(chNum);
        if (ret < 0) {
          return ret;
        }
      }
      return 0;
    }
    decodeChannelCodeTab(chNum) {
      let vlcTab;
      let numVals;
      const mask = this.ctx.useFullTable ? 7 : 3;
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      chan.tableType = this.br.read(1);
      switch (this.br.read(2)) {
        case 0: {
          const numBits = this.ctx.useFullTable ? 3 : 2;
          numVals = this.numCtValues;
          if (numVals < 0) {
            return numVals;
          }
          for (let i = 0; i < numVals; i++) {
            if (chan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = this.br.read(numBits);
            } else if (chNum > 0 && refChan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = this.br.read1();
            }
          }
          break;
        }
        case 1: {
          vlcTab = this.ctx.useFullTable ? _ChannelUnit.ct_vlc_tabs[1] : _ChannelUnit.ct_vlc_tabs[0];
          numVals = this.numCtValues;
          if (numVals < 0) {
            return numVals;
          }
          for (let i = 0; i < numVals; i++) {
            if (chan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = vlcTab.getVLC2(this.br);
            } else if (chNum > 0 && refChan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = this.br.read1();
            }
          }
          break;
        }
        case 2: {
          let deltaVlc;
          if (this.ctx.useFullTable) {
            vlcTab = _ChannelUnit.ct_vlc_tabs[1];
            deltaVlc = _ChannelUnit.ct_vlc_tabs[2];
          } else {
            vlcTab = _ChannelUnit.ct_vlc_tabs[0];
            deltaVlc = _ChannelUnit.ct_vlc_tabs[0];
          }
          let pred = 0;
          numVals = this.numCtValues;
          if (numVals < 0) {
            return numVals;
          }
          for (let i = 0; i < numVals; i++) {
            if (chan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = i == 0 ? vlcTab.getVLC2(this.br) : pred + deltaVlc.getVLC2(this.br) & mask;
              pred = chan.quTabIdx[i];
            } else if (chNum > 0 && refChan.quWordlen[i] != 0) {
              chan.quTabIdx[i] = this.br.read1();
            }
          }
          break;
        }
        case 3: {
          if (chNum > 0) {
            vlcTab = this.ctx.useFullTable ? _ChannelUnit.ct_vlc_tabs[3] : _ChannelUnit.ct_vlc_tabs[0];
            numVals = this.numCtValues;
            if (numVals < 0) {
              return numVals;
            }
            for (let i = 0; i < numVals; i++) {
              if (chan.quWordlen[i] != 0) {
                chan.quTabIdx[i] = refChan.quTabIdx[i] + vlcTab.getVLC2(this.br) & mask;
              } else if (chNum > 0 && refChan.quWordlen[i] != 0) {
                chan.quTabIdx[i] = this.br.read1();
              }
            }
          }
          break;
        }
      }
      return 0;
    }
    decodeCodeTableIndexes() {
      if (this.ctx.usedQuantUnits == 0) {
        return 0;
      }
      this.ctx.useFullTable = this.br.readBool();
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        this.ctx.channels[chNum].quTabIdx.fill(0);
        const ret = this.decodeChannelCodeTab(chNum);
        if (ret < 0) {
          return ret;
        }
      }
      return 0;
    }
    decodeQuSpectra(tab, vlcTab, out, outOffset, numSpecs) {
      const groupSize = tab.groupSize;
      const numCoeffs = tab.numCoeffs;
      const bits = tab.bits;
      const isSigned = tab.isSigned;
      const mask = (1 << bits) - 1;
      let pos = 0;
      while (pos < numSpecs) {
        if (groupSize == 1 || this.br.readBool()) {
          for (let j = 0; j < groupSize; j++) {
            let _val = vlcTab.getVLC2(this.br);
            for (let i = 0; i < numCoeffs; i++) {
              let cf = _val & mask;
              if (isSigned) {
                cf = BitUtils.signExtend(cf, bits);
              } else if (cf != 0 && this.br.readBool()) {
                cf = -cf;
              }
              out[outOffset + pos] = cf;
              pos++;
              _val = _val >> bits;
            }
          }
        } else {
          pos += groupSize * numCoeffs;
        }
      }
    }
    decodeSpectrum() {
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        const chan = this.ctx.channels[chNum];
        chan.spectrum.fill(0);
        chan.powerLevs.fill(Atrac3plusConstants.ATRAC3P_POWER_COMP_OFF);
        for (let qu = 0; qu < this.ctx.usedQuantUnits; qu++) {
          const numSpecs = Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu + 1] - Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
          const wordlen = chan.quWordlen[qu];
          let codetab = chan.quTabIdx[qu];
          if (wordlen > 0) {
            if (!this.ctx.useFullTable) {
              codetab = Atrac3plusData2.atrac3p_ct_restricted_to_full[chan.tableType][wordlen - 1][codetab];
            }
            let tabIndex = (chan.tableType * 8 + codetab) * 7 + wordlen - 1;
            const tab = Atrac3plusData1.atrac3p_spectra_tabs[tabIndex];
            if (tab.redirect >= 0) {
              tabIndex = tab.redirect;
            }
            this.decodeQuSpectra(tab, _ChannelUnit.spec_vlc_tabs[tabIndex], chan.spectrum, Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu], numSpecs);
          } else if (chNum > 0 && this.ctx.channels[0].quWordlen[qu] != 0 && codetab == 0) {
            MemoryUtils.arraycopyI(this.ctx.channels[0].spectrum, Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu], chan.spectrum, Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu], numSpecs);
            chan.quWordlen[qu] = this.ctx.channels[0].quWordlen[qu];
          }
        }
        if (this.ctx.usedQuantUnits > 2) {
          const numSpecs = Atrac3plusData2.atrac3p_subband_to_num_powgrps[this.ctx.numCodedSubbands - 1];
          for (let i = 0; i < numSpecs; i++) {
            chan.powerLevs[i] = this.br.read(4);
          }
        }
      }
    }
    getSubbandFlags(out, numFlags) {
      const result = this.br.readBool();
      if (result) {
        if (this.br.readBool()) {
          for (let i = 0; i < numFlags; i++) {
            out[i] = this.br.readBool();
          }
        } else {
          for (let i = 0; i < numFlags; i++) {
            out[i] = true;
          }
        }
      } else {
        for (let i = 0; i < numFlags; i++) {
          out[i] = false;
        }
      }
      return result;
    }
    decodeWindowShape() {
      for (let i = 0; i < this.numChannels; i++) {
        this.getSubbandFlags(this.ctx.channels[i].wndShape, this.ctx.numSubbands);
      }
    }
    decodeGaincNPoints(chNum, codedSubbands) {
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      switch (this.br.read(2)) {
        case 0: {
          for (let i = 0; i < codedSubbands; i++) {
            chan.gainData[i].numPoints = this.br.read(3);
          }
          break;
        }
        case 1: {
          for (let i = 0; i < codedSubbands; i++) {
            chan.gainData[i].numPoints = _ChannelUnit.gain_vlc_tabs[0].getVLC2(this.br);
          }
          break;
        }
        case 2: {
          if (chNum > 0) {
            for (let i = 0; i < codedSubbands; i++) {
              const delta = _ChannelUnit.gain_vlc_tabs[1].getVLC2(this.br);
              chan.gainData[i].numPoints = refChan.gainData[i].numPoints + delta & 7;
            }
          } else {
            chan.gainData[0].numPoints = _ChannelUnit.gain_vlc_tabs[0].getVLC2(this.br);
            for (let i = 1; i < codedSubbands; i++) {
              const delta = _ChannelUnit.gain_vlc_tabs[1].getVLC2(this.br);
              chan.gainData[i].numPoints = chan.gainData[i - 1].numPoints + delta & 7;
            }
          }
          break;
        }
        case 3: {
          if (chNum > 0) {
            for (let i = 0; i < codedSubbands; i++) {
              chan.gainData[i].numPoints = refChan.gainData[i].numPoints;
            }
          } else {
            const deltaBits = this.br.read(2);
            const minVal = this.br.read(3);
            for (let i = 0; i < codedSubbands; i++) {
              chan.gainData[i].numPoints = minVal + this.getDelta(deltaBits);
              if (chan.gainData[i].numPoints > 7) {
                return Atrac3plusConstants.AT3P_ERROR;
              }
            }
          }
          break;
        }
      }
      return 0;
    }
    gaincLevelMode1m(dst) {
      if (dst.numPoints > 0) {
        dst.levCode[0] = _ChannelUnit.gain_vlc_tabs[2].getVLC2(this.br);
      }
      for (let i = 1; i < dst.numPoints; i++) {
        const delta = _ChannelUnit.gain_vlc_tabs[3].getVLC2(this.br);
        dst.levCode[i] = dst.levCode[i - 1] + delta & 15;
      }
    }
    gaincLevelMode3s(dst, ref) {
      for (let i = 0; i < dst.numPoints; i++) {
        dst.levCode[i] = i >= ref.numPoints ? 7 : ref.levCode[i];
      }
    }
    decodeGaincLevels(chNum, codedSubbands) {
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      switch (this.br.read(2)) {
        case 0: {
          for (let sb = 0; sb < codedSubbands; sb++) {
            for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
              chan.gainData[sb].levCode[i] = this.br.read(4);
            }
          }
          break;
        }
        case 1: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                const delta = _ChannelUnit.gain_vlc_tabs[5].getVLC2(this.br);
                const pred = i >= refChan.gainData[sb].numPoints ? 7 : refChan.gainData[sb].levCode[i];
                chan.gainData[sb].levCode[i] = pred + delta & 15;
              }
            }
          } else {
            for (let sb = 0; sb < codedSubbands; sb++) {
              this.gaincLevelMode1m(chan.gainData[sb]);
            }
          }
          break;
        }
        case 2: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              if (chan.gainData[sb].numPoints > 0) {
                if (this.br.readBool()) {
                  this.gaincLevelMode1m(chan.gainData[sb]);
                } else {
                  this.gaincLevelMode3s(chan.gainData[sb], refChan.gainData[sb]);
                }
              }
            }
          } else {
            if (chan.gainData[0].numPoints > 0) {
              this.gaincLevelMode1m(chan.gainData[0]);
            }
            for (let sb = 1; sb < codedSubbands; sb++) {
              for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                const delta = _ChannelUnit.gain_vlc_tabs[4].getVLC2(this.br);
                const pred = i >= chan.gainData[sb - 1].numPoints ? 7 : chan.gainData[sb - 1].levCode[i];
                chan.gainData[sb].levCode[i] = pred + delta & 15;
              }
            }
          }
          break;
        }
        case 3: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              this.gaincLevelMode3s(chan.gainData[sb], refChan.gainData[sb]);
            }
          } else {
            const deltaBits = this.br.read(2);
            const minVal = this.br.read(4);
            for (let sb = 0; sb < codedSubbands; sb++) {
              for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                chan.gainData[sb].levCode[i] = minVal + this.getDelta(deltaBits);
                if (chan.gainData[sb].levCode[i] > 15) {
                  return Atrac3plusConstants.AT3P_ERROR;
                }
              }
            }
          }
          break;
        }
      }
      return 0;
    }
    gaincLocMode0(dst, pos) {
      if (pos == 0 || dst.locCode[pos - 1] < 15) {
        dst.locCode[pos] = this.br.read(5);
      } else if (dst.locCode[pos - 1] >= 30) {
        dst.locCode[pos] = 31;
      } else {
        const deltaBits = CodecUtils.avLog2(30 - dst.locCode[pos - 1]) + 1;
        dst.locCode[pos] = dst.locCode[pos - 1] + this.br.read(deltaBits) + 1;
      }
    }
    gaincLocMode1(dst) {
      if (dst.numPoints > 0) {
        dst.locCode[0] = this.br.read(5);
        for (let i = 1; i < dst.numPoints; i++) {
          const tab = dst.levCode[i] <= dst.levCode[i - 1] ? _ChannelUnit.gain_vlc_tabs[7] : _ChannelUnit.gain_vlc_tabs[9];
          dst.locCode[i] = dst.locCode[i - 1] + tab.getVLC2(this.br);
        }
      }
    }
    decodeGaincLocCodes(chNum, codedSubbands) {
      const chan = this.ctx.channels[chNum];
      const refChan = this.ctx.channels[0];
      const codingMode = this.br.read(2);
      switch (codingMode) {
        case 0: {
          for (let sb = 0; sb < codedSubbands; sb++) {
            for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
              this.gaincLocMode0(chan.gainData[sb], i);
            }
          }
          break;
        }
        case 1: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              if (chan.gainData[sb].numPoints <= 0) {
                continue;
              }
              const dst = chan.gainData[sb];
              const ref = refChan.gainData[sb];
              let delta = _ChannelUnit.gain_vlc_tabs[10].getVLC2(this.br);
              const pred = ref.numPoints > 0 ? ref.locCode[0] : 0;
              dst.locCode[0] = pred + delta & 31;
              for (let i = 1; i < dst.numPoints; i++) {
                const moreThanRef = i >= ref.numPoints;
                if (dst.levCode[i] > dst.levCode[i - 1]) {
                  if (moreThanRef) {
                    delta = _ChannelUnit.gain_vlc_tabs[9].getVLC2(this.br);
                    dst.locCode[i] = dst.locCode[i - 1] + delta;
                  } else {
                    if (this.br.readBool()) {
                      this.gaincLocMode0(dst, i);
                    } else {
                      dst.locCode[i] = ref.locCode[i];
                    }
                  }
                } else {
                  const tab = moreThanRef ? _ChannelUnit.gain_vlc_tabs[7] : _ChannelUnit.gain_vlc_tabs[10];
                  delta = tab.getVLC2(this.br);
                  if (moreThanRef) {
                    dst.locCode[i] = dst.locCode[i - 1] + delta;
                  } else {
                    dst.locCode[i] = ref.locCode[i] + delta & 31;
                  }
                }
              }
            }
          } else {
            for (let sb = 0; sb < codedSubbands; sb++) {
              this.gaincLocMode1(chan.gainData[sb]);
            }
          }
          break;
        }
        case 2: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              if (chan.gainData[sb].numPoints <= 0) {
                continue;
              }
              const dst = chan.gainData[sb];
              const ref = refChan.gainData[sb];
              if (dst.numPoints > ref.numPoints || this.br.readBool()) {
                this.gaincLocMode1(dst);
              } else {
                for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                  dst.locCode[i] = ref.locCode[i];
                }
              }
            }
          } else {
            for (let i = 0; i < chan.gainData[0].numPoints; i++) {
              this.gaincLocMode0(chan.gainData[0], i);
            }
            for (let sb = 1; sb < codedSubbands; sb++) {
              if (chan.gainData[sb].numPoints <= 0) {
                continue;
              }
              const dst = chan.gainData[sb];
              let delta = _ChannelUnit.gain_vlc_tabs[6].getVLC2(this.br);
              const pred = chan.gainData[sb - 1].numPoints > 0 ? chan.gainData[sb - 1].locCode[0] : 0;
              dst.locCode[0] = pred + delta & 31;
              for (let i = 1; i < dst.numPoints; i++) {
                const moreThanRef = i >= chan.gainData[sb - 1].numPoints;
                const tab = _ChannelUnit.gain_vlc_tabs[(dst.levCode[i] > dst.levCode[i - 1] ? 2 : 0) + (moreThanRef ? 1 : 0) + 6];
                delta = tab.getVLC2(this.br);
                if (moreThanRef) {
                  dst.locCode[i] = dst.locCode[i - 1] + delta;
                } else {
                  dst.locCode[i] = chan.gainData[sb - 1].locCode[i] + delta & 31;
                }
              }
            }
          }
          break;
        }
        case 3: {
          if (chNum > 0) {
            for (let sb = 0; sb < codedSubbands; sb++) {
              for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                if (i >= refChan.gainData[sb].numPoints) {
                  this.gaincLocMode0(chan.gainData[sb], i);
                } else {
                  chan.gainData[sb].locCode[i] = refChan.gainData[sb].locCode[i];
                }
              }
            }
          } else {
            const deltaBits = this.br.read(2) + 1;
            const minVal = this.br.read(5);
            for (let sb = 0; sb < codedSubbands; sb++) {
              for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
                chan.gainData[sb].locCode[i] = minVal + i + this.br.read(deltaBits);
              }
            }
          }
          break;
        }
      }
      for (let sb = 0; sb < codedSubbands; sb++) {
        const dst = chan.gainData[sb];
        for (let i = 0; i < chan.gainData[sb].numPoints; i++) {
          if (dst.locCode[i] < 0 || dst.locCode[i] > 31 || i > 0 && dst.locCode[i] <= dst.locCode[i - 1]) {
            log3.error("Invalid gain location: ch=%d, sb=%d, pos=%d, val=%d".format(chNum, sb, i, dst.locCode[i]));
            return Atrac3plusConstants.AT3P_ERROR;
          }
        }
      }
      return 0;
    }
    decodeGaincData() {
      let ret;
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        for (let i = 0; i < Atrac3plusConstants.ATRAC3P_SUBBANDS; i++) {
          this.ctx.channels[chNum].gainData[i].clear();
        }
        if (this.br.readBool()) {
          const codedSubbands = this.br.read(4) + 1;
          if (this.br.readBool()) {
            this.ctx.channels[chNum].numGainSubbands = this.br.read(4) + 1;
          } else {
            this.ctx.channels[chNum].numGainSubbands = codedSubbands;
          }
          ret = this.decodeGaincNPoints(chNum, codedSubbands);
          if (ret < 0) {
            return ret;
          }
          ret = this.decodeGaincLevels(chNum, codedSubbands);
          if (ret < 0) {
            return ret;
          }
          ret = this.decodeGaincLocCodes(chNum, codedSubbands);
          if (ret < 0) {
            return ret;
          }
          if (codedSubbands > 0) {
            const max = this.ctx.channels[chNum].numGainSubbands;
            for (let sb = codedSubbands; sb < max; sb++) {
              this.ctx.channels[chNum].gainData[sb].copy(this.ctx.channels[chNum].gainData[sb - 1]);
            }
          }
        } else {
          this.ctx.channels[chNum].numGainSubbands = 0;
        }
      }
      return 0;
    }
    decodeTonesEnvelope(chNum, bandHasTones) {
      const dst = this.ctx.channels[chNum].tonesInfo;
      const ref = this.ctx.channels[0].tonesInfo;
      if (chNum == 0 || !this.br.readBool()) {
        for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
          if (!bandHasTones[sb]) {
            continue;
          }
          dst[sb].pendEnv.hasStartPoint = this.br.readBool();
          dst[sb].pendEnv.startPos = dst[sb].pendEnv.hasStartPoint ? this.br.read(5) : -1;
          dst[sb].pendEnv.hasStopPoint = this.br.readBool();
          dst[sb].pendEnv.stopPos = dst[sb].pendEnv.hasStopPoint ? this.br.read(5) : 32;
        }
      } else {
        for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
          if (!bandHasTones[sb]) {
            continue;
          }
          dst[sb].pendEnv.copy(ref[sb].pendEnv);
        }
      }
    }
    decodeBandNumwavs(chNum, bandHasTones) {
      const dst = this.ctx.channels[chNum].tonesInfo;
      const ref = this.ctx.channels[0].tonesInfo;
      const mode = this.br.read(chNum + 1);
      switch (mode) {
        case 0: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (bandHasTones[sb]) {
              dst[sb].numWavs = this.br.read(4);
            }
          }
          break;
        }
        case 1: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (bandHasTones[sb]) {
              dst[sb].numWavs = _ChannelUnit.tone_vlc_tabs[1].getVLC2(this.br);
            }
          }
          break;
        }
        case 2: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (bandHasTones[sb]) {
              let delta = _ChannelUnit.tone_vlc_tabs[2].getVLC2(this.br);
              delta = BitUtils.signExtend(delta, 3);
              dst[sb].numWavs = ref[sb].numWavs + delta & 15;
            }
          }
          break;
        }
        case 3: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (bandHasTones[sb]) {
              dst[sb].numWavs = ref[sb].numWavs;
            }
          }
          break;
        }
      }
      for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
        if (bandHasTones[sb]) {
          if (this.ctx.wavesInfo.tonesIndex + dst[sb].numWavs > 48) {
            log3.error("Too many tones: %d (max. 48)".format(this.ctx.wavesInfo.tonesIndex + dst[sb].numWavs));
            return Atrac3plusConstants.AT3P_ERROR;
          }
          dst[sb].startIndex = this.ctx.wavesInfo.tonesIndex;
          this.ctx.wavesInfo.tonesIndex += dst[sb].numWavs;
        }
      }
      return 0;
    }
    decodeTonesFrequency(chNum, bandHasTones) {
      const dst = this.ctx.channels[chNum].tonesInfo;
      const ref = this.ctx.channels[0].tonesInfo;
      if (chNum == 0 || !this.br.readBool()) {
        for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
          if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
            continue;
          }
          const iwav = dst[sb].startIndex;
          const direction = dst[sb].numWavs > 1 ? this.br.readBool() : false;
          if (direction) {
            if (dst[sb].numWavs > 0) {
              this.ctx.wavesInfo.waves[iwav + dst[sb].numWavs - 1].freqIndex = this.br.read(10);
            }
            for (let i = dst[sb].numWavs - 2; i >= 0; i--) {
              const nbits = CodecUtils.avLog2(this.ctx.wavesInfo.waves[iwav + i + 1].freqIndex) + 1;
              this.ctx.wavesInfo.waves[iwav + i].freqIndex = this.br.read(nbits);
            }
          } else {
            for (let i = 0; i < dst[sb].numWavs; i++) {
              if (i == 0 || this.ctx.wavesInfo.waves[iwav + i - 1].freqIndex < 512) {
                this.ctx.wavesInfo.waves[iwav + i].freqIndex = this.br.read(10);
              } else {
                const nbits = CodecUtils.avLog2(1023 - this.ctx.wavesInfo.waves[iwav + i - 1].freqIndex) + 1;
                this.ctx.wavesInfo.waves[iwav + i].freqIndex = this.br.read(nbits) + 1024 - (1 << nbits);
              }
            }
          }
        }
      } else {
        for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
          if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
            continue;
          }
          const iwav = ref[sb].startIndex;
          const owav = dst[sb].startIndex;
          for (let i = 0; i < dst[sb].numWavs; i++) {
            let delta = _ChannelUnit.tone_vlc_tabs[6].getVLC2(this.br);
            delta = BitUtils.signExtend(delta, 8);
            const pred = i < ref[sb].numWavs ? this.ctx.wavesInfo.waves[iwav + i].freqIndex : ref[sb].numWavs > 0 ? this.ctx.wavesInfo.waves[iwav + ref[sb].numWavs - 1].freqIndex : 0;
            this.ctx.wavesInfo.waves[owav + i].freqIndex = pred + delta & 1023;
          }
        }
      }
    }
    decodeTonesAmplitude(chNum, bandHasTones) {
      const dst = this.ctx.channels[chNum].tonesInfo;
      const ref = this.ctx.channels[0].tonesInfo;
      const refwaves = new Int32Array(48);
      if (chNum > 0) {
        for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
          if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
            continue;
          }
          const wsrc = dst[sb].startIndex;
          const wref = ref[sb].startIndex;
          for (let j = 0; j < dst[sb].numWavs; j++) {
            let fi = 0;
            let maxdiff = 1024;
            for (let i = 0; i < ref[sb].numWavs; i++) {
              const diff = Math.abs(this.ctx.wavesInfo.waves[wsrc + j].freqIndex - this.ctx.wavesInfo.waves[wref + i].freqIndex);
              if (diff < maxdiff) {
                maxdiff = diff;
                fi = i;
              }
            }
            if (maxdiff < 8) {
              refwaves[dst[sb].startIndex + j] = fi + ref[sb].startIndex;
            } else if (j < ref[sb].numWavs) {
              refwaves[dst[sb].startIndex + j] = j + ref[sb].startIndex;
            } else {
              refwaves[dst[sb].startIndex + j] = -1;
            }
          }
        }
      }
      const mode = this.br.read(chNum + 1);
      switch (mode) {
        case 0: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
              continue;
            }
            if (this.ctx.wavesInfo.amplitudeMode != 0) {
              for (let i = 0; i < dst[sb].numWavs; i++) {
                this.ctx.wavesInfo.waves[dst[sb].startIndex + i].ampSf = this.br.read(6);
              }
            } else {
              this.ctx.wavesInfo.waves[dst[sb].startIndex].ampSf = this.br.read(6);
            }
          }
          break;
        }
        case 1: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
              continue;
            }
            if (this.ctx.wavesInfo.amplitudeMode != 0) {
              for (let i = 0; i < dst[sb].numWavs; i++) {
                this.ctx.wavesInfo.waves[dst[sb].startIndex + i].ampSf = _ChannelUnit.tone_vlc_tabs[3].getVLC2(this.br) + 20;
              }
            } else {
              this.ctx.wavesInfo.waves[dst[sb].startIndex].ampSf = _ChannelUnit.tone_vlc_tabs[4].getVLC2(this.br) + 24;
            }
          }
          break;
        }
        case 2: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (!bandHasTones[sb] || dst[sb].numWavs == 0) {
              continue;
            }
            for (let i = 0; i < dst[sb].numWavs; i++) {
              let delta = _ChannelUnit.tone_vlc_tabs[5].getVLC2(this.br);
              delta = BitUtils.signExtend(delta, 5);
              const pred = refwaves[dst[sb].startIndex + i] >= 0 ? this.ctx.wavesInfo.waves[refwaves[dst[sb].startIndex + i]].ampSf : 34;
              this.ctx.wavesInfo.waves[dst[sb].startIndex + i].ampSf = pred + delta & 63;
            }
          }
          break;
        }
        case 3: {
          for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
            if (!bandHasTones[sb]) {
              continue;
            }
            for (let i = 0; i < dst[sb].numWavs; i++) {
              this.ctx.wavesInfo.waves[dst[sb].startIndex + i].ampSf = refwaves[dst[sb].startIndex + i] >= 0 ? this.ctx.wavesInfo.waves[refwaves[dst[sb].startIndex + i]].ampSf : 32;
            }
          }
          break;
        }
      }
    }
    decodeTonesPhase(chNum, bandHasTones) {
      const dst = this.ctx.channels[chNum].tonesInfo;
      for (let sb = 0; sb < this.ctx.wavesInfo.numToneBands; sb++) {
        if (!bandHasTones[sb]) {
          continue;
        }
        const wparam = dst[sb].startIndex;
        for (let i = 0; i < dst[sb].numWavs; i++) {
          this.ctx.wavesInfo.waves[wparam + i].phaseIndex = this.br.read(5);
        }
      }
    }
    decodeTonesInfo() {
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        for (let i = 0; i < Atrac3plusConstants.ATRAC3P_SUBBANDS; i++) {
          this.ctx.channels[chNum].tonesInfo[i].clear();
        }
      }
      this.ctx.wavesInfo.tonesPresent = this.br.readBool();
      if (!this.ctx.wavesInfo.tonesPresent) {
        return 0;
      }
      for (let i = 0; i < this.ctx.wavesInfo.waves.length; i++) {
        this.ctx.wavesInfo.waves[i].clear();
      }
      this.ctx.wavesInfo.amplitudeMode = this.br.read1();
      if (this.ctx.wavesInfo.amplitudeMode == 0) {
        log3.error("GHA amplitude mode 0");
        return Atrac3plusConstants.AT3P_ERROR;
      }
      this.ctx.wavesInfo.numToneBands = _ChannelUnit.tone_vlc_tabs[0].getVLC2(this.br) + 1;
      if (this.numChannels == 2) {
        this.getSubbandFlags(this.ctx.wavesInfo.toneSharing, this.ctx.wavesInfo.numToneBands);
        this.getSubbandFlags(this.ctx.wavesInfo.toneMaster, this.ctx.wavesInfo.numToneBands);
        if (this.getSubbandFlags(this.ctx.wavesInfo.phaseShift, this.ctx.wavesInfo.numToneBands)) {
          log3.warn("GHA Phase shifting");
        }
      }
      this.ctx.wavesInfo.tonesIndex = 0;
      for (let chNum = 0; chNum < this.numChannels; chNum++) {
        const bandHasTones = ArrayUtils.create(16, (_) => false);
        for (let i = 0; i < this.ctx.wavesInfo.numToneBands; i++) {
          bandHasTones[i] = chNum == 0 ? true : !this.ctx.wavesInfo.toneSharing[i];
        }
        this.decodeTonesEnvelope(chNum, bandHasTones);
        const ret = this.decodeBandNumwavs(chNum, bandHasTones);
        if (ret < 0) {
          return ret;
        }
        this.decodeTonesFrequency(chNum, bandHasTones);
        this.decodeTonesAmplitude(chNum, bandHasTones);
        this.decodeTonesPhase(chNum, bandHasTones);
      }
      if (this.numChannels == 2) {
        for (let i = 0; i < this.ctx.wavesInfo.numToneBands; i++) {
          if (this.ctx.wavesInfo.toneSharing[i]) {
            this.ctx.channels[1].tonesInfo[i].copy(this.ctx.channels[0].tonesInfo[i]);
          }
          if (this.ctx.wavesInfo.toneMaster[i]) {
            const tmp = new WavesData();
            tmp.copy(this.ctx.channels[0].tonesInfo[i]);
            this.ctx.channels[0].tonesInfo[i].copy(this.ctx.channels[1].tonesInfo[i]);
            this.ctx.channels[1].tonesInfo[i].copy(tmp);
          }
        }
      }
      return 0;
    }
    decodeResidualSpectrum(out) {
      const sbRNGindex = new Int32Array(Atrac3plusConstants.ATRAC3P_SUBBANDS);
      if (this.ctx.muteFlag) {
        for (let ch = 0; ch < this.numChannels; ch++) {
          out[ch].fill(0);
        }
        return;
      }
      let RNGindex = 0;
      for (let qu = 0; qu < this.ctx.usedQuantUnits; qu++) {
        RNGindex += this.ctx.channels[0].quSfIdx[qu] + this.ctx.channels[1].quSfIdx[qu];
      }
      {
        let sb = 0;
        while (sb < this.ctx.numCodedSubbands) {
          sbRNGindex[sb] = RNGindex & 1020;
          sb++;
          RNGindex += 128;
        }
      }
      for (let ch = 0; ch < this.numChannels; ch++) {
        out[ch].fill(0, 0, Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES);
        for (let qu = 0; qu < this.ctx.usedQuantUnits; qu++) {
          const src = Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
          const dst = Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
          const nspeclines = Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu + 1] - Atrac3plusDsp.ff_atrac3p_qu_to_spec_pos[qu];
          if (this.ctx.channels[ch].quWordlen[qu] > 0) {
            const q = Atrac3plusDsp.ff_atrac3p_sf_tab[this.ctx.channels[ch].quSfIdx[qu]] * Atrac3plusDsp.ff_atrac3p_mant_tab[this.ctx.channels[ch].quWordlen[qu]];
            for (let i = 0; i < nspeclines; i++) {
              out[ch][dst + i] = this.ctx.channels[ch].spectrum[src + i] * q;
            }
          }
        }
        for (let sb = 0; sb < this.ctx.numCodedSubbands; sb++) {
          this.dsp.powerCompensation(this.ctx, ch, out[ch], sbRNGindex[sb], sb);
        }
      }
      if (this.ctx.unitType == Atrac3plusConstants.CH_UNIT_STEREO) {
        const tmp = new Float32Array(Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
        for (let sb = 0; sb < this.ctx.numCodedSubbands; sb++) {
          if (this.ctx.swapChannels[sb]) {
            MemoryUtils.arraycopyF(out[0], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, tmp, 0, Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
            MemoryUtils.arraycopyF(out[1], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, out[0], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
            MemoryUtils.arraycopyF(tmp, 0, out[1], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
          }
          if (this.ctx.negateCoeffs[sb]) {
            for (let i = 0; i < Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES; i++) {
              out[1][sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES + i] = -out[1][sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES + i];
            }
          }
        }
      }
    }
    reconstructFrame(at3pContext) {
      for (let ch = 0; ch < this.numChannels; ch++) {
        for (let sb = 0; sb < this.ctx.numSubbands; sb++) {
          this.dsp.imdct(at3pContext.mdctCtx, at3pContext.samples[ch], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, at3pContext.mdctBuf[ch], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, (this.ctx.channels[ch].wndShapePrev[sb] ? 2 : 0) + (this.ctx.channels[ch].wndShape[sb] ? 1 : 0), sb);
          at3pContext.gaincCtx.gainCompensation(at3pContext.mdctBuf[ch], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, this.ctx.prevBuf[ch], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, this.ctx.channels[ch].gainDataPrev[sb], this.ctx.channels[ch].gainData[sb], Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, at3pContext.timeBuf[ch], sb * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES);
        }
        this.ctx.prevBuf[ch].fill(0, this.ctx.numSubbands * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, this.ctx.prevBuf[ch].length);
        at3pContext.timeBuf[ch].fill(0, this.ctx.numSubbands * Atrac3plusConstants.ATRAC3P_SUBBAND_SAMPLES, at3pContext.timeBuf[ch].length);
        if (this.ctx.wavesInfo.tonesPresent || this.ctx.wavesInfoPrev.tonesPresent) {
          for (let sb = 0; sb < this.ctx.numSubbands; sb++) {
            if (this.ctx.channels[ch].tonesInfo[sb].numWavs > 0 || this.ctx.channels[ch].tonesInfoPrev[sb].numWavs > 0) {
              this.dsp.generateTones(this.ctx, ch, sb, at3pContext.timeBuf[ch], sb * 128);
            }
          }
        }
        this.dsp.ipqf(at3pContext.ipqfDctCtx, this.ctx.ipqfCtx[ch], at3pContext.timeBuf[ch], at3pContext.outpBuf[ch]);
      }
      for (let ch = 0; ch < this.numChannels; ch++) {
        const tmp1 = this.ctx.channels[ch].wndShape;
        this.ctx.channels[ch].wndShape = this.ctx.channels[ch].wndShapePrev;
        this.ctx.channels[ch].wndShapePrev = tmp1;
        const tmp2 = this.ctx.channels[ch].gainData;
        this.ctx.channels[ch].gainData = this.ctx.channels[ch].gainDataPrev;
        this.ctx.channels[ch].gainDataPrev = tmp2;
        const tmp3 = this.ctx.channels[ch].tonesInfo;
        this.ctx.channels[ch].tonesInfo = this.ctx.channels[ch].tonesInfoPrev;
        this.ctx.channels[ch].tonesInfoPrev = tmp3;
      }
      const tmp = this.ctx.wavesInfo;
      this.ctx.wavesInfo = this.ctx.wavesInfoPrev;
      this.ctx.wavesInfoPrev = tmp;
    }
    static buildCanonicalHuff(cb, xlat, vlc) {
      const codes = new Int32Array(256);
      const bits = new Int32Array(256);
      let cbIndex = 0;
      let index = 0;
      let code = 0;
      const minLen = cb[cbIndex++];
      const maxLen = cb[cbIndex++];
      for (let b = minLen; b <= maxLen; b++) {
        for (let i = cb[cbIndex++]; i >= 1; i--) {
          bits[index] = b;
          codes[index] = code++;
          index++;
        }
        code = code << 1;
      }
      return vlc.initVLCSparse(maxLen, index, bits, codes, xlat);
    }
  };
  var ChannelUnit = _ChannelUnit;
  ChannelUnit.gain_cbs = arrayOf5(Atrac3plusData2.atrac3p_huff_gain_npoints1_cb, Atrac3plusData2.atrac3p_huff_gain_npoints1_cb, Atrac3plusData2.atrac3p_huff_gain_lev1_cb, Atrac3plusData2.atrac3p_huff_gain_lev2_cb, Atrac3plusData2.atrac3p_huff_gain_lev3_cb, Atrac3plusData2.atrac3p_huff_gain_lev4_cb, Atrac3plusData2.atrac3p_huff_gain_loc3_cb, Atrac3plusData2.atrac3p_huff_gain_loc1_cb, Atrac3plusData2.atrac3p_huff_gain_loc4_cb, Atrac3plusData2.atrac3p_huff_gain_loc2_cb, Atrac3plusData2.atrac3p_huff_gain_loc5_cb);
  ChannelUnit.gain_xlats = arrayOf5(null, Atrac3plusData2.atrac3p_huff_gain_npoints2_xlat, Atrac3plusData2.atrac3p_huff_gain_lev1_xlat, Atrac3plusData2.atrac3p_huff_gain_lev2_xlat, Atrac3plusData2.atrac3p_huff_gain_lev3_xlat, Atrac3plusData2.atrac3p_huff_gain_lev4_xlat, Atrac3plusData2.atrac3p_huff_gain_loc3_xlat, Atrac3plusData2.atrac3p_huff_gain_loc1_xlat, Atrac3plusData2.atrac3p_huff_gain_loc4_xlat, Atrac3plusData2.atrac3p_huff_gain_loc2_xlat, Atrac3plusData2.atrac3p_huff_gain_loc5_xlat);
  ChannelUnit.gain_vlc_tabs = ArrayUtils.create(11, (i) => {
    const vlc = new VLC();
    _ChannelUnit.buildCanonicalHuff(_ChannelUnit.gain_cbs[i], _ChannelUnit.gain_xlats[i], vlc);
    return vlc;
  });
  ChannelUnit.tone_cbs = arrayOf5(Atrac3plusData2.atrac3p_huff_tonebands_cb, Atrac3plusData2.atrac3p_huff_numwavs1_cb, Atrac3plusData2.atrac3p_huff_numwavs2_cb, Atrac3plusData2.atrac3p_huff_wav_ampsf1_cb, Atrac3plusData2.atrac3p_huff_wav_ampsf2_cb, Atrac3plusData2.atrac3p_huff_wav_ampsf3_cb, Atrac3plusData2.atrac3p_huff_freq_cb);
  ChannelUnit.tone_xlats = arrayOf5(null, null, Atrac3plusData2.atrac3p_huff_numwavs2_xlat, Atrac3plusData2.atrac3p_huff_wav_ampsf1_xlat, Atrac3plusData2.atrac3p_huff_wav_ampsf2_xlat, Atrac3plusData2.atrac3p_huff_wav_ampsf3_xlat, Atrac3plusData2.atrac3p_huff_freq_xlat);
  ChannelUnit.tone_vlc_tabs = ArrayUtils.create(7, (i) => {
    const vlc = new VLC();
    _ChannelUnit.buildCanonicalHuff(_ChannelUnit.tone_cbs[i], _ChannelUnit.tone_xlats[i], vlc);
    return vlc;
  });
  ChannelUnit.wl_nb_bits = intArrayOf4(2, 3, 5, 5);
  ChannelUnit.wl_nb_codes = intArrayOf4(3, 5, 8, 8);
  ChannelUnit.wl_bits = arrayOf5(Atrac3plusData2.atrac3p_wl_huff_bits1, Atrac3plusData2.atrac3p_wl_huff_bits2, Atrac3plusData2.atrac3p_wl_huff_bits3, Atrac3plusData2.atrac3p_wl_huff_bits4);
  ChannelUnit.wl_codes = arrayOf5(Atrac3plusData2.atrac3p_wl_huff_code1, Atrac3plusData2.atrac3p_wl_huff_code2, Atrac3plusData2.atrac3p_wl_huff_code3, Atrac3plusData2.atrac3p_wl_huff_code4);
  ChannelUnit.wl_xlats = arrayOf5(Atrac3plusData2.atrac3p_wl_huff_xlat1, Atrac3plusData2.atrac3p_wl_huff_xlat2, null, null);
  ChannelUnit.ct_nb_bits = intArrayOf4(3, 4, 4, 4);
  ChannelUnit.ct_nb_codes = intArrayOf4(4, 8, 8, 8);
  ChannelUnit.ct_bits = arrayOf5(Atrac3plusData2.atrac3p_ct_huff_bits1, Atrac3plusData2.atrac3p_ct_huff_bits2, Atrac3plusData2.atrac3p_ct_huff_bits2, Atrac3plusData2.atrac3p_ct_huff_bits3);
  ChannelUnit.ct_codes = arrayOf5(Atrac3plusData2.atrac3p_ct_huff_code1, Atrac3plusData2.atrac3p_ct_huff_code2, Atrac3plusData2.atrac3p_ct_huff_code2, Atrac3plusData2.atrac3p_ct_huff_code3);
  ChannelUnit.ct_xlats = arrayOf5(null, null, Atrac3plusData2.atrac3p_ct_huff_xlat1, null);
  ChannelUnit.sf_nb_bits = intArrayOf4(9, 9, 9, 9, 6, 6, 7, 7);
  ChannelUnit.sf_nb_codes = intArrayOf4(64, 64, 64, 64, 16, 16, 16, 16);
  ChannelUnit.sf_bits = arrayOf5(Atrac3plusData2.atrac3p_sf_huff_bits1, Atrac3plusData2.atrac3p_sf_huff_bits1, Atrac3plusData2.atrac3p_sf_huff_bits2, Atrac3plusData2.atrac3p_sf_huff_bits3, Atrac3plusData2.atrac3p_sf_huff_bits4, Atrac3plusData2.atrac3p_sf_huff_bits4, Atrac3plusData2.atrac3p_sf_huff_bits5, Atrac3plusData2.atrac3p_sf_huff_bits6);
  ChannelUnit.sf_codes = arrayOf5(Atrac3plusData2.atrac3p_sf_huff_code1, Atrac3plusData2.atrac3p_sf_huff_code1, Atrac3plusData2.atrac3p_sf_huff_code2, Atrac3plusData2.atrac3p_sf_huff_code3, Atrac3plusData2.atrac3p_sf_huff_code4, Atrac3plusData2.atrac3p_sf_huff_code4, Atrac3plusData2.atrac3p_sf_huff_code5, Atrac3plusData2.atrac3p_sf_huff_code6);
  ChannelUnit.sf_xlats = arrayOf5(Atrac3plusData2.atrac3p_sf_huff_xlat1, Atrac3plusData2.atrac3p_sf_huff_xlat2, null, null, Atrac3plusData2.atrac3p_sf_huff_xlat4, Atrac3plusData2.atrac3p_sf_huff_xlat5, null, null);
  ChannelUnit.wl_vlc_tabs = ArrayUtils.create(4, (i) => {
    const vlc = new VLC();
    vlc.initVLCSparse(_ChannelUnit.wl_nb_bits[i], _ChannelUnit.wl_nb_codes[i], _ChannelUnit.wl_bits[i], _ChannelUnit.wl_codes[i], _ChannelUnit.wl_xlats[i]);
    return vlc;
  });
  ChannelUnit.sf_vlc_tabs = ArrayUtils.create(8, (i) => {
    const vlc = new VLC();
    vlc.initVLCSparse(_ChannelUnit.sf_nb_bits[i], _ChannelUnit.sf_nb_codes[i], _ChannelUnit.sf_bits[i], _ChannelUnit.sf_codes[i], _ChannelUnit.sf_xlats[i]);
    return vlc;
  });
  ChannelUnit.ct_vlc_tabs = ArrayUtils.create(4, (i) => {
    const vlc = new VLC();
    vlc.initVLCSparse(_ChannelUnit.ct_nb_bits[i], _ChannelUnit.ct_nb_codes[i], _ChannelUnit.ct_bits[i], _ChannelUnit.ct_codes[i], _ChannelUnit.ct_xlats[i]);
    return vlc;
  });
  ChannelUnit.spec_vlc_tabs = ArrayUtils.create(112, (i) => {
    const atrac3pSpecCodeTab = Atrac3plusData1.atrac3p_spectra_tabs[i];
    if (atrac3pSpecCodeTab.cb != null) {
      const vlc = new VLC();
      _ChannelUnit.buildCanonicalHuff(atrac3pSpecCodeTab.cb, atrac3pSpecCodeTab.xlat, vlc);
      return vlc;
    } else {
      return null;
    }
  });

  // src/me/atrac3plus/Atrac3plusDecoder.ts
  var log4 = logger.named("atrac3plus");
  var Atrac3plusDecoder = class {
    constructor() {
      this.ctx = void 0;
    }
    get numberOfSamples() {
      return Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES;
    }
    init(bytesPerFrame, channels, outputChannels, codingMode) {
      const ctx = new Context();
      this.ctx = ctx;
      ctx.outputChannels = outputChannels;
      ctx.dsp = new Atrac3plusDsp();
      for (let i = 0; i < ctx.numChannelBlocks; i++) {
        ctx.channelUnits[i] = new ChannelUnit();
        ctx.channelUnits[i].setDsp(ctx.dsp);
      }
      ctx.ipqfDctCtx = new FFT();
      ctx.ipqfDctCtx.mdctInit(5, true, 31 / 32768.9);
      ctx.mdctCtx = new FFT();
      ctx.dsp.initImdct(ctx.mdctCtx);
      Atrac3plusDsp.initWaveSynth();
      ctx.gaincCtx = new Atrac();
      ctx.gaincCtx.initGainCompensation(6, 2);
      return 0;
    }
    decode(mem, inputAddr, inputLength, output) {
      let ret;
      if (!this.ctx) {
        return Atrac3plusConstants.AT3P_ERROR;
      }
      if (inputLength < 0) {
        return Atrac3plusConstants.AT3P_ERROR;
      }
      if (inputLength == 0) {
        return 0;
      }
      this.ctx.br = new BitReader(mem, inputAddr, inputLength);
      if (this.ctx.br.readBool()) {
        log4.error("Invalid start bit");
        return Atrac3plusConstants.AT3P_ERROR;
      }
      let chBlock = 0;
      let channelsToProcess = 0;
      while (this.ctx.br.bitsLeft >= 2) {
        const chUnitId = this.ctx.br.read(2);
        if (chUnitId == Atrac3plusConstants.CH_UNIT_TERMINATOR) {
          break;
        }
        if (chUnitId == Atrac3plusConstants.CH_UNIT_EXTENSION) {
          log4.warn(`Non implemented channel unit extension`);
          return Atrac3plusConstants.AT3P_ERROR;
        }
        if (chBlock >= this.ctx.channelUnits.length) {
          log4.error(`Too many channel blocks`);
          return Atrac3plusConstants.AT3P_ERROR;
        }
        if (this.ctx.channelUnits[chBlock] == null) {
          log4.warn(`Null channelUnits block: ${chBlock}`);
          break;
        }
        const channelUnit = this.ctx.channelUnits[chBlock];
        channelUnit.setBitReader(this.ctx.br);
        channelUnit.ctx.unitType = chUnitId;
        channelsToProcess = chUnitId + 1;
        channelUnit.setNumChannels(channelsToProcess);
        ret = channelUnit.decode();
        if (ret < 0) {
          return ret;
        }
        channelUnit.decodeResidualSpectrum(this.ctx.samples);
        channelUnit.reconstructFrame(this.ctx);
        CodecUtils.writeOutput(this.ctx.outpBuf, output, Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES, channelsToProcess, this.ctx.outputChannels);
        chBlock++;
      }
      if (log4.isTraceEnabled) {
        log4.trace("Bytes read 0x%X".format(this.ctx.br.bytesRead));
      }
      return this.ctx.br.bytesRead;
    }
  };

  // src/hle/module/sceAtrac3plus.ts
  var log5 = logger.named("sceAtrac3plus");
  var sceAtrac3plus = class {
    constructor(context) {
      this.context = context;
      this.atracIDs = ArrayUtils.create(6, (i) => new AtracID(i));
    }
    getStartSkippedSamples(codecType) {
      switch (codecType) {
        case Atrac3plusConstants.PSP_CODEC_AT3:
          return 69;
        case Atrac3plusConstants.PSP_CODEC_AT3PLUS:
          return 368;
        default:
          return 0;
      }
    }
    getMaxSamples(codecType) {
      switch (codecType) {
        case Atrac3plusConstants.PSP_CODEC_AT3:
          return 1024;
        case Atrac3plusConstants.PSP_CODEC_AT3PLUS:
          return Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES;
        default:
          return 0;
      }
    }
    sceAtracSetDataAndGetID(dataPtr, bufferSize) {
      const id = this.atracIDs.first((it) => !it.inUse);
      if (!id)
        return SceKernelErrors.ERROR_ATRAC_NO_ID;
      this.sceAtracSetData(id.id, dataPtr, bufferSize);
      return id.id;
    }
    sceAtracSetData(atID, dataPtr, bufferSize) {
      if (!this.hasById(atID))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const id = this.getAtrac(atID);
      const info = id.info;
      const mem = this.context.memory;
      const dataStream = mem.getPointerStream(dataPtr, bufferSize);
      log5.trace("sceAtracSetData Partially implemented");
      const res = Atrac3PlusUtil.analyzeRiffFile(dataStream.clone(), 0, bufferSize, id.info);
      if (res < 0) {
        console.error("Invalid atrac data");
        return res;
      }
      const outputChannels = 2;
      const startSkippedSamples = this.getStartSkippedSamples(Atrac3plusConstants.PSP_CODEC_AT3PLUS);
      const maxSamples = this.getMaxSamples(Atrac3plusConstants.PSP_CODEC_AT3PLUS);
      const skippedSamples = startSkippedSamples + info.atracSampleOffset;
      const skippedFrames = Math.ceil(skippedSamples / maxSamples);
      id.data = dataStream.clone().skipThis(id.info.inputFileDataOffset).readBytesCloned(id.info.inputDataSize);
      id.dataMem = new Uint8ArrayMem(id.data);
      id.startAddr = 0;
      id.readAddr = id.startAddr;
      id.endAddr = id.startAddr + id.info.inputDataSize;
      id.decoder.init(id.info.atracBytesPerFrame, id.info.atracChannels, outputChannels, 0);
      return 0;
    }
    getAtrac(id) {
      return this.atracIDs[id];
    }
    sceAtracGetSecondBufferInfo(atID, puiPosition, puiDataByte) {
      logger.error(`sceAtracGetSecondBufferInfo Not implemented (${atID}, ${puiPosition}, ${puiDataByte})`);
      const id = this.getAtrac(atID);
      if (!id.isSecondBufferNeeded) {
        puiPosition.writeInt32(0);
        puiDataByte.writeInt32(0);
        return SceKernelErrors.ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED;
      } else {
        puiPosition.writeInt32(id.secondBufferReadPosition);
        puiDataByte.writeInt32(id.secondBufferSize);
        return 0;
      }
    }
    sceAtracSetSecondBuffer(id, pucSecondBufferAddr, uiSecondBufferByte) {
      return 0;
    }
    sceAtracGetSoundSample(id, endSamplePtr, loopStartSamplePtr, loopEndSamplePtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      const hasLoops = atrac3.info.loops != null && atrac3.info.loops.length > 0;
      if (endSamplePtr)
        endSamplePtr.writeInt32(atrac3.info.atracEndSample);
      if (loopStartSamplePtr)
        loopStartSamplePtr.writeInt32(-1);
      if (loopEndSamplePtr)
        loopEndSamplePtr.writeInt32(-1);
      return 0;
    }
    sceAtracSetLoopNum(id, numberOfLoops) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      atrac3.info.numLoops = numberOfLoops;
      return 0;
    }
    sceAtracGetRemainFrame(id, remainFramePtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      if (remainFramePtr)
        remainFramePtr.writeInt32(atrac3.remainFrames);
      return 0;
    }
    sceAtracGetNextDecodePosition(id, samplePositionPtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      if (atrac3.decodingReachedEnd)
        return SceKernelErrors.ERROR_ATRAC_ALL_DATA_DECODED;
      if (samplePositionPtr)
        samplePositionPtr.writeInt32(atrac3.currentFrame);
      return 0;
    }
    sceAtracDecodeData(idAT, samplesAddr, samplesNbrAddr, outEndAddr, remainFramesAddr) {
      logger.trace("sceAtracDecodeData Not implemented ($idAT, $samplesAddr, $samplesNbrAddr, $outEndAddr, $remainFramesAddr)");
      const id = this.getAtrac(idAT);
      const info = id.info;
      if (id.isSecondBufferNeeded && !id.isSecondBufferSet) {
        logger.warn("sceAtracDecodeData atracID=0x%X needs second buffer!".format(idAT));
        return SceKernelErrors.ERROR_ATRAC_SECOND_BUFFER_NEEDED;
      }
      const result = id.decoder.decode(id.dataMem, id.readAddr, info.atracBytesPerFrame, samplesAddr);
      if (result < 0) {
        samplesNbrAddr.writeInt32(0);
        return result;
      }
      id.moveNext();
      samplesNbrAddr.writeInt32(id.decoder.numberOfSamples);
      remainFramesAddr.writeInt32(id.remainFrames);
      if (result == 0) {
        this.context.threadManager.delayThread(2300);
      }
      return result;
    }
    sceAtracReleaseAtracID(atID) {
      const atrac = this.getAtrac(atID);
      atrac.inUse = false;
      return 0;
    }
    sceAtracGetBitrate(id, bitratePtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      bitratePtr.writeInt32(atrac3.info.atracBitrate);
      return 0;
    }
    sceAtracGetChannel(id, channelsPtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      channelsPtr.writeInt32(atrac3.info.atracChannels);
      return 0;
    }
    sceAtracGetMaxSample(id, maxNumberOfSamplesPtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      maxNumberOfSamplesPtr.writeInt32(this.getMaxSamples(Atrac3plusConstants.PSP_CODEC_AT3PLUS));
      return 0;
    }
    sceAtracGetNextSample(id, numberOfSamplesInNextFramePtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      numberOfSamplesInNextFramePtr.writeInt32(Math.min(this.getMaxSamples(Atrac3plusConstants.PSP_CODEC_AT3PLUS), atrac3.byteAvailable));
      return 0;
    }
    sceAtracGetAtracID(codecType) {
      if (codecType != CodecType.PSP_MODE_AT_3 && codecType != CodecType.PSP_MODE_AT_3_PLUS) {
        return SceKernelErrors.ATRAC_ERROR_INVALID_CODECTYPE;
      }
      return 1;
    }
    hasById(id) {
      return id >= 0 && id < this.atracIDs.length;
    }
    sceAtracAddStreamData(id, bytesToAdd) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      return 0;
    }
    sceAtracGetStreamDataInfo(id, writePointerPointer, availableBytesPtr, readOffsetPtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      writePointerPointer.writeInt32(0);
      availableBytesPtr.writeInt32(0);
      readOffsetPtr.writeInt32(0);
      return 0;
    }
    sceAtracGetBufferInfoForReseting(id, uiSample, bufferInfoPtr) {
      throw new Error("Not implemented sceAtracGetBufferInfoForReseting");
    }
    sceAtracResetPlayPosition(id, uiSample, uiWriteByteFirstBuf, uiWriteByteSecondBuf) {
      throw new Error("Not implemented sceAtracResetPlayPosition");
    }
    sceAtracGetInternalErrorInfo(id, errorResultPtr) {
      throw new Error("Not implemented sceAtracGetInternalErrorInfo");
    }
    sceAtracGetOutputChannel(id, outputChannelPtr) {
      if (!this.hasById(id))
        return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
      const atrac3 = this.getAtrac(id);
      const sceAudioChReserve = this.context.moduleManager.getByName("sceAudio").getByName("sceAudioChReserve").nativeCall;
      const channel = sceAudioChReserve(-1, this.getMaxSamples(Atrac3plusConstants.PSP_CODEC_AT3PLUS), 0);
      outputChannelPtr.writeInt32(channel);
      return 0;
    }
  };
  __decorate([
    nativeFunction(2048976815, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceAtrac3plus.prototype, "sceAtracSetDataAndGetID", 1);
  __decorate([
    nativeFunction(237663147, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceAtrac3plus.prototype, "sceAtracSetData", 1);
  __decorate([
    nativeFunction(2213043872, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetSecondBufferInfo", 1);
  __decorate([
    nativeFunction(2210364157, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, U32)
  ], sceAtrac3plus.prototype, "sceAtracSetSecondBuffer", 1);
  __decorate([
    nativeFunction(2730207422, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetSoundSample", 1);
  __decorate([
    nativeFunction(2256609461, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceAtrac3plus.prototype, "sceAtracSetLoopNum", 1);
  __decorate([
    nativeFunction(2598914471, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetRemainFrame", 1);
  __decorate([
    nativeFunction(3795728949, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetNextDecodePosition", 1);
  __decorate([
    nativeFunction(1787575509, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, PTR),
    __param(4, PTR)
  ], sceAtrac3plus.prototype, "sceAtracDecodeData", 1);
  __decorate([
    nativeFunction(1642804213, 150),
    U32,
    __param(0, I32)
  ], sceAtrac3plus.prototype, "sceAtracReleaseAtracID", 1);
  __decorate([
    nativeFunction(2773786968, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetBitrate", 1);
  __decorate([
    nativeFunction(828804010, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetChannel", 1);
  __decorate([
    nativeFunction(3601199863, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetMaxSample", 1);
  __decorate([
    nativeFunction(922397691, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetNextSample", 1);
  __decorate([
    nativeFunction(2014283985, 150),
    U32,
    __param(0, I32)
  ], sceAtrac3plus.prototype, "sceAtracGetAtracID", 1);
  __decorate([
    nativeFunction(2108887633, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceAtrac3plus.prototype, "sceAtracAddStreamData", 1);
  __decorate([
    nativeFunction(1562806023, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetStreamDataInfo", 1);
  __decorate([
    nativeFunction(3392971730, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetBufferInfoForReseting", 1);
  __decorate([
    nativeFunction(1682855431, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, U32),
    __param(3, U32)
  ], sceAtrac3plus.prototype, "sceAtracResetPlayPosition", 1);
  __decorate([
    nativeFunction(3901715867, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetInternalErrorInfo", 1);
  __decorate([
    nativeFunction(3015036994, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAtrac3plus.prototype, "sceAtracGetOutputChannel", 1);
  var Uint8ArrayMem = class {
    constructor(data) {
      this.data = data;
    }
    read8(addr) {
      return this.data[addr];
    }
  };
  var AtracID = class {
    constructor(id) {
      this.id = id;
      this.decoder = new Atrac3plusDecoder();
      this.inUse = false;
      this.isSecondBufferNeeded = false;
      this.isSecondBufferSet = false;
      this.info = new AtracFileInfo();
      this.atracCurrentSample = 0;
      this.secondBufferReadPosition = 0;
      this.secondBufferSize = 0;
      this.data = new Uint8Array(0);
      this.startAddr = 0;
      this.readAddr = 0;
      this.endAddr = 0;
      this.currentFrame = 0;
    }
    get atracEndSample() {
      return this.info.atracEndSample;
    }
    get byteLength() {
      return this.endAddr - this.startAddr;
    }
    get byteOffset() {
      return this.readAddr - this.startAddr;
    }
    get byteAvailable() {
      return this.byteLength - this.byteOffset;
    }
    get remainFrames() {
      return Math.floor(this.byteAvailable / this.info.atracBytesPerFrame);
    }
    get decodingReachedEnd() {
      return this.remainFrames <= 0;
    }
    getNumberOfSamplesInNextFrame() {
      return Math.min(this.getMaxSamples(CodecType.PSP_MODE_AT_3_PLUS), this.info.atracEndSample - this.currentFrame);
    }
    getMaxSamples(codecType) {
      switch (codecType) {
        case Atrac3plusConstants.PSP_CODEC_AT3:
          return 1024;
        case Atrac3plusConstants.PSP_CODEC_AT3PLUS:
          return Atrac3plusConstants.ATRAC3P_FRAME_SAMPLES;
        default:
          return 0;
      }
    }
    moveNext() {
      this.readAddr += this.info.atracBytesPerFrame;
    }
  };

  // src/hle/module/sceAudio.ts
  var sceAudio_exports = {};
  __export(sceAudio_exports, {
    sceAudio: () => sceAudio
  });
  var sceAudio = class {
    constructor(context) {
      this.context = context;
      this.channels = [];
      for (let n = 0; n < 8; n++)
        this.channels.push(new Channel3(n));
    }
    isValidChannel(channelId) {
      return channelId >= 0 && channelId < this.channels.length;
    }
    sceAudioOutput2Reserve(sampleCount) {
      console.warn("sceAudioOutput2Reserve not implemented!");
      debugger;
      return 0;
    }
    async sceAudioOutput2OutputBlocking(volume, buffer) {
      await waitAsync(10);
      return 0;
    }
    sceAudioGetChannelRestLength(channelId) {
      if (!this.isValidChannel(channelId))
        return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
      const channel = this.getChannelById(channelId);
      return channel.restLength;
    }
    sceAudioChReserve(channelId, sampleCount, format) {
      if (channelId >= this.channels.length)
        return -1;
      if (channelId < 0) {
        channelId = this.channels.first((channel2) => !channel2.allocated).id;
        if (channelId === void 0) {
          console.warn("Not implemented sceAudio.sceAudioChReserve");
          return -2;
        }
      }
      const channel = this.channels[channelId];
      channel.allocated = true;
      channel.sampleCount = sampleCount;
      channel.format = format;
      channel.channel = this.context.audio.createChannel();
      channel.channel.start();
      return channelId;
    }
    getChannelById(id) {
      return this.channels[id];
    }
    sceAudioChRelease(channelId) {
      if (!this.isValidChannel(channelId))
        return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
      const channel = this.getChannelById(channelId);
      channel.allocated = false;
      channel.channel?.stop();
      channel.channel = null;
      return 0;
    }
    sceAudioChangeChannelConfig(channelId, format) {
      if (!this.isValidChannel(channelId))
        return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
      const channel = this.getChannelById(channelId);
      channel.format = format;
      return 0;
    }
    sceAudioSetChannelDataLen(channelId, sampleCount) {
      if (!this.isValidChannel(channelId))
        return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
      if (sampleCount % 64 != 0)
        return SceKernelErrors.ERROR_AUDIO_OUTPUT_SAMPLE_DATA_SIZE_NOT_ALIGNED;
      const channel = this.getChannelById(channelId);
      channel.sampleCount = sampleCount;
      return 0;
    }
    _sceAudioOutput(channelId, leftVolume, rightVolume, buffer) {
      if (!buffer)
        return -1;
      if (!this.isValidChannel(channelId))
        return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
      const channel = this.getChannelById(channelId);
      return channel.channel.playAsync(channel.numberOfChannels, buffer.readInt16Array(channel.totalSampleCount), MathUtils.clamp01(leftVolume / 32768), MathUtils.clamp01(rightVolume / 32768));
    }
    sceAudioOutputPannedBlocking(channelId, leftVolume, rightVolume, buffer) {
      const result = this._sceAudioOutput(channelId, leftVolume, rightVolume, buffer);
      if (!PromiseFast.isPromise(result))
        return result;
      return new WaitingThreadInfo("sceAudioOutputPannedBlocking", channelId, result, AcceptCallbacks.NO);
    }
    sceAudioOutputBlocking(channelId, volume, buffer) {
      return this._sceAudioOutput(channelId, volume, volume, buffer);
    }
    sceAudioOutput(channelId, volume, buffer) {
      const result = this._sceAudioOutput(channelId, volume, volume, buffer);
      return 0;
    }
    sceAudioOutputPanned(channelId, leftVolume, rightVolume, buffer) {
      const result = this._sceAudioOutput(channelId, leftVolume, rightVolume, buffer);
      return 0;
    }
    sceAudioChangeChannelVolume(channelId, volumeLeft, volumeRight) {
      console.warn("Not implemented sceAudioChangeChannelVolume");
      return 0;
    }
    sceAudioGetChannelRestLen(channelId) {
      console.warn("Not implemented sceAudioGetChannelRestLen");
      return 0;
    }
  };
  __decorate([
    nativeFunction(22424483, 150),
    U32,
    __param(0, I32)
  ], sceAudio.prototype, "sceAudioOutput2Reserve", 1);
  __decorate([
    nativeFunction(760476526, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceAudio.prototype, "sceAudioOutput2OutputBlocking", 1);
  __decorate([
    nativeFunction(2953941551, 150, {disableInsideInterrupt: true}),
    U32,
    __param(0, I32)
  ], sceAudio.prototype, "sceAudioGetChannelRestLength", 1);
  __decorate([
    nativeFunction(1590172757, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceAudio.prototype, "sceAudioChReserve", 1);
  __decorate([
    nativeFunction(1875142739, 150),
    U32,
    __param(0, I32)
  ], sceAudio.prototype, "sceAudioChRelease", 1);
  __decorate([
    nativeFunction(2516388909, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceAudio.prototype, "sceAudioChangeChannelConfig", 1);
  __decorate([
    nativeFunction(3408806814, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceAudio.prototype, "sceAudioSetChannelDataLen", 1);
  __decorate([
    nativeFunction(334860988, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], sceAudio.prototype, "sceAudioOutputPannedBlocking", 1);
  __decorate([
    nativeFunction(325889873, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR)
  ], sceAudio.prototype, "sceAudioOutputBlocking", 1);
  __decorate([
    nativeFunction(2349861298, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR)
  ], sceAudio.prototype, "sceAudioOutput", 1);
  __decorate([
    nativeFunction(3805637421, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], sceAudio.prototype, "sceAudioOutputPanned", 1);
  __decorate([
    nativeFunction(3085031655, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceAudio.prototype, "sceAudioChangeChannelVolume", 1);
  __decorate([
    nativeFunction(3085031655, 150),
    U32,
    __param(0, I32)
  ], sceAudio.prototype, "sceAudioGetChannelRestLen", 1);
  var AudioFormat;
  (function(AudioFormat2) {
    AudioFormat2[AudioFormat2["Stereo"] = 0] = "Stereo";
    AudioFormat2[AudioFormat2["Mono"] = 16] = "Mono";
  })(AudioFormat || (AudioFormat = {}));
  var Channel3 = class {
    constructor(id) {
      this.id = id;
      this.allocated = false;
      this.sampleCount = 44100;
      this.format = 0;
      this.channel = null;
      this.restLength = 1024;
    }
    get totalSampleCount() {
      return this.sampleCount * this.numberOfChannels;
    }
    get numberOfChannels() {
      return this.format == 0 ? 2 : 1;
    }
  };

  // src/hle/module/sceCtrl.ts
  var sceCtrl_exports = {};
  __export(sceCtrl_exports, {
    sceCtrl: () => sceCtrl
  });
  var sceCtrl = class {
    constructor(context) {
      this.context = context;
      this.lastLatchData = new SceCtrlData();
    }
    sceCtrlPeekBufferPositive(sceCtrlDataPtr, count) {
      for (let n = 0; n < count; n++)
        SceCtrlData.struct.write(sceCtrlDataPtr, this.context.controller.data);
      return count;
    }
    sceCtrlReadBufferPositive(thread, sceCtrlDataPtr, count) {
      for (let n = 0; n < count; n++)
        SceCtrlData.struct.write(sceCtrlDataPtr, this.context.controller.data);
      const promise = (async () => {
        await this.context.display.waitVblankStartAsync(thread);
        return count;
      })();
      return new WaitingThreadInfo("sceCtrlReadBufferPositive", this.context.display, promise, AcceptCallbacks.NO);
    }
    sceCtrlSetSamplingCycle(samplingCycle) {
      return 0;
    }
    sceCtrlSetSamplingMode(samplingMode) {
      return 0;
    }
    _peekLatch(currentLatchPtr) {
      const ButtonsNew = this.context.controller.data.buttons;
      const ButtonsOld = this.lastLatchData.buttons;
      const ButtonsChanged = ButtonsOld ^ ButtonsNew;
      currentLatchPtr.writeInt32(ButtonsNew & ButtonsChanged);
      currentLatchPtr.writeInt32(ButtonsOld & ButtonsChanged);
      currentLatchPtr.writeInt32(ButtonsNew);
      currentLatchPtr.writeInt32(ButtonsOld & ~ButtonsNew & ButtonsChanged);
      return this.context.controller.latchSamplingCount;
    }
    sceCtrlReadLatch(currentLatchPtr) {
      try {
        return this._peekLatch(currentLatchPtr);
      } finally {
        this.lastLatchData = this.context.controller.data;
        this.context.controller.latchSamplingCount = 0;
      }
    }
    sceCtrlSetIdleCancelThreshold(idlereset, idleback) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(979510608, 150),
    U32,
    __param(0, PTR),
    __param(1, I32)
  ], sceCtrl.prototype, "sceCtrlPeekBufferPositive", 1);
  __decorate([
    nativeFunction(528496952, 150),
    U32,
    __param(0, THREAD),
    __param(1, PTR),
    __param(2, I32)
  ], sceCtrl.prototype, "sceCtrlReadBufferPositive", 1);
  __decorate([
    nativeFunction(1780970739, 150),
    U32,
    __param(0, I32)
  ], sceCtrl.prototype, "sceCtrlSetSamplingCycle", 1);
  __decorate([
    nativeFunction(524292582, 150),
    U32,
    __param(0, I32)
  ], sceCtrl.prototype, "sceCtrlSetSamplingMode", 1);
  __decorate([
    nativeFunction(190350593, 150),
    U32,
    __param(0, PTR)
  ], sceCtrl.prototype, "sceCtrlReadLatch", 1);
  __decorate([
    nativeFunction(2803124224, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceCtrl.prototype, "sceCtrlSetIdleCancelThreshold", 1);

  // src/hle/module/sceDisplay.ts
  var sceDisplay_exports = {};
  __export(sceDisplay_exports, {
    sceDisplay: () => sceDisplay
  });
  var console4 = logger.named("sceDisplay");
  var sceDisplay = class {
    constructor(context) {
      this.context = context;
      this.mode = 0;
      this.width = 512;
      this.height = 272;
    }
    sceDisplaySetMode(mode, width, height) {
      console4.info(sprintf("sceDisplay.sceDisplaySetMode(mode: %d, width: %d, height: %d)", mode, width, height));
      this.mode = mode;
      this.width = width;
      this.height = height;
      return 0;
    }
    sceDisplayGetMode(modePtr, widthPtr, heightPtr) {
      if (modePtr)
        modePtr.writeInt32(this.mode);
      if (widthPtr)
        widthPtr.writeInt32(this.width);
      if (heightPtr)
        heightPtr.writeInt32(this.height);
      return 0;
    }
    _waitVblankAsync(thread, acceptCallbacks) {
      this.context.display.updateTime();
      return new WaitingThreadInfo("_waitVblankAsync", this.context.display, this.context.display.waitVblankAsync(thread), acceptCallbacks);
    }
    _waitVblankStartAsync(thread, acceptCallbacks) {
      this.context.display.updateTime();
      return new WaitingThreadInfo("_waitVblankStartAsync", this.context.display, this.context.display.waitVblankStartAsync(thread), acceptCallbacks);
    }
    sceDisplayWaitVblank(thread, cycleNum) {
      return this._waitVblankAsync(thread, AcceptCallbacks.NO);
    }
    sceDisplayWaitVblankCB(thread, cycleNum) {
      return this._waitVblankAsync(thread, AcceptCallbacks.YES);
    }
    sceDisplayWaitVblankStart(thread) {
      return this._waitVblankAsync(thread, AcceptCallbacks.NO);
    }
    sceDisplayWaitVblankStartCB(thread) {
      return this._waitVblankAsync(thread, AcceptCallbacks.YES);
    }
    sceDisplayGetVcount() {
      this.context.display.updateTime();
      return this.context.display.vblankCount;
    }
    sceDisplayGetFramePerSec() {
      return PspDisplay.PROCESSED_PIXELS_PER_SECOND * PspDisplay.CYCLES_PER_PIXEL / (PspDisplay.PIXELS_IN_A_ROW * PspDisplay.NUMBER_OF_ROWS);
    }
    sceDisplayIsVblank() {
      return this.context.display.secondsLeftForVblank == 0;
    }
    sceDisplaySetFrameBuf(address, bufferWidth, pixelFormat, sync) {
      this.context.display.address = address;
      this.context.display.bufferWidth = bufferWidth;
      this.context.display.pixelFormat = pixelFormat;
      this.context.display.sync = sync;
      return 0;
    }
    sceDisplayGetFrameBuf(topaddrPtr, bufferWidthPtr, pixelFormatPtr, syncPtr) {
      if (topaddrPtr)
        topaddrPtr.writeInt32(this.context.display.address);
      if (bufferWidthPtr)
        bufferWidthPtr.writeInt32(this.context.display.bufferWidth);
      if (pixelFormatPtr)
        pixelFormatPtr.writeInt32(this.context.display.pixelFormat);
      if (syncPtr)
        syncPtr.writeInt32(this.context.display.sync);
      return 0;
    }
    sceDisplayGetCurrentHcount() {
      this.context.display.updateTime();
      return this.context.display.hcountTotal;
    }
  };
  __decorate([
    nativeFunction(237039991, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, U32)
  ], sceDisplay.prototype, "sceDisplaySetMode", 1);
  __decorate([
    nativeFunction(3735132116, 150),
    U32,
    __param(0, PTR),
    __param(1, PTR),
    __param(2, PTR)
  ], sceDisplay.prototype, "sceDisplayGetMode", 1);
  __decorate([
    nativeFunction(919468766, 150, {disableInsideInterrupt: true}),
    U32,
    __param(0, THREAD),
    __param(1, I32)
  ], sceDisplay.prototype, "sceDisplayWaitVblank", 1);
  __decorate([
    nativeFunction(2394549321, 150, {disableInsideInterrupt: true}),
    U32,
    __param(0, THREAD),
    __param(1, I32)
  ], sceDisplay.prototype, "sceDisplayWaitVblankCB", 1);
  __decorate([
    nativeFunction(2555127783, 150, {disableInsideInterrupt: true}),
    U32,
    __param(0, THREAD)
  ], sceDisplay.prototype, "sceDisplayWaitVblankStart", 1);
  __decorate([
    nativeFunction(1190233795, 150, {disableInsideInterrupt: true}),
    U32,
    __param(0, THREAD)
  ], sceDisplay.prototype, "sceDisplayWaitVblankStartCB", 1);
  __decorate([
    nativeFunction(2624498391, 150),
    I32
  ], sceDisplay.prototype, "sceDisplayGetVcount", 1);
  __decorate([
    nativeFunction(3685139652, 150),
    F32
  ], sceDisplay.prototype, "sceDisplayGetFramePerSec", 1);
  __decorate([
    nativeFunction(1296961772, 150),
    I32
  ], sceDisplay.prototype, "sceDisplayIsVblank", 1);
  __decorate([
    nativeFunction(681411326, 150),
    U32,
    __param(0, U32),
    __param(1, I32),
    __param(2, U32),
    __param(3, U32)
  ], sceDisplay.prototype, "sceDisplaySetFrameBuf", 1);
  __decorate([
    nativeFunction(4007276116, 150),
    U32,
    __param(0, PTR),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, PTR)
  ], sceDisplay.prototype, "sceDisplayGetFrameBuf", 1);
  __decorate([
    nativeFunction(2000540579, 150),
    U32
  ], sceDisplay.prototype, "sceDisplayGetCurrentHcount", 1);
  var SebufMode;
  (function(SebufMode2) {
    SebufMode2[SebufMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
    SebufMode2[SebufMode2["NEXTFRAME"] = 1] = "NEXTFRAME";
  })(SebufMode || (SebufMode = {}));

  // src/hle/module/sceDmac.ts
  var sceDmac_exports = {};
  __export(sceDmac_exports, {
    sceDmac: () => sceDmac
  });
  var sceDmac = class {
    constructor(context) {
      this.context = context;
    }
    _sceDmacMemcpy(destination, source, size) {
      if (size == 0)
        return SceKernelErrors.ERROR_INVALID_SIZE;
      if (destination == 0)
        return SceKernelErrors.ERROR_INVALID_POINTER;
      if (source == 0)
        return SceKernelErrors.ERROR_INVALID_POINTER;
      this.context.memory.copy(source, destination, size);
      if (size < 272)
        return 0;
      return PromiseFast.resolve(0);
    }
    sceDmacMemcpy(destination, source, size) {
      return this._sceDmacMemcpy(destination, source, size);
    }
    sceDmacTryMemcpy(destination, source, size) {
      return this._sceDmacMemcpy(destination, source, size);
    }
  };
  __decorate([
    nativeFunction(1635729382, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, I32)
  ], sceDmac.prototype, "sceDmacMemcpy", 1);
  __decorate([
    nativeFunction(3649017048, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, I32)
  ], sceDmac.prototype, "sceDmacTryMemcpy", 1);

  // src/hle/module/sceGe_user.ts
  var sceGe_user_exports = {};
  __export(sceGe_user_exports, {
    sceGe_user: () => sceGe_user
  });

  // src/core/gpu/gpu_vertex.ts
  var memory = getMemoryInstance();
  var SpriteVID;
  (function(SpriteVID2) {
    SpriteVID2[SpriteVID2["TL"] = 0] = "TL";
    SpriteVID2[SpriteVID2["BR"] = 1] = "BR";
    SpriteVID2[SpriteVID2["TR"] = 2] = "TR";
    SpriteVID2[SpriteVID2["BL"] = 3] = "BL";
  })(SpriteVID || (SpriteVID = {}));
  var SpriteExpander = class {
    static forVertexInfo(vi) {
      const hash = vi.hash;
      if (!this.cache.has(hash)) {
        this.cache.set(hash, eval(`(function read_${vi.describe()}(input, output, count) { ${this.readAllCode(vi)} })`));
      }
      return this.cache.get(hash);
    }
    static readAllCode(vi) {
      let code = `"use strict";`;
      code += `const i8  = new Uint8Array(input.buffer, input.byteOffset);
`;
      code += `const i16 = new Uint16Array(input.buffer, input.byteOffset);
`;
      code += `const i32 = new Uint32Array(input.buffer, input.byteOffset);
`;
      code += `const o8  = new Uint8Array(output.buffer, output.byteOffset);
`;
      if (vi.align >= 2) {
        code += `const o16 = new Uint16Array(output.buffer, output.byteOffset);
`;
        if (vi.align >= 4) {
          code += `const o32 = new Uint32Array(output.buffer, output.byteOffset);
`;
        }
      }
      code += `let i = 0, o = 0;
`;
      code += `for (let n = 0; n < count; n++) {
`;
      code += this.readOneCode(vi);
      code += `}
`;
      return code;
    }
    static readOneCode(vi) {
      let code = "";
      const vsize = vi.size;
      const CONVV = [null, "o8", "o16", "o32"];
      const CONVS = [0, 0, 1, 2];
      const COLV = [null, null, null, null, "o16", "o16", "o16", "o32"];
      const COLS = [0, 0, 0, 0, 1, 1, 1, 2];
      function _get(vid, type, offset, component) {
        return `${CONVV[type]}[((o + ${offset + vsize * +vid}) >> ${CONVS[type]}) + ${component}]`;
      }
      function getColor(vid) {
        return `${COLV[vi.color]}[((o + ${vi.colorOffset + vsize * +vid}) >> ${COLS[vi.color]})]`;
      }
      function getP_(vid, n) {
        return _get(vid, vi.position, vi.positionOffset, n);
      }
      function getN_(vid, n) {
        return _get(vid, vi.normal, vi.normalOffset, n);
      }
      function getT_(vid, n) {
        return _get(vid, vi.texture, vi.textureOffset, n);
      }
      function copy_(vidTo, vidFrom, n) {
        const out = [];
        if (vi.hasPosition)
          out.push(`${getP_(vidTo, n)} = ${getP_(vidFrom, n)};`);
        if (vi.hasNormal)
          out.push(`${getN_(vidTo, n)} = ${getN_(vidFrom, n)};`);
        if (vi.hasTexture)
          out.push(`${getT_(vidTo, n)} = ${getT_(vidFrom, n)};`);
        return out.join("\n");
      }
      function copyX(vidTo, vidFrom) {
        return copy_(vidTo, vidFrom, 0);
      }
      function copyY(vidTo, vidFrom) {
        return copy_(vidTo, vidFrom, 1);
      }
      function copyColor(vidTo, vidFrom) {
        return vi.hasColor ? `${getColor(vidTo)} = ${getColor(vidFrom)};
` : "";
      }
      const vsizex2 = vsize * 2;
      if (vsize % 4 == 0) {
        for (let n = 0; n < vsizex2 / 4; n++) {
          const n4 = n * 4;
          code += `o32[(o + ${n4}) >> 2] = i32[(i + ${n4}) >> 2]; o32[(o + ${n4 + vsizex2}) >> 2] = i32[(i + ${n4}) >> 2];
`;
        }
      } else {
        for (let n = 0; n < vsizex2; n++) {
          code += `o8[o + ${n}] = i8[i + ${n}]; o8[o + ${n + vsizex2}] = i8[i + ${n}];
`;
        }
      }
      const TL = 0;
      const BR = 1;
      code += copyX(2, BR);
      code += copyY(2, TL);
      code += copyX(3, TL);
      code += copyY(3, BR);
      code += copyColor(0, BR);
      code += copyColor(2, BR);
      code += copyColor(3, BR);
      code += `i += ${vsize * 2};
`;
      code += `o += ${vsize * 4};
`;
      return code;
    }
  };
  SpriteExpander.cache = new Map();
  var OptimizedDrawBufferTransfer = class {
    static buildBatchesTransfer(odb, batches2) {
      const chunks = [];
      let offset = 0;
      const batches = [];
      function alloc(size) {
        const address = offset;
        offset += MathUtils.nextAligned(size, 16);
        return address;
      }
      function allocData(data2) {
        chunks.push({offset, size: data2.byteLength, data: data2});
        return alloc(data2.byteLength);
      }
      const odbData = odb.getData();
      const odbIndices = odb.getIndices();
      const data = {
        data: allocData(odbData),
        datasize: odbData.length,
        indices: allocData(odbIndices),
        indicesCount: odbIndices.length
      };
      const memorySegments = new Map();
      function allocMemoryData(data2) {
        if (data2 == null)
          return 0;
        if (!memorySegments.has(data2.byteOffset))
          memorySegments.set(data2.byteOffset, allocData(data2));
        return memorySegments.get(data2.byteOffset);
      }
      for (let batch of batches2) {
        let btl = allocMemoryData(batch.textureData);
        let bcl = allocMemoryData(batch.clutData);
        batches.push({
          stateOffset: allocData(batch.stateData),
          primType: batch.primType,
          dataLow: batch.dataLow,
          dataHigh: batch.dataHigh,
          indexLow: batch.indexLow,
          indexHigh: batch.indexHigh,
          indexCount: batch.indexCount,
          textureLow: btl,
          textureHigh: btl + (batch.textureData ? batch.textureData.length : 0),
          clutLow: bcl,
          clutHigh: bcl + (batch.clutData ? batch.clutData.length : 0)
        });
      }
      const buffer = new ArrayBuffer(offset);
      const bufferU8 = new Uint8Array(buffer);
      for (let chunk of chunks) {
        bufferU8.set(new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.size), chunk.offset);
      }
      return {
        buffer,
        data,
        batches
      };
    }
  };
  var OptimizedDrawBuffer = class {
    constructor() {
      this.data = new Uint8Array(2 * 1024 * 1024);
      this.dataOffset = 0;
      this.indices = new Uint16Array(512 * 1024);
      this.indexOffset = 0;
      this.vertexIndex = 0;
      this.batchDataOffset = 0;
      this.batchIndexOffset = 0;
    }
    reset() {
      this.dataOffset = 0;
      this.indexOffset = 0;
      this.vertexIndex = 0;
      this.batchDataOffset = 0;
      this.batchIndexOffset = 0;
    }
    getData() {
      return this.data.subarray(0, this.dataOffset);
    }
    getIndices() {
      return this.indices.subarray(0, this.indexOffset);
    }
    get hasElements() {
      return this.dataOffset > this.batchDataOffset;
    }
    createBatch(state, primType, vertexInfo) {
      const data = new OptimizedBatch(state, this, primType, vertexInfo, this.batchDataOffset, this.dataOffset, this.batchIndexOffset, this.indexOffset);
      this.dataOffset = this.batchDataOffset = this.dataOffset + 15 & ~15;
      this.batchIndexOffset = this.indexOffset;
      this.vertexIndex = 0;
      return data;
    }
    addVertices(vertices, vertexCount, verticesSize) {
      this.addVerticesData(vertices, verticesSize);
      this.addVerticesIndices(vertexCount);
    }
    addVerticesData(vertices, verticesSize) {
      ArrayBufferUtils.copy(vertices, 0, this.data, this.dataOffset, verticesSize);
      this.dataOffset += verticesSize;
    }
    addVerticesIndices(vertexCount) {
      for (let n = 0; n < vertexCount; n++)
        this.indices[this.indexOffset++] = this.vertexIndex++;
    }
    addVerticesIndicesSprite(vertexCount) {
      for (let n = 0; n < vertexCount / 2; n++) {
        this.indices[this.indexOffset++] = this.vertexIndex + 3;
        this.indices[this.indexOffset++] = this.vertexIndex + 0;
        this.indices[this.indexOffset++] = this.vertexIndex + 2;
        this.indices[this.indexOffset++] = this.vertexIndex + 3;
        this.indices[this.indexOffset++] = this.vertexIndex + 2;
        this.indices[this.indexOffset++] = this.vertexIndex + 1;
        this.vertexIndex += 4;
      }
    }
    addVerticesDataSprite(vertices, verticesSize, count, vi) {
      const func = SpriteExpander.forVertexInfo(vi);
      func(vertices, this.data.subarray(this.dataOffset), count / 2);
      this.dataOffset += verticesSize * 2;
    }
    addVerticesIndicesList(indices) {
      let max = 0;
      const ioffset = this.indexOffset;
      for (let n = 0; n < indices.length; n++) {
        const v = indices[n];
        this.indices[ioffset + n] = v;
        max = Math.max(max, v);
      }
      max++;
      this.vertexIndex = max;
      this.indexOffset += indices.length;
      return max;
    }
    join(vertexSize) {
      this.indices[this.indexOffset++] = this.vertexIndex - 1;
      this.indices[this.indexOffset++] = this.vertexIndex;
    }
  };
  var OptimizedBatch = class {
    constructor(state, drawBuffer, primType, vertexInfo, dataLow, dataHigh, indexLow, indexHigh) {
      this.drawBuffer = drawBuffer;
      this.primType = primType;
      this.dataLow = dataLow;
      this.dataHigh = dataHigh;
      this.indexLow = indexLow;
      this.indexHigh = indexHigh;
      this.textureData = null;
      this.clutData = null;
      this.stateData = state.readData();
      this.indexCount = this.indexHigh - this.indexLow;
      if (vertexInfo.hasTexture) {
        const mipmap = state.texture.mipmaps[0];
        this.textureData = memory.getPointerU8Array(mipmap.address, mipmap.sizeInBytes);
        if (state.texture.hasClut) {
          const clut = state.texture.clut;
          this.clutData = memory.getPointerU8Array(clut.address, clut.sizeInBytes);
        }
      }
    }
  };

  // src/core/gpu/gpu_core.ts
  var optimizedDrawBuffer = new OptimizedDrawBuffer();
  var PrimDrawType;
  (function(PrimDrawType2) {
    PrimDrawType2[PrimDrawType2["SINGLE_DRAW"] = 0] = "SINGLE_DRAW";
    PrimDrawType2[PrimDrawType2["BATCH_DRAW"] = 1] = "BATCH_DRAW";
    PrimDrawType2[PrimDrawType2["BATCH_DRAW_DEGENERATE"] = 2] = "BATCH_DRAW_DEGENERATE";
  })(PrimDrawType || (PrimDrawType = {}));
  var DRAW_TYPE_CONV = [
    1,
    1,
    2,
    1,
    2,
    0,
    1
  ];
  function param32(p, offset) {
    return p >> offset & 7;
  }
  function param162(p, offset) {
    return p >> offset & 65535;
  }
  function param242(p) {
    return p & 16777215;
  }
  function float12(p) {
    return MathFloat.reinterpretIntAsFloat(p << 8);
  }
  var dumpFrameCommands = false;
  var dumpFrameCommandsList = [];
  var PspGpuList = class {
    constructor(id, stats, memory2, runner, gpu, cpuExecutor, state) {
      this.id = id;
      this.stats = stats;
      this.memory = memory2;
      this.runner = runner;
      this.gpu = gpu;
      this.cpuExecutor = cpuExecutor;
      this.state = state;
      this.current4 = 0;
      this.stall4 = 0;
      this.callbackId = 0;
      this.completed = false;
      this.status = DisplayListStatus.Paused;
      this.errorCount = 0;
      this.callstack = new Int32Array(1024);
      this.callstackIndex = 0;
      this.primBatchPrimitiveType = -1;
      this.batchPrimCount = 0;
      this.showOpcodes = false;
      this.opcodes = [];
      this.vertexInfo = new VertexInfo();
      this.vertexInfo2 = new VertexInfo();
    }
    complete() {
      this.completed = true;
      this.runner.deallocate(this);
      this.promiseResolve(0);
    }
    finishPrimBatch() {
      if (optimizedDrawBuffer.hasElements) {
        this.batchPrimCount = 0;
        const batch = optimizedDrawBuffer.createBatch(this.state, this.primBatchPrimitiveType, this.vertexInfo);
        this.gpu.queueBatch(batch);
        if (dumpFrameCommands)
          dumpFrameCommandsList.push(`<BATCH:${batch.indexCount}>`);
        this.primBatchPrimitiveType = -1;
        this.stats.batchCount++;
      }
    }
    finish() {
    }
    get isStalled() {
      return this.stall4 != 0 && this.current4 >= this.stall4;
    }
    get hasMoreInstructions() {
      return !this.completed && !this.isStalled;
    }
    gpuHang() {
      console.error("GPU hang!");
      debugger;
    }
    runUntilStallInner() {
      let memory2 = this.memory;
      let stall4 = this.stall4;
      let state = this.state;
      let totalCommandsLocal = 0;
      let current4 = this.current4;
      let localPrimCount = 0;
      let stats = this.stats;
      if (stall4 == 0)
        stall4 = 2147483647;
      loop:
        while (current4 < stall4) {
          totalCommandsLocal++;
          let instructionPC4 = current4++;
          let instruction = memory2.lw_2(instructionPC4);
          let op = instruction >> 24 & 255;
          let p = instruction & 16777215;
          if (totalCommandsLocal >= 3e4) {
            this.gpuHang();
            totalCommandsLocal = 0;
            break;
          }
          if (dumpFrameCommands) {
            dumpFrameCommandsList.push(`${GpuOpCodes[op]}:${addressToHex(p)}`);
          }
          switch (op) {
            case GpuOpCodes.PRIM: {
              const rprimCount = 0;
              this.current4 = current4;
              localPrimCount++;
              let primitiveType = param32(p, 16);
              if (this.primBatchPrimitiveType != primitiveType)
                this.finishPrimBatch();
              if (this.prim(param242(p)) == PrimAction.FLUSH_PRIM) {
                this.finishPrimBatch();
              }
              current4 = this.current4;
              break;
            }
            case GpuOpCodes.BEZIER:
              this.finishPrimBatch();
              this.bezier(param242(p));
              break;
            case GpuOpCodes.END:
              this.finishPrimBatch();
              this.gpu.end();
              this.complete();
              break loop;
            case GpuOpCodes.TFLUSH:
              this.gpu.textureFlush(state);
              this.finishPrimBatch();
              break;
            case GpuOpCodes.TSYNC:
              this.gpu.textureSync(state);
              break;
            case GpuOpCodes.NOP:
              break;
            case GpuOpCodes.DUMMY:
              break;
            case GpuOpCodes.JUMP:
            case GpuOpCodes.CALL:
              if (op == GpuOpCodes.CALL) {
                this.callstack[this.callstackIndex++] = (instructionPC4 << 2) + 4;
                this.callstack[this.callstackIndex++] = state.baseOffset >>> 2 & Memory.MASK;
              }
              current4 = this.state.baseAddress + (param242(p) & ~3) >> 2 & Memory.MASK;
              break;
            case GpuOpCodes.RET:
              if (this.callstackIndex > 0 && this.callstackIndex < 1024) {
                state.baseOffset = this.callstack[--this.callstackIndex];
                current4 = this.callstack[--this.callstackIndex] >>> 2 & Memory.MASK;
              } else {
                console.info("gpu callstack empty or overflow");
              }
              break;
            case GpuOpCodes.FINISH: {
              this.finish();
              let callback = this.gpu.callbacks.get(this.callbackId);
              if (callback && callback.cpuState && callback.finishFunction) {
                this.cpuExecutor.execute(callback.cpuState, callback.finishFunction, [param242(p), callback.finishArgument]);
              }
              break;
            }
            case GpuOpCodes.SIGNAL:
              console.warn("Not implemented: GPU SIGNAL");
              break;
            case GpuOpCodes.PROJMATRIXDATA:
              state.writeFloat(GpuOpCodes.PROJMATRIXNUMBER, GpuOpCodes.MAT_PROJ, float12(p));
              break;
            case GpuOpCodes.VIEWMATRIXDATA:
              state.writeFloat(GpuOpCodes.VIEWMATRIXNUMBER, GpuOpCodes.MAT_VIEW, float12(p));
              break;
            case GpuOpCodes.WORLDMATRIXDATA:
              state.writeFloat(GpuOpCodes.WORLDMATRIXNUMBER, GpuOpCodes.MAT_WORLD, float12(p));
              break;
            case GpuOpCodes.BONEMATRIXDATA:
              state.writeFloat(GpuOpCodes.BONEMATRIXNUMBER, GpuOpCodes.MAT_BONES, float12(p));
              break;
            case GpuOpCodes.TGENMATRIXDATA:
              state.writeFloat(GpuOpCodes.TGENMATRIXNUMBER, GpuOpCodes.MAT_TEXTURE, float12(p));
              break;
            case GpuOpCodes.BASE:
            case GpuOpCodes.IADDR:
            case GpuOpCodes.VADDR:
            case GpuOpCodes.OFFSETADDR:
              break;
            default:
              if (state.data[op] != p)
                this.finishPrimBatch();
              break;
          }
          state.data[op] = p;
        }
      this.current4 = current4;
      this.stats.totalStalls++;
      this.stats.primCount = localPrimCount;
      this.stats.totalCommands += totalCommandsLocal;
      this.status = this.isStalled ? DisplayListStatus.Stalling : DisplayListStatus.Completed;
    }
    prim(p) {
      const vertexCount = param162(p, 0);
      const primitiveType = param32(p, 16);
      if (vertexCount <= 0)
        return PrimAction.NOTHING;
      const memory2 = this.memory;
      const state = this.state;
      const stats = this.stats;
      const vertexInfo = this.vertexInfo.setState(this.state);
      const vertexSize = vertexInfo.size;
      const vertexAddress = state.getAddressRelativeToBaseOffset(vertexInfo.address);
      const indicesAddress = state.getAddressRelativeToBaseOffset(state.indexAddress);
      const hasIndices = vertexInfo.index != IndexEnum.Void;
      if (hasIndices) {
        stats.indexCount++;
      } else {
        stats.nonIndexCount++;
      }
      this.primBatchPrimitiveType = primitiveType;
      switch (primitiveType) {
        case PrimitiveType.Triangles:
          stats.trianglePrimCount++;
          break;
        case PrimitiveType.TriangleStrip:
          stats.triangleStripPrimCountalue++;
          break;
        case PrimitiveType.Sprites:
          stats.spritePrimCount++;
          break;
        default:
          stats.otherPrimCount++;
          break;
      }
      const vertexInput = this.memory.getPointerU8Array(vertexAddress);
      const drawType = DRAW_TYPE_CONV[primitiveType];
      const optimized = vertexInfo.realMorphingVertexCount == 1;
      if (vertexInfo.realMorphingVertexCount != 1) {
        throw new Error("@TODO: Morphing not implemented!");
      }
      switch (vertexInfo.index) {
        case IndexEnum.Void:
          this.primOptimizedNoIndex(primitiveType, drawType == 2, vertexSize, vertexInfo, vertexInput);
          break;
        case IndexEnum.Byte:
        case IndexEnum.Short:
          if (primitiveType == PrimitiveType.Sprites) {
            throw new Error("@TODO: Sprites with indices not implemented!");
          }
          let totalVertices = 0;
          if (vertexInfo.index == IndexEnum.Byte) {
            totalVertices = optimizedDrawBuffer.addVerticesIndicesList(this.memory.getPointerU8Array(indicesAddress, vertexCount));
          } else {
            totalVertices = optimizedDrawBuffer.addVerticesIndicesList(this.memory.getPointerU16Array(indicesAddress, vertexCount * 2));
          }
          optimizedDrawBuffer.addVerticesData(vertexInput, totalVertices * vertexSize);
          return PrimAction.FLUSH_PRIM;
      }
      return drawType == 0 ? PrimAction.FLUSH_PRIM : PrimAction.NOTHING;
    }
    primOptimizedNoIndex(primitiveType, drawTypeDegenerated, vertexSize, vertexInfo, vertexInput) {
      let current4 = this.current4 - 1 | 0;
      let batchPrimCount = this.batchPrimCount | 0;
      const _optimizedDrawBuffer = optimizedDrawBuffer;
      let p2 = 0;
      let vertex2Count = 0;
      const memory2 = this.memory;
      let totalVertexCount = 0;
      const isSprite = primitiveType == PrimitiveType.Sprites;
      primitiveType |= 0;
      vertexSize |= 0;
      while (true) {
        p2 = memory2.lw_2(current4) | 0;
        if ((p2 >> 24 & 255) != GpuOpCodes.PRIM || param32(p2, 16) != primitiveType)
          break;
        vertex2Count = param162(p2, 0) | 0;
        totalVertexCount += vertex2Count;
        if (isSprite) {
          _optimizedDrawBuffer.addVerticesIndicesSprite(vertex2Count);
        } else {
          if (drawTypeDegenerated && batchPrimCount > 0)
            _optimizedDrawBuffer.join(vertexSize);
          _optimizedDrawBuffer.addVerticesIndices(vertex2Count);
        }
        current4++;
        batchPrimCount++;
      }
      this.stats.vertexCount += totalVertexCount;
      let totalVerticesSize = totalVertexCount * vertexSize;
      if (isSprite) {
        _optimizedDrawBuffer.addVerticesDataSprite(vertexInput, totalVerticesSize, totalVertexCount, vertexInfo);
      } else {
        _optimizedDrawBuffer.addVerticesData(vertexInput, totalVerticesSize);
      }
      vertexInfo.address += totalVerticesSize;
      this.state.vertex.address = vertexInfo.address;
      this.batchPrimCount = batchPrimCount;
      this.current4 = current4;
    }
    bezier(p) {
    }
    runUntilStall() {
      this.status = DisplayListStatus.Drawing;
      while (this.hasMoreInstructions) {
        this.runUntilStallInner();
      }
    }
    enqueueRunUntilStall() {
      Microtask.queue(() => {
        this.runUntilStall();
      });
    }
    updateStall(stall) {
      this.stall4 = stall >>> 2 & Memory.MASK;
      this.enqueueRunUntilStall();
    }
    start() {
      this.status = DisplayListStatus.Queued;
      this.promise = new PromiseFast((resolve, reject) => {
        this.promiseResolve = resolve;
        this.promiseReject = reject;
      });
      this.completed = false;
      this.enqueueRunUntilStall();
    }
    waitAsync() {
      return this.promise;
    }
  };
  var PspGpuListRunner = class {
    constructor(memory2, stats, gpu, callbackManager) {
      this.memory = memory2;
      this.stats = stats;
      this.gpu = gpu;
      this.callbackManager = callbackManager;
      this.lists = [];
      this.freeLists = [];
      this.runningLists = [];
      this.state = new GpuState();
      for (let n = 0; n < 32; n++) {
        const list = new PspGpuList(n, stats, memory2, this, gpu, callbackManager, this.state);
        this.lists.push(list);
        this.freeLists.push(list);
      }
    }
    allocate() {
      if (!this.freeLists.length)
        throw new Error("Out of gpu free lists");
      const list = this.freeLists.pop();
      this.runningLists.push(list);
      return list;
    }
    getById(id) {
      return this.lists[id];
    }
    deallocate(list) {
      this.freeLists.push(list);
      this.runningLists.remove(list);
    }
    peek() {
      const _peek = () => {
        for (let n = 0; n < this.runningLists.length; n++) {
          const list = this.runningLists[n];
          if (list.status != DisplayListStatus.Completed)
            return list.status;
        }
        return DisplayListStatus.Completed;
      };
      const result = _peek();
      console.warn(`not implemented gpu list peeking -> ${result}`);
      return result;
    }
    waitAsync() {
      return PromiseFast.all(this.runningLists.map((list) => list.waitAsync())).thenFast(() => DisplayListStatus.Completed);
    }
  };
  var PspGpuCallback = class {
    constructor(cpuState, signalFunction, signalArgument, finishFunction, finishArgument) {
      this.cpuState = cpuState;
      this.signalFunction = signalFunction;
      this.signalArgument = signalArgument;
      this.finishFunction = finishFunction;
      this.finishArgument = finishArgument;
    }
  };
  var PspGpu = class {
    constructor(memory2, display, cpuExecutor, stats) {
      this.memory = memory2;
      this.display = display;
      this.cpuExecutor = cpuExecutor;
      this.stats = stats;
      this.callbacks = new UidCollection(1);
      this.batches = [];
      this.onDrawBatches = new Signal2();
      this.wv = new WatchValue(false);
      this.freezing = new WatchValue(false);
      this.lastTime = 0;
      this.listRunner = new PspGpuListRunner(memory2, this.stats, this, this.cpuExecutor);
    }
    dumpCommands() {
      dumpFrameCommands = true;
    }
    register() {
    }
    unregister() {
      this.onDrawBatches.clear();
    }
    listEnqueue(start, stall, callbackId, argsPtr) {
      const list = this.listRunner.allocate();
      list.current4 = start >>> 2 & Memory.MASK;
      list.stall4 = stall;
      list.callbackId = callbackId;
      list.argsPtr = argsPtr;
      list.start();
      return list.id;
    }
    listSync(displayListId, syncType) {
      return this.listRunner.getById(displayListId).waitAsync();
    }
    updateStallAddr(displayListId, stall) {
      this.listRunner.getById(displayListId).updateStall(stall);
      return 0;
    }
    end() {
    }
    textureFlush(state) {
    }
    textureSync(state) {
    }
    queueBatch(batch) {
      this.batches.push(batch);
    }
    flushCommands() {
      if (!dumpFrameCommands || dumpFrameCommandsList.length == 0)
        return;
      console.info("-----------------------------------------------");
      dumpFrameCommands = false;
      const list = [];
      function flushBuffer() {
        if (list.length == 0)
          return;
        console.log(list.join(", "));
        list.length = 0;
      }
      for (let item of dumpFrameCommandsList) {
        if (item.startsWith("<BATCH")) {
          flushBuffer();
          console.warn(item);
        } else {
          list.push(item);
          if (item.startsWith("PRIM"))
            flushBuffer();
        }
      }
      flushBuffer();
      dumpFrameCommandsList.length = 0;
    }
    sync() {
      this.wv.value = true;
    }
    drawSync(syncType) {
      return this.listRunner.waitAsync().thenFast(() => {
        this.flushCommands();
        try {
          const end = performance.now();
          this.stats.timePerFrame = MathUtils.interpolate(this.stats.timePerFrame, end - this.lastTime, 0.5);
          this.lastTime = end;
          this.stats.updateAndReset();
          this.wv.value = false;
          this.onDrawBatches.dispatch(optimizedDrawBuffer, this.batches);
          optimizedDrawBuffer.reset();
          this.batches = [];
          return this.wv.waitUntilValueAsync(true).thenFast(() => {
            return this.freezing.waitUntilValueAsync(false);
          });
        } catch (e) {
          EmulatorUI.openMessageAsync(e.stack || e);
          throw e;
        }
      });
    }
  };
  var PrimAction;
  (function(PrimAction2) {
    PrimAction2[PrimAction2["NOTHING"] = 0] = "NOTHING";
    PrimAction2[PrimAction2["FLUSH_PRIM"] = 1] = "FLUSH_PRIM";
  })(PrimAction || (PrimAction = {}));

  // src/hle/module/sceGe_user.ts
  var sceGe_user = class {
    constructor(context) {
      this.context = context;
      this.eDRAMMemoryWidth = 0;
    }
    sceGeEdramSetAddrTranslation(size) {
      try {
        return this.eDRAMMemoryWidth;
      } finally {
        this.eDRAMMemoryWidth = size;
      }
    }
    sceGeSetCallback(thread, callbackDataPtr) {
      const callbacks = this.context.gpu.callbacks;
      const info = CallbackData.struct.read(callbackDataPtr);
      return callbacks.allocate(new PspGpuCallback(thread.state, info.signalFunction, info.signalArgument, info.finishFunction, info.finishArgument));
    }
    sceGeUnsetCallback(callbackId) {
      this.context.gpu.callbacks.remove(callbackId);
      return 0;
    }
    sceGeListEnQueue(start, stall, callbackId, argsPtr) {
      return this.context.gpu.listEnqueue(start, stall, callbackId, argsPtr);
    }
    sceGeListSync(displayListId, syncType) {
      return this.context.gpu.listSync(displayListId, syncType);
    }
    sceGeListUpdateStallAddr(displayListId, stall) {
      return this.context.gpu.updateStallAddr(displayListId, stall);
    }
    sceGeDrawSync(syncType) {
      const result = this.context.gpu.drawSync(syncType);
      if (PromiseFast.isPromise(result)) {
        return new WaitingThreadInfo("sceGeDrawSync", this.context.gpu, result, AcceptCallbacks.NO, Compensate.YES);
      } else {
        return result;
      }
    }
    sceGeContinue() {
      return -1;
    }
    sceGeBreak(mode, breakAddress) {
      return -1;
    }
    sceGeEdramGetAddr() {
      return 67108864;
    }
    sceGeEdramGetSize() {
      return 2097152;
    }
  };
  __decorate([
    nativeFunction(3078161898, 150),
    U32,
    __param(0, I32)
  ], sceGe_user.prototype, "sceGeEdramSetAddrTranslation", 1);
  __decorate([
    nativeFunction(2767980196, 150),
    U32,
    __param(0, THREAD),
    __param(1, PTR)
  ], sceGe_user.prototype, "sceGeSetCallback", 1);
  __decorate([
    nativeFunction(98247374, 150),
    U32,
    __param(0, I32)
  ], sceGe_user.prototype, "sceGeUnsetCallback", 1);
  __decorate([
    nativeFunction(2873747306, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, I32),
    __param(3, PTR)
  ], sceGe_user.prototype, "sceGeListEnQueue", 1);
  __decorate([
    nativeFunction(54808244, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceGe_user.prototype, "sceGeListSync", 1);
  __decorate([
    nativeFunction(3772154184, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceGe_user.prototype, "sceGeListUpdateStallAddr", 1);
  __decorate([
    nativeFunction(2995240289, 150),
    U32,
    __param(0, I32)
  ], sceGe_user.prototype, "sceGeDrawSync", 1);
  __decorate([
    nativeFunction(1275520114, 150),
    U32
  ], sceGe_user.prototype, "sceGeContinue", 1);
  __decorate([
    nativeFunction(3024677901, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceGe_user.prototype, "sceGeBreak", 1);
  __decorate([
    nativeFunction(3833479396, 150),
    U32
  ], sceGe_user.prototype, "sceGeEdramGetAddr", 1);
  __decorate([
    nativeFunction(526865069, 150),
    U32
  ], sceGe_user.prototype, "sceGeEdramGetSize", 1);
  var CallbackData = class extends Struct {
    constructor() {
      super(...arguments);
      this.signalFunction = 0;
      this.signalArgument = 0;
      this.finishFunction = 0;
      this.finishArgument = 0;
    }
  };
  __decorate([
    StructUInt32
  ], CallbackData.prototype, "signalFunction", 2);
  __decorate([
    StructUInt32
  ], CallbackData.prototype, "signalArgument", 2);
  __decorate([
    StructUInt32
  ], CallbackData.prototype, "finishFunction", 2);
  __decorate([
    StructUInt32
  ], CallbackData.prototype, "finishArgument", 2);

  // src/hle/module/sceHprm.ts
  var sceHprm_exports = {};
  __export(sceHprm_exports, {
    sceHprm: () => sceHprm
  });
  var sceHprm = class {
    constructor(context) {
      this.context = context;
    }
    sceHprmPeekCurrentKey(PspHprmKeysEnumKeyPtr) {
      PspHprmKeysEnumKeyPtr.writeInt32(0);
      return 0;
    }
  };
  __decorate([
    nativeFunction(420524839, 150),
    U32,
    __param(0, PTR)
  ], sceHprm.prototype, "sceHprmPeekCurrentKey", 1);

  // src/hle/module/sceHttp.ts
  var sceHttp_exports = {};
  __export(sceHttp_exports, {
    sceHttp: () => sceHttp
  });
  var sceHttp = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceParseHttp.ts
  var sceParseHttp_exports = {};
  __export(sceParseHttp_exports, {
    sceParseHttp: () => sceParseHttp
  });
  var sceParseHttp = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceParseUri.ts
  var sceParseUri_exports = {};
  __export(sceParseUri_exports, {
    sceParseUri: () => sceParseUri
  });
  var sceParseUri = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceImpose.ts
  var sceImpose_exports = {};
  __export(sceImpose_exports, {
    sceImpose: () => sceImpose
  });
  var sceImpose = class {
    constructor(context) {
      this.context = context;
    }
    sceImposeGetBatteryIconStatus(isChargingPointer, iconStatusPointer) {
      isChargingPointer.writeInt32(this.context.battery.chargingType);
      iconStatusPointer.writeInt32(this.context.battery.iconStatus);
      return 0;
    }
    sceImposeSetLanguageMode(language, buttonPreference) {
      this.context.config.language = language;
      this.context.config.buttonPreference = buttonPreference;
      return 0;
    }
    sceImposeGetLanguageMode(languagePtr, buttonPreferencePtr) {
      languagePtr.writeUInt32(this.context.config.language);
      buttonPreferencePtr.writeUInt32(this.context.config.buttonPreference);
      return 0;
    }
  };
  __decorate([
    nativeFunction(2358522257, 150),
    U32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceImpose.prototype, "sceImposeGetBatteryIconStatus", 1);
  __decorate([
    nativeFunction(917139089, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], sceImpose.prototype, "sceImposeSetLanguageMode", 1);
  __decorate([
    nativeFunction(620592079, 150),
    U32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceImpose.prototype, "sceImposeGetLanguageMode", 1);

  // src/hle/module/sceLibFont.ts
  var sceLibFont_exports = {};
  __export(sceLibFont_exports, {
    sceLibFont: () => sceLibFont
  });
  var sceLibFont = class {
    constructor(context) {
      this.context = context;
      this.fontLibUid = new UidCollection(1);
      this.fontUid = new UidCollection(1);
    }
    sceFontNewLib(paramsPtr, errorCodePtr) {
      const fontLib = new FontLib();
      return this.fontLibUid.allocate(fontLib);
    }
    sceFontFindOptimumFont(fontLibId, fontStylePointer, errorCodePointer) {
      const fontLib = this.fontLibUid.get(fontLibId);
      return 0;
    }
    sceFontOpen(fontLibId, index, mode, errorCodePointer) {
      const fontLib = this.fontLibUid.get(fontLibId);
      return this.fontUid.allocate(new Font());
    }
    sceFontGetFontInfo(fontId, fontInfoPointer) {
      const font = this.fontUid.get(fontId);
      return 0;
    }
    sceFontSetResolution(fontLibId, horizontalResolution, verticalResolution) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(1743879895, 150),
    U32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceLibFont.prototype, "sceFontNewLib", 1);
  __decorate([
    nativeFunction(161411900, 150),
    U32,
    __param(0, U32),
    __param(1, PTR),
    __param(2, PTR)
  ], sceLibFont.prototype, "sceFontFindOptimumFont", 1);
  __decorate([
    nativeFunction(2821992861, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], sceLibFont.prototype, "sceFontOpen", 1);
  __decorate([
    nativeFunction(229069662, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceLibFont.prototype, "sceFontGetFontInfo", 1);
  __decorate([
    nativeFunction(1210659456, 150),
    U32,
    __param(0, I32),
    __param(1, F32),
    __param(2, F32)
  ], sceLibFont.prototype, "sceFontSetResolution", 1);
  var FontLib = class {
  };
  var Font = class {
  };

  // src/hle/module/sceMp3.ts
  var sceMp3_exports = {};
  __export(sceMp3_exports, {
    sceMp3: () => sceMp3
  });
  var sceMp3 = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceMpeg.ts
  var sceMpeg_exports = {};
  __export(sceMpeg_exports, {
    sceMpeg: () => sceMpeg
  });
  var ENABLE = false;
  var _sceMpeg = class {
    constructor(context) {
      this.context = context;
      this.mode = 0;
      this.pixelformat = PixelFormat.RGBA_8888;
      this.mpegs = new Map();
    }
    sceMpegInit() {
      return ENABLE ? 0 : -1;
    }
    sceMpegFinish() {
      return 0;
    }
    _sceMpegReadField(name2, bufferAddr, output, readField) {
      const buffer = this.context.memory.getPointerStream(bufferAddr);
      console.log(`${name2}: ${addressToHex(bufferAddr)}`);
      const pmf = PmfStruct.struct.createProxy(buffer);
      if (pmf.magic != "PSMF") {
        debugger;
        return SceKernelErrors.ERROR_MPEG_INVALID_VALUE;
      }
      const result = readField(pmf);
      output.writeInt32(result);
      console.log(`--> ${result}`);
      return 0;
    }
    sceMpegQueryStreamOffset(mpegAddr, bufferAddr, output) {
      if (!this.isValidMpeg(mpegAddr))
        return -1;
      return this._sceMpegReadField("sceMpegQueryStreamOffset", bufferAddr, output, (p) => p.offset);
    }
    sceMpegQueryStreamSize(bufferAddr, output) {
      return this._sceMpegReadField("sceMpegQueryStreamSize", bufferAddr, output, (p) => p.size);
    }
    sceMpegAvcDecodeMode(mpegAddr, modeAddr) {
      if (!this.isValidMpeg(mpegAddr))
        return -1;
      const mode = SceMpegAvcMode.struct.createProxy(modeAddr);
      this.mode = mode.mode;
      if (mode.pixelformat >= PixelFormat.RGBA_5650 && mode.pixelformat <= PixelFormat.RGBA_8888) {
        this.pixelformat = mode.pixelformat;
      } else {
        console.warn(`sceMpegAvcDecodeMode(${mode.mode}, ${mode.pixelformat}) invalid pixelformat`);
      }
      return 0;
    }
    sceMpegMallocAvcEsBuf(mpegAddr) {
      if (!this.isValidMpeg(mpegAddr))
        return -1;
      const mpeg = this.mpegs.get(mpegAddr);
      return mpeg.allocAvcEsBuf();
    }
    sceMpegInitAu(mpegAddr, bufferAddr, auPointer) {
      const au = SceMpegAu.struct.createProxy(auPointer);
      au.esBuffer = bufferAddr;
      au.esSize = 2112;
      au.pts = Integer64.fromNumber(0);
      au.dts = Integer64.fromNumber(0);
      return 0;
    }
    sceMpegQueryAtracEsSize(mpegAddr, esSizeAddr, outSizeAddr) {
      esSizeAddr.writeInt32(2112);
      outSizeAddr.writeInt32(8192);
      return 0;
    }
    sceMpegRegistStream(mpegAddr, streamType, streamNum) {
      if (!this.isValidMpeg(mpegAddr))
        return -1;
      const mpeg = this.mpegs.get(mpegAddr);
      return mpeg.registerStream(streamType, streamNum);
    }
    sceMpegQueryMemSize(mode) {
      return _sceMpeg.MPEG_MEMSIZE;
    }
    isValidMpeg(mpegAddr) {
      return this.mpegs.has(mpegAddr);
    }
    sceMpegCreate(mpegAddr, dataPtr, size, ringbufferAddr, mode, ddrTop) {
      if (!this.context.memory.isValidAddress(mpegAddr))
        return -1;
      if (size < _sceMpeg.MPEG_MEMSIZE)
        return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
      if (ringbufferAddr == Stream.INVALID) {
        const ringBuffer = RingBuffer.struct.createProxy(ringbufferAddr.clone());
        if (ringBuffer.packetSize == 0) {
          ringBuffer.packetsAvail = 0;
        } else {
          ringBuffer.packetsAvail = (ringBuffer.dataUpperBound - ringBuffer.data) / ringBuffer.packetSize;
        }
        ringBuffer.mpeg = mpegAddr;
      }
      const mpeg = this.context.memory.getPointerStream(mpegAddr);
      mpeg.writeInt32(dataPtr + 48);
      const mpegHandle = this.context.memory.getPointerStream(dataPtr + 48);
      mpegHandle.writeString("LIBMPEG\x00001\0");
      mpegHandle.writeInt32(-1);
      this.mpegs.set(mpegAddr, this.mpeg = new Mpeg());
    }
    sceMpegDelete(sceMpegPointer) {
      return 0;
    }
    sceMpegRingbufferAvailableSize(rinbuggerAddr) {
      const ringbuffer = RingBuffer.struct.createProxy(rinbuggerAddr);
      return ringbuffer.packets - ringbuffer.packetsAvail;
    }
    sceMpegRingbufferQueryMemSize(numberOfPackets) {
      return (_sceMpeg.RING_BUFFER_PACKET_SIZE + 104) * numberOfPackets;
    }
    sceMpegRingbufferConstruct(ringbufferAddr, numPackets, data, size, callbackAddr, callbackArg) {
      if (ringbufferAddr == Stream.INVALID)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ADDR;
      if (size < 0)
        return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
      if (this.__mpegRingbufferQueryMemSize(numPackets) > size) {
        if (numPackets < 1048576) {
          return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
        } else {
        }
      }
      const buf = RingBuffer.struct.createProxy(ringbufferAddr);
      buf.packets = numPackets;
      buf.packetsRead = 0;
      buf.packetsWritten = 0;
      buf.packetsAvail = 0;
      buf.packetSize = 2048;
      buf.data = data;
      buf.callback_addr = callbackAddr;
      buf.callback_args = callbackArg;
      buf.dataUpperBound = data + numPackets * 2048;
      buf.semaID = 0;
      buf.mpeg = 0;
    }
    sceMpegRingbufferDestruct(ringBufferPointer) {
      return 0;
    }
    _mpegRingbufferRead() {
    }
    sceMpegRingbufferPut(ringbufferAddr, numPackets, available) {
      const state = this.context.currentState;
      this._mpegRingbufferRead();
      numPackets = Math.min(numPackets, available);
      if (numPackets <= 0) {
        debugger;
        return 0;
      }
      const ringbuffer = RingBuffer.struct.createProxy(ringbufferAddr.clone());
      if (ringbuffer.callback_addr != 0) {
        const packetsThisRound = Math.min(numPackets, ringbuffer.packets);
        this.context.interop.execute(state, ringbuffer.callback_addr, [
          ringbuffer.data,
          packetsThisRound,
          ringbuffer.callback_args
        ]);
        console.log(state.V0);
      } else {
        console.warn("sceMpegRingbufferPut: callback_addr zero");
        debugger;
      }
      this.mpeg.addData(this.context.memory.getPointerU8Array(ringbuffer.data, ringbuffer.packetSize));
      return state.V0;
    }
    __mpegRingbufferQueryMemSize(packets) {
      return packets * (104 + 2048);
    }
  };
  var sceMpeg = _sceMpeg;
  sceMpeg.RING_BUFFER_PACKET_SIZE = 2048;
  sceMpeg.MPEG_MEMSIZE = 64 * 1024;
  __decorate([
    nativeFunction(1747607963, 150),
    U32
  ], sceMpeg.prototype, "sceMpegInit", 1);
  __decorate([
    nativeFunction(2269521110, 150),
    U32
  ], sceMpeg.prototype, "sceMpegFinish", 1);
  __decorate([
    nativeFunction(570392804, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, PTR)
  ], sceMpeg.prototype, "sceMpegQueryStreamOffset", 1);
  __decorate([
    nativeFunction(1629396497, 150),
    U32,
    __param(0, U32),
    __param(1, PTR)
  ], sceMpeg.prototype, "sceMpegQueryStreamSize", 1);
  __decorate([
    nativeFunction(2702995494, 150),
    U32,
    __param(0, U32),
    __param(1, PTR)
  ], sceMpeg.prototype, "sceMpegAvcDecodeMode", 1);
  __decorate([
    nativeFunction(2810236798, 150),
    U32,
    __param(0, U32)
  ], sceMpeg.prototype, "sceMpegMallocAvcEsBuf", 1);
  __decorate([
    nativeFunction(377159070, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, PTR)
  ], sceMpeg.prototype, "sceMpegInitAu", 1);
  __decorate([
    nativeFunction(4175214201, 150),
    U32,
    __param(0, U32),
    __param(1, PTR),
    __param(2, PTR)
  ], sceMpeg.prototype, "sceMpegQueryAtracEsSize", 1);
  __decorate([
    nativeFunction(1112936227, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, U32)
  ], sceMpeg.prototype, "sceMpegRegistStream", 1);
  __decorate([
    nativeFunction(3241337391, 150),
    U32,
    __param(0, I32)
  ], sceMpeg.prototype, "sceMpegQueryMemSize", 1);
  __decorate([
    nativeFunction(3636850977, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, U32),
    __param(3, PTR),
    __param(4, U32),
    __param(5, U32)
  ], sceMpeg.prototype, "sceMpegCreate", 1);
  __decorate([
    nativeFunction(1617577545, 150),
    U32,
    __param(0, I32)
  ], sceMpeg.prototype, "sceMpegDelete", 1);
  __decorate([
    nativeFunction(3052854407, 150),
    U32,
    __param(0, PTR)
  ], sceMpeg.prototype, "sceMpegRingbufferAvailableSize", 1);
  __decorate([
    nativeFunction(3617759046, 150),
    U32,
    __param(0, I32)
  ], sceMpeg.prototype, "sceMpegRingbufferQueryMemSize", 1);
  __decorate([
    nativeFunction(925458136, 150),
    U32,
    __param(0, PTR),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32)
  ], sceMpeg.prototype, "sceMpegRingbufferConstruct", 1);
  __decorate([
    nativeFunction(322993939, 150),
    U32,
    __param(0, I32)
  ], sceMpeg.prototype, "sceMpegRingbufferDestruct", 1);
  __decorate([
    nativeFunction(2990581150, 150),
    U32,
    __param(0, PTR),
    __param(1, U32),
    __param(2, U32)
  ], sceMpeg.prototype, "sceMpegRingbufferPut", 1);
  var StreamType;
  (function(StreamType2) {
    StreamType2[StreamType2["Avc"] = 0] = "Avc";
    StreamType2[StreamType2["Atrac"] = 1] = "Atrac";
    StreamType2[StreamType2["Pcm"] = 2] = "Pcm";
    StreamType2[StreamType2["Data"] = 3] = "Data";
    StreamType2[StreamType2["Audio"] = 15] = "Audio";
  })(StreamType || (StreamType = {}));
  var MeStream = class {
    static openData(data) {
      throw new ProgramExitException("Unimplemented MeStream");
    }
  };
  var Mpeg = class {
    constructor() {
      this.streamIdGen = 1;
      this.avcEsBuf = 1;
      MeStream.openData(new Uint8Array(1024));
    }
    addData(data) {
    }
    registerStream(type, num) {
      return this.streamIdGen++;
    }
    allocAvcEsBuf() {
      return this.avcEsBuf++;
    }
  };
  var SceMpegAvcMode = class extends Struct {
    constructor() {
      super(...arguments);
      this.mode = 0;
      this.pixelformat = 0;
    }
  };
  __decorate([
    StructInt32
  ], SceMpegAvcMode.prototype, "mode", 2);
  __decorate([
    StructInt32
  ], SceMpegAvcMode.prototype, "pixelformat", 2);
  var SceMpegAu = class extends Struct {
    constructor() {
      super(...arguments);
      this.pts = Integer64.ZERO;
      this.dts = Integer64.ZERO;
      this.esBuffer = 0;
      this.esSize = 0;
    }
  };
  __decorate([
    StructInt64
  ], SceMpegAu.prototype, "pts", 2);
  __decorate([
    StructInt64
  ], SceMpegAu.prototype, "dts", 2);
  __decorate([
    StructUInt32
  ], SceMpegAu.prototype, "esBuffer", 2);
  __decorate([
    StructUInt32
  ], SceMpegAu.prototype, "esSize", 2);
  var PmfStruct = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = "";
      this.version = 0;
      this.offset = 0;
      this.size = 0;
      this._unknown = 0;
      this.firstTimestampOffset = "";
      this.lastTimestampOffset = "";
    }
  };
  __decorate([
    StructStructStringn(4)
  ], PmfStruct.prototype, "magic", 2);
  __decorate([
    StructUInt32
  ], PmfStruct.prototype, "version", 2);
  __decorate([
    StructUInt32
  ], PmfStruct.prototype, "offset", 2);
  __decorate([
    StructUInt32
  ], PmfStruct.prototype, "size", 2);
  __decorate([
    StructStructStringn(68)
  ], PmfStruct.prototype, "_unknown", 2);
  __decorate([
    StructStructStringn(6)
  ], PmfStruct.prototype, "firstTimestampOffset", 2);
  __decorate([
    StructStructStringn(6)
  ], PmfStruct.prototype, "lastTimestampOffset", 2);
  var RingBuffer = class extends Struct {
    constructor() {
      super(...arguments);
      this.packets = 0;
      this.packetsRead = 0;
      this.packetsWritten = 0;
      this.packetsAvail = 0;
      this.packetSize = 0;
      this.data = 0;
      this.callback_addr = 0;
      this.callback_args = 0;
      this.dataUpperBound = 0;
      this.semaID = 0;
      this.mpeg = 0;
      this.gp = 0;
    }
  };
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "packets", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "packetsRead", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "packetsWritten", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "packetsAvail", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "packetSize", 2);
  __decorate([
    StructUInt32_l
  ], RingBuffer.prototype, "data", 2);
  __decorate([
    StructUInt32_l
  ], RingBuffer.prototype, "callback_addr", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "callback_args", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "dataUpperBound", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "semaID", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "mpeg", 2);
  __decorate([
    StructInt32_l
  ], RingBuffer.prototype, "gp", 2);

  // src/hle/module/sceNet.ts
  var sceNet_exports = {};
  __export(sceNet_exports, {
    sceNet: () => sceNet
  });
  var sceNet = class {
    constructor(context) {
      this.context = context;
    }
    sceNetInit(memoryPoolSize, calloutprio, calloutstack, netintrprio, netintrstack) {
      this.context.container["mac"] = new Uint8Array(xrange(0, 6).map((index) => Math.random() * 255));
      return 0;
    }
    sceNetTerm() {
      return 0;
    }
    sceNetFreeThreadinfo(threadId) {
      throw new Error("Not implemented");
    }
    sceNetThreadAbort(threadId) {
      throw new Error("Not implemented");
    }
    sceNetEtherStrton(string, mac) {
      mac.set(string2mac(string));
      return 0;
    }
    sceNetEtherNtostr(mac, outputAddress) {
      outputAddress.writeStringz(mac2string(mac));
      return 0;
    }
    sceNetGetLocalEtherAddr(macOut) {
      console.info("sceNetGetLocalEtherAddr: ", mac2string(this.context.netManager.mac));
      macOut.set(this.context.netManager.mac);
      return 0;
    }
    sceNetGetMallocStat(statPtr) {
      throw new Error("Not implemented");
    }
  };
  __decorate([
    nativeFunction(967784870, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32)
  ], sceNet.prototype, "sceNetInit", 1);
  __decorate([
    nativeFunction(672737449, 150),
    I32
  ], sceNet.prototype, "sceNetTerm", 1);
  __decorate([
    nativeFunction(1348760880, 150),
    I32,
    __param(0, I32)
  ], sceNet.prototype, "sceNetFreeThreadinfo", 1);
  __decorate([
    nativeFunction(2909291718, 150),
    I32,
    __param(0, I32)
  ], sceNet.prototype, "sceNetThreadAbort", 1);
  __decorate([
    nativeFunction(3531170249, 150),
    I32,
    __param(0, STRING),
    __param(1, FBYTES(6))
  ], sceNet.prototype, "sceNetEtherStrton", 1);
  __decorate([
    nativeFunction(2302019920, 150),
    I32,
    __param(0, FBYTES(6)),
    __param(1, PTR)
  ], sceNet.prototype, "sceNetEtherNtostr", 1);
  __decorate([
    nativeFunction(200319918, 150),
    I32,
    __param(0, FBYTES(6))
  ], sceNet.prototype, "sceNetGetLocalEtherAddr", 1);
  __decorate([
    nativeFunction(3426303560, 150),
    I32,
    __param(0, PTR)
  ], sceNet.prototype, "sceNetGetMallocStat", 1);

  // src/hle/module/sceNetAdhoc.ts
  var sceNetAdhoc_exports = {};
  __export(sceNetAdhoc_exports, {
    Pdp: () => Pdp,
    sceNetAdhoc: () => sceNetAdhoc
  });
  var sceNetAdhoc = class {
    constructor(context) {
      this.context = context;
      this.pdps = new UidCollection(1);
    }
    sceNetAdhocInit() {
      this.partition = this.context.memoryManager.kernelPartition.allocateLow(16384);
      return 0;
    }
    sceNetAdhocTerm() {
      this.partition.deallocate();
      return 0;
    }
    sceNetAdhocPollSocket(socketAddress, int, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPollSocket");
    }
    sceNetAdhocPdpCreate(mac, port, bufsize, unk1) {
      const pdp = new Pdp(this.context, mac, port, bufsize);
      pdp.id = this.pdps.allocate(pdp);
      return pdp.id;
    }
    sceNetAdhocPdpDelete(pdpId, unk1) {
      const pdp = this.pdps.get(pdpId);
      pdp.dispose();
      this.pdps.remove(pdpId);
      return 0;
    }
    sceNetAdhocPdpSend(pdpId, destMac, port, dataStream, timeout, nonblock) {
      const pdp = this.pdps.get(pdpId);
      const data = dataStream.readBytes(dataStream.length);
      pdp.send(port, destMac, data);
      return 0;
    }
    async sceNetAdhocPdpRecv(pdpId, srcMac, portPtr, data, dataLengthPtr, timeout, nonblock) {
      const block = !nonblock;
      const pdp = this.pdps.get(pdpId);
      const recvOne = (chunk) => {
        srcMac.set(chunk.mac);
        data.writeBytes(chunk.payload);
        portPtr.writeInt16(pdp.port);
        dataLengthPtr.writeInt32(chunk.payload.length);
        return 0;
      };
      if (block) {
        const data2 = await pdp.recvOneAsync();
        return recvOne(data2);
      } else {
        if (pdp.chunks.length <= 0)
          return 2151745289;
        return recvOne(pdp.chunks.shift());
      }
    }
    sceNetAdhocGetPdpStat(sizeStream, pdpStatStruct) {
      const maxSize = sizeStream.sliceWithLength(0).readInt32();
      const pdps = this.pdps.list();
      const totalSize = pdps.length * PdpStatStruct.struct.length;
      sizeStream.sliceWithLength(0).writeInt32(totalSize);
      const pos = 0;
      pdps.forEach((pdp) => {
        const stat = new PdpStatStruct();
        stat.nextPointer = 0;
        stat.pdpId = pdp.id;
        stat.port = pdp.port;
        stat.mac = xrange(0, 6).map((index) => pdp.mac[index]);
        stat.rcvdData = pdp.getDataLength();
        PdpStatStruct.struct.write(pdpStatStruct, stat);
      });
      return 0;
    }
    sceNetAdhocGameModeCreateMaster(data) {
      throw new Error("Not implemented sceNetAdhocGameModeCreateMaster");
    }
    sceNetAdhocGameModeCreateReplica(mac, data) {
      throw new Error("Not implemented sceNetAdhocGameModeCreateReplica");
    }
    sceNetAdhocGameModeUpdateMaster() {
      throw new Error("Not implemented sceNetAdhocGameModeUpdateMaster");
    }
    sceNetAdhocGameModeUpdateReplica(id, unk1) {
      throw new Error("Not implemented sceNetAdhocGameModeUpdateReplica");
    }
    sceNetAdhocGameModeDeleteMaster() {
      throw new Error("Not implemented sceNetAdhocGameModeDeleteMaster");
    }
    sceNetAdhocGameModeDeleteReplica(id) {
      throw new Error("Not implemented sceNetAdhocGameModeDeleteReplica");
    }
    sceNetAdhocPtpOpen(srcmac, srcport, destmac, destport, bufsize, delay2, count, unk1) {
      throw new Error("Not implemented sceNetAdhocPtpOpen");
    }
    sceNetAdhocPtpListen(srcmac, srcport, bufsize, delay2, count, queue, unk1) {
      throw new Error("Not implemented sceNetAdhocPtpListen");
    }
    sceNetAdhocPtpConnect(id, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPtpConnect");
    }
    sceNetAdhocPtpAccept(id, data, datasize, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPtpAccept");
    }
    sceNetAdhocPtpSend(id, data, datasize, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPtpSend");
    }
    sceNetAdhocPtpRecv(id, data, datasize, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPtpRecv");
    }
    sceNetAdhocPtpFlush(id, timeout, nonblock) {
      throw new Error("Not implemented sceNetAdhocPtpFlush");
    }
    sceNetAdhocPtpClose(id, unk1) {
      throw new Error("Not implemented sceNetAdhocPtpClose");
    }
    sceNetAdhocGetPtpStat(size, stat) {
      throw new Error("Not implemented sceNetAdhocGetPtpStat");
    }
  };
  __decorate([
    nativeFunction(3788906967, 150),
    I32
  ], sceNetAdhoc.prototype, "sceNetAdhocInit", 1);
  __decorate([
    nativeFunction(2787929943, 150),
    I32
  ], sceNetAdhoc.prototype, "sceNetAdhocTerm", 1);
  __decorate([
    nativeFunction(2053516651, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPollSocket", 1);
  __decorate([
    nativeFunction(1871868955, 150),
    I32,
    __param(0, FBYTES(6)),
    __param(1, I32),
    __param(2, U32),
    __param(3, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPdpCreate", 1);
  __decorate([
    nativeFunction(2133310302, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPdpDelete", 1);
  __decorate([
    nativeFunction(2884450192, 150),
    I32,
    __param(0, I32),
    __param(1, FBYTES(6)),
    __param(2, I32),
    __param(3, FBYTES(6)),
    __param(4, I32),
    __param(5, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPdpSend", 1);
  __decorate([
    nativeFunction(3756342787, 150),
    I32,
    __param(0, I32),
    __param(1, FBYTES(6)),
    __param(2, PTR),
    __param(3, PTR),
    __param(4, PTR),
    __param(5, I32),
    __param(6, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPdpRecv", 1);
  __decorate([
    nativeFunction(3351379031, 150),
    I32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceNetAdhoc.prototype, "sceNetAdhocGetPdpStat", 1);
  __decorate([
    nativeFunction(2138424120, 150),
    I32,
    __param(0, BYTES)
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeCreateMaster", 1);
  __decorate([
    nativeFunction(846768908, 150),
    I32,
    __param(0, FBYTES(6)),
    __param(1, BYTES)
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeCreateReplica", 1);
  __decorate([
    nativeFunction(2562852040, 150),
    I32
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeUpdateMaster", 1);
  __decorate([
    nativeFunction(4197600078, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeUpdateReplica", 1);
  __decorate([
    nativeFunction(2686620514, 150),
    I32
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeDeleteMaster", 1);
  __decorate([
    nativeFunction(186788073, 150),
    I32,
    __param(0, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocGameModeDeleteReplica", 1);
  __decorate([
    nativeFunction(2273275238, 150),
    I32,
    __param(0, FBYTES(6)),
    __param(1, I32),
    __param(2, PTR),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, I32),
    __param(7, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpOpen", 1);
  __decorate([
    nativeFunction(3767261889, 150),
    I32,
    __param(0, FBYTES(6)),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpListen", 1);
  __decorate([
    nativeFunction(4235182203, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpConnect", 1);
  __decorate([
    nativeFunction(2650280344, 150),
    I32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, I32),
    __param(4, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpAccept", 1);
  __decorate([
    nativeFunction(1302644616, 150),
    I32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, I32),
    __param(4, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpSend", 1);
  __decorate([
    nativeFunction(2347379518, 150),
    I32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, PTR),
    __param(3, I32),
    __param(4, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpRecv", 1);
  __decorate([
    nativeFunction(2596466348, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpFlush", 1);
  __decorate([
    nativeFunction(360604197, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], sceNetAdhoc.prototype, "sceNetAdhocPtpClose", 1);
  __decorate([
    nativeFunction(3110621464, 150),
    I32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceNetAdhoc.prototype, "sceNetAdhocGetPtpStat", 1);
  var Pdp = class {
    constructor(context, mac, port, bufsize) {
      this.context = context;
      this.mac = mac;
      this.port = port;
      this.bufsize = bufsize;
      this.id = 0;
      this.chunks = [];
      this.onChunkRecv = new Signal0();
      this.onMessageCancel = this.context.netManager.onmessage(port).add((packet) => {
        this.chunks.push(packet);
        this.onChunkRecv.dispatch();
      });
    }
    recvOneAsync() {
      return new PromiseFast((resolve, reject) => {
        this.onChunkRecv.once(() => {
          resolve(this.chunks.shift());
        });
      });
    }
    send(port, destMac, data) {
      this.context.netManager.send(port, "sceNetAdhocPdpSend", destMac, data);
    }
    getDataLength() {
      return this.chunks.sum((chunk) => chunk.payload.length);
    }
    dispose() {
      if (this.onMessageCancel) {
        this.onMessageCancel.cancel();
        this.onMessageCancel = null;
      }
    }
  };
  var PdpStatStruct = class extends Struct {
    constructor() {
      super(...arguments);
      this.nextPointer = 0;
      this.pdpId = 0;
      this.mac = [0, 0, 0, 0, 0, 0];
      this.port = 0;
      this.rcvdData = 0;
    }
  };
  __decorate([
    StructUInt32
  ], PdpStatStruct.prototype, "nextPointer", 2);
  __decorate([
    StructInt32
  ], PdpStatStruct.prototype, "pdpId", 2);
  __decorate([
    StructStructArray(Int8, 6)
  ], PdpStatStruct.prototype, "mac", 2);
  __decorate([
    StructInt16
  ], PdpStatStruct.prototype, "port", 2);
  __decorate([
    StructUInt32
  ], PdpStatStruct.prototype, "rcvdData", 2);

  // src/hle/module/sceNetAdhocctl.ts
  var sceNetAdhocctl_exports = {};
  __export(sceNetAdhocctl_exports, {
    sceNetAdhocctl: () => sceNetAdhocctl
  });
  var sceNetAdhocctl = class {
    constructor(context) {
      this.context = context;
      this.currentState = State.Disconnected;
      this.currentName = "noname";
      this.connectHandlers = [];
      this.handlers = new UidCollection(1);
    }
    sceNetAdhocctlInit(stacksize, priority, product) {
      this.currentState = State.Disconnected;
      return 0;
    }
    sceNetAdhocctlTerm() {
      return 0;
    }
    sceNetAdhocctlConnect(name2) {
      this.currentName = name2;
      this.connectHandlers.push(this.context.netManager.onopen.add(() => {
        this.currentState = State.Connected;
        this._notifyAdhocctlHandler(Event.Connected);
      }));
      this.connectHandlers.push(this.context.netManager.onclose.add(() => {
        this.currentState = State.Disconnected;
        this._notifyAdhocctlHandler(Event.Disconnected);
      }));
      if (this.context.netManager.connected) {
        this.currentState = State.Connected;
        this._notifyAdhocctlHandler(Event.Connected);
      }
      this.context.netManager.connectOnce();
      return 0;
    }
    sceNetAdhocctlDisconnect() {
      while (this.connectHandlers.length)
        this.connectHandlers.shift().cancel();
      return 0;
    }
    sceNetAdhocctlAddHandler(callback, parameter) {
      return this.handlers.allocate(new HandlerCallback(callback, parameter));
    }
    sceNetAdhocctlDelHandler(handler) {
      this.handlers.remove(handler);
      return 0;
    }
    sceNetAdhocctlGetState(stateOut) {
      stateOut.writeInt32(this.currentState);
      return 0;
    }
    _notifyAdhocctlHandler(event, error = 0) {
      this.handlers.list().forEach((callback) => {
        this.context.callbackManager.executeLater(callback.callback, [event, error, callback.argument]);
      });
    }
  };
  __decorate([
    nativeFunction(3798934126, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR)
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlInit", 1);
  __decorate([
    nativeFunction(2640879123, 150),
    I32
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlTerm", 1);
  __decorate([
    nativeFunction(181421037, 150),
    I32,
    __param(0, STRING)
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlConnect", 1);
  __decorate([
    nativeFunction(876617061, 150),
    I32
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlDisconnect", 1);
  __decorate([
    nativeFunction(548607904, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlAddHandler", 1);
  __decorate([
    nativeFunction(1677871371, 150),
    I32,
    __param(0, I32)
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlDelHandler", 1);
  __decorate([
    nativeFunction(1978454918, 150),
    I32,
    __param(0, PTR)
  ], sceNetAdhocctl.prototype, "sceNetAdhocctlGetState", 1);
  var HandlerCallback = class {
    constructor(callback, argument) {
      this.callback = callback;
      this.argument = argument;
    }
  };
  var State;
  (function(State3) {
    State3[State3["Disconnected"] = 0] = "Disconnected";
    State3[State3["Connected"] = 1] = "Connected";
    State3[State3["Scan"] = 2] = "Scan";
    State3[State3["Game"] = 3] = "Game";
    State3[State3["Discover"] = 4] = "Discover";
    State3[State3["Wol"] = 5] = "Wol";
  })(State || (State = {}));
  var Mode;
  (function(Mode3) {
    Mode3[Mode3["Normal"] = 0] = "Normal";
    Mode3[Mode3["GameMode"] = 1] = "GameMode";
    Mode3[Mode3["None"] = -1] = "None";
  })(Mode || (Mode = {}));
  var Event;
  (function(Event3) {
    Event3[Event3["Error"] = 0] = "Error";
    Event3[Event3["Connected"] = 1] = "Connected";
    Event3[Event3["Disconnected"] = 2] = "Disconnected";
    Event3[Event3["Scan"] = 3] = "Scan";
    Event3[Event3["Game"] = 4] = "Game";
    Event3[Event3["Discover"] = 5] = "Discover";
    Event3[Event3["Wol"] = 6] = "Wol";
    Event3[Event3["WolInterrupted"] = 7] = "WolInterrupted";
  })(Event || (Event = {}));

  // src/hle/module/sceNetAdhocMatching.ts
  var sceNetAdhocMatching_exports = {};
  __export(sceNetAdhocMatching_exports, {
    Event: () => Event2,
    Matching: () => Matching,
    Mode: () => Mode2,
    State: () => State2,
    sceNetAdhocMatching: () => sceNetAdhocMatching
  });
  var sceNetAdhocMatching = class {
    constructor(context) {
      this.context = context;
      this.poolStat = {size: 0, maxsize: 0, freesize: 0};
      this.matchings = new UidCollection(1);
    }
    sceNetAdhocMatchingInit(memSize) {
      this.poolStat.size = memSize;
      this.poolStat.maxsize = memSize;
      this.poolStat.freesize = memSize;
      return 0;
    }
    sceNetAdhocMatchingTerm() {
      return 0;
    }
    sceNetAdhocMatchingCreate(thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback) {
      const matching = new Matching(this.context, thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback);
      matching.id = this.matchings.allocate(matching);
      return matching.id;
    }
    sceNetAdhocMatchingSelectTarget(matchingId, macStream, dataLength, dataPointer) {
      const matching = this.matchings.get(matchingId);
      const mac = macStream.readBytes(6);
      matching.selectTarget(mac, dataPointer && dataLength ? dataPointer.readBytes(dataLength) : null);
      return 0;
    }
    sceNetAdhocMatchingCancelTarget(matchingId, mac) {
      const matching = this.matchings.get(matchingId);
      matching.cancelTarget(mac.readBytes(6));
      return 0;
    }
    sceNetAdhocMatchingDelete(matchingId) {
      this.matchings.remove(matchingId);
      return 0;
    }
    sceNetAdhocMatchingStart(matchingId, evthPri, evthStack, inthPri, inthStack, optLen, optData) {
      const matching = this.matchings.get(matchingId);
      matching.hello = optData.readBytes(optLen);
      matching.start();
      return 0;
    }
    sceNetAdhocMatchingStop(matchingId) {
      const matching = this.matchings.get(matchingId);
      matching.stop();
      return 0;
    }
  };
  __decorate([
    nativeFunction(707403271, 150),
    I32,
    __param(0, I32)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingInit", 1);
  __decorate([
    nativeFunction(2034625754, 150),
    I32
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingTerm", 1);
  __decorate([
    nativeFunction(3395213935, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, I32),
    __param(7, I32),
    __param(8, I32),
    __param(9, U32)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingCreate", 1);
  __decorate([
    nativeFunction(1581075321, 150),
    I32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, I32),
    __param(3, PTR)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingSelectTarget", 1);
  __decorate([
    nativeFunction(3929825544, 150),
    I32,
    __param(0, I32),
    __param(1, PTR)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingCancelTarget", 1);
  __decorate([
    nativeFunction(4050562895, 150),
    I32,
    __param(0, I32)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingDelete", 1);
  __decorate([
    nativeFunction(2481928259, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, PTR)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingStart", 1);
  __decorate([
    nativeFunction(850482867, 150),
    I32,
    __param(0, I32)
  ], sceNetAdhocMatching.prototype, "sceNetAdhocMatchingStop", 1);
  var State2;
  (function(State3) {
    State3[State3["START"] = 0] = "START";
    State3[State3["JOIN_WAIT_RESPONSE"] = 1] = "JOIN_WAIT_RESPONSE";
    State3[State3["JOIN_WAIT_COMPLETE"] = 2] = "JOIN_WAIT_COMPLETE";
    State3[State3["COMPLETED"] = 3] = "COMPLETED";
  })(State2 || (State2 = {}));
  var _Matching = class {
    constructor(context, thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback) {
      this.context = context;
      this.thread = thread;
      this.mode = mode;
      this.maxPeers = maxPeers;
      this.port = port;
      this.bufSize = bufSize;
      this.helloDelay = helloDelay;
      this.pingDelay = pingDelay;
      this.initCount = initCount;
      this.msgDelay = msgDelay;
      this.callback = callback;
      this.id = 0;
      this.joinMac = "00:00:00:00:00:00";
      this.mac = new Uint8Array([1, 2, 3, 4, 5, 6]);
      this.hello = new Uint8Array(0);
      this.helloTimer = -1;
      this.dataTimer = -1;
      this.onMessageCancelable = null;
      this.state = 0;
    }
    sendHello() {
      if (this.state != 0)
        return;
      this.sendMessage(Event2.Hello, _Matching.MAC_ALL, this.hello);
    }
    start() {
      this.onMessageCancelable = this.context.netManager.onmessage(this.port).add((packet) => {
        this.notify(Event2[packet.type], packet.mac, packet.payload);
      });
      this.helloTimer = setInterval(() => {
        this.sendHello();
      }, this.helloDelay / 1e3);
      this.sendHello();
      this.dataTimer = setInterval(() => {
      }, this.msgDelay / 1e3);
    }
    stop() {
      clearInterval(this.helloTimer);
      clearInterval(this.dataTimer);
      if (this.onMessageCancelable) {
        this.onMessageCancelable.cancel();
        this.onMessageCancelable = null;
      }
    }
    selectTarget(mac, data) {
      const macstr = mac2string(mac);
      console.info("net.adhoc: selectTarget", macstr);
      if (this.state == 1 && macstr == this.joinMac) {
        this.state = 2;
        this.sendMessage(Event2.Accept, mac, data);
      } else {
        this.state = 1;
        this.sendMessage(Event2.Join, mac, data);
      }
    }
    cancelTarget(mac) {
      const macstr = mac2string(mac);
      console.info("net.adhoc: cancelTarget", macstr);
      this.state = 0;
      this.sendMessage(Event2.Cancel, mac, null);
    }
    sendMessage(event, tomac, data) {
      if (!data)
        data = new Uint8Array(0);
      if (event != Event2.Hello) {
        console.info("net.adhoc: send ->", Event2[event], event, ":", mac2string(tomac), ":", Stream.fromUint8Array(data).readString(data.length));
      }
      this.context.netManager.send(this.port, Event2[event], tomac, data);
    }
    notify(event, frommac, data) {
      if (!data)
        data = new Uint8Array(0);
      if (event != Event2.Hello) {
        console.info("net.adhoc: received <-", Event2[event], event, ":", mac2string(frommac), ":", Stream.fromUint8Array(data).readString(data.length));
      }
      switch (event) {
        case Event2.Join:
          this.state = 1;
          this.joinMac = mac2string(frommac);
          break;
      }
      const macPartition = this.context.memoryManager.kernelPartition.allocateLow(8, "Matching.mac");
      this.context.memory.memset(macPartition.low, 0, macPartition.size);
      this.context.memory.writeUint8Array(macPartition.low, frommac);
      const dataPartition = this.context.memoryManager.kernelPartition.allocateLow(Math.max(8, MathUtils.nextAligned(data.length, 8)), "Matching.data");
      this.context.memory.memset(dataPartition.low, 0, dataPartition.size);
      this.context.memory.writeUint8Array(dataPartition.low, data);
      this.context.callbackManager.executeLater(this.callback, [
        this.id,
        event,
        macPartition.low,
        data.length,
        data.length ? dataPartition.low : 0
      ]);
      dataPartition.deallocate();
      macPartition.deallocate();
      switch (event) {
        case Event2.Accept:
          this.sendMessage(Event2.Complete, frommac, data);
          this.state = 2;
          break;
        case Event2.Complete:
          if (this.state == 2) {
            this.sendMessage(Event2.Complete, frommac, data);
            this.state = 3;
          }
          break;
        case Event2.Data:
          this.sendMessage(Event2.DataConfirm, frommac, null);
          break;
        case Event2.Disconnect:
        case Event2.Left:
          this.state = 0;
          break;
      }
    }
  };
  var Matching = _Matching;
  Matching.MAC_ALL = new Uint8Array([0, 0, 0, 0, 0, 0]);
  var Event2;
  (function(Event3) {
    Event3[Event3["Hello"] = 1] = "Hello";
    Event3[Event3["Join"] = 2] = "Join";
    Event3[Event3["Left"] = 3] = "Left";
    Event3[Event3["Reject"] = 4] = "Reject";
    Event3[Event3["Cancel"] = 5] = "Cancel";
    Event3[Event3["Accept"] = 6] = "Accept";
    Event3[Event3["Complete"] = 7] = "Complete";
    Event3[Event3["Timeout"] = 8] = "Timeout";
    Event3[Event3["Error"] = 9] = "Error";
    Event3[Event3["Disconnect"] = 10] = "Disconnect";
    Event3[Event3["Data"] = 11] = "Data";
    Event3[Event3["DataConfirm"] = 12] = "DataConfirm";
    Event3[Event3["DataTimeout"] = 13] = "DataTimeout";
  })(Event2 || (Event2 = {}));
  var Mode2;
  (function(Mode3) {
    Mode3[Mode3["Host"] = 1] = "Host";
    Mode3[Mode3["Client"] = 2] = "Client";
    Mode3[Mode3["Ptp"] = 3] = "Ptp";
  })(Mode2 || (Mode2 = {}));

  // src/hle/module/sceNetApctl.ts
  var sceNetApctl_exports = {};
  __export(sceNetApctl_exports, {
    sceNetApctl: () => sceNetApctl
  });
  var sceNetApctl = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceNetInet.ts
  var sceNetInet_exports = {};
  __export(sceNetInet_exports, {
    sceNetInet: () => sceNetInet
  });
  var sceNetInet = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceNetResolver.ts
  var sceNetResolver_exports = {};
  __export(sceNetResolver_exports, {
    sceNetResolver: () => sceNetResolver
  });
  var sceNetResolver = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceNp.ts
  var sceNp_exports = {};
  __export(sceNp_exports, {
    sceNp: () => sceNp
  });
  var sceNp = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceNpAuth.ts
  var sceNpAuth_exports = {};
  __export(sceNpAuth_exports, {
    sceNpAuth: () => sceNpAuth
  });
  var sceNpAuth = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceNpService.ts
  var sceNpService_exports = {};
  __export(sceNpService_exports, {
    sceNpService: () => sceNpService
  });
  var sceNpService = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceOpenPSID.ts
  var sceOpenPSID_exports = {};
  __export(sceOpenPSID_exports, {
    sceOpenPSID: () => sceOpenPSID
  });
  var sceOpenPSID = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/scePower.ts
  var scePower_exports = {};
  __export(scePower_exports, {
    scePower: () => scePower
  });
  var scePower = class {
    constructor(context) {
      this.context = context;
      this.cpuMult = 511;
      this.pllFreq = 222;
      this.busFreq = 111;
    }
    _getCpuMult() {
      return 0.43444227005871 * (this.busFreq / 111);
    }
    _getCpuFreq() {
      return this.cpuMult * this._getCpuMult();
    }
    _setCpuFreq(cpuFreq) {
      if (cpuFreq > 222) {
      } else if (cpuFreq == 222) {
        this.cpuMult = 511;
      } else {
        this.cpuMult = Math.floor(cpuFreq / this._getCpuMult());
      }
    }
    scePowerRegisterCallback(slotIndex, callbackId) {
      this.context.callbackManager.notify(callbackId, CallbackStatus.BATTERY_EXIST);
      return 0;
    }
    scePowerUnregitserCallback(slotIndex) {
      return 0;
    }
    scePowerUnregisterCallback(slotIndex) {
      return 0;
    }
    _isValidCpuFreq(freq) {
      return freq >= 1 && freq <= 222;
    }
    _isValidBusFreq(freq) {
      return freq >= 1 && freq <= 111;
    }
    _isValidPllFreq(freq) {
      return freq >= 19 && freq <= 111;
    }
    _scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq) {
      if (!this._isValidCpuFreq(cpuFreq))
        return SceKernelErrors.ERROR_INVALID_VALUE;
      if (!this._isValidBusFreq(busFreq))
        return SceKernelErrors.ERROR_INVALID_VALUE;
      if (!this._isValidPllFreq(pllFreq))
        return SceKernelErrors.ERROR_INVALID_VALUE;
      this.pllFreq = pllFreq;
      this._setCpuFreq(cpuFreq);
      this.busFreq = busFreq;
      return 0;
    }
    scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq) {
      return this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
    }
    scePowerSetClockFrequency2(pllFreq, cpuFreq, busFreq) {
      return this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
    }
    scePowerSetClockFrequency3(pllFreq, cpuFreq, busFreq) {
      return this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
    }
    scePowerGetCpuClockFrequency() {
      return this._getCpuFreq();
    }
    scePowerGetCpuClockFrequencyInt() {
      return this._getCpuFreq();
    }
    scePowerGetCpuClockFrequencyFloat() {
      return this._getCpuFreq();
    }
    scePowerGetBusClockFrequency() {
      return this.busFreq;
    }
    scePowerGetBusClockFrequencyInt() {
      return this.busFreq;
    }
    scePowerGetBusClockFrequencyFloat() {
      return this.busFreq;
    }
    scePowerGetPllClockFrequencyInt() {
      return this.pllFreq;
    }
    scePowerGetPllClockFrequencyFloat() {
      return this.pllFreq;
    }
    scePowerSetBusClockFrequency(busFreq) {
      if (!this._isValidBusFreq(busFreq))
        return SceKernelErrors.ERROR_INVALID_VALUE;
      this.busFreq = 111;
      return 0;
    }
    scePowerSetCpuClockFrequency(cpuFreq) {
      if (!this._isValidCpuFreq(cpuFreq))
        return SceKernelErrors.ERROR_INVALID_VALUE;
      this._setCpuFreq(cpuFreq);
      return 0;
    }
    scePowerGetBatteryLifePercent() {
      return this.context.battery.level * 100 | 0;
    }
    scePowerIsPowerOnline() {
      return +this.context.battery.charging;
    }
    scePowerIsBatteryExist() {
      return 1;
    }
    scePowerIsLowBattery() {
      return +this.context.battery.isLowBattery;
    }
    scePowerIsBatteryCharging() {
      return +this.context.battery.charging;
    }
    scePowerGetBatteryLifeTime() {
      return this.context.battery.lifetime / 60 | 0;
    }
    scePowerGetBatteryVolt() {
      return 4135;
    }
    scePowerGetBatteryTemp() {
      return 28;
    }
    scePowerLock(unknown) {
      return 0;
    }
    scePowerUnlock(unknown) {
      return 0;
    }
    scePowerTick(type) {
      return 0;
    }
    scePowerGetBatteryChargingStatus() {
      return PowerFlagsSet.BatteryExists | PowerFlagsSet.AcPower | PowerFlagsSet.BatteryPower;
    }
  };
  __decorate([
    nativeFunction(79132270, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], scePower.prototype, "scePowerRegisterCallback", 1);
  __decorate([
    nativeFunction(3684509917, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerUnregitserCallback", 1);
  __decorate([
    nativeFunction(3752377080, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerUnregisterCallback", 1);
  __decorate([
    nativeFunction(1937016562, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], scePower.prototype, "scePowerSetClockFrequency", 1);
  __decorate([
    nativeFunction(3956373462, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], scePower.prototype, "scePowerSetClockFrequency2", 1);
  __decorate([
    nativeFunction(1184467373, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], scePower.prototype, "scePowerSetClockFrequency3", 1);
  __decorate([
    nativeFunction(4276107823, 150),
    I32
  ], scePower.prototype, "scePowerGetCpuClockFrequency", 1);
  __decorate([
    nativeFunction(4256546793, 150),
    I32
  ], scePower.prototype, "scePowerGetCpuClockFrequencyInt", 1);
  __decorate([
    nativeFunction(2980392067, 150),
    F32
  ], scePower.prototype, "scePowerGetCpuClockFrequencyFloat", 1);
  __decorate([
    nativeFunction(1200613109, 150),
    I32
  ], scePower.prototype, "scePowerGetBusClockFrequency", 1);
  __decorate([
    nativeFunction(3177716073, 150),
    I32
  ], scePower.prototype, "scePowerGetBusClockFrequencyInt", 1);
  __decorate([
    nativeFunction(2611852267, 150),
    F32
  ], scePower.prototype, "scePowerGetBusClockFrequencyFloat", 1);
  __decorate([
    nativeFunction(888783971, 150),
    I32
  ], scePower.prototype, "scePowerGetPllClockFrequencyInt", 1);
  __decorate([
    nativeFunction(3929549351, 150),
    F32
  ], scePower.prototype, "scePowerGetPllClockFrequencyFloat", 1);
  __decorate([
    nativeFunction(3101144059, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerSetBusClockFrequency", 1);
  __decorate([
    nativeFunction(2218770243, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerSetCpuClockFrequency", 1);
  __decorate([
    nativeFunction(545640797, 150),
    I32
  ], scePower.prototype, "scePowerGetBatteryLifePercent", 1);
  __decorate([
    nativeFunction(2269384542, 150),
    I32
  ], scePower.prototype, "scePowerIsPowerOnline", 1);
  __decorate([
    nativeFunction(184356235, 150),
    I32
  ], scePower.prototype, "scePowerIsBatteryExist", 1);
  __decorate([
    nativeFunction(3540474150, 150),
    I32
  ], scePower.prototype, "scePowerIsLowBattery", 1);
  __decorate([
    nativeFunction(508101633, 150),
    I32
  ], scePower.prototype, "scePowerIsBatteryCharging", 1);
  __decorate([
    nativeFunction(2398830498, 150),
    I32
  ], scePower.prototype, "scePowerGetBatteryLifeTime", 1);
  __decorate([
    nativeFunction(1211951211, 150),
    I32
  ], scePower.prototype, "scePowerGetBatteryVolt", 1);
  __decorate([
    nativeFunction(685842467, 150),
    I32
  ], scePower.prototype, "scePowerGetBatteryTemp", 1);
  __decorate([
    nativeFunction(3603961583, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerLock", 1);
  __decorate([
    nativeFunction(3393008833, 150),
    I32,
    __param(0, I32)
  ], scePower.prototype, "scePowerUnlock", 1);
  __decorate([
    nativeFunction(4023634275, 150),
    I32
  ], scePower.prototype, "scePowerTick", 1);
  __decorate([
    nativeFunction(3024301e3, 150),
    I32
  ], scePower.prototype, "scePowerGetBatteryChargingStatus", 1);
  var CallbackStatus;
  (function(CallbackStatus2) {
    CallbackStatus2[CallbackStatus2["AC_POWER"] = 4096] = "AC_POWER";
    CallbackStatus2[CallbackStatus2["BATTERY_EXIST"] = 128] = "BATTERY_EXIST";
    CallbackStatus2[CallbackStatus2["BATTERY_FULL"] = 100] = "BATTERY_FULL";
  })(CallbackStatus || (CallbackStatus = {}));
  var PowerFlagsSet;
  (function(PowerFlagsSet2) {
    PowerFlagsSet2[PowerFlagsSet2["PowerSwitch"] = 2147483648] = "PowerSwitch";
    PowerFlagsSet2[PowerFlagsSet2["HoldSwitch"] = 1073741824] = "HoldSwitch";
    PowerFlagsSet2[PowerFlagsSet2["StandBy"] = 524288] = "StandBy";
    PowerFlagsSet2[PowerFlagsSet2["ResumeComplete"] = 262144] = "ResumeComplete";
    PowerFlagsSet2[PowerFlagsSet2["Resuming"] = 131072] = "Resuming";
    PowerFlagsSet2[PowerFlagsSet2["Suspending"] = 65536] = "Suspending";
    PowerFlagsSet2[PowerFlagsSet2["AcPower"] = 4096] = "AcPower";
    PowerFlagsSet2[PowerFlagsSet2["BatteryLow"] = 256] = "BatteryLow";
    PowerFlagsSet2[PowerFlagsSet2["BatteryExists"] = 128] = "BatteryExists";
    PowerFlagsSet2[PowerFlagsSet2["BatteryPower"] = 127] = "BatteryPower";
  })(PowerFlagsSet || (PowerFlagsSet = {}));

  // src/hle/module/scePspNpDrm_user.ts
  var scePspNpDrm_user_exports = {};
  __export(scePspNpDrm_user_exports, {
    scePspNpDrm_user: () => scePspNpDrm_user
  });
  var scePspNpDrm_user = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceReg.ts
  var sceReg_exports = {};
  __export(sceReg_exports, {
    sceReg: () => sceReg
  });
  var sceReg = class {
    constructor(context) {
      this.context = context;
    }
    sceRegOpenRegistry(regParamPtr, mode, regHandlePtr) {
      const regParam = RegParam.struct.read(regParamPtr);
      console.warn(`sceRegOpenRegistry: ${regParam.name}`);
      regHandlePtr.writeInt32(0);
      return 0;
    }
    sceRegOpenCategory(regHandle, name2, mode, regCategoryHandlePtr) {
      console.warn(`sceRegOpenCategory: ${name2}`);
      return 0;
    }
    sceRegGetKeyInfo(categoryHandle, name2, regKeyHandlePtr, regKeyTypesPtr, sizePtr) {
      console.warn(`sceRegGetKeyInfo: ${name2}`);
      return 0;
    }
    sceRegGetKeyValue(categoryHandle, regKeyHandle, bufferPtr, size) {
      console.warn("sceRegGetKeyValue");
      return 0;
    }
    sceRegFlushCategory(categoryHandle) {
      console.warn("sceRegFlushCategory");
      return 0;
    }
    sceRegCloseCategory(categoryHandle) {
      console.warn("sceRegCloseCategory");
      return 0;
    }
    sceRegFlushRegistry(regHandle) {
      console.warn("sceRegFlushRegistry");
      return 0;
    }
    sceRegCloseRegistry(regHandle) {
      console.warn("sceRegCloseRegistry");
      return 0;
    }
  };
  __decorate([
    nativeFunction(2464420480, 150),
    I32,
    __param(0, PTR),
    __param(1, I32),
    __param(2, PTR)
  ], sceReg.prototype, "sceRegOpenRegistry", 1);
  __decorate([
    nativeFunction(495613486, 150),
    I32,
    __param(0, I32),
    __param(1, STRING),
    __param(2, I32),
    __param(3, PTR)
  ], sceReg.prototype, "sceRegOpenCategory", 1);
  __decorate([
    nativeFunction(3561446056, 150),
    I32,
    __param(0, I32),
    __param(1, STRING),
    __param(2, PTR),
    __param(3, PTR),
    __param(4, PTR)
  ], sceReg.prototype, "sceRegGetKeyInfo", 1);
  __decorate([
    nativeFunction(682158474, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR),
    __param(3, I32)
  ], sceReg.prototype, "sceRegGetKeyValue", 1);
  __decorate([
    nativeFunction(225034048, 150),
    I32,
    __param(0, I32)
  ], sceReg.prototype, "sceRegFlushCategory", 1);
  __decorate([
    nativeFunction(212763435, 150),
    I32,
    __param(0, I32)
  ], sceReg.prototype, "sceRegCloseCategory", 1);
  __decorate([
    nativeFunction(960895821, 150),
    I32,
    __param(0, I32)
  ], sceReg.prototype, "sceRegFlushRegistry", 1);
  __decorate([
    nativeFunction(4203370297, 150),
    I32,
    __param(0, I32)
  ], sceReg.prototype, "sceRegCloseRegistry", 1);
  var RegParam = class extends Struct {
    constructor() {
      super(...arguments);
      this.regType = 0;
      this.name = "";
      this.nameLength = 0;
      this.unknown2 = 0;
      this.unknown3 = 0;
    }
  };
  __decorate([
    StructUInt32
  ], RegParam.prototype, "regType", 2);
  __decorate([
    StructStructStringz(256)
  ], RegParam.prototype, "name", 2);
  __decorate([
    StructInt32
  ], RegParam.prototype, "nameLength", 2);
  __decorate([
    StructInt32
  ], RegParam.prototype, "unknown2", 2);
  __decorate([
    StructInt32
  ], RegParam.prototype, "unknown3", 2);

  // src/hle/module/sceRtc.ts
  var sceRtc_exports = {};
  __export(sceRtc_exports, {
    sceRtc: () => sceRtc
  });
  var sceRtc = class {
    constructor(context) {
      this.context = context;
    }
    sceRtcGetCurrentTick(tickPtr) {
      tickPtr.writeUInt64(ScePspDateTime.fromDate(new Date()).getTotalMicroseconds());
      return 0;
    }
    sceRtcGetDayOfWeek(year, month, day) {
      return this.context.rtc.getDayOfWeek(year, month, day);
    }
    sceRtcGetDaysInMonth(year, month) {
      return this.context.rtc.getDaysInMonth(year, month);
    }
    sceRtcGetTickResolution(tickPtr) {
      return 1e6;
    }
    sceRtcSetTick(datePtr, ticksPtr) {
      const ticks = ticksPtr.readInt64();
      datePtr.writeStruct(ScePspDateTime.struct, ScePspDateTime.fromTicks(ticks));
      return 0;
    }
    sceRtcGetTick(datePtr, ticksPtr) {
      try {
        const date = ScePspDateTime.struct.read(datePtr);
        ticksPtr.writeUInt64(date.getTotalMicroseconds());
        return 0;
      } catch (e) {
        return SceKernelErrors.ERROR_INVALID_VALUE;
      }
    }
    sceRtcGetCurrentClock(dateAddress, timezone) {
      const date = new Date();
      const pointer = this.context.memory.getPointerPointer(ScePspDateTime.struct, dateAddress);
      pointer.write(ScePspDateTime.fromDate(new Date()));
      return 0;
    }
    sceRtcGetCurrentClockLocalTime(dateAddress) {
      const pointer = this.context.memory.getPointerPointer(ScePspDateTime.struct, dateAddress);
      pointer.write(ScePspDateTime.fromDate(new Date()));
      return 0;
    }
  };
  __decorate([
    nativeFunction(1065015143, 150),
    I32,
    __param(0, PTR)
  ], sceRtc.prototype, "sceRtcGetCurrentTick", 1);
  __decorate([
    nativeFunction(1467116481, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceRtc.prototype, "sceRtcGetDayOfWeek", 1);
  __decorate([
    nativeFunction(99562028, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], sceRtc.prototype, "sceRtcGetDaysInMonth", 1);
  __decorate([
    nativeFunction(3290179667, 150),
    U32,
    __param(0, PTR)
  ], sceRtc.prototype, "sceRtcGetTickResolution", 1);
  __decorate([
    nativeFunction(2127732288, 150),
    I32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceRtc.prototype, "sceRtcSetTick", 1);
  __decorate([
    nativeFunction(1878264524, 150),
    I32,
    __param(0, PTR),
    __param(1, PTR)
  ], sceRtc.prototype, "sceRtcGetTick", 1);
  __decorate([
    nativeFunction(1291474864, 150),
    I32,
    __param(0, U32),
    __param(1, I32)
  ], sceRtc.prototype, "sceRtcGetCurrentClock", 1);
  __decorate([
    nativeFunction(3888282907, 150),
    nativeFunction(2417144128, 660),
    I32,
    __param(0, U32)
  ], sceRtc.prototype, "sceRtcGetCurrentClockLocalTime", 1);

  // src/hle/module/sceSasCore.ts
  var sceSasCore_exports = {};
  __export(sceSasCore_exports, {
    PcmSoundSource: () => PcmSoundSource,
    sceSasCore: () => sceSasCore
  });

  // src/format/vag.ts
  var VAG_f = [0, 0, 60, 0, 115, -52, 98, -55, 122, -60];
  var _VagDecoder = class {
    constructor(blockStream, BlockTotalCount) {
      this.blockStream = blockStream;
      this.BlockTotalCount = BlockTotalCount;
      this.decodedBlockSamples = new Array(_VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK);
      this.predict1 = 0;
      this.predict2 = 0;
      this.sampleIndexInBlock = 0;
      this.sampleIndexInBlock2 = 0;
      this.reachedEnd = false;
      this.loopStack = [];
      this.currentState = new VagState();
      this.currentLoopCount = 0;
      this.totalLoopCount = 0;
      this.sample = new Sample(0, 0);
      this.reset();
    }
    get hasMore() {
      return !this.reachedEnd;
    }
    reset() {
      this.currentState = new VagState();
      this.sampleIndexInBlock = 0;
      this.sampleIndexInBlock2 = 0;
      this.reachedEnd = false;
      this.currentLoopCount = 0;
    }
    setLoopCount(LoopCount) {
      this.currentLoopCount = 0;
      this.totalLoopCount = LoopCount;
    }
    seekNextBlock() {
      if (this.reachedEnd || this.currentState.blockIndex >= this.BlockTotalCount) {
        this.reachedEnd = true;
        return;
      }
      this.blockStream.position = this.currentState.blockIndex * 16;
      this.currentState.blockIndex++;
      const block = this.blockStream.readBytes(16);
      switch (block[1]) {
        case VagBlockType.LOOP_START:
          const copyState = this.currentState.clone();
          copyState.blockIndex--;
          this.loopStack.push(copyState);
          break;
        case VagBlockType.LOOP_END:
          if (this.currentLoopCount++ < this.totalLoopCount) {
            this.currentState = this.loopStack.pop();
          } else {
            this.loopStack.pop();
          }
          break;
        case VagBlockType.END:
          this.reachedEnd = true;
          return;
      }
      this.decodeBlock(block);
    }
    getNextSample() {
      if (this.reachedEnd)
        return this.sample.set(0, 0);
      this.sampleIndexInBlock %= _VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK;
      if (this.sampleIndexInBlock == 0) {
        this.seekNextBlock();
      }
      if (this.reachedEnd)
        return this.sample.set(0, 0);
      const value = this.decodedBlockSamples[this.sampleIndexInBlock++];
      return this.sample.set(value, value);
    }
    decodeBlock(block) {
      let sampleOffset = 0;
      const shiftFactor = BitUtils.extract(block[0], 0, 4);
      const predictIndex = BitUtils.extract(block[0], 4, 4) % VAG_f.length;
      this.predict1 = VAG_f[predictIndex * 2 + 0];
      this.predict2 = VAG_f[predictIndex * 2 + 1];
      for (let n = 0; n < _VagDecoder.COMPRESSED_BYTES_IN_BLOCK; n++) {
        const dataByte = block[n + 2];
        const v1 = MathUtils.sextend16((dataByte >>> 0 & 15) << 12) >> shiftFactor;
        const v2 = MathUtils.sextend16((dataByte >>> 4 & 15) << 12) >> shiftFactor;
        this.decodedBlockSamples[sampleOffset + 0] = this.handleSampleKeepHistory(v1);
        this.decodedBlockSamples[sampleOffset + 1] = this.handleSampleKeepHistory(v2);
        sampleOffset += 2;
      }
    }
    handleSampleKeepHistory(unpackedSample) {
      const sample = this.handleSample(unpackedSample);
      this.currentState.history2 = this.currentState.history1;
      this.currentState.history1 = sample;
      return sample;
    }
    handleSample(unpackedSample) {
      let sample = 0;
      sample += unpackedSample;
      sample += this.currentState.history1 * this.predict1 / 64 >> 0;
      sample += this.currentState.history2 * this.predict2 / 64 >> 0;
      return MathUtils.clamp(sample, -32768, 32767);
    }
  };
  var VagDecoder = _VagDecoder;
  VagDecoder.COMPRESSED_BYTES_IN_BLOCK = 14;
  VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK = _VagDecoder.COMPRESSED_BYTES_IN_BLOCK * 2;
  var VagBlockType;
  (function(VagBlockType2) {
    VagBlockType2[VagBlockType2["LOOP_END"] = 3] = "LOOP_END";
    VagBlockType2[VagBlockType2["LOOP_START"] = 6] = "LOOP_START";
    VagBlockType2[VagBlockType2["END"] = 7] = "END";
  })(VagBlockType || (VagBlockType = {}));
  var VagHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.vagVersion = 0;
      this.dataSize = 0;
      this.sampleRate = 0;
    }
  };
  __decorate([
    StructUInt32
  ], VagHeader.prototype, "magic", 2);
  __decorate([
    StructUInt32_b
  ], VagHeader.prototype, "vagVersion", 2);
  __decorate([
    StructUInt32_b
  ], VagHeader.prototype, "dataSize", 2);
  __decorate([
    StructUInt32_b
  ], VagHeader.prototype, "sampleRate", 2);
  var VagSoundSource = class {
    constructor(stream, loopCount) {
      this.header = null;
      this.samplesCount = 0;
      if (stream.length < 16) {
        this.header = null;
        this.samplesCount = 0;
        this.decoder = new VagDecoder(stream, 0);
      } else {
        const headerStream = stream.sliceWithLength(0, VagHeader.struct.length);
        const dataStream = stream.sliceWithLength(VagHeader.struct.length);
        this.header = VagHeader.struct.read(headerStream);
        this.samplesCount = Math.floor(dataStream.length * 56 / 16);
        this.decoder = new VagDecoder(dataStream, Math.floor(dataStream.length / 16));
      }
    }
    reset() {
      this.decoder.reset();
    }
    get hasMore() {
      return this.decoder.hasMore;
    }
    getNextSample() {
      return this.decoder.getNextSample();
    }
  };
  var VagState = class {
    constructor(blockIndex = 0, history1 = 0, history2 = 0) {
      this.blockIndex = blockIndex;
      this.history1 = history1;
      this.history2 = history2;
    }
    clone() {
      return new VagState(this.blockIndex, this.history1, this.history2);
    }
  };

  // src/hle/module/sceSasCore.ts
  var PSP_SAS_VOL_MAX = 4096;
  var PSP_SAS_PITCH_MIN = 1;
  var PSP_SAS_PITCH_BASE = 4096;
  var PSP_SAS_PITCH_MAX = 16384;
  var _sceSasCore = class {
    constructor(context) {
      this.context = context;
      this.core = new SasCore();
    }
    __sceSasInit(sasCorePointer, grainSamples, maxVoices, outputMode, sampleRate) {
      if (sampleRate != 44100) {
        return SceKernelErrors.ERROR_SAS_INVALID_SAMPLE_RATE;
      }
      if (maxVoices < 1 || maxVoices > _sceSasCore.PSP_SAS_VOICES_MAX) {
        return SceKernelErrors.ERROR_SAS_INVALID_MAX_VOICES;
      }
      if (outputMode != OutputMode.STEREO && outputMode != OutputMode.MULTICHANNEL) {
        return SceKernelErrors.ERROR_SAS_INVALID_OUTPUT_MODE;
      }
      this.core.grainSamples = grainSamples;
      this.core.maxVoices = maxVoices;
      this.core.outputMode = outputMode;
      this.core.sampleRate = sampleRate;
      this.core.initialized = true;
      return 0;
    }
    __sceSasSetGrain(sasCorePointer, grainSamples) {
      this.core.grainSamples = grainSamples;
      return 0;
    }
    __sceSasSetOutputmode(sasCorePointer, outputMode) {
      this.core.outputMode = outputMode;
      return 0;
    }
    __sceSasSetVoice(sasCorePointer, voiceId, data, loop) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      if (data == null) {
        voice.unsetSource();
        return 0;
      }
      if (data.length == 0)
        return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
      if (data.length < 16)
        return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
      if (data.length % 16)
        return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
      if (data == Stream.INVALID)
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      if (loop != 0 && loop != 1)
        return SceKernelErrors.ERROR_SAS_INVALID_LOOP_POS;
      if (data == null) {
        voice.unsetSource();
      } else {
        voice.setAdpcm(data, loop);
      }
      return 0;
    }
    __sceSasSetVoicePCM(sasCorePointer, voiceId, data, loop) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      if (data == null) {
        voice.unsetSource();
      } else {
        voice.setPCM(data, loop);
      }
      return 0;
    }
    __sceSasCoreWithMix(sasCorePointer, sasOut, leftVolume, rightVolume) {
      return this.core.mix(sasCorePointer, sasOut, leftVolume, rightVolume);
    }
    __sceSasCore(sasCorePointer, sasOut) {
      return this.core.mix(sasCorePointer, sasOut, PSP_SAS_VOL_MAX, PSP_SAS_VOL_MAX);
    }
    __sceSasGetEndFlag(sasCorePointer) {
      return this.core.endFlags;
    }
    __sceSasRevType(sasCorePointer, waveformEffectType) {
      this.core.waveformEffectType = waveformEffectType;
      return 0;
    }
    __sceSasRevVON(sasCorePointer, waveformEffectIsDry, waveformEffectIsWet) {
      this.core.waveformEffectIsDry = waveformEffectIsDry;
      this.core.waveformEffectIsWet = waveformEffectIsWet;
      return 0;
    }
    __sceSasRevEVOL(sasCorePointer, leftVolume, rightVolume) {
      this.core.leftVolume = leftVolume;
      this.core.rightVolume = rightVolume;
      return 0;
    }
    hasSasCoreVoice(sasCorePointer, voiceId) {
      return this.core.voices[voiceId] != null;
    }
    getSasCoreVoice(sasCorePointer, voiceId) {
      return this.core.voices[voiceId];
    }
    __sceSasSetADSR(sasCorePointer, voiceId, flags, attackRate, decayRate, sustainRate, releaseRate) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      if (flags & AdsrFlags.HasAttack)
        voice.envelope.attackRate = attackRate;
      if (flags & AdsrFlags.HasDecay)
        voice.envelope.decayRate = decayRate;
      if (flags & AdsrFlags.HasSustain)
        voice.envelope.sustainRate = sustainRate;
      if (flags & AdsrFlags.HasRelease)
        voice.envelope.releaseRate = releaseRate;
      return 0;
    }
    __sceSasSetADSRmode(sasCorePointer, voiceId, flags, attackCurveMode, decayCurveMode, sustainCurveMode, releaseCurveMode) {
      console.warn("__sceSasSetADSRmode not implemented!");
      return 0;
    }
    __sceSasSetKeyOff(sasCorePointer, voiceId) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      if (!voice.paused)
        return SceKernelErrors.ERROR_SAS_VOICE_PAUSED;
      voice.setOn(false);
      return 0;
    }
    __sceSasSetKeyOn(sasCorePointer, voiceId) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      voice.setOn(true);
      return 0;
    }
    __sceSasGetEnvelopeHeight(sasCorePointer, voiceId) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      return voice.envelope.height;
    }
    __sceSasSetSL(sasCorePointer, voiceId, sustainLevel) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      voice.sustainLevel = sustainLevel;
      return 0;
    }
    __sceSasSetPause(sasCorePointer, voiceBits, pause) {
      this.core.voices.forEach((voice) => {
        if (voiceBits & 1 << voice.index) {
          voice.paused = pause;
        }
      });
      return 0;
    }
    __sceSasGetPauseFlag(sasCorePointer) {
      let voiceBits = 0;
      this.core.voices.forEach((voice) => {
        voiceBits |= (voice.paused ? 1 : 0) << voice.index;
      });
      return voiceBits;
    }
    __sceSasGetAllEnvelopeHeights(sasCorePointer, heightPtr) {
      this.core.voices.forEach((voice) => {
        heightPtr.writeInt32(voice.envelope.height);
      });
      return 0;
    }
    __sceSasSetNoise(sasCorePointer, voiceId, noiseFrequency) {
      if (noiseFrequency < 0 || noiseFrequency >= 64)
        return SceKernelErrors.ERROR_SAS_INVALID_NOISE_CLOCK;
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      return 0;
    }
    __sceSasSetVolume(sasCorePointer, voiceId, leftVolume, rightVolume, effectLeftVol, effectRightVol) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      leftVolume = Math.abs(leftVolume);
      rightVolume = Math.abs(rightVolume);
      effectLeftVol = Math.abs(effectLeftVol);
      effectRightVol = Math.abs(effectRightVol);
      if (leftVolume > PSP_SAS_VOL_MAX || rightVolume > PSP_SAS_VOL_MAX || effectLeftVol > PSP_SAS_VOL_MAX || effectRightVol > PSP_SAS_VOL_MAX) {
        return SceKernelErrors.ERROR_SAS_INVALID_VOLUME_VAL;
      }
      voice.leftVolume = leftVolume;
      voice.rightVolume = rightVolume;
      voice.effectLeftVolume = effectLeftVol;
      voice.effectRightVolume = effectRightVol;
      return 0;
    }
    __sceSasSetPitch(sasCorePointer, voiceId, pitch) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      if (pitch < PSP_SAS_PITCH_MIN || pitch > PSP_SAS_PITCH_MAX)
        return -1;
      voice.pitch = pitch;
      return 0;
    }
    __sceSasRevParam(sasCorePointer, delay2, feedback) {
      this.core.delay = delay2;
      this.core.feedback = feedback;
      return 0;
    }
    __sceSasSetSimpleADSR(sasCorePointer, voiceId, env1Bitfield, env2Bitfield) {
      if (!this.hasSasCoreVoice(sasCorePointer, voiceId))
        return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
      const voice = this.getSasCoreVoice(sasCorePointer, voiceId);
      return 0;
    }
  };
  var sceSasCore = _sceSasCore;
  sceSasCore.PSP_SAS_VOICES_MAX = 32;
  sceSasCore.PSP_SAS_GRAIN_SAMPLES = 256;
  sceSasCore.PSP_SAS_LOOP_MODE_OFF = 0;
  sceSasCore.PSP_SAS_LOOP_MODE_ON = 1;
  sceSasCore.PSP_SAS_NOISE_FREQ_MAX = 63;
  sceSasCore.PSP_SAS_ENVELOPE_HEIGHT_MAX = 1073741824;
  sceSasCore.PSP_SAS_ENVELOPE_FREQ_MAX = 2147483647;
  sceSasCore.PSP_SAS_ADSR_ATTACK = 1;
  sceSasCore.PSP_SAS_ADSR_DECAY = 2;
  sceSasCore.PSP_SAS_ADSR_SUSTAIN = 4;
  sceSasCore.PSP_SAS_ADSR_RELEASE = 8;
  __decorate([
    nativeFunction(1115130527, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32)
  ], sceSasCore.prototype, "__sceSasInit", 1);
  __decorate([
    nativeFunction(3521159198, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasSetGrain", 1);
  __decorate([
    nativeFunction(3897933686, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasSetOutputmode", 1);
  __decorate([
    nativeFunction(2576629897, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, BYTES),
    __param(3, I32)
  ], sceSasCore.prototype, "__sceSasSetVoice", 1);
  __decorate([
    nativeFunction(3788346721, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, BYTES),
    __param(3, I32)
  ], sceSasCore.prototype, "__sceSasSetVoicePCM", 1);
  __decorate([
    nativeFunction(1352748540, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, I32),
    __param(3, I32)
  ], sceSasCore.prototype, "__sceSasCoreWithMix", 1);
  __decorate([
    nativeFunction(2740493697, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceSasCore.prototype, "__sceSasCore", 1);
  __decorate([
    nativeFunction(1755605909, 150),
    U32,
    __param(0, I32)
  ], sceSasCore.prototype, "__sceSasGetEndFlag", 1);
  __decorate([
    nativeFunction(869575479, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasRevType", 1);
  __decorate([
    nativeFunction(4186157446, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasRevVON", 1);
  __decorate([
    nativeFunction(3584174537, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasRevEVOL", 1);
  __decorate([
    nativeFunction(26945003, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, I32)
  ], sceSasCore.prototype, "__sceSasSetADSR", 1);
  __decorate([
    nativeFunction(2663606122, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, I32)
  ], sceSasCore.prototype, "__sceSasSetADSRmode", 1);
  __decorate([
    nativeFunction(2697932708, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasSetKeyOff", 1);
  __decorate([
    nativeFunction(1995446986, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasSetKeyOn", 1);
  __decorate([
    nativeFunction(1957582890, 150),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], sceSasCore.prototype, "__sceSasGetEnvelopeHeight", 1);
  __decorate([
    nativeFunction(1603611126, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasSetSL", 1);
  __decorate([
    nativeFunction(2021459157, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, BOOL)
  ], sceSasCore.prototype, "__sceSasSetPause", 1);
  __decorate([
    nativeFunction(747530931, 150),
    U32,
    __param(0, I32)
  ], sceSasCore.prototype, "__sceSasGetPauseFlag", 1);
  __decorate([
    nativeFunction(133532708, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceSasCore.prototype, "__sceSasGetAllEnvelopeHeights", 1);
  __decorate([
    nativeFunction(3076917795, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasSetNoise", 1);
  __decorate([
    nativeFunction(1141680088, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32)
  ], sceSasCore.prototype, "__sceSasSetVolume", 1);
  __decorate([
    nativeFunction(2911163263, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasSetPitch", 1);
  __decorate([
    nativeFunction(645557714, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], sceSasCore.prototype, "__sceSasRevParam", 1);
  __decorate([
    nativeFunction(3419230073, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32)
  ], sceSasCore.prototype, "__sceSasSetSimpleADSR", 1);
  var SasCore = class {
    constructor() {
      this.initialized = false;
      this.grainSamples = 0;
      this.maxVoices = 32;
      this.outputMode = OutputMode.STEREO;
      this.sampleRate = 44100;
      this.delay = 0;
      this.feedback = 0;
      this.endFlags = 0;
      this.waveformEffectType = WaveformEffectType.OFF;
      this.waveformEffectIsDry = false;
      this.waveformEffectIsWet = false;
      this.leftVolume = PSP_SAS_VOL_MAX;
      this.rightVolume = PSP_SAS_VOL_MAX;
      this.voices = [];
      this.bufferTempArray = [];
      while (this.voices.length < 32)
        this.voices.push(new Voice(this.voices.length));
    }
    mix(sasCorePointer, sasOut, leftVolume, rightVolume) {
      while (this.bufferTempArray.length < this.grainSamples)
        this.bufferTempArray.push(new Sample(0, 0));
      const numberOfChannels = this.outputMode == OutputMode.STEREO ? 2 : 1;
      const numberOfSamples = this.grainSamples;
      const numberOfVoicesPlaying = Math.max(1, this.voices.count((Voice2) => Voice2.onAndPlaying));
      for (let n = 0; n < numberOfSamples; n++)
        this.bufferTempArray[n].set(0, 0);
      let prevPosDiv = -1;
      for (let n = 0; n < this.voices.length; n++) {
        const voice = this.voices[n];
        if (!voice.onAndPlaying)
          continue;
        let pos = 0;
        while (true) {
          if (voice.source != null && voice.source.hasMore) {
            const posDiv = Math.floor(pos / voice.pitch);
            if (posDiv >= numberOfSamples)
              break;
            const sample = voice.source.getNextSample();
            for (let m = prevPosDiv + 1; m <= posDiv; m++) {
              this.bufferTempArray[m].addScaled(sample, voice.leftVolume / PSP_SAS_VOL_MAX, voice.rightVolume / PSP_SAS_VOL_MAX);
            }
            prevPosDiv = posDiv;
            pos += PSP_SAS_PITCH_BASE;
          } else {
            voice.setPlaying(false);
            break;
          }
        }
      }
      for (let n = 0; n < numberOfSamples; n++) {
        const sample = this.bufferTempArray[n];
        sample.scale(leftVolume / PSP_SAS_VOL_MAX, rightVolume / PSP_SAS_VOL_MAX);
        if (numberOfChannels >= 1)
          sasOut.writeInt16(MathUtils.clamp(sample.left, -32768, 32767));
        if (numberOfChannels >= 2)
          sasOut.writeInt16(MathUtils.clamp(sample.right, -32768, 32767));
      }
      return 0;
    }
  };
  var Voice = class {
    constructor(index) {
      this.index = index;
      this.envelope = new Envelope();
      this.sustainLevel = 0;
      this.on = false;
      this.playing = false;
      this.paused = false;
      this.leftVolume = PSP_SAS_VOL_MAX;
      this.rightVolume = PSP_SAS_VOL_MAX;
      this.effectLeftVolume = PSP_SAS_VOL_MAX;
      this.effectRightVolume = PSP_SAS_VOL_MAX;
      this.pitch = PSP_SAS_PITCH_BASE;
      this.source = null;
    }
    get onAndPlaying() {
      return this.on && this.playing;
    }
    setOn(set) {
      this.on = set;
      this.setPlaying(set);
    }
    setPlaying(set) {
      this.playing = set;
      if (this.source)
        this.source.reset();
    }
    get ended() {
      return !this.playing;
    }
    unsetSource() {
      this.source = null;
    }
    setAdpcm(stream, loopCount) {
      this.source = new VagSoundSource(stream, loopCount);
      this.source.reset();
    }
    setPCM(stream, loopCount) {
      this.source = new PcmSoundSource(stream, loopCount);
      this.source.reset();
    }
  };
  var PcmSoundSource = class {
    constructor(stream, loopCount) {
      this.dummySample = new Sample(0, 0);
    }
    reset() {
    }
    get hasMore() {
      return false;
    }
    getNextSample() {
      return this.dummySample;
    }
  };
  var Envelope = class {
    constructor() {
      this.attackRate = 0;
      this.decayRate = 0;
      this.sustainRate = 0;
      this.releaseRate = 0;
      this.height = 0;
    }
  };
  var OutputMode;
  (function(OutputMode2) {
    OutputMode2[OutputMode2["STEREO"] = 0] = "STEREO";
    OutputMode2[OutputMode2["MULTICHANNEL"] = 1] = "MULTICHANNEL";
  })(OutputMode || (OutputMode = {}));
  var WaveformEffectType;
  (function(WaveformEffectType2) {
    WaveformEffectType2[WaveformEffectType2["OFF"] = -1] = "OFF";
    WaveformEffectType2[WaveformEffectType2["ROOM"] = 0] = "ROOM";
    WaveformEffectType2[WaveformEffectType2["UNK1"] = 1] = "UNK1";
    WaveformEffectType2[WaveformEffectType2["UNK2"] = 2] = "UNK2";
    WaveformEffectType2[WaveformEffectType2["UNK3"] = 3] = "UNK3";
    WaveformEffectType2[WaveformEffectType2["HALL"] = 4] = "HALL";
    WaveformEffectType2[WaveformEffectType2["SPACE"] = 5] = "SPACE";
    WaveformEffectType2[WaveformEffectType2["ECHO"] = 6] = "ECHO";
    WaveformEffectType2[WaveformEffectType2["DELAY"] = 7] = "DELAY";
    WaveformEffectType2[WaveformEffectType2["PIPE"] = 8] = "PIPE";
  })(WaveformEffectType || (WaveformEffectType = {}));
  var AdsrCurveMode;
  (function(AdsrCurveMode2) {
    AdsrCurveMode2[AdsrCurveMode2["LINEAR_INCREASE"] = 0] = "LINEAR_INCREASE";
    AdsrCurveMode2[AdsrCurveMode2["LINEAR_DECREASE"] = 1] = "LINEAR_DECREASE";
    AdsrCurveMode2[AdsrCurveMode2["LINEAR_BENT"] = 2] = "LINEAR_BENT";
    AdsrCurveMode2[AdsrCurveMode2["EXPONENT_REV"] = 3] = "EXPONENT_REV";
    AdsrCurveMode2[AdsrCurveMode2["EXPONENT"] = 4] = "EXPONENT";
    AdsrCurveMode2[AdsrCurveMode2["DIRECT"] = 5] = "DIRECT";
  })(AdsrCurveMode || (AdsrCurveMode = {}));
  var AdsrFlags;
  (function(AdsrFlags2) {
    AdsrFlags2[AdsrFlags2["HasAttack"] = 1] = "HasAttack";
    AdsrFlags2[AdsrFlags2["HasDecay"] = 2] = "HasDecay";
    AdsrFlags2[AdsrFlags2["HasSustain"] = 4] = "HasSustain";
    AdsrFlags2[AdsrFlags2["HasRelease"] = 8] = "HasRelease";
  })(AdsrFlags || (AdsrFlags = {}));

  // src/hle/module/sceSsl.ts
  var sceSsl_exports = {};
  __export(sceSsl_exports, {
    sceSsl: () => sceSsl
  });
  var sceSsl = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceSuspendForUser.ts
  var sceSuspendForUser_exports = {};
  __export(sceSuspendForUser_exports, {
    sceSuspendForUser: () => sceSuspendForUser
  });
  var sceSuspendForUser = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelPowerLock(lockType) {
      if (lockType != 0)
        return SceKernelErrors.ERROR_INVALID_MODE;
      return 0;
    }
    sceKernelPowerUnlock(lockType) {
      if (lockType != 0)
        return SceKernelErrors.ERROR_INVALID_MODE;
      return 0;
    }
    sceKernelPowerTick(value) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(3940228055, 150),
    U32,
    __param(0, U32)
  ], sceSuspendForUser.prototype, "sceKernelPowerLock", 1);
  __decorate([
    nativeFunction(988705377, 150),
    U32,
    __param(0, U32)
  ], sceSuspendForUser.prototype, "sceKernelPowerUnlock", 1);
  __decorate([
    nativeFunction(151833407, 150),
    U32,
    __param(0, U32)
  ], sceSuspendForUser.prototype, "sceKernelPowerTick", 1);

  // src/hle/module/sceUmdUser.ts
  var sceUmdUser_exports = {};
  __export(sceUmdUser_exports, {
    sceUmdUser: () => sceUmdUser
  });
  var sceUmdUser = class {
    constructor(context) {
      this.context = context;
      this.callbackIds = [];
      this.signal = new Signal1();
    }
    sceUmdRegisterUMDCallBack(callbackId) {
      this.callbackIds.push(callbackId);
      return 0;
    }
    sceUmdUnRegisterUMDCallBack(callbackId) {
      if (!this.callbackIds.contains(callbackId))
        return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
      this.callbackIds.remove(callbackId);
      return 0;
    }
    sceUmdCheckMedium() {
      return UmdCheckMedium.Inserted;
    }
    _sceUmdWaitDriveStat(pspUmdState, acceptCallbacks) {
      this.context.callbackManager.executePendingWithinThread(this.context.threadManager.current);
      return 0;
    }
    sceUmdWaitDriveStat(pspUmdState) {
      return this._sceUmdWaitDriveStat(pspUmdState, AcceptCallbacks.NO);
    }
    sceUmdWaitDriveStatCB(pspUmdState, timeout) {
      return this._sceUmdWaitDriveStat(pspUmdState, AcceptCallbacks.YES);
    }
    _notify(data) {
      this.signal.dispatch(data);
      this.callbackIds.forEach((callbackId) => {
        this.context.callbackManager.notify(callbackId, data);
      });
    }
    sceUmdActivate(mode, drive) {
      this._notify(PspUmdState.PSP_UMD_READABLE | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_PRESENT);
      return 0;
    }
    sceUmdDeactivate(mode, drive) {
      this._notify(PspUmdState.PSP_UMD_READABLE | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_PRESENT);
      return 0;
    }
    sceUmdGetDriveStat() {
      return PspUmdState.PSP_UMD_PRESENT | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_READABLE;
    }
    sceUmdWaitDriveStatWithTimer(state, timeout) {
      return PromiseFast.resolve(0);
    }
    sceUmdGetErrorStat() {
      return PromiseFast.resolve(0);
    }
  };
  __decorate([
    nativeFunction(2934390861, 150),
    U32,
    __param(0, I32)
  ], sceUmdUser.prototype, "sceUmdRegisterUMDCallBack", 1);
  __decorate([
    nativeFunction(3173768711, 150),
    U32,
    __param(0, I32)
  ], sceUmdUser.prototype, "sceUmdUnRegisterUMDCallBack", 1);
  __decorate([
    nativeFunction(1189852969, 150),
    U32
  ], sceUmdUser.prototype, "sceUmdCheckMedium", 1);
  __decorate([
    nativeFunction(2398130126, 150),
    U32,
    __param(0, U32)
  ], sceUmdUser.prototype, "sceUmdWaitDriveStat", 1);
  __decorate([
    nativeFunction(1251892777, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], sceUmdUser.prototype, "sceUmdWaitDriveStatCB", 1);
  __decorate([
    nativeFunction(3323477319, 150),
    U32,
    __param(0, I32),
    __param(1, STRING)
  ], sceUmdUser.prototype, "sceUmdActivate", 1);
  __decorate([
    nativeFunction(3895935674, 150),
    U32,
    __param(0, I32),
    __param(1, STRING)
  ], sceUmdUser.prototype, "sceUmdDeactivate", 1);
  __decorate([
    nativeFunction(1800017004, 150),
    U32
  ], sceUmdUser.prototype, "sceUmdGetDriveStat", 1);
  __decorate([
    nativeFunction(1444948339, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], sceUmdUser.prototype, "sceUmdWaitDriveStatWithTimer", 1);
  __decorate([
    nativeFunction(543329903, 150),
    U32
  ], sceUmdUser.prototype, "sceUmdGetErrorStat", 1);
  var UmdCheckMedium;
  (function(UmdCheckMedium2) {
    UmdCheckMedium2[UmdCheckMedium2["NoDisc"] = 0] = "NoDisc";
    UmdCheckMedium2[UmdCheckMedium2["Inserted"] = 1] = "Inserted";
  })(UmdCheckMedium || (UmdCheckMedium = {}));
  var PspUmdState;
  (function(PspUmdState2) {
    PspUmdState2[PspUmdState2["PSP_UMD_INIT"] = 0] = "PSP_UMD_INIT";
    PspUmdState2[PspUmdState2["PSP_UMD_NOT_PRESENT"] = 1] = "PSP_UMD_NOT_PRESENT";
    PspUmdState2[PspUmdState2["PSP_UMD_PRESENT"] = 2] = "PSP_UMD_PRESENT";
    PspUmdState2[PspUmdState2["PSP_UMD_CHANGED"] = 4] = "PSP_UMD_CHANGED";
    PspUmdState2[PspUmdState2["PSP_UMD_NOT_READY"] = 8] = "PSP_UMD_NOT_READY";
    PspUmdState2[PspUmdState2["PSP_UMD_READY"] = 16] = "PSP_UMD_READY";
    PspUmdState2[PspUmdState2["PSP_UMD_READABLE"] = 32] = "PSP_UMD_READABLE";
  })(PspUmdState || (PspUmdState = {}));

  // src/hle/module/sceUtility.ts
  var sceUtility_exports = {};
  __export(sceUtility_exports, {
    sceUtility: () => sceUtility
  });
  var sceUtility = class {
    constructor(context) {
      this.context = context;
      this.currentStep = DialogStepEnum.NONE;
    }
    sceUtilityLoadModule(pspModule) {
      console.warn("Not implemented sceUtilityLoadModule '" + pspModule + "'");
      return PromiseFast.resolve(0);
    }
    async sceUtilitySavedataInitStart(paramsPtr) {
      const result = await this._sceUtilitySavedataInitStart(paramsPtr.clone());
      const params = SceUtilitySavedataParam.struct.read(paramsPtr.clone());
      params.base.result = result;
      return 0;
    }
    async _sceUtilitySavedataInitStart(paramsPtr) {
      console.error("sceUtilitySavedataInitStart");
      const params = SceUtilitySavedataParam.struct.createProxy(paramsPtr);
      const func = async () => {
        const fileManager = this.context.fileManager;
        const savePathFolder = "ms0:/PSP/SAVEDATA/" + params.gameName + params.saveName;
        const saveDataBin = savePathFolder + "/DATA.BIN";
        const saveIcon0 = savePathFolder + "/ICON0.PNG";
        const savePic1 = savePathFolder + "/PIC1.PNG";
        this.currentStep = DialogStepEnum.SUCCESS;
        console.info("mode:", PspUtilitySavedataMode[params.mode]);
        switch (params.mode) {
          case PspUtilitySavedataMode.Autoload:
          case PspUtilitySavedataMode.Load:
          case PspUtilitySavedataMode.ListLoad: {
            try {
              const file = await fileManager.openAsync(saveDataBin, FileOpenFlags.Read, parseIntFormat("0777"));
              const data = await file.entry.readAllAsync();
              console.info("readed:", data.byteLength);
              params.dataSize = data.byteLength;
              this.context.memory.writeBytes(params.dataBufPointer, data);
              return 0;
            } catch (error) {
              console.info("can't read file:", saveDataBin, error);
              return SceKernelErrors.ERROR_SAVEDATA_LOAD_NO_DATA;
            }
          }
          case PspUtilitySavedataMode.Autosave:
          case PspUtilitySavedataMode.Save:
          case PspUtilitySavedataMode.ListSave: {
            try {
              const data = this.context.memory.readArrayBuffer(params.dataBufPointer, params.dataSize);
              const file = await fileManager.openAsync(saveDataBin, FileOpenFlags.Create | FileOpenFlags.Truncate | FileOpenFlags.Write, parseIntFormat("0777"));
              const written = file.entry.writeAllAsync(data);
              return 0;
            } catch (e) {
              return SceKernelErrors.ERROR_SAVEDATA_SAVE_ACCESS_ERROR;
            }
          }
          case PspUtilitySavedataMode.Read:
          case PspUtilitySavedataMode.ReadSecure: {
            console.error("Not Implemented: sceUtilitySavedataInitStart.Read");
            return 0;
          }
          case PspUtilitySavedataMode.Sizes: {
            const SceKernelError = SceKernelErrors.ERROR_OK;
            const SectorSize = 1024;
            const FreeSize = 32 * 1024 * 1024;
            const UsedSize = 0;
            {
              const sizeFreeInfoPtr = this.context.memory.getPointerPointer(SizeFreeInfo.struct, params.msFreeAddr);
              sizeFreeInfoPtr.readWrite((sizeFreeInfo) => {
                sizeFreeInfo.sectorSize = SectorSize;
                sizeFreeInfo.freeSectors = FreeSize / SectorSize;
                sizeFreeInfo.freeKb = FreeSize / 1024;
                sizeFreeInfo.freeKbString = sizeFreeInfo.freeKb + "KB";
              });
            }
            {
              const sizeUsedInfoPtr = this.context.memory.getPointerPointer(SizeUsedInfo.struct, params.msDataAddr);
            }
            {
              const sizeRequiredSpaceInfoPtr = this.context.memory.getPointerPointer(SizeRequiredSpaceInfo.struct, params.utilityDataAddr);
              if (sizeRequiredSpaceInfoPtr != null) {
                let RequiredSize = 0;
                RequiredSize += params.icon0FileData.size;
                RequiredSize += params.icon1FileData.size;
                RequiredSize += params.pic1FileData.size;
                RequiredSize += params.snd0FileData.size;
                RequiredSize += params.dataSize;
                sizeRequiredSpaceInfoPtr.readWrite((sizeRequiredSpaceInfo) => {
                  sizeRequiredSpaceInfo.requiredSpaceSectors = MathUtils.requiredBlocks(RequiredSize, SectorSize);
                  sizeRequiredSpaceInfo.requiredSpaceKb = MathUtils.requiredBlocks(RequiredSize, 1024);
                  sizeRequiredSpaceInfo.requiredSpace32KB = MathUtils.requiredBlocks(RequiredSize, 32 * 1024);
                  sizeRequiredSpaceInfo.requiredSpaceString = sizeRequiredSpaceInfo.requiredSpaceKb + "KB";
                  sizeRequiredSpaceInfo.requiredSpace32KBString = sizeRequiredSpaceInfo.requiredSpace32KB + "KB";
                });
              }
            }
            if (SceKernelError != SceKernelErrors.ERROR_OK)
              return PromiseFast.resolve(SceKernelError);
            break;
          }
          default: {
            console.error(`Not implemented ${params.mode}: ${PspUtilitySavedataMode[params.mode]}`);
            break;
          }
        }
        return PromiseFast.resolve(0);
      };
      const result = await func();
      try {
        console.error("result: ", result);
        params.base.result = result;
        return 0;
      } catch (e) {
        console.error(e);
        return 0;
      }
    }
    sceUtilitySavedataShutdownStart() {
      this.currentStep = DialogStepEnum.SHUTDOWN;
      return 0;
    }
    sceUtilitySavedataGetStatus() {
      try {
        return this.currentStep;
      } finally {
        if (this.currentStep == DialogStepEnum.SHUTDOWN)
          this.currentStep = DialogStepEnum.NONE;
      }
    }
    async sceUtilityMsgDialogInitStart(paramsPtr) {
      let params = PspUtilityMsgDialogParams.struct.createProxy(paramsPtr);
      console.warn("sceUtilityMsgDialogInitStart:", params.message);
      await EmulatorUI.openMessageAsync(params.message);
      params.buttonPressed = PspUtilityMsgDialogPressed.PSP_UTILITY_MSGDIALOG_RESULT_YES;
      this.currentStep = DialogStepEnum.SUCCESS;
      return 0;
    }
    sceUtilityMsgDialogGetStatus() {
      try {
        return this.currentStep;
      } finally {
        if (this.currentStep == DialogStepEnum.SHUTDOWN)
          this.currentStep = DialogStepEnum.NONE;
      }
    }
    sceUtilityMsgDialogUpdate(value) {
    }
    sceUtilityLoadNetModule() {
      console.warn("Not implemented sceUtilityLoadNetModule");
      return 0;
    }
    _getKey(id) {
      switch (id) {
        case PSP_SYSTEMPARAM_ID.INT_ADHOC_CHANNEL:
          return PSP_SYSTEMPARAM_ADHOC_CHANNEL.AUTOMATIC;
        case PSP_SYSTEMPARAM_ID.INT_WLAN_POWERSAVE:
          return PSP_SYSTEMPARAM_WLAN_POWERSAVE.ON;
        case PSP_SYSTEMPARAM_ID.INT_DATE_FORMAT:
          return PSP_SYSTEMPARAM_DATE_FORMAT.YYYYMMDD;
        case PSP_SYSTEMPARAM_ID.INT_TIME_FORMAT:
          return PSP_SYSTEMPARAM_TIME_FORMAT._24HR;
        case PSP_SYSTEMPARAM_ID.INT_TIMEZONE:
          return -5 * 60;
        case PSP_SYSTEMPARAM_ID.INT_DAYLIGHTSAVINGS:
          return PSP_SYSTEMPARAM_DAYLIGHTSAVINGS.STD;
        case PSP_SYSTEMPARAM_ID.INT_LANGUAGE:
          return this.context.config.language;
        case PSP_SYSTEMPARAM_ID.INT_BUTTON_PREFERENCE:
          return PSP_SYSTEMPARAM_BUTTON_PREFERENCE.NA;
        case PSP_SYSTEMPARAM_ID.STRING_NICKNAME:
          return "USERNAME";
      }
      throw new Error("Invalid key " + id);
    }
    sceUtilityGetSystemParamInt(id, valuePtr) {
      const value = parseInt(this._getKey(id));
      if (valuePtr)
        valuePtr.writeInt32(value);
      return 0;
    }
    sceUtilityGetSystemParamString(id, strPtr, len) {
      let value = String(this._getKey(id));
      value = value.substr(0, Math.min(value.length, len - 1));
      if (strPtr)
        strPtr.writeStringz(value);
      return 0;
    }
    sceUtilityLoadAvModule(id) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(707476960, 150),
    U32,
    __param(0, I32)
  ], sceUtility.prototype, "sceUtilityLoadModule", 1);
  __decorate([
    nativeFunction(1355074903, 150),
    U32,
    __param(0, PTR)
  ], sceUtility.prototype, "sceUtilitySavedataInitStart", 1);
  __decorate([
    nativeFunction(2542842684, 150),
    U32
  ], sceUtility.prototype, "sceUtilitySavedataShutdownStart", 1);
  __decorate([
    nativeFunction(2289359840, 150),
    U32
  ], sceUtility.prototype, "sceUtilitySavedataGetStatus", 1);
  __decorate([
    nativeFunction(718856761, 150),
    U32,
    __param(0, PTR)
  ], sceUtility.prototype, "sceUtilityMsgDialogInitStart", 1);
  __decorate([
    nativeFunction(2585563607, 150),
    U32
  ], sceUtility.prototype, "sceUtilityMsgDialogGetStatus", 1);
  __decorate([
    nativeFunction(2585563607, 150),
    U32,
    __param(0, I32)
  ], sceUtility.prototype, "sceUtilityMsgDialogUpdate", 1);
  __decorate([
    nativeFunction(360292697, 150),
    U32
  ], sceUtility.prototype, "sceUtilityLoadNetModule", 1);
  __decorate([
    nativeFunction(2782536710, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], sceUtility.prototype, "sceUtilityGetSystemParamInt", 1);
  __decorate([
    nativeFunction(884441923, 150),
    U32,
    __param(0, I32),
    __param(1, PTR),
    __param(2, I32)
  ], sceUtility.prototype, "sceUtilityGetSystemParamString", 1);
  __decorate([
    nativeFunction(3324620582, 150),
    U32,
    __param(0, I32)
  ], sceUtility.prototype, "sceUtilityLoadAvModule", 1);
  var PSP_SYSTEMPARAM_ID;
  (function(PSP_SYSTEMPARAM_ID2) {
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["STRING_NICKNAME"] = 1] = "STRING_NICKNAME";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_ADHOC_CHANNEL"] = 2] = "INT_ADHOC_CHANNEL";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_WLAN_POWERSAVE"] = 3] = "INT_WLAN_POWERSAVE";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_DATE_FORMAT"] = 4] = "INT_DATE_FORMAT";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_TIME_FORMAT"] = 5] = "INT_TIME_FORMAT";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_TIMEZONE"] = 6] = "INT_TIMEZONE";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_DAYLIGHTSAVINGS"] = 7] = "INT_DAYLIGHTSAVINGS";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_LANGUAGE"] = 8] = "INT_LANGUAGE";
    PSP_SYSTEMPARAM_ID2[PSP_SYSTEMPARAM_ID2["INT_BUTTON_PREFERENCE"] = 9] = "INT_BUTTON_PREFERENCE";
  })(PSP_SYSTEMPARAM_ID || (PSP_SYSTEMPARAM_ID = {}));
  var DialogStepEnum;
  (function(DialogStepEnum2) {
    DialogStepEnum2[DialogStepEnum2["NONE"] = 0] = "NONE";
    DialogStepEnum2[DialogStepEnum2["INIT"] = 1] = "INIT";
    DialogStepEnum2[DialogStepEnum2["PROCESSING"] = 2] = "PROCESSING";
    DialogStepEnum2[DialogStepEnum2["SUCCESS"] = 3] = "SUCCESS";
    DialogStepEnum2[DialogStepEnum2["SHUTDOWN"] = 4] = "SHUTDOWN";
  })(DialogStepEnum || (DialogStepEnum = {}));
  var PSP_SYSTEMPARAM_ADHOC_CHANNEL;
  (function(PSP_SYSTEMPARAM_ADHOC_CHANNEL2) {
    PSP_SYSTEMPARAM_ADHOC_CHANNEL2[PSP_SYSTEMPARAM_ADHOC_CHANNEL2["AUTOMATIC"] = 0] = "AUTOMATIC";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL2[PSP_SYSTEMPARAM_ADHOC_CHANNEL2["C1"] = 1] = "C1";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL2[PSP_SYSTEMPARAM_ADHOC_CHANNEL2["C6"] = 6] = "C6";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL2[PSP_SYSTEMPARAM_ADHOC_CHANNEL2["C11"] = 11] = "C11";
  })(PSP_SYSTEMPARAM_ADHOC_CHANNEL || (PSP_SYSTEMPARAM_ADHOC_CHANNEL = {}));
  var PSP_SYSTEMPARAM_WLAN_POWERSAVE;
  (function(PSP_SYSTEMPARAM_WLAN_POWERSAVE2) {
    PSP_SYSTEMPARAM_WLAN_POWERSAVE2[PSP_SYSTEMPARAM_WLAN_POWERSAVE2["OFF"] = 0] = "OFF";
    PSP_SYSTEMPARAM_WLAN_POWERSAVE2[PSP_SYSTEMPARAM_WLAN_POWERSAVE2["ON"] = 1] = "ON";
  })(PSP_SYSTEMPARAM_WLAN_POWERSAVE || (PSP_SYSTEMPARAM_WLAN_POWERSAVE = {}));
  var PSP_SYSTEMPARAM_DATE_FORMAT;
  (function(PSP_SYSTEMPARAM_DATE_FORMAT2) {
    PSP_SYSTEMPARAM_DATE_FORMAT2[PSP_SYSTEMPARAM_DATE_FORMAT2["YYYYMMDD"] = 0] = "YYYYMMDD";
    PSP_SYSTEMPARAM_DATE_FORMAT2[PSP_SYSTEMPARAM_DATE_FORMAT2["MMDDYYYY"] = 1] = "MMDDYYYY";
    PSP_SYSTEMPARAM_DATE_FORMAT2[PSP_SYSTEMPARAM_DATE_FORMAT2["DDMMYYYY"] = 2] = "DDMMYYYY";
  })(PSP_SYSTEMPARAM_DATE_FORMAT || (PSP_SYSTEMPARAM_DATE_FORMAT = {}));
  var PSP_SYSTEMPARAM_TIME_FORMAT;
  (function(PSP_SYSTEMPARAM_TIME_FORMAT2) {
    PSP_SYSTEMPARAM_TIME_FORMAT2[PSP_SYSTEMPARAM_TIME_FORMAT2["_24HR"] = 0] = "_24HR";
    PSP_SYSTEMPARAM_TIME_FORMAT2[PSP_SYSTEMPARAM_TIME_FORMAT2["_12HR"] = 1] = "_12HR";
  })(PSP_SYSTEMPARAM_TIME_FORMAT || (PSP_SYSTEMPARAM_TIME_FORMAT = {}));
  var PSP_SYSTEMPARAM_DAYLIGHTSAVINGS;
  (function(PSP_SYSTEMPARAM_DAYLIGHTSAVINGS2) {
    PSP_SYSTEMPARAM_DAYLIGHTSAVINGS2[PSP_SYSTEMPARAM_DAYLIGHTSAVINGS2["STD"] = 0] = "STD";
    PSP_SYSTEMPARAM_DAYLIGHTSAVINGS2[PSP_SYSTEMPARAM_DAYLIGHTSAVINGS2["SAVING"] = 1] = "SAVING";
  })(PSP_SYSTEMPARAM_DAYLIGHTSAVINGS || (PSP_SYSTEMPARAM_DAYLIGHTSAVINGS = {}));
  var PSP_SYSTEMPARAM_LANGUAGE;
  (function(PSP_SYSTEMPARAM_LANGUAGE2) {
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["JAPANESE"] = 0] = "JAPANESE";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["ENGLISH"] = 1] = "ENGLISH";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["FRENCH"] = 2] = "FRENCH";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["SPANISH"] = 3] = "SPANISH";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["GERMAN"] = 4] = "GERMAN";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["ITALIAN"] = 5] = "ITALIAN";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["DUTCH"] = 6] = "DUTCH";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["PORTUGUESE"] = 7] = "PORTUGUESE";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["RUSSIAN"] = 8] = "RUSSIAN";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["KOREAN"] = 9] = "KOREAN";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["CHINESE_TRADITIONAL"] = 10] = "CHINESE_TRADITIONAL";
    PSP_SYSTEMPARAM_LANGUAGE2[PSP_SYSTEMPARAM_LANGUAGE2["CHINESE_SIMPLIFIED"] = 11] = "CHINESE_SIMPLIFIED";
  })(PSP_SYSTEMPARAM_LANGUAGE || (PSP_SYSTEMPARAM_LANGUAGE = {}));
  var PSP_SYSTEMPARAM_BUTTON_PREFERENCE;
  (function(PSP_SYSTEMPARAM_BUTTON_PREFERENCE2) {
    PSP_SYSTEMPARAM_BUTTON_PREFERENCE2[PSP_SYSTEMPARAM_BUTTON_PREFERENCE2["JAP"] = 0] = "JAP";
    PSP_SYSTEMPARAM_BUTTON_PREFERENCE2[PSP_SYSTEMPARAM_BUTTON_PREFERENCE2["NA"] = 1] = "NA";
  })(PSP_SYSTEMPARAM_BUTTON_PREFERENCE || (PSP_SYSTEMPARAM_BUTTON_PREFERENCE = {}));
  var PspModule;
  (function(PspModule2) {
    PspModule2[PspModule2["PSP_MODULE_NET_COMMON"] = 256] = "PSP_MODULE_NET_COMMON";
    PspModule2[PspModule2["PSP_MODULE_NET_ADHOC"] = 257] = "PSP_MODULE_NET_ADHOC";
    PspModule2[PspModule2["PSP_MODULE_NET_INET"] = 258] = "PSP_MODULE_NET_INET";
    PspModule2[PspModule2["PSP_MODULE_NET_PARSEURI"] = 259] = "PSP_MODULE_NET_PARSEURI";
    PspModule2[PspModule2["PSP_MODULE_NET_PARSEHTTP"] = 260] = "PSP_MODULE_NET_PARSEHTTP";
    PspModule2[PspModule2["PSP_MODULE_NET_HTTP"] = 261] = "PSP_MODULE_NET_HTTP";
    PspModule2[PspModule2["PSP_MODULE_NET_SSL"] = 262] = "PSP_MODULE_NET_SSL";
    PspModule2[PspModule2["PSP_MODULE_USB_PSPCM"] = 512] = "PSP_MODULE_USB_PSPCM";
    PspModule2[PspModule2["PSP_MODULE_USB_MIC"] = 513] = "PSP_MODULE_USB_MIC";
    PspModule2[PspModule2["PSP_MODULE_USB_CAM"] = 514] = "PSP_MODULE_USB_CAM";
    PspModule2[PspModule2["PSP_MODULE_USB_GPS"] = 515] = "PSP_MODULE_USB_GPS";
    PspModule2[PspModule2["PSP_MODULE_AV_AVCODEC"] = 768] = "PSP_MODULE_AV_AVCODEC";
    PspModule2[PspModule2["PSP_MODULE_AV_SASCORE"] = 769] = "PSP_MODULE_AV_SASCORE";
    PspModule2[PspModule2["PSP_MODULE_AV_ATRAC3PLUS"] = 770] = "PSP_MODULE_AV_ATRAC3PLUS";
    PspModule2[PspModule2["PSP_MODULE_AV_MPEGBASE"] = 771] = "PSP_MODULE_AV_MPEGBASE";
    PspModule2[PspModule2["PSP_MODULE_AV_MP3"] = 772] = "PSP_MODULE_AV_MP3";
    PspModule2[PspModule2["PSP_MODULE_AV_VAUDIO"] = 773] = "PSP_MODULE_AV_VAUDIO";
    PspModule2[PspModule2["PSP_MODULE_AV_AAC"] = 774] = "PSP_MODULE_AV_AAC";
    PspModule2[PspModule2["PSP_MODULE_AV_G729"] = 775] = "PSP_MODULE_AV_G729";
    PspModule2[PspModule2["PSP_MODULE_NP_COMMON"] = 1024] = "PSP_MODULE_NP_COMMON";
    PspModule2[PspModule2["PSP_MODULE_NP_SERVICE"] = 1025] = "PSP_MODULE_NP_SERVICE";
    PspModule2[PspModule2["PSP_MODULE_NP_MATCHING2"] = 1026] = "PSP_MODULE_NP_MATCHING2";
    PspModule2[PspModule2["PSP_MODULE_NP_DRM"] = 1280] = "PSP_MODULE_NP_DRM";
    PspModule2[PspModule2["PSP_MODULE_IRDA"] = 1536] = "PSP_MODULE_IRDA";
  })(PspModule || (PspModule = {}));
  var PspUtilityMsgDialogMode;
  (function(PspUtilityMsgDialogMode2) {
    PspUtilityMsgDialogMode2[PspUtilityMsgDialogMode2["PSP_UTILITY_MSGDIALOG_MODE_ERROR"] = 0] = "PSP_UTILITY_MSGDIALOG_MODE_ERROR";
    PspUtilityMsgDialogMode2[PspUtilityMsgDialogMode2["PSP_UTILITY_MSGDIALOG_MODE_TEXT"] = 1] = "PSP_UTILITY_MSGDIALOG_MODE_TEXT";
  })(PspUtilityMsgDialogMode || (PspUtilityMsgDialogMode = {}));
  var PspUtilityMsgDialogOption;
  (function(PspUtilityMsgDialogOption2) {
    PspUtilityMsgDialogOption2[PspUtilityMsgDialogOption2["PSP_UTILITY_MSGDIALOG_OPTION_ERROR"] = 0] = "PSP_UTILITY_MSGDIALOG_OPTION_ERROR";
    PspUtilityMsgDialogOption2[PspUtilityMsgDialogOption2["PSP_UTILITY_MSGDIALOG_OPTION_TEXT"] = 1] = "PSP_UTILITY_MSGDIALOG_OPTION_TEXT";
    PspUtilityMsgDialogOption2[PspUtilityMsgDialogOption2["PSP_UTILITY_MSGDIALOG_OPTION_YESNO_BUTTONS"] = 16] = "PSP_UTILITY_MSGDIALOG_OPTION_YESNO_BUTTONS";
    PspUtilityMsgDialogOption2[PspUtilityMsgDialogOption2["PSP_UTILITY_MSGDIALOG_OPTION_DEFAULT_NO"] = 256] = "PSP_UTILITY_MSGDIALOG_OPTION_DEFAULT_NO";
  })(PspUtilityMsgDialogOption || (PspUtilityMsgDialogOption = {}));
  var PspUtilityMsgDialogPressed;
  (function(PspUtilityMsgDialogPressed2) {
    PspUtilityMsgDialogPressed2[PspUtilityMsgDialogPressed2["PSP_UTILITY_MSGDIALOG_RESULT_UNKNOWN1"] = 0] = "PSP_UTILITY_MSGDIALOG_RESULT_UNKNOWN1";
    PspUtilityMsgDialogPressed2[PspUtilityMsgDialogPressed2["PSP_UTILITY_MSGDIALOG_RESULT_YES"] = 1] = "PSP_UTILITY_MSGDIALOG_RESULT_YES";
    PspUtilityMsgDialogPressed2[PspUtilityMsgDialogPressed2["PSP_UTILITY_MSGDIALOG_RESULT_NO"] = 2] = "PSP_UTILITY_MSGDIALOG_RESULT_NO";
    PspUtilityMsgDialogPressed2[PspUtilityMsgDialogPressed2["PSP_UTILITY_MSGDIALOG_RESULT_BACK"] = 3] = "PSP_UTILITY_MSGDIALOG_RESULT_BACK";
  })(PspUtilityMsgDialogPressed || (PspUtilityMsgDialogPressed = {}));
  var PspUtilityDialogCommon = class extends Struct {
    constructor() {
      super(...arguments);
      this.size = 0;
      this.language = PspLanguages.SPANISH;
      this.buttonSwap = 0;
      this.graphicsThread = 0;
      this.accessThread = 0;
      this.fontThread = 0;
      this.soundThread = 0;
      this.result = SceKernelErrors.ERROR_OK;
      this.reserved = [0, 0, 0, 0];
    }
  };
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "size", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "language", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "buttonSwap", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "graphicsThread", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "accessThread", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "fontThread", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "soundThread", 2);
  __decorate([
    StructInt32
  ], PspUtilityDialogCommon.prototype, "result", 2);
  __decorate([
    StructStructArray(Int32, 4)
  ], PspUtilityDialogCommon.prototype, "reserved", 2);
  var PspUtilitySavedataMode;
  (function(PspUtilitySavedataMode2) {
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Autoload"] = 0] = "Autoload";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Autosave"] = 1] = "Autosave";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Load"] = 2] = "Load";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Save"] = 3] = "Save";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["ListLoad"] = 4] = "ListLoad";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["ListSave"] = 5] = "ListSave";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["ListDelete"] = 6] = "ListDelete";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Delete"] = 7] = "Delete";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Sizes"] = 8] = "Sizes";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["AutoDelete"] = 9] = "AutoDelete";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["SingleDelete"] = 10] = "SingleDelete";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["List"] = 11] = "List";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Files"] = 12] = "Files";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["MakeDataSecure"] = 13] = "MakeDataSecure";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["MakeData"] = 14] = "MakeData";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["ReadSecure"] = 15] = "ReadSecure";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Read"] = 16] = "Read";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["WriteSecure"] = 17] = "WriteSecure";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Write"] = 18] = "Write";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["EraseSecure"] = 19] = "EraseSecure";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["Erase"] = 20] = "Erase";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["DeleteData"] = 21] = "DeleteData";
    PspUtilitySavedataMode2[PspUtilitySavedataMode2["GetSize"] = 22] = "GetSize";
  })(PspUtilitySavedataMode || (PspUtilitySavedataMode = {}));
  var PspUtilitySavedataFocus;
  (function(PspUtilitySavedataFocus2) {
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN"] = 0] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_FIRSTLIST"] = 1] = "PSP_UTILITY_SAVEDATA_FOCUS_FIRSTLIST";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_LASTLIST"] = 2] = "PSP_UTILITY_SAVEDATA_FOCUS_LASTLIST";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_LATEST"] = 3] = "PSP_UTILITY_SAVEDATA_FOCUS_LATEST";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_OLDEST"] = 4] = "PSP_UTILITY_SAVEDATA_FOCUS_OLDEST";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN2"] = 5] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN2";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN3"] = 6] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN3";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_FIRSTEMPTY"] = 7] = "PSP_UTILITY_SAVEDATA_FOCUS_FIRSTEMPTY";
    PspUtilitySavedataFocus2[PspUtilitySavedataFocus2["PSP_UTILITY_SAVEDATA_FOCUS_LASTEMPTY"] = 8] = "PSP_UTILITY_SAVEDATA_FOCUS_LASTEMPTY";
  })(PspUtilitySavedataFocus || (PspUtilitySavedataFocus = {}));
  var PspUtilitySavedataFileData = class extends Struct {
    constructor() {
      super(...arguments);
      this.bufferPointer = 0;
      this.bufferSize = 0;
      this.size = 0;
      this.unknown = 0;
    }
    get used() {
      if (this.bufferPointer == 0)
        return false;
      if (this.size == 0)
        return false;
      return true;
    }
  };
  __decorate([
    StructInt32
  ], PspUtilitySavedataFileData.prototype, "bufferPointer", 2);
  __decorate([
    StructInt32
  ], PspUtilitySavedataFileData.prototype, "bufferSize", 2);
  __decorate([
    StructInt32
  ], PspUtilitySavedataFileData.prototype, "size", 2);
  __decorate([
    StructInt32
  ], PspUtilitySavedataFileData.prototype, "unknown", 2);
  var PspUtilitySavedataSFOParam = class extends Struct {
    constructor() {
      super(...arguments);
      this.title = "";
      this.savedataTitle = "";
      this.detail = "";
      this.parentalLevel = 0;
      this.unknown = [0, 0, 0];
    }
  };
  __decorate([
    StructStructStringz(128)
  ], PspUtilitySavedataSFOParam.prototype, "title", 2);
  __decorate([
    StructStructStringz(128)
  ], PspUtilitySavedataSFOParam.prototype, "savedataTitle", 2);
  __decorate([
    StructStructStringz(1024)
  ], PspUtilitySavedataSFOParam.prototype, "detail", 2);
  __decorate([
    StructUInt8
  ], PspUtilitySavedataSFOParam.prototype, "parentalLevel", 2);
  __decorate([
    StructStructArray(UInt8, 3)
  ], PspUtilitySavedataSFOParam.prototype, "unknown", 2);
  var SceUtilitySavedataParam = class extends Struct {
    constructor() {
      super(...arguments);
      this.base = new PspUtilityDialogCommon();
      this.mode = 0;
      this.unknown1 = 0;
      this.overwrite = 0;
      this.gameName = "";
      this.saveName = "";
      this.saveNameListPointer = 0;
      this.fileName = "";
      this.dataBufPointer = 0;
      this.dataBufSize = 0;
      this.dataSize = 0;
      this.sfoParam = new PspUtilitySavedataSFOParam();
      this.icon0FileData = new PspUtilitySavedataFileData();
      this.icon1FileData = new PspUtilitySavedataFileData();
      this.pic1FileData = new PspUtilitySavedataFileData();
      this.snd0FileData = new PspUtilitySavedataFileData();
      this.newDataPointer = 0;
      this.focus = 0;
      this.abortStatus = 0;
      this.msFreeAddr = 0;
      this.msDataAddr = 0;
      this.utilityDataAddr = 0;
      this.key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.secureVersion = 0;
      this.multiStatus = 0;
      this.idListAddr = 0;
      this.fileListAddr = 0;
      this.sizeAddr = 0;
      this.unknown3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
  };
  __decorate([
    StructMember(PspUtilityDialogCommon.struct)
  ], SceUtilitySavedataParam.prototype, "base", 2);
  __decorate([
    StructInt32
  ], SceUtilitySavedataParam.prototype, "mode", 2);
  __decorate([
    StructInt32
  ], SceUtilitySavedataParam.prototype, "unknown1", 2);
  __decorate([
    StructInt32
  ], SceUtilitySavedataParam.prototype, "overwrite", 2);
  __decorate([
    StructStructStringz(16)
  ], SceUtilitySavedataParam.prototype, "gameName", 2);
  __decorate([
    StructStructStringz(20)
  ], SceUtilitySavedataParam.prototype, "saveName", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "saveNameListPointer", 2);
  __decorate([
    StructStructStringz(16)
  ], SceUtilitySavedataParam.prototype, "fileName", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "dataBufPointer", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "dataBufSize", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "dataSize", 2);
  __decorate([
    StructMember(PspUtilitySavedataSFOParam.struct)
  ], SceUtilitySavedataParam.prototype, "sfoParam", 2);
  __decorate([
    StructMember(PspUtilitySavedataFileData.struct)
  ], SceUtilitySavedataParam.prototype, "icon0FileData", 2);
  __decorate([
    StructMember(PspUtilitySavedataFileData.struct)
  ], SceUtilitySavedataParam.prototype, "icon1FileData", 2);
  __decorate([
    StructMember(PspUtilitySavedataFileData.struct)
  ], SceUtilitySavedataParam.prototype, "pic1FileData", 2);
  __decorate([
    StructMember(PspUtilitySavedataFileData.struct)
  ], SceUtilitySavedataParam.prototype, "snd0FileData", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "newDataPointer", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "focus", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "abortStatus", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "msFreeAddr", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "msDataAddr", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "utilityDataAddr", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], SceUtilitySavedataParam.prototype, "key", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "secureVersion", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "multiStatus", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "idListAddr", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "fileListAddr", 2);
  __decorate([
    StructUInt32
  ], SceUtilitySavedataParam.prototype, "sizeAddr", 2);
  __decorate([
    StructStructArray(UInt8, 20 - 5)
  ], SceUtilitySavedataParam.prototype, "unknown3", 2);
  var SizeFreeInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.sectorSize = 0;
      this.freeSectors = 0;
      this.freeKb = 0;
      this.freeKbString = "";
    }
  };
  __decorate([
    StructUInt32
  ], SizeFreeInfo.prototype, "sectorSize", 2);
  __decorate([
    StructUInt32
  ], SizeFreeInfo.prototype, "freeSectors", 2);
  __decorate([
    StructUInt32
  ], SizeFreeInfo.prototype, "freeKb", 2);
  __decorate([
    StructStructStringz(8)
  ], SizeFreeInfo.prototype, "freeKbString", 2);
  var SizeUsedInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.gameName = "";
      this.saveName = "";
      this.usedSectors = 0;
      this.usedKb = 0;
      this.usedKbString = "";
      this.usedKb32 = 0;
      this.usedKb32String = "";
    }
  };
  __decorate([
    StructStructStringz(16)
  ], SizeUsedInfo.prototype, "gameName", 2);
  __decorate([
    StructStructStringz(24)
  ], SizeUsedInfo.prototype, "saveName", 2);
  __decorate([
    StructUInt32
  ], SizeUsedInfo.prototype, "usedSectors", 2);
  __decorate([
    StructUInt32
  ], SizeUsedInfo.prototype, "usedKb", 2);
  __decorate([
    StructStructStringz(8)
  ], SizeUsedInfo.prototype, "usedKbString", 2);
  __decorate([
    StructUInt32
  ], SizeUsedInfo.prototype, "usedKb32", 2);
  __decorate([
    StructStructStringz(8)
  ], SizeUsedInfo.prototype, "usedKb32String", 2);
  var SizeRequiredSpaceInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.requiredSpaceSectors = 0;
      this.requiredSpaceKb = 0;
      this.requiredSpaceString = "";
      this.requiredSpace32KB = 0;
      this.requiredSpace32KBString = "";
    }
  };
  __decorate([
    StructUInt32
  ], SizeRequiredSpaceInfo.prototype, "requiredSpaceSectors", 2);
  __decorate([
    StructUInt32
  ], SizeRequiredSpaceInfo.prototype, "requiredSpaceKb", 2);
  __decorate([
    StructStructStringz(8)
  ], SizeRequiredSpaceInfo.prototype, "requiredSpaceString", 2);
  __decorate([
    StructUInt32
  ], SizeRequiredSpaceInfo.prototype, "requiredSpace32KB", 2);
  __decorate([
    StructStructStringz(8)
  ], SizeRequiredSpaceInfo.prototype, "requiredSpace32KBString", 2);
  var PspUtilityMsgDialogParams = class extends Struct {
    constructor() {
      super(...arguments);
      this.unknown = 0;
      this.mnode = 0;
      this.errorValue = 0;
      this.message = "";
      this.options = 0;
      this.buttonPressed = 0;
    }
  };
  __decorate([
    StructMember(PspUtilityDialogCommon.struct)
  ], PspUtilityMsgDialogParams.prototype, "base", 2);
  __decorate([
    StructInt32
  ], PspUtilityMsgDialogParams.prototype, "unknown", 2);
  __decorate([
    StructInt32
  ], PspUtilityMsgDialogParams.prototype, "mnode", 2);
  __decorate([
    StructInt32
  ], PspUtilityMsgDialogParams.prototype, "errorValue", 2);
  __decorate([
    StructStructUtf8Stringz(512)
  ], PspUtilityMsgDialogParams.prototype, "message", 2);
  __decorate([
    StructInt32
  ], PspUtilityMsgDialogParams.prototype, "options", 2);
  __decorate([
    StructInt32
  ], PspUtilityMsgDialogParams.prototype, "buttonPressed", 2);

  // src/hle/module/sceVaudio.ts
  var sceVaudio_exports = {};
  __export(sceVaudio_exports, {
    sceVaudio: () => sceVaudio
  });
  var sceVaudio = class {
    constructor(context) {
      this.context = context;
    }
  };

  // src/hle/module/sceWlanDrv.ts
  var sceWlanDrv_exports = {};
  __export(sceWlanDrv_exports, {
    sceWlanDrv: () => sceWlanDrv
  });
  var sceWlanDrv = class {
    constructor(context) {
      this.context = context;
    }
    sceWlanGetSwitchState() {
      return true;
    }
  };
  __decorate([
    nativeFunction(3614848665, 150),
    BOOL
  ], sceWlanDrv.prototype, "sceWlanGetSwitchState", 1);

  // src/hle/module/StdioForUser.ts
  var StdioForUser_exports = {};
  __export(StdioForUser_exports, {
    StdioForUser: () => StdioForUser
  });
  var StdioForUser = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelStdin() {
      return 0;
    }
    sceKernelStdout() {
      return 1;
    }
    sceKernelStderr() {
      return 2;
    }
  };
  __decorate([
    nativeFunction(388837742, 150),
    I32
  ], StdioForUser.prototype, "sceKernelStdin", 1);
  __decorate([
    nativeFunction(2797253353, 150),
    I32
  ], StdioForUser.prototype, "sceKernelStdout", 1);
  __decorate([
    nativeFunction(4153125130, 150),
    I32
  ], StdioForUser.prototype, "sceKernelStderr", 1);

  // src/hle/module/SysMemUserForUser.ts
  var SysMemUserForUser_exports = {};
  __export(SysMemUserForUser_exports, {
    SysMemUserForUser: () => SysMemUserForUser
  });
  var console5 = logger.named("module.SysMemUserForUser");
  var SysMemUserForUser = class {
    constructor(context) {
      this.context = context;
      this.partitionUids = new UidCollection(1);
      this.blockUids = new UidCollection(1);
    }
    sceKernelAllocPartitionMemory(partitionId, name2, anchor, size, address) {
      if (name2 == null)
        return SceKernelErrors.ERROR_ERROR;
      try {
        const parentPartition = this.context.memoryManager.memoryPartitionsUid[partitionId];
        const allocatedPartition = parentPartition.allocate(size, anchor, address, name2);
        console5.info(sprintf("SysMemUserForUser.sceKernelAllocPartitionMemory (partitionId:%d, name:'%s', type:%d, size:%d, address:%08X) : %08X-%08X", partitionId, name2, anchor, size, address, allocatedPartition.low, allocatedPartition.high));
        return this.partitionUids.allocate(allocatedPartition);
      } catch (e) {
        console5.error(e);
        return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
      }
    }
    AllocMemoryBlock(name2, type, size, paramsAddrPtr) {
      if (name2 == null)
        return SceKernelErrors.ERROR_ERROR;
      if (type < 0 || type > 1)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE;
      if (size == 0)
        return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
      if (paramsAddrPtr) {
        const size2 = paramsAddrPtr.readInt32();
        const unk = paramsAddrPtr.readInt32();
        if (size2 != 4)
          return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ARGUMENT;
      }
      const parentPartition = this.context.memoryManager.userPartition;
      try {
        const block = parentPartition.allocate(size, type, 0, name2);
        return this.blockUids.allocate(block);
      } catch (e) {
        console5.error(e);
        return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
      }
    }
    GetMemoryBlockAddr(blockId) {
      if (!this.blockUids.has(blockId))
        return 0;
      const block = this.blockUids.get(blockId);
      return block.low;
    }
    FreeMemoryBlock(blockId) {
      if (!this.blockUids.has(blockId))
        return SceKernelErrors.ERROR_KERNEL_UNKNOWN_UID;
      this.blockUids.remove(blockId);
      return 0;
    }
    sceKernelFreePartitionMemory(partitionId) {
      if (!this.partitionUids.has(partitionId))
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK;
      const partition = this.partitionUids.get(partitionId);
      partition.deallocate();
      this.partitionUids.remove(partitionId);
      return 0;
    }
    sceKernelTotalFreeMemSize() {
      return this.context.memoryManager.userPartition.getTotalFreeMemory() - 32768;
    }
    sceKernelGetBlockHeadAddr(partitionId) {
      if (!this.partitionUids.has(partitionId))
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK;
      const block = this.partitionUids.get(partitionId);
      return block.low;
    }
    sceKernelMaxFreeMemSize() {
      return this.context.memoryManager.userPartition.nonAllocatedPartitions.max((partition) => partition.size).size;
    }
    sceKernelSetCompiledSdkVersion(sdkVersion) {
      console5.info(sprintf("sceKernelSetCompiledSdkVersion: %08X", sdkVersion));
    }
    sceKernelSetCompilerVersion(version) {
      console5.info(sprintf("sceKernelSetCompilerVersion: %08X", version));
    }
    sceKernelSetCompiledSdkVersion395(param7) {
      console5.info(sprintf("sceKernelSetCompiledSdkVersion395: %08X", param7));
    }
    sceKernelDevkitVersion(version) {
      return 34013456;
    }
    sceKernelPrintf(thread, format) {
      let gprIndex = 5;
      const memory2 = this.context.memory;
      let state = thread.state;
      const readParam = (type) => {
        switch (type) {
          case "%s":
            return memory2.readStringz(state.getGPR(gprIndex++));
          case "%d":
            return String(state.getGPR(gprIndex++));
        }
        return `??[${type}]??`;
      };
      console5.info(`sceKernelPrintf: ${format.replace(/%[dsux]/g, (data) => {
        return readParam(data);
      })}`);
    }
  };
  __decorate([
    nativeFunction(595443023, 150),
    I32,
    __param(0, I32),
    __param(1, STRING),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32)
  ], SysMemUserForUser.prototype, "sceKernelAllocPartitionMemory", 1);
  __decorate([
    nativeFunction(4268785631, 150),
    I32,
    __param(0, STRING),
    __param(1, U32),
    __param(2, U32),
    __param(3, PTR)
  ], SysMemUserForUser.prototype, "AllocMemoryBlock", 1);
  __decorate([
    nativeFunction(3682838866, 150),
    I32,
    __param(0, I32)
  ], SysMemUserForUser.prototype, "GetMemoryBlockAddr", 1);
  __decorate([
    nativeFunction(1358306698, 150),
    I32,
    __param(0, I32)
  ], SysMemUserForUser.prototype, "FreeMemoryBlock", 1);
  __decorate([
    nativeFunction(3067485442, 150),
    I32,
    __param(0, I32)
  ], SysMemUserForUser.prototype, "sceKernelFreePartitionMemory", 1);
  __decorate([
    nativeFunction(4179228200, 150),
    I32
  ], SysMemUserForUser.prototype, "sceKernelTotalFreeMemSize", 1);
  __decorate([
    nativeFunction(2644138913, 150),
    U32,
    __param(0, I32)
  ], SysMemUserForUser.prototype, "sceKernelGetBlockHeadAddr", 1);
  __decorate([
    nativeFunction(2727473415, 150),
    I32
  ], SysMemUserForUser.prototype, "sceKernelMaxFreeMemSize", 1);
  __decorate([
    nativeFunction(1972488155, 150),
    U32,
    __param(0, U32)
  ], SysMemUserForUser.prototype, "sceKernelSetCompiledSdkVersion", 1);
  __decorate([
    nativeFunction(4152195019, 150),
    U32,
    __param(0, U32)
  ], SysMemUserForUser.prototype, "sceKernelSetCompilerVersion", 1);
  __decorate([
    nativeFunction(3956655078, 150),
    U32,
    __param(0, U32)
  ], SysMemUserForUser.prototype, "sceKernelSetCompiledSdkVersion395", 1);
  __decorate([
    nativeFunction(1070181994, 150),
    U32,
    __param(0, U32)
  ], SysMemUserForUser.prototype, "sceKernelDevkitVersion", 1);
  __decorate([
    nativeFunction(329624559, 150),
    VOID,
    __param(0, THREAD),
    __param(1, STRING)
  ], SysMemUserForUser.prototype, "sceKernelPrintf", 1);

  // src/hle/module/UtilsForKernel.ts
  var UtilsForKernel_exports = {};
  __export(UtilsForKernel_exports, {
    UtilsForKernel: () => UtilsForKernel
  });
  var UtilsForKernel = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelIcacheInvalidateRange(address, size) {
      this.context.currentInstructionCache.invalidateRange(address, address + size);
    }
  };
  __decorate([
    nativeFunction(3269424910, 150),
    VOID,
    __param(0, U32),
    __param(1, U32)
  ], UtilsForKernel.prototype, "sceKernelIcacheInvalidateRange", 1);

  // src/hle/module/UtilsForUser.ts
  var UtilsForUser_exports = {};
  __export(UtilsForUser_exports, {
    UtilsForUser: () => UtilsForUser
  });
  var UtilsForUser = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelLibcClock() {
      return this.context.rtc.getClockMicroseconds();
    }
    sceKernelLibcTime(pointer) {
      if (pointer == Stream.INVALID)
        return 0;
      const result = this.context.rtc.getCurrentUnixSeconds() | 0;
      if (pointer)
        pointer.writeInt32(result);
      return result;
    }
    sceKernelGetGPI() {
      return 0;
    }
    sceKernelUtilsMt19937Init(memory2, contextPtr, seed) {
      console.warn("Not implemented UtilsForUser.sceKernelUtilsMt19937Init");
      return 0;
    }
    sceKernelUtilsMt19937UInt(memory2, contextPtr) {
      return Math.round(Math.random() * 4294967295);
    }
    sceKernelLibcGettimeofday(timevalPtr, timezonePtr) {
      if (timevalPtr) {
        const totalMilliseconds = Date.now();
        const totalSeconds = Math.floor(totalMilliseconds / 1e3);
        const milliseconds = Math.floor(totalMilliseconds % 1e3);
        const microseconds = milliseconds * 1e3;
        this.context.memory.writeInt32(timevalPtr, totalSeconds);
        this.context.memory.writeInt32(timevalPtr + 4, microseconds);
      }
      if (timezonePtr) {
        const minutesWest = 0;
        const dstTime = 0;
        this.context.memory.writeInt32(timezonePtr, minutesWest);
        this.context.memory.writeInt32(timezonePtr + 4, dstTime);
      }
      return 0;
    }
    sceKernelDcacheWritebackInvalidateRange(pointer, size) {
      if (size > 2147483647)
        return SceKernelErrors.ERROR_INVALID_SIZE;
      if (pointer >= 2147483648)
        return SceKernelErrors.ERROR_INVALID_POINTER;
      this.context.memory.invalidateDataRange.dispatch(pointer, pointer + size);
      return 0;
    }
    sceKernelDcacheWritebackRange(pointer, size) {
      if (size > 2147483647)
        return SceKernelErrors.ERROR_INVALID_SIZE;
      if (pointer >= 2147483648)
        return SceKernelErrors.ERROR_INVALID_POINTER;
      this.context.memory.invalidateDataRange.dispatch(pointer, pointer + size);
      return 0;
    }
    sceKernelDcacheWritebackAll() {
      this.context.memory.invalidateDataAll.dispatch();
      return 0;
    }
    sceKernelDcacheInvalidateRange(pointer, size) {
      if (!MathUtils.isAlignedTo(size, 4))
        return SceKernelErrors.ERROR_KERNEL_NOT_CACHE_ALIGNED;
      if (size > 2147483647)
        return SceKernelErrors.ERROR_INVALID_SIZE;
      if (pointer >= 2147483648)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ADDR;
      if (!MathUtils.isAlignedTo(pointer, 4))
        return SceKernelErrors.ERROR_KERNEL_NOT_CACHE_ALIGNED;
      this.context.memory.invalidateDataRange.dispatch(pointer, pointer + size);
      return 0;
    }
    sceKernelDcacheWritebackInvalidateAll() {
      this.context.memory.invalidateDataAll.dispatch();
      return 0;
    }
    sceKernelSetGPO(value) {
      return 0;
    }
  };
  __decorate([
    nativeFunction(2447701671, 150),
    U32
  ], UtilsForUser.prototype, "sceKernelLibcClock", 1);
  __decorate([
    nativeFunction(667703280, 150),
    U32,
    __param(0, PTR)
  ], UtilsForUser.prototype, "sceKernelLibcTime", 1);
  __decorate([
    nativeFunction(939220034, 150),
    U32
  ], UtilsForUser.prototype, "sceKernelGetGPI", 1);
  __decorate([
    nativeFunction(3898664798, 150),
    U32,
    __param(0, MEMORY),
    __param(1, U32),
    __param(2, U32)
  ], UtilsForUser.prototype, "sceKernelUtilsMt19937Init", 1);
  __decorate([
    nativeFunction(117148259, 150),
    U32,
    __param(0, MEMORY),
    __param(1, U32)
  ], UtilsForUser.prototype, "sceKernelUtilsMt19937UInt", 1);
  __decorate([
    nativeFunction(1911308913, 150, {doNotWait: true}),
    U32,
    __param(0, I32),
    __param(1, I32)
  ], UtilsForUser.prototype, "sceKernelLibcGettimeofday", 1);
  __decorate([
    nativeFunction(884603550, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], UtilsForUser.prototype, "sceKernelDcacheWritebackInvalidateRange", 1);
  __decorate([
    nativeFunction(1055066145, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], UtilsForUser.prototype, "sceKernelDcacheWritebackRange", 1);
  __decorate([
    nativeFunction(2043790330, 150),
    U32
  ], UtilsForUser.prototype, "sceKernelDcacheWritebackAll", 1);
  __decorate([
    nativeFunction(3215556706, 150),
    U32,
    __param(0, U32),
    __param(1, U32)
  ], UtilsForUser.prototype, "sceKernelDcacheInvalidateRange", 1);
  __decorate([
    nativeFunction(3023429317, 150),
    U32
  ], UtilsForUser.prototype, "sceKernelDcacheWritebackInvalidateAll", 1);
  __decorate([
    nativeFunction(1792230871, 150),
    U32,
    __param(0, I32)
  ], UtilsForUser.prototype, "sceKernelSetGPO", 1);

  // src/hle/module/iofilemgr/IoFileMgrForUser.ts
  var IoFileMgrForUser_exports = {};
  __export(IoFileMgrForUser_exports, {
    IoFileMgrForUser: () => IoFileMgrForUser
  });
  var log6 = logger.named("module.IoFileMgrForUser");
  var IoFileMgrForUser = class {
    constructor(context) {
      this.context = context;
      this.fileUids = new UidCollection(3);
      this.directoryUids = new UidCollection(1);
    }
    sceIoDevctl(deviceName, command, inputPointer, inputLength, outputPointer, outputLength) {
      const input = this.context.memory.getPointerStream(inputPointer, inputLength);
      const output = this.context.memory.getPointerStream(outputPointer, outputLength);
      return this.context.fileManager.devctlAsync(deviceName, command, input, output);
    }
    hasFileById(id) {
      return this.fileUids.has(id);
    }
    getFileById(id) {
      return this.fileUids.get(id);
    }
    sceIoOpen(filename, flags, mode) {
      return this._sceIoOpenAsync(filename, flags, mode).thenFast((result) => {
        const str = sprintf('IoFileMgrForUser.sceIoOpen("%s", %d(%s), 0%o)', filename, flags, setToString(FileOpenFlags, flags), mode);
        if (result == SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND) {
          log6.error(str, result);
        } else {
          log6.info(str, result);
        }
        return result;
      });
    }
    _sceIoOpenAsync(filename, flags, mode) {
      return this.context.fileManager.openAsync(filename, flags, mode).thenFast((file) => {
        return this.fileUids.allocate(file);
      }).catch((e) => {
        log6.error("Not found", filename, e);
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      });
    }
    sceIoOpenAsync(filename, flags, mode) {
      log6.info(sprintf('IoFileMgrForUser.sceIoOpenAsync("%s", %d(%s), 0%o)', filename, flags, setToString(FileOpenFlags, flags), mode));
      return this._sceIoOpenAsync(filename, flags, mode).thenFast((fileId) => {
        if (!this.hasFileById(fileId))
          return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
        const file = this.getFileById(fileId);
        file.setAsyncOperation(PromiseFast.resolve(Integer64.fromNumber(fileId)));
        log6.info("-->", fileId);
        return fileId;
      });
    }
    sceIoCloseAsync(fileId) {
      log6.info(sprintf("IoFileMgrForUser.closeAsync(%d)", fileId));
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      if (file)
        file.close();
      (async () => {
        await delay(100);
        this.fileUids.remove(fileId);
      })();
      file.setAsyncOperation(Integer64.ZERO);
      return 0;
    }
    sceIoAssign(device1, device2, device3, mode, unk1Ptr, unk2) {
      log6.warn(sprintf("sceIoAssign not implemented! %s -> %s -> %s", device1, device2, device3));
      return 0;
    }
    sceIoClose(fileId) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      if (file)
        file.close();
      this.fileUids.remove(fileId);
      return 0;
    }
    sceIoWrite(fileId, input) {
      if (fileId < 3) {
        const str = input.readString(input.length);
        log6.warn(`STD[${fileId}]`, str);
        this.context.onStdout.dispatch(str);
        return 0;
      } else {
        if (!this.hasFileById(fileId))
          return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
        const file = this.getFileById(fileId);
        return file.entry.writeChunkAsync(file.cursor, input.toArrayBuffer()).thenFast((writtenCount) => {
          log6.info("sceIoWrite", "file.cursor", file.cursor, "input.length:", input.length, "writtenCount:", writtenCount);
          file.cursor += writtenCount;
          return writtenCount;
        }).catch((e) => {
          log6.error(e);
          return SceKernelErrors.ERROR_ERROR;
        });
      }
    }
    sceIoRead(fileId, outputPointer, outputLength) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      return file.entry.readChunkAsync(file.cursor, outputLength).thenFast((readedData) => {
        file.cursor += readedData.byteLength;
        this.context.memory.writeBytes(outputPointer, readedData);
        return readedData.byteLength;
      });
    }
    sceIoReadAsync(thread, fileId, outputPointer, outputLength) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      file.setAsyncOperation(file.entry.readChunkAsync(file.cursor, outputLength).thenFast((readedData) => {
        file.cursor += readedData.byteLength;
        this.context.memory.writeBytes(outputPointer, readedData);
        return Integer64.fromNumber(readedData.byteLength);
      }));
      return 0;
    }
    _sceIoWaitAsyncCB(thread, fileId, resultPointer) {
      thread.state.LO = fileId;
      if (!this.fileUids.has(fileId)) {
        if (DebugOnce("_sceIoWaitAsyncCB", 100))
          log6.info("_sceIoWaitAsyncCB", fileId, "file not found");
        return PromiseFast.resolve(SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND);
      }
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      if (file.asyncOperation) {
        if (DebugOnce("_sceIoWaitAsyncCB", 100))
          log6.info(thread.name, ":_sceIoWaitAsyncCB", fileId, "completed");
        return file.asyncOperation.thenFast((result) => {
          if (DebugOnce("_sceIoWaitAsyncCB", 100))
            log6.info(thread.name, ":_sceIoWaitAsyncCB", fileId, "result: ", result.getNumber());
          resultPointer.writeInt64(result);
          return 0;
        });
      } else {
        if (DebugOnce("_sceIoWaitAsyncCB", 100))
          log6.info(thread.name, ":_sceIoWaitAsyncCB", fileId, "incompleted");
        resultPointer.writeInt64(Integer64.fromNumber(0));
        return PromiseFast.resolve(1);
      }
    }
    sceIoWaitAsync(thread, fileId, resultPointer) {
      return this._sceIoWaitAsyncCB(thread, fileId, resultPointer);
    }
    sceIoWaitAsyncCB(thread, fileId, resultPointer) {
      return this._sceIoWaitAsyncCB(thread, fileId, resultPointer);
    }
    sceIoPollAsync(thread, fileId, resultPointer) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      if (file.asyncResult) {
        resultPointer.writeInt64(file.asyncResult);
        return 0;
      } else {
        resultPointer.writeInt64(Integer64.fromInt(0));
        return 1;
      }
    }
    _vfsStatToSceIoStat(stat) {
      const stat2 = new SceIoStat();
      stat2.mode = 0;
      stat2.size = stat.size;
      stat2.timeCreation = ScePspDateTime.fromDate(stat.timeCreation);
      stat2.timeLastAccess = ScePspDateTime.fromDate(stat.timeLastAccess);
      stat2.timeLastModification = ScePspDateTime.fromDate(stat.timeLastModification);
      stat2.deviceDependentData[0] = stat.dependentData0 || 0;
      stat2.deviceDependentData[1] = stat.dependentData1 || 0;
      stat2.attributes = 0;
      if (stat.isDirectory) {
        stat2.mode = 4096;
        stat2.attributes |= IOFileModes.Directory;
        stat2.attributes |= IOFileModes.CanRead;
      } else {
        stat2.mode = 8192;
        stat2.attributes |= IOFileModes.File;
        stat2.attributes |= IOFileModes.CanExecute;
        stat2.attributes |= IOFileModes.CanRead;
        stat2.attributes |= IOFileModes.CanWrite;
      }
      return stat2;
    }
    sceIoGetstat(fileName, sceIoStatPointer) {
      if (sceIoStatPointer) {
        sceIoStatPointer.position = 0;
        SceIoStat.struct.write(sceIoStatPointer, new SceIoStat());
      }
      try {
        return this.context.fileManager.getStatAsync(fileName).thenFast((stat) => {
          const stat2 = this._vfsStatToSceIoStat(stat);
          log6.info(sprintf('IoFileMgrForUser.sceIoGetstat("%s")', fileName), stat2);
          if (sceIoStatPointer) {
            sceIoStatPointer.position = 0;
            SceIoStat.struct.write(sceIoStatPointer, stat2);
          }
          return 0;
        }).catch((error) => SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND);
      } catch (e) {
        log6.error(e);
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      }
    }
    sceIoChdir(path) {
      log6.info(sprintf('IoFileMgrForUser.sceIoChdir("%s")', path));
      try {
        this.context.fileManager.chdir(path);
        return 0;
      } catch (e) {
        log6.error(e);
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      }
    }
    sceIoLseekAsync(fileId, offset, whence) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      const result = this._seek(fileId, offset.getNumber(), whence);
      file.setAsyncOperationNow(Integer64.fromNumber(result));
      return 0;
    }
    sceIoLseek(fileId, offset, whence) {
      const result = this._seek(fileId, offset.getNumber(), whence);
      return Integer64.fromNumber(result);
    }
    sceIoLseek32(fileId, offset, whence) {
      const result = this._seek(fileId, offset, whence);
      return result;
    }
    sceIoMkdir(path, accessMode) {
      log6.warn(`Not implemented: sceIoMkdir("${path}", ${accessMode.toString(8)})`);
      return 0;
    }
    sceIoDopen(path) {
      log6.log(`sceIoDopen("${path}")`);
      return this.context.fileManager.openDirectoryAsync(path).thenFast((directory) => {
        log6.log(`opened directory "${path}"`);
        return this.directoryUids.allocate(directory);
      }).catch((error) => {
        log6.error(error);
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      });
    }
    sceIoDclose(fileId) {
      if (!this.directoryUids.has(fileId))
        return -1;
      this.directoryUids.get(fileId).close();
      this.directoryUids.remove(fileId);
      return 0;
    }
    sceIoDread(fileId, hleIoDirentPtr) {
      if (!this.directoryUids.has(fileId))
        return -1;
      const directory = this.directoryUids.get(fileId);
      if (directory.left > 0) {
        const stat = directory.read();
        const hleIoDirent = new HleIoDirent();
        hleIoDirent.name = stat.name ?? "";
        hleIoDirent.stat = this._vfsStatToSceIoStat(stat);
        hleIoDirent.privateData = 0;
        HleIoDirent.struct.write(hleIoDirentPtr, hleIoDirent);
      }
      return directory.left;
    }
    sceIoChangeAsyncPriority(fileId, priority) {
      return 0;
    }
    _seek(fileId, offset, whence) {
      if (!this.hasFileById(fileId))
        return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
      const file = this.getFileById(fileId);
      switch (whence) {
        case SeekAnchor.Set:
          file.cursor = 0 + offset;
          break;
        case SeekAnchor.Cursor:
          file.cursor = file.cursor + offset;
          break;
        case SeekAnchor.End:
          file.cursor = file.entry.size + offset;
          break;
      }
      return file.cursor;
    }
  };
  IoFileMgrForUser.STDIN_ID = 0;
  IoFileMgrForUser.STDOUT_ID = 1;
  IoFileMgrForUser.STDERR_ID = 2;
  __decorate([
    nativeFunction(1425406737, 150),
    U32,
    __param(0, STRING),
    __param(1, U32),
    __param(2, U32),
    __param(3, I32),
    __param(4, U32),
    __param(5, I32)
  ], IoFileMgrForUser.prototype, "sceIoDevctl", 1);
  __decorate([
    nativeFunction(278876348, 150),
    I32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoOpen", 1);
  __decorate([
    nativeFunction(2309658886, 150),
    I32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoOpenAsync", 1);
  __decorate([
    nativeFunction(4284039350, 150),
    I32,
    __param(0, I32)
  ], IoFileMgrForUser.prototype, "sceIoCloseAsync", 1);
  __decorate([
    nativeFunction(2997233857, 150),
    I32,
    __param(0, STRING),
    __param(1, STRING),
    __param(2, STRING),
    __param(3, I32),
    __param(4, PTR),
    __param(5, I64)
  ], IoFileMgrForUser.prototype, "sceIoAssign", 1);
  __decorate([
    nativeFunction(2165066691, 150),
    I32,
    __param(0, I32)
  ], IoFileMgrForUser.prototype, "sceIoClose", 1);
  __decorate([
    nativeFunction(1122763692, 150),
    I32,
    __param(0, I32),
    __param(1, BYTES)
  ], IoFileMgrForUser.prototype, "sceIoWrite", 1);
  __decorate([
    nativeFunction(1784909187, 150),
    I32,
    __param(0, I32),
    __param(1, U32),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoRead", 1);
  __decorate([
    nativeFunction(2696259522, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, U32),
    __param(3, I32)
  ], IoFileMgrForUser.prototype, "sceIoReadAsync", 1);
  __decorate([
    nativeFunction(3795774515, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, PTR)
  ], IoFileMgrForUser.prototype, "sceIoWaitAsync", 1);
  __decorate([
    nativeFunction(903599942, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, PTR)
  ], IoFileMgrForUser.prototype, "sceIoWaitAsyncCB", 1);
  __decorate([
    nativeFunction(844229206, 150),
    U32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, PTR)
  ], IoFileMgrForUser.prototype, "sceIoPollAsync", 1);
  __decorate([
    nativeFunction(2900969192, 150),
    I32,
    __param(0, STRING),
    __param(1, PTR)
  ], IoFileMgrForUser.prototype, "sceIoGetstat", 1);
  __decorate([
    nativeFunction(1442083197, 150),
    I32,
    __param(0, STRING)
  ], IoFileMgrForUser.prototype, "sceIoChdir", 1);
  __decorate([
    nativeFunction(1907465847, 150),
    I32,
    __param(0, I32),
    __param(1, I64),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoLseekAsync", 1);
  __decorate([
    nativeFunction(669722552, 150),
    I64,
    __param(0, I32),
    __param(1, I64),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoLseek", 1);
  __decorate([
    nativeFunction(1754673956, 150),
    I32,
    __param(0, I32),
    __param(1, I32),
    __param(2, I32)
  ], IoFileMgrForUser.prototype, "sceIoLseek32", 1);
  __decorate([
    nativeFunction(111607812, 150),
    U32,
    __param(0, STRING),
    __param(1, I32)
  ], IoFileMgrForUser.prototype, "sceIoMkdir", 1);
  __decorate([
    nativeFunction(2996690844, 150),
    U32,
    __param(0, STRING)
  ], IoFileMgrForUser.prototype, "sceIoDopen", 1);
  __decorate([
    nativeFunction(3943244905, 150),
    U32,
    __param(0, I32)
  ], IoFileMgrForUser.prototype, "sceIoDclose", 1);
  __decorate([
    nativeFunction(3823829068, 150),
    I32,
    __param(0, I32),
    __param(1, PTR)
  ], IoFileMgrForUser.prototype, "sceIoDread", 1);
  __decorate([
    nativeFunction(2996007551, 150),
    I32,
    __param(0, I32),
    __param(1, I32)
  ], IoFileMgrForUser.prototype, "sceIoChangeAsyncPriority", 1);

  // src/hle/module/threadman/ThreadManForUser.ts
  var ThreadManForUser_exports = {};
  __export(ThreadManForUser_exports, {
    ThreadManForUser: () => ThreadManForUser
  });

  // src/hle/manager/thread.ts
  var console6 = logger.named("hle.thread");
  var ThreadStatus;
  (function(ThreadStatus2) {
    ThreadStatus2[ThreadStatus2["RUNNING"] = 1] = "RUNNING";
    ThreadStatus2[ThreadStatus2["READY"] = 2] = "READY";
    ThreadStatus2[ThreadStatus2["WAIT"] = 4] = "WAIT";
    ThreadStatus2[ThreadStatus2["SUSPEND"] = 8] = "SUSPEND";
    ThreadStatus2[ThreadStatus2["DORMANT"] = 16] = "DORMANT";
    ThreadStatus2[ThreadStatus2["DEAD"] = 32] = "DEAD";
    ThreadStatus2[ThreadStatus2["WAITSUSPEND"] = 12] = "WAITSUSPEND";
  })(ThreadStatus || (ThreadStatus = {}));
  var PspThreadAttributes;
  (function(PspThreadAttributes2) {
    PspThreadAttributes2[PspThreadAttributes2["None"] = 0] = "None";
    PspThreadAttributes2[PspThreadAttributes2["LowFF"] = 255] = "LowFF";
    PspThreadAttributes2[PspThreadAttributes2["Vfpu"] = 16384] = "Vfpu";
    PspThreadAttributes2[PspThreadAttributes2["V0x2000"] = 8192] = "V0x2000";
    PspThreadAttributes2[PspThreadAttributes2["V0x4000"] = 16384] = "V0x4000";
    PspThreadAttributes2[PspThreadAttributes2["V0x400000"] = 4194304] = "V0x400000";
    PspThreadAttributes2[PspThreadAttributes2["V0x800000"] = 8388608] = "V0x800000";
    PspThreadAttributes2[PspThreadAttributes2["V0xf00000"] = 15728640] = "V0xf00000";
    PspThreadAttributes2[PspThreadAttributes2["V0x8000000"] = 134217728] = "V0x8000000";
    PspThreadAttributes2[PspThreadAttributes2["V0xf000000"] = 251658240] = "V0xf000000";
    PspThreadAttributes2[PspThreadAttributes2["User"] = 2147483648] = "User";
    PspThreadAttributes2[PspThreadAttributes2["UsbWlan"] = 2684354560] = "UsbWlan";
    PspThreadAttributes2[PspThreadAttributes2["Vsh"] = 3221225472] = "Vsh";
    PspThreadAttributes2[PspThreadAttributes2["NoFillStack"] = 1048576] = "NoFillStack";
    PspThreadAttributes2[PspThreadAttributes2["ClearStack"] = 2097152] = "ClearStack";
    PspThreadAttributes2[PspThreadAttributes2["ValidMask"] = -269459201] = "ValidMask";
  })(PspThreadAttributes || (PspThreadAttributes = {}));
  var Thread = class {
    constructor(name2, manager, memoryManager, state, stackSize) {
      this.name = name2;
      this.manager = manager;
      this.state = state;
      this.id = 0;
      this.status = 16;
      this.initialPriority = 10;
      this.entryPoint = 0;
      this.priority = 10;
      this.attributes = 0;
      this.sceKernelCpuResumeIntrCount = 0;
      this.exitStatus = SceKernelErrors.ERROR_KERNEL_THREAD_ALREADY_DORMANT;
      this.running = false;
      this.preemptionCount = 0;
      this.info = null;
      this.waitingName = null;
      this.waitingObject = null;
      this.waitingPromise = null;
      this.acceptingCallbacks = false;
      this.wakeupCount = 0;
      this.wakeupPromise = null;
      this.wakeupFunc = null;
      this.accumulatedMicroseconds = 0;
      this.state.thread = this;
      this.runningPromise = new PromiseFast((resolve, reject) => {
        this.runningStop = resolve;
      });
      this.stackPartition = memoryManager.stackPartition.allocateHigh(stackSize, name2 + "-stack", 256);
    }
    get runningOrAcceptingCallbacks() {
      return this.running || this.acceptingCallbacks;
    }
    delete() {
      this.stackPartition.deallocate();
    }
    waitEndAsync() {
      return this.runningPromise;
    }
    getWakeupPromise() {
      if (!this.wakeupPromise) {
        this.wakeupPromise = new PromiseFast((resolve, reject) => {
          this.wakeupFunc = resolve;
        });
      }
      return this.wakeupPromise;
    }
    wakeupSleepAsync(callbacks) {
      this.wakeupCount--;
      this.suspend();
      return this.getWakeupPromise();
    }
    wakeupWakeupAsync() {
      this.wakeupCount++;
      if (this.wakeupCount >= 0) {
        this.wakeupFunc?.();
        this.wakeupPromise = null;
        this.wakeupFunc = null;
      }
      return PromiseFast.resolve(0);
    }
    async delayMicrosecondsAsync(delayMicroseconds, allowCompensating = false) {
      this.accumulatedMicroseconds = Math.min(this.accumulatedMicroseconds, 5e4);
      if (allowCompensating) {
        const subtractAccumulatedMicroseconds = Math.min(delayMicroseconds, this.accumulatedMicroseconds);
        delayMicroseconds -= subtractAccumulatedMicroseconds;
        this.accumulatedMicroseconds -= subtractAccumulatedMicroseconds;
      }
      if (delayMicroseconds <= 1e-5) {
      }
      const start = performance.now();
      await waitAsync(delayMicroseconds / 1e3);
      const end = performance.now();
      const elapsedmicroseconds = (end - start) * 1e3;
      this.accumulatedMicroseconds += elapsedmicroseconds - delayMicroseconds | 0;
      return 0;
    }
    suspend() {
      this.running = false;
      this.manager.eventOcurred();
    }
    suspendUntilDone(info) {
      this.info = info;
      this.waitingName = info.name;
      this.waitingObject = info.object;
      this.acceptingCallbacks = info.callbacks == AcceptCallbacks.YES;
      this._suspendUntilPromiseDone(PromiseFast.ensure(info.promise), info.compensate);
    }
    suspendUntilPromiseDone(promise, info) {
      this.waitingName = `${info.name}:0x${info.nid.toString(16)} (PromiseFast)`;
      this.waitingObject = info;
      this._suspendUntilPromiseDone(promise, Compensate.NO);
    }
    _suspendUntilPromiseDone(promise, compensate) {
      let startTime = 0;
      if (compensate == Compensate.YES) {
        startTime = performance.now();
      }
      this.waitingPromise = promise;
      this.suspend();
      promise.thenFast((result) => {
        this.waitingPromise = null;
        this.waitingName = null;
        this.waitingObject = null;
        this.acceptingCallbacks = false;
        if (result !== void 0) {
          if (result instanceof Integer64) {
            this.state.V0 = result.low;
            this.state.V1 = result.high;
          } else {
            this.state.V0 = result;
          }
        }
        if (compensate == Compensate.YES) {
          const endTime = performance.now();
          this.accumulatedMicroseconds += (endTime - startTime) * 1e3;
        }
        this.resume();
      });
    }
    resume() {
      this.running = true;
      this.manager.eventOcurred();
    }
    start() {
      this.running = true;
      console6.info("starting thread ", this.name);
      this.manager.threads.add(this);
      this.manager.eventOcurred();
    }
    stop(reason) {
      this.running = false;
      this.runningStop();
      console6.info("stopping thread ", this.name, "reason:", reason);
      this.manager.threads.delete(this);
      this.manager.eventOcurred();
    }
    runStep() {
      this.manager.current = this;
      this.preemptionCount++;
      CpuExecutor.executeAtPC(this.state);
    }
  };
  var ThreadManager = class {
    constructor(memory2, interruptManager, callbackManager, memoryManager, display, syscallManager, cpuConfig) {
      this.memory = memory2;
      this.interruptManager = interruptManager;
      this.callbackManager = callbackManager;
      this.memoryManager = memoryManager;
      this.display = display;
      this.syscallManager = syscallManager;
      this.cpuConfig = cpuConfig;
      this.threads = new DSet();
      this.enqueued = false;
      this.enqueuedTime = 0;
      this.running = false;
      this.callbackAdded = null;
      this.rootCpuState = new CpuState(this.memory, this.syscallManager, this.cpuConfig);
      this.exitPromise = new PromiseFast((resolve, reject) => {
        this.exitResolve = resolve;
      });
      this.interruptManager.event.add(this.eventOcurred);
    }
    create(name2, entryPoint, initialPriority, stackSize = 4096, attributes = 0) {
      const thread = new Thread(name2, this, this.memoryManager, this.rootCpuState.clone(), stackSize);
      thread.entryPoint = entryPoint;
      thread.state.setPC(entryPoint);
      thread.state.setRA(CpuSpecialAddresses.EXIT_THREAD);
      thread.state.SP = thread.stackPartition.high;
      thread.initialPriority = initialPriority;
      thread.priority = initialPriority;
      thread.attributes = attributes;
      if ((thread.stackPartition.high & 255) != 0)
        throw new Error("Stack not aligned");
      if (!(thread.attributes & 1048576)) {
      } else if (thread.attributes & 2097152) {
      }
      return thread;
    }
    eventOcurred() {
      if (!this.running)
        return;
      if (this.enqueued)
        return;
      this.enqueued = true;
      this.enqueuedTime = performance.now();
      Microtask.queue(() => this.eventOcurredCallback());
    }
    frame() {
    }
    static getHighestPriority(threads) {
      let priority = -9999;
      threads.forEach((thread) => {
        priority = Math.max(priority, thread.priority);
      });
      return priority;
    }
    eventOcurredCallback() {
      if (!this.running)
        return;
      const microsecondsToCompensate = Math.round((performance.now() - this.enqueuedTime) * 1e3);
      this.enqueued = false;
      const start = window.performance.now();
      while (true) {
        if (this.threads.elements.length > 0) {
          this.interruptManager.execute(this.threads.elements[0].state);
        }
        let callbackThreadCount = 0;
        let callbackPriority = Number.MAX_VALUE;
        let runningThreadCount = 0;
        let runningPriority = Number.MAX_VALUE;
        this.threads.forEach((thread) => {
          if (this.callbackManager.hasPendingCallbacks) {
            if (thread.acceptingCallbacks) {
              callbackThreadCount++;
              callbackPriority = Math.min(callbackPriority, thread.priority);
            }
          }
          if (thread.running) {
            runningThreadCount++;
            runningPriority = Math.min(runningPriority, thread.priority);
          }
        });
        if (runningThreadCount == 0 && callbackThreadCount == 0)
          break;
        if (callbackThreadCount != 0) {
          this.threads.forEach((thread) => {
            if (thread.acceptingCallbacks && thread.priority == callbackPriority) {
              this.callbackManager.executePendingWithinThread(thread);
            }
          });
        }
        if (runningThreadCount != 0) {
          try {
            this.threads.forEach((thread) => {
              if (thread.running && thread.priority == runningPriority) {
                this.callbackManager.executeLaterPendingWithinThread(thread);
                this.runThreadStep(thread);
              }
            });
          } catch (e) {
            if (ProgramExitException.is(e)) {
              console6.error("Stopping game due to error", e);
              this.exitGame(-1);
              return;
            }
            throw e;
          }
        }
        const current = window.performance.now();
        if (current - start >= 100) {
          setTimeout(() => this.eventOcurred(), 0);
          return;
        }
      }
    }
    runThreadStep(thread) {
      try {
        do {
          thread.runStep();
          if (!this.interruptManager.enabled) {
            console6.log(thread.name, ":interrupts disabled, no thread scheduling!");
          }
        } while (!this.interruptManager.enabled);
      } catch (e) {
        if (CpuBreakException.is(e))
          return;
        if (ProgramExitException.is(e))
          throw e;
        const estack = e["stack"] || e;
        EmulatorUI.openMessageAsync(estack);
        thread.stop(`thread.stop.error:${estack}`);
        throw e;
      }
    }
    debugThreads() {
      let html = "";
      this.threads.forEach((thread) => {
        html += sprintf("%08X:%s:%s", thread.state.PC, thread.name, thread.running);
      });
      document.getElementById("thread_list").innerHTML = html;
    }
    register() {
      this.running = true;
      this.eventOcurred();
      this.callbackAdded = this.callbackManager.onAdded.add(() => {
        this.eventOcurred();
      });
    }
    unregister() {
      this.running = false;
      this.callbackManager.onAdded.remove(this.callbackAdded);
    }
    stopAsync() {
      this.unregister();
      return PromiseFast.resolve();
    }
    startAsync() {
      this.register();
      return PromiseFast.resolve();
    }
    exitGame(errorCode = 0) {
      this.exitResolve(errorCode);
    }
    waitExitGameAsync() {
      return this.exitPromise;
    }
    delayThread(microseconds) {
    }
  };

  // src/hle/manager/memory.ts
  var MemoryPartitions;
  (function(MemoryPartitions2) {
    MemoryPartitions2[MemoryPartitions2["Kernel0"] = 0] = "Kernel0";
    MemoryPartitions2[MemoryPartitions2["User"] = 2] = "User";
    MemoryPartitions2[MemoryPartitions2["VolatilePartition"] = 5] = "VolatilePartition";
    MemoryPartitions2[MemoryPartitions2["UserStacks"] = 6] = "UserStacks";
  })(MemoryPartitions || (MemoryPartitions = {}));
  var MemoryAnchor;
  (function(MemoryAnchor2) {
    MemoryAnchor2[MemoryAnchor2["Low"] = 0] = "Low";
    MemoryAnchor2[MemoryAnchor2["High"] = 1] = "High";
    MemoryAnchor2[MemoryAnchor2["Address"] = 2] = "Address";
    MemoryAnchor2[MemoryAnchor2["LowAligned"] = 3] = "LowAligned";
    MemoryAnchor2[MemoryAnchor2["HighAligned"] = 4] = "HighAligned";
  })(MemoryAnchor || (MemoryAnchor = {}));
  var OutOfMemoryError = class {
    constructor(message, name2 = "OutOfMemoryError") {
      this.message = message;
      this.name = name2;
    }
  };
  var MemoryPartition = class {
    constructor(name2, low, high, allocated, parent) {
      this.name = name2;
      this.low = low;
      this.high = high;
      this.allocated = allocated;
      this.parent = parent;
      this._childPartitions = [];
    }
    get size() {
      return this.high - this.low;
    }
    get root() {
      return this.parent ? this.parent.root : this;
    }
    get childPartitions() {
      if (this._childPartitions.length == 0)
        this._childPartitions.push(new MemoryPartition("", this.low, this.high, false));
      return this._childPartitions;
    }
    contains(address) {
      return address >= this.low && address < this.high;
    }
    deallocate() {
      this.allocated = false;
      if (this.parent) {
        this.parent.cleanup();
      }
    }
    allocate(size, anchor, address = 0, name2 = "") {
      switch (anchor) {
        case 3:
        case 0:
          return this.allocateLow(size, name2);
        case 1:
          return this.allocateHigh(size, name2);
        case 2:
          return this.allocateSet(size, address, name2);
        default:
          throw new Error(sprintf("Not implemented anchor %d:%s", anchor, MemoryAnchor[anchor]));
      }
    }
    allocateSet(size, addressLow, name2 = "") {
      const childs = this.childPartitions;
      const addressHigh = addressLow + size;
      if (!this.contains(addressLow) || !this.contains(addressHigh)) {
        throw new OutOfMemoryError(sprintf("Can't allocate [%08X-%08X] in [%08X-%08X]", addressLow, addressHigh, this.low, this.high));
      }
      for (let n = 0; n < childs.length; n++) {
        const child = childs[n];
        if (!child.contains(addressLow))
          continue;
        if (child.allocated)
          throw new Error("Memory already allocated");
        if (!child.contains(addressHigh - 1))
          throw new Error("Can't fit memory");
        const p1 = new MemoryPartition("", child.low, addressLow, false, this);
        const p2 = new MemoryPartition(name2, addressLow, addressHigh, true, this);
        const p3 = new MemoryPartition("", addressHigh, child.high, false, this);
        childs.splice(n, 1, p1, p2, p3);
        this.cleanup();
        return p2;
      }
      console.log(sprintf("address: %08X, size: %d", addressLow, size));
      console.log(this);
      throw new Error("Can't find the segment");
    }
    allocateLow(size, name2 = "") {
      return this.allocateLowHigh(size, true, name2);
    }
    allocateHigh(size, name2 = "", alignment = 1) {
      return this.allocateLowHigh(size, false, name2);
    }
    _validateChilds() {
      const childs = this._childPartitions;
      if (childs[0].low != this.low)
        throw new Error("Invalid state [1]");
      if (childs[childs.length - 1].high != this.high)
        throw new Error("Invalid state [2]");
      for (let n = 0; n < childs.length - 1; n++) {
        if (childs[n + 0].high != childs[n + 1].low)
          throw new Error("Invalid state [3] -> " + n);
      }
    }
    allocateLowHigh(size, low, name2 = "") {
      const childs = this.childPartitions;
      for (let n = 0; n < childs.length; n++) {
        const child = childs[n];
        if (child.allocated)
          continue;
        if (child.size < size)
          continue;
        let allocatedChild;
        if (low) {
          const p1 = child.low;
          const p2 = child.low + size;
          const p3 = child.high;
          allocatedChild = new MemoryPartition(name2, p1, p2, true, this);
          const unallocatedChild = new MemoryPartition("", p2, p3, false, this);
          childs.splice(n, 1, allocatedChild, unallocatedChild);
        } else {
          const p1 = child.low;
          const p2 = child.high - size;
          const p3 = child.high;
          const unallocatedChild = new MemoryPartition("", p1, p2, false, this);
          allocatedChild = new MemoryPartition(name2, p2, p3, true, this);
          childs.splice(n, 1, unallocatedChild, allocatedChild);
        }
        this.cleanup();
        return allocatedChild;
      }
      throw new OutOfMemoryError("Can't find a partition with " + size + " available");
    }
    unallocate() {
      this.name = "";
      this.allocated = false;
      if (this.parent)
        this.parent.cleanup();
    }
    cleanup() {
      const startTotalFreeMemory = this.getTotalFreeMemory();
      const childs = this.childPartitions;
      if (childs.length >= 2) {
        for (let n = 0; n < childs.length - 1; n++) {
          const child = childs[n + 0];
          const c1 = childs[n + 1];
          if (!child.allocated && !c1.allocated) {
            childs.splice(n, 2, new MemoryPartition("", child.low, c1.high, false, this));
            n--;
          }
        }
      }
      for (let n = 0; n < childs.length; n++) {
        const child = childs[n];
        if (!child.allocated && child.size == 0)
          childs.splice(n, 1);
      }
      const endTotalFreeMemory = this.getTotalFreeMemory();
      if (endTotalFreeMemory != startTotalFreeMemory) {
        console.log(`assertion failed! : ${startTotalFreeMemory},${endTotalFreeMemory}`);
      }
    }
    get nonAllocatedPartitions() {
      return this.childPartitions.filter((item) => !item.allocated);
    }
    getTotalFreeMemory() {
      return this.nonAllocatedPartitions.reduce((prev, item) => item.size + prev, 0);
    }
    getMaxContiguousFreeMemory() {
      return this.nonAllocatedPartitions.max((item) => item.size).size;
    }
    findFreeChildWithSize(size) {
    }
  };
  var MemoryManager = class {
    constructor() {
      this.memoryPartitionsUid = {};
      this.init();
    }
    init() {
      this.memoryPartitionsUid[0] = new MemoryPartition("Kernel Partition 1", 2281701376, 2284847104, false);
      this.memoryPartitionsUid[2] = new MemoryPartition("User Partition", 142606336, 142606336 + 1048576 * 24, false);
      this.memoryPartitionsUid[6] = new MemoryPartition("User Stacks Partition", 142606336, 142606336 + 1048576 * 24, false);
      this.memoryPartitionsUid[5] = new MemoryPartition("Volatile Partition", 138412032, 142606336, false);
    }
    get kernelPartition() {
      return this.memoryPartitionsUid[0];
    }
    get userPartition() {
      return this.memoryPartitionsUid[2];
    }
    get stackPartition() {
      return this.memoryPartitionsUid[6];
    }
  };

  // src/hle/module/threadman/ThreadManForUser.ts
  var console7 = logger.named("module.ThreadManForUser");
  var ThreadManForUser = class {
    constructor(context) {
      this.context = context;
      this.threadUids = new UidCollection(1);
    }
    sceKernelCreateThread(name2, entryPoint, initPriority, stackSize, attributes, optionPtr, currentThread) {
      if (name2 == null)
        return SceKernelErrors.ERROR_ERROR;
      if (stackSize < 512)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_STACK_SIZE;
      if (initPriority < 8 || initPriority > 119)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_PRIORITY;
      if (!this.context.memory.isValidAddress(entryPoint) || entryPoint == 0)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR;
      if (name2.length > 31)
        name2 = name2.substr(0, 31);
      if (stackSize > 2 * 1024 * 1024)
        return -3;
      if ((attributes & ~PspThreadAttributes.ValidMask) != 0) {
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ATTR;
      }
      attributes |= PspThreadAttributes.User;
      attributes |= PspThreadAttributes.LowFF;
      try {
        stackSize = Math.max(stackSize, 512);
        stackSize = MathUtils.nextAligned(stackSize, 256);
        const newThread = this.context.threadManager.create(name2, entryPoint, initPriority, stackSize, attributes);
        newThread.id = this.threadUids.allocate(newThread);
        newThread.status = ThreadStatus.DORMANT;
        newThread.state.GP = currentThread.state.GP;
        console7.info(sprintf('sceKernelCreateThread: %d:"%s":priority=%d, currentPriority=%d, entryPC=%08X', newThread.id, newThread.name, newThread.priority, currentThread.priority, entryPoint));
        return newThread.id;
      } catch (e) {
        if (e instanceof OutOfMemoryError)
          return SceKernelErrors.ERROR_KERNEL_NO_MEMORY;
        throw e;
      }
    }
    hasThreadById(id) {
      return this.threadUids.has(id);
    }
    getThreadById(id) {
      if (id == 0)
        return this.context.threadManager.current;
      return this.threadUids.get(id);
    }
    _sceKernelDelayThreadCB(thread, delayInMicroseconds, acceptCallbacks) {
      return new WaitingThreadInfo("_sceKernelDelayThreadCB", `microseconds:${delayInMicroseconds}`, thread.delayMicrosecondsAsync(delayInMicroseconds, false), acceptCallbacks);
    }
    sceKernelDelayThread(thread, delayInMicroseconds) {
      return this._sceKernelDelayThreadCB(thread, delayInMicroseconds, AcceptCallbacks.NO);
    }
    sceKernelDelayThreadCB(thread, delayInMicroseconds) {
      return this._sceKernelDelayThreadCB(thread, delayInMicroseconds, AcceptCallbacks.YES);
    }
    _sceKernelWaitThreadEndCB(thread, acceptCallbacks) {
      return new WaitingThreadInfo("_sceKernelWaitThreadEndCB", thread, (async () => {
        await thread.waitEndAsync();
        return thread.exitStatus;
      })(), acceptCallbacks);
    }
    sceKernelWaitThreadEndCB(threadId, timeoutPtr) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      return this._sceKernelWaitThreadEndCB(this.getThreadById(threadId), AcceptCallbacks.YES);
    }
    sceKernelWaitThreadEnd(threadId, timeoutPtr) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      return this._sceKernelWaitThreadEndCB(this.getThreadById(threadId), AcceptCallbacks.NO);
    }
    sceKernelGetThreadCurrentPriority(currentThread) {
      return currentThread.priority;
    }
    sceKernelStartThread(currentThread, threadId, userDataLength, userDataPointer) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const newThread = this.getThreadById(threadId);
      newThread.exitStatus = SceKernelErrors.ERROR_KERNEL_THREAD_IS_NOT_DORMANT;
      const newState = newThread.state;
      const memory2 = newState.memory;
      const currentStack = newThread.stackPartition;
      newState.setRA(CpuSpecialAddresses.EXIT_THREAD);
      if ((newThread.attributes & 1048576) == 0) {
        memory2.memset(currentStack.low, 255, currentStack.size);
      }
      const copiedDataAddress = newThread.stackPartition.high - (userDataLength + 15 & ~15);
      if (userDataPointer != null) {
        memory2.copy(userDataPointer, copiedDataAddress, userDataLength);
        newState.setGPR(4, userDataLength);
        newState.setGPR(5, copiedDataAddress);
      } else {
        newState.setGPR(4, 0);
        newState.setGPR(5, 0);
      }
      newState.SP = copiedDataAddress;
      newState.SP -= 256;
      newState.K0 = newState.SP;
      memory2.memset(newState.K0, 0, 256);
      memory2.sw(newState.K0 + 192, newThread.id);
      memory2.sw(newState.K0 + 200, currentStack.low);
      memory2.sw(newState.K0 + 248, 4294967295);
      memory2.sw(newState.K0 + 252, 4294967295);
      memory2.sw(currentStack.low, newThread.id);
      console7.info(sprintf('sceKernelStartThread: %d:"%s":priority=%d, currentPriority=%d, SP=%08X, GP=%08X, FP=%08X', threadId, newThread.name, newThread.priority, currentThread.priority, newState.SP, newState.GP, newState.FP));
      newThread.start();
      return PromiseFast.resolve(0);
    }
    sceKernelChangeThreadPriority(currentThread, threadId, priority) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const thread = this.getThreadById(threadId);
      thread.priority = priority;
      return PromiseFast.resolve(0);
    }
    sceKernelExitThread(exitStatus, currentThread, state) {
      console7.info(sprintf("sceKernelExitThread: %d", exitStatus));
      currentThread.exitStatus = exitStatus < 0 ? SceKernelErrors.ERROR_KERNEL_ILLEGAL_ARGUMENT : exitStatus;
      currentThread.stop("sceKernelExitThread");
      state.throwEndCycles();
    }
    sceKernelGetThreadExitStatus(threadId) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const thread = this.getThreadById(threadId);
      return thread.exitStatus;
    }
    _sceKernelTerminateThread(threadId) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const newThread = this.getThreadById(threadId);
      newThread.stop("_sceKernelTerminateThread");
      newThread.exitStatus = 2147615148;
      return 0;
    }
    _sceKernelDeleteThread(threadId) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const newThread = this.getThreadById(threadId);
      newThread.delete();
      this.threadUids.remove(threadId);
      return 0;
    }
    sceKernelDeleteThread(threadId) {
      return this._sceKernelDeleteThread(threadId);
    }
    sceKernelTerminateThread(threadId) {
      console7.info(sprintf("sceKernelTerminateThread: %d", threadId));
      return this._sceKernelTerminateThread(threadId);
    }
    sceKernelExitDeleteThread(exitStatus, currentThread, state) {
      currentThread.exitStatus = exitStatus;
      currentThread.stop("sceKernelExitDeleteThread");
      state.throwEndCycles();
    }
    sceKernelTerminateDeleteThread(threadId) {
      this._sceKernelTerminateThread(threadId);
      this._sceKernelDeleteThread(threadId);
      return 0;
    }
    sceKernelSleepThreadCB(currentThread) {
      return currentThread.wakeupSleepAsync(AcceptCallbacks.YES);
    }
    sceKernelSleepThread(currentThread) {
      return currentThread.wakeupSleepAsync(AcceptCallbacks.NO);
    }
    sceKernelWakeupThread(threadId) {
      if (!this.hasThreadById(threadId))
        return PromiseFast.resolve(SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD);
      const thread = this.getThreadById(threadId);
      return thread.wakeupWakeupAsync();
    }
    _getCurrentMicroseconds() {
      return this.context.rtc.getCurrentUnixMicroseconds();
    }
    sceKernelUSec2SysClock(microseconds, clockPtr) {
      if (clockPtr != null)
        clockPtr.writeInt64(Integer64.fromUnsignedInt(microseconds));
      return 0;
    }
    sceKernelGetSystemTimeLow() {
      return this._getCurrentMicroseconds();
    }
    sceKernelGetSystemTime(timePtr) {
      if (timePtr == null)
        return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
      timePtr.writeInt64(Integer64.fromNumber(this._getCurrentMicroseconds()));
      return 0;
    }
    sceKernelGetSystemTimeWide() {
      return Integer64.fromNumber(this._getCurrentMicroseconds());
    }
    sceKernelGetThreadId(currentThread) {
      return currentThread.id;
    }
    sceKernelSuspendThread(threadId) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      this.getThreadById(threadId).suspend();
      return 0;
    }
    sceKernelResumeThread(threadId) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      this.getThreadById(threadId).resume();
      return 0;
    }
    sceKernelReferThreadStatus(threadId, sceKernelThreadInfoPtr) {
      if (!this.hasThreadById(threadId))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
      const thread = this.getThreadById(threadId);
      const info = new SceKernelThreadInfo();
      info.size = SceKernelThreadInfo.struct.length;
      info.name = thread.name;
      info.attributes = thread.attributes;
      info.status = thread.status;
      info.threadPreemptionCount = thread.preemptionCount;
      info.entryPoint = thread.entryPoint;
      info.stackPointer = thread.stackPartition.high;
      info.stackSize = thread.stackPartition.size;
      info.GP = thread.state.GP;
      info.priorityInit = thread.initialPriority;
      info.priority = thread.priority;
      info.waitType = 0;
      info.waitId = 0;
      info.wakeupCount = 0;
      info.exitStatus = thread.exitStatus;
      info.runClocksLow = 0;
      info.runClocksHigh = 0;
      info.interruptPreemptionCount = 0;
      info.threadPreemptionCount = 0;
      info.releaseCount = 0;
      SceKernelThreadInfo.struct.write(sceKernelThreadInfoPtr, info);
      return 0;
    }
    sceKernelChangeCurrentThreadAttr(currentThread, removeAttributes, addAttributes) {
      currentThread.attributes &= ~removeAttributes;
      currentThread.attributes |= addAttributes;
      return 0;
    }
    sceKernelUSec2SysClockWide(microseconds) {
      return microseconds;
    }
  };
  __decorate([
    nativeFunction(1148030438, 150),
    I32,
    __param(0, STRING),
    __param(1, U32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, I32),
    __param(6, THREAD)
  ], ThreadManForUser.prototype, "sceKernelCreateThread", 1);
  __decorate([
    nativeFunction(3467504455, 150),
    U32,
    __param(0, THREAD),
    __param(1, U32)
  ], ThreadManForUser.prototype, "sceKernelDelayThread", 1);
  __decorate([
    nativeFunction(1759157814, 150),
    U32,
    __param(0, THREAD),
    __param(1, U32)
  ], ThreadManForUser.prototype, "sceKernelDelayThreadCB", 1);
  __decorate([
    nativeFunction(2215543091, 150),
    U32,
    __param(0, U32),
    __param(1, PTR)
  ], ThreadManForUser.prototype, "sceKernelWaitThreadEndCB", 1);
  __decorate([
    nativeFunction(663490037, 150),
    U32,
    __param(0, U32),
    __param(1, PTR)
  ], ThreadManForUser.prototype, "sceKernelWaitThreadEnd", 1);
  __decorate([
    nativeFunction(2494194158, 150),
    I32,
    __param(0, THREAD)
  ], ThreadManForUser.prototype, "sceKernelGetThreadCurrentPriority", 1);
  __decorate([
    nativeFunction(4101342301, 150),
    U32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32)
  ], ThreadManForUser.prototype, "sceKernelStartThread", 1);
  __decorate([
    nativeFunction(1908185201, 150),
    U32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32)
  ], ThreadManForUser.prototype, "sceKernelChangeThreadPriority", 1);
  __decorate([
    nativeFunction(2859714869, 150),
    I32,
    __param(0, I32),
    __param(1, THREAD),
    __param(2, CPUSTATE)
  ], ThreadManForUser.prototype, "sceKernelExitThread", 1);
  __decorate([
    nativeFunction(991444518, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelGetThreadExitStatus", 1);
  __decorate([
    nativeFunction(2678078675, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelDeleteThread", 1);
  __decorate([
    nativeFunction(1633944506, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelTerminateThread", 1);
  __decorate([
    nativeFunction(2157765275, 150),
    U32,
    __param(0, I32),
    __param(1, THREAD),
    __param(2, CPUSTATE)
  ], ThreadManForUser.prototype, "sceKernelExitDeleteThread", 1);
  __decorate([
    nativeFunction(943684556, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelTerminateDeleteThread", 1);
  __decorate([
    nativeFunction(2189586288, 150),
    U32,
    __param(0, THREAD)
  ], ThreadManForUser.prototype, "sceKernelSleepThreadCB", 1);
  __decorate([
    nativeFunction(2597196574, 150),
    U32,
    __param(0, THREAD)
  ], ThreadManForUser.prototype, "sceKernelSleepThread", 1);
  __decorate([
    nativeFunction(3583946031, 150),
    U32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelWakeupThread", 1);
  __decorate([
    nativeFunction(286125210, 150),
    U32,
    __param(0, U32),
    __param(1, PTR)
  ], ThreadManForUser.prototype, "sceKernelUSec2SysClock", 1);
  __decorate([
    nativeFunction(916379037, 150),
    U32
  ], ThreadManForUser.prototype, "sceKernelGetSystemTimeLow", 1);
  __decorate([
    nativeFunction(3681783605, 150),
    U32,
    __param(0, PTR)
  ], ThreadManForUser.prototype, "sceKernelGetSystemTime", 1);
  __decorate([
    nativeFunction(2193381239, 150),
    I64
  ], ThreadManForUser.prototype, "sceKernelGetSystemTimeWide", 1);
  __decorate([
    I32,
    nativeFunction(691750328, 150),
    __param(0, THREAD)
  ], ThreadManForUser.prototype, "sceKernelGetThreadId", 1);
  __decorate([
    nativeFunction(2571432735, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelSuspendThread", 1);
  __decorate([
    nativeFunction(1964338831, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser.prototype, "sceKernelResumeThread", 1);
  __decorate([
    nativeFunction(398551118, 150),
    I32,
    __param(0, I32),
    __param(1, PTR)
  ], ThreadManForUser.prototype, "sceKernelReferThreadStatus", 1);
  __decorate([
    nativeFunction(3933507121, 150),
    I32,
    __param(0, THREAD),
    __param(1, U32),
    __param(2, U32)
  ], ThreadManForUser.prototype, "sceKernelChangeCurrentThreadAttr", 1);
  __decorate([
    nativeFunction(3368883596, 150),
    I32,
    __param(0, U32)
  ], ThreadManForUser.prototype, "sceKernelUSec2SysClockWide", 1);
  var SceKernelThreadInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.size = 0;
      this.name = "";
      this.attributes = 0;
      this.status = ThreadStatus.RUNNING;
      this.entryPoint = 0;
      this.stackPointer = 0;
      this.stackSize = 0;
      this.GP = 0;
      this.priorityInit = 0;
      this.priority = 0;
      this.waitType = 0;
      this.waitId = 0;
      this.wakeupCount = 0;
      this.exitStatus = 0;
      this.runClocksLow = 0;
      this.runClocksHigh = 0;
      this.interruptPreemptionCount = 0;
      this.threadPreemptionCount = 0;
      this.releaseCount = 0;
    }
  };
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "size", 2);
  __decorate([
    StructStructStringz(32)
  ], SceKernelThreadInfo.prototype, "name", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "attributes", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "status", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "entryPoint", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "stackPointer", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "stackSize", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "GP", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "priorityInit", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "priority", 2);
  __decorate([
    StructUInt32
  ], SceKernelThreadInfo.prototype, "waitType", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "waitId", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "wakeupCount", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "exitStatus", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "runClocksLow", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "runClocksHigh", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "interruptPreemptionCount", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "threadPreemptionCount", 2);
  __decorate([
    StructInt32
  ], SceKernelThreadInfo.prototype, "releaseCount", 2);

  // src/hle/module/threadman/ThreadManForUser_callbacks.ts
  var ThreadManForUser_callbacks_exports = {};
  __export(ThreadManForUser_callbacks_exports, {
    ThreadManForUser: () => ThreadManForUser2
  });

  // src/hle/manager/callback.ts
  var CallbackManager = class {
    constructor(interop) {
      this.interop = interop;
      this.uids = new UidCollection(1);
      this.notifications = [];
      this.onAdded = new Signal1();
      this.normalCallbacks = [];
    }
    get hasPendingCallbacks() {
      return this.notifications.length > 0;
    }
    register(callback) {
      return this.uids.allocate(callback);
    }
    remove(id) {
      return this.uids.remove(id);
    }
    get(id) {
      return this.uids.get(id);
    }
    executeLater(callback, args) {
      this.normalCallbacks.push({callback, args});
    }
    notify(id, arg2) {
      const callback = this.get(id);
      this.notifications.push(new CallbackNotification(callback, arg2));
      this.onAdded.dispatch(this.notifications.length);
    }
    executeLaterPendingWithinThread(thread) {
      const state = thread.state;
      while (this.normalCallbacks.length > 0) {
        const normalCallback = this.normalCallbacks.shift();
        this.interop.execute(state, normalCallback.callback, normalCallback.args);
      }
    }
    executePendingWithinThread(thread) {
      const state = thread.state;
      let count = 0;
      this.executeLaterPendingWithinThread(thread);
      while (this.notifications.length > 0) {
        const notification = this.notifications.shift();
        this.interop.execute(state, notification.callback.funcptr, [1, notification.arg2, notification.callback.argument]);
        count++;
      }
      return count > 0;
    }
  };
  var CallbackNotification = class {
    constructor(callback, arg2) {
      this.callback = callback;
      this.arg2 = arg2;
    }
  };
  var Callback = class {
    constructor(name2, funcptr, argument) {
      this.name = name2;
      this.funcptr = funcptr;
      this.argument = argument;
      this.count = 0;
    }
  };

  // src/hle/module/threadman/ThreadManForUser_callbacks.ts
  var ThreadManForUser2 = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelCreateCallback(name2, functionCallbackAddr, argument) {
      return this.context.callbackManager.register(new Callback(name2, functionCallbackAddr, argument));
    }
    sceKernelDeleteCallback(callbackId) {
      this.context.callbackManager.remove(callbackId);
    }
    sceKernelCheckCallback(thread) {
      return this.context.callbackManager.executePendingWithinThread(thread) ? 1 : 0;
    }
    sceKernelNotifyCallback(thread, callbackId, argument2) {
      return this.context.callbackManager.notify(callbackId, argument2);
    }
  };
  __decorate([
    nativeFunction(3894194063, 150),
    U32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, U32)
  ], ThreadManForUser2.prototype, "sceKernelCreateCallback", 1);
  __decorate([
    nativeFunction(3988412484, 150),
    U32,
    __param(0, I32)
  ], ThreadManForUser2.prototype, "sceKernelDeleteCallback", 1);
  __decorate([
    nativeFunction(882732396, 150),
    U32,
    __param(0, THREAD)
  ], ThreadManForUser2.prototype, "sceKernelCheckCallback", 1);
  __decorate([
    nativeFunction(3239815364, 150),
    U32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32)
  ], ThreadManForUser2.prototype, "sceKernelNotifyCallback", 1);

  // src/hle/module/threadman/ThreadManForUser_sema.ts
  var ThreadManForUser_sema_exports = {};
  __export(ThreadManForUser_sema_exports, {
    ThreadManForUser: () => ThreadManForUser3
  });
  var ThreadManForUser3 = class {
    constructor(context) {
      this.context = context;
      this.semaporesUid = new UidCollection(1);
    }
    sceKernelCreateSema(name2, attribute, initialCount, maxCount, options) {
      const semaphore = new Semaphore(name2, attribute, initialCount, maxCount);
      const id = this.semaporesUid.allocate(semaphore);
      semaphore.id = id;
      console.warn(sprintf('Not implemented ThreadManForUser.sceKernelCreateSema("%s", %d, count=%d, maxCount=%d) -> %d', name2, attribute, initialCount, maxCount, id));
      return id;
    }
    sceKernelDeleteSema(id) {
      if (!this.semaporesUid.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
      const semaphore = this.semaporesUid.get(id);
      semaphore.delete();
      this.semaporesUid.remove(id);
      return 0;
    }
    nativeFunctionEx(id, count, numWaitingThreadsPtr) {
      if (!this.semaporesUid.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
      const semaphore = this.semaporesUid.get(id);
      if (numWaitingThreadsPtr)
        numWaitingThreadsPtr.writeInt32(semaphore.numberOfWaitingThreads);
      semaphore.cancel();
      return 0;
    }
    _sceKernelWaitSemaCB(currentThread, id, signal, timeout, acceptCallbacks) {
      if (!this.semaporesUid.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
      const semaphore = this.semaporesUid.get(id);
      const promise = semaphore.waitAsync(currentThread, signal);
      if (promise) {
        return new WaitingThreadInfo("sceKernelWaitSema", semaphore, promise, acceptCallbacks);
      } else {
        return 0;
      }
    }
    sceKernelWaitSemaCB(currentThread, id, signal, timeout) {
      return this._sceKernelWaitSemaCB(currentThread, id, signal, timeout, AcceptCallbacks.YES);
    }
    sceKernelWaitSemaEx(currentThread, id, signal, timeout) {
      return this._sceKernelWaitSemaCB(currentThread, id, signal, timeout, AcceptCallbacks.NO);
    }
    sceKernelReferSemaStatus(id, infoStream) {
      if (!this.semaporesUid.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
      const semaphore = this.semaporesUid.get(id);
      const semaphoreInfo = new SceKernelSemaInfo();
      semaphoreInfo.size = SceKernelSemaInfo.struct.length;
      semaphoreInfo.attributes = semaphore.attributes;
      semaphoreInfo.currentCount = semaphore.currentCount;
      semaphoreInfo.initialCount = semaphore.initialCount;
      semaphoreInfo.maximumCount = semaphore.maximumCount;
      semaphoreInfo.name = semaphore.name;
      semaphoreInfo.numberOfWaitingThreads = semaphore.numberOfWaitingThreads;
      SceKernelSemaInfo.struct.write(infoStream, semaphoreInfo);
      return 0;
    }
    sceKernelSignalSema(currentThread, id, signal) {
      if (!this.semaporesUid.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
      const semaphore = this.semaporesUid.get(id);
      const previousCount = semaphore.currentCount;
      if (semaphore.currentCount + signal > semaphore.maximumCount)
        return SceKernelErrors.ERROR_KERNEL_SEMA_OVERFLOW;
      const awakeCount = semaphore.incrementCount(signal);
      if (awakeCount > 0) {
        return PromiseFast.resolve(0);
      } else {
        return 0;
      }
    }
    sceKernelPollSema(currentThread, id, signal) {
      const semaphore = this.semaporesUid.get(id);
      if (signal <= 0)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_COUNT;
      if (signal > semaphore.currentCount)
        return SceKernelErrors.ERROR_KERNEL_SEMA_ZERO;
      semaphore.incrementCount(-signal);
      return 0;
    }
  };
  __decorate([
    nativeFunction(3604630433, 150),
    I32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, PTR)
  ], ThreadManForUser3.prototype, "sceKernelCreateSema", 1);
  __decorate([
    nativeFunction(683034780, 150),
    I32,
    __param(0, I32)
  ], ThreadManForUser3.prototype, "sceKernelDeleteSema", 1);
  __decorate([
    nativeFunction(2415786402, 150),
    U32,
    __param(0, U32),
    __param(1, U32),
    __param(2, PTR)
  ], ThreadManForUser3.prototype, "nativeFunctionEx", 1);
  __decorate([
    nativeFunction(1830890412, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], ThreadManForUser3.prototype, "sceKernelWaitSemaCB", 1);
  __decorate([
    nativeFunction(1312428293, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], ThreadManForUser3.prototype, "sceKernelWaitSemaEx", 1);
  __decorate([
    nativeFunction(3161451461, 150),
    I32,
    __param(0, I32),
    __param(1, PTR)
  ], ThreadManForUser3.prototype, "sceKernelReferSemaStatus", 1);
  __decorate([
    nativeFunction(1062463040, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32)
  ], ThreadManForUser3.prototype, "sceKernelSignalSema", 1);
  __decorate([
    nativeFunction(1488058679, 150),
    I32,
    __param(0, THREAD),
    __param(1, I32),
    __param(2, I32)
  ], ThreadManForUser3.prototype, "sceKernelPollSema", 1);
  var SceKernelSemaInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.size = 0;
      this.name = "";
      this.attributes = SemaphoreAttribute.FirstInFirstOut;
      this.initialCount = 0;
      this.currentCount = 0;
      this.maximumCount = 0;
      this.numberOfWaitingThreads = 0;
    }
  };
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "size", 2);
  __decorate([
    StructStructStringz(32)
  ], SceKernelSemaInfo.prototype, "name", 2);
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "attributes", 2);
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "initialCount", 2);
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "currentCount", 2);
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "maximumCount", 2);
  __decorate([
    StructInt32
  ], SceKernelSemaInfo.prototype, "numberOfWaitingThreads", 2);
  var WaitingSemaphoreThread = class {
    constructor(expectedCount, wakeUp) {
      this.expectedCount = expectedCount;
      this.wakeUp = wakeUp;
    }
  };
  var Semaphore = class {
    constructor(name2, attributes, initialCount, maximumCount) {
      this.name = name2;
      this.attributes = attributes;
      this.initialCount = initialCount;
      this.maximumCount = maximumCount;
      this.id = 0;
      this.waitingSemaphoreThreadList = new SortedSet();
      this.currentCount = initialCount;
    }
    get numberOfWaitingThreads() {
      return this.waitingSemaphoreThreadList.length;
    }
    incrementCount(count) {
      this.currentCount = Math.min(this.currentCount + count, this.maximumCount);
      return this.updatedCount();
    }
    cancel() {
      this.waitingSemaphoreThreadList.forEach((item) => {
        item.wakeUp();
      });
    }
    updatedCount() {
      let awakeCount = 0;
      this.waitingSemaphoreThreadList.forEach((item) => {
        if (this.currentCount >= item.expectedCount) {
          this.currentCount -= item.expectedCount;
          item.wakeUp();
          awakeCount++;
        }
      });
      return awakeCount;
    }
    waitAsync(thread, expectedCount) {
      if (this.currentCount >= expectedCount) {
        this.currentCount -= expectedCount;
        return null;
      } else {
        const promise = new PromiseFast((resolve, reject) => {
          const waitingSemaphoreThread = new WaitingSemaphoreThread(expectedCount, () => {
            this.waitingSemaphoreThreadList.delete(waitingSemaphoreThread);
            resolve();
          });
          this.waitingSemaphoreThreadList.add(waitingSemaphoreThread);
        });
        this.updatedCount();
        return promise;
      }
    }
    delete() {
    }
  };
  var SemaphoreAttribute;
  (function(SemaphoreAttribute2) {
    SemaphoreAttribute2[SemaphoreAttribute2["FirstInFirstOut"] = 0] = "FirstInFirstOut";
    SemaphoreAttribute2[SemaphoreAttribute2["Priority"] = 256] = "Priority";
  })(SemaphoreAttribute || (SemaphoreAttribute = {}));

  // src/hle/module/threadman/ThreadManForUser_eventflag.ts
  var ThreadManForUser_eventflag_exports = {};
  __export(ThreadManForUser_eventflag_exports, {
    ThreadManForUser: () => ThreadManForUser4
  });
  var ThreadManForUser4 = class {
    constructor(context) {
      this.context = context;
      this.eventFlagUids = new UidCollection(1);
    }
    sceKernelCreateEventFlag(name2, attributes, bitPattern, optionsPtr) {
      if (name2 === null)
        return SceKernelErrors.ERROR_ERROR;
      if ((attributes & 256) != 0 || attributes >= 768)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ATTR;
      const eventFlag = new EventFlag();
      eventFlag.name = name2;
      eventFlag.attributes = attributes;
      eventFlag.initialPattern = bitPattern;
      eventFlag.currentPattern = bitPattern;
      return this.eventFlagUids.allocate(eventFlag);
    }
    sceKernelSetEventFlag(id, bitPattern) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      this.eventFlagUids.get(id).setBits(bitPattern);
      return 0;
    }
    _sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, acceptCallbacks, state) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      const eventFlag = this.eventFlagUids.get(id);
      if ((waitType & ~EventFlagWaitTypeSet.MaskValidBits) != 0)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
      if (bits == 0)
        return SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN;
      const timedOut = false;
      const previousPattern = eventFlag.currentPattern;
      const promise = (async () => {
        await eventFlag.waitAsync(bits, waitType, outBits, timeout, acceptCallbacks, state);
        if (outBits != null)
          outBits.writeUInt32(previousPattern);
        return 0;
      })();
      return new WaitingThreadInfo("_sceKernelWaitEventFlagCB", eventFlag, promise, acceptCallbacks);
    }
    sceKernelWaitEventFlag(id, bits, waitType, outBits, timeout, state) {
      return this._sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, AcceptCallbacks.NO, state);
    }
    sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, state) {
      return this._sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, AcceptCallbacks.YES, state);
    }
    sceKernelPollEventFlag(id, bits, waitType, outBits) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      if ((waitType & ~EventFlagWaitTypeSet.MaskValidBits) != 0)
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
      if ((waitType & (EventFlagWaitTypeSet.Clear | EventFlagWaitTypeSet.ClearAll)) == (EventFlagWaitTypeSet.Clear | EventFlagWaitTypeSet.ClearAll)) {
        return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
      }
      if (bits == 0)
        return SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN;
      if (EventFlag == null)
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      const matched = this.eventFlagUids.get(id).poll(bits, waitType, outBits);
      return matched ? 0 : SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_POLL_FAILED;
    }
    sceKernelDeleteEventFlag(id) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      this.eventFlagUids.remove(id);
      return 0;
    }
    sceKernelClearEventFlag(id, bitsToClear) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      this.eventFlagUids.get(id).clearBits(bitsToClear);
      return 0;
    }
    sceKernelCancelEventFlag(id, newPattern, numWaitThreadPtr) {
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      this.eventFlagUids.get(id).cancel(newPattern);
      return 0;
    }
    sceKernelReferEventFlagStatus(id, infoPtr) {
      const size = infoPtr.readUInt32();
      if (size == 0)
        return 0;
      infoPtr.position = 0;
      if (!this.eventFlagUids.has(id))
        return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
      const eventFlag = this.eventFlagUids.get(id);
      const info = new EventFlagInfo();
      info.size = EventFlagInfo.struct.length;
      info.name = eventFlag.name;
      info.currentPattern = eventFlag.currentPattern;
      info.initialPattern = eventFlag.initialPattern;
      info.attributes = eventFlag.attributes;
      info.numberOfWaitingThreads = eventFlag.waitingThreads.length;
      EventFlagInfo.struct.write(infoPtr, info);
      console.warn("Not implemented ThreadManForUser.sceKernelReferEventFlagStatus");
      return 0;
    }
  };
  __decorate([
    nativeFunction(1438779904, 150),
    U32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32),
    __param(3, PTR)
  ], ThreadManForUser4.prototype, "sceKernelCreateEventFlag", 1);
  __decorate([
    nativeFunction(531716658, 150),
    U32,
    __param(0, I32),
    __param(1, U32)
  ], ThreadManForUser4.prototype, "sceKernelSetEventFlag", 1);
  __decorate([
    nativeFunction(1076875042, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, I32),
    __param(3, PTR),
    __param(4, PTR),
    __param(5, CPUSTATE)
  ], ThreadManForUser4.prototype, "sceKernelWaitEventFlag", 1);
  __decorate([
    nativeFunction(848057450, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, I32),
    __param(3, PTR),
    __param(4, PTR),
    __param(5, CPUSTATE)
  ], ThreadManForUser4.prototype, "sceKernelWaitEventFlagCB", 1);
  __decorate([
    nativeFunction(821905648, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, I32),
    __param(3, PTR)
  ], ThreadManForUser4.prototype, "sceKernelPollEventFlag", 1);
  __decorate([
    nativeFunction(4020128880, 150),
    U32,
    __param(0, I32)
  ], ThreadManForUser4.prototype, "sceKernelDeleteEventFlag", 1);
  __decorate([
    nativeFunction(2166572772, 150),
    U32,
    __param(0, I32),
    __param(1, U32)
  ], ThreadManForUser4.prototype, "sceKernelClearEventFlag", 1);
  __decorate([
    nativeFunction(3441439378, 150),
    U32,
    __param(0, I32),
    __param(1, U32),
    __param(2, PTR)
  ], ThreadManForUser4.prototype, "sceKernelCancelEventFlag", 1);
  __decorate([
    nativeFunction(2792030496, 150),
    U32,
    __param(0, I32),
    __param(1, PTR)
  ], ThreadManForUser4.prototype, "sceKernelReferEventFlagStatus", 1);
  var EventFlagWaitingThread = class {
    constructor(bitsToMatch, waitType, outBits, eventFlag, wakeUp) {
      this.bitsToMatch = bitsToMatch;
      this.waitType = waitType;
      this.outBits = outBits;
      this.eventFlag = eventFlag;
      this.wakeUp = wakeUp;
    }
  };
  var EventFlag = class {
    constructor() {
      this.name = "";
      this.attributes = 0;
      this.currentPattern = 0;
      this.initialPattern = 0;
      this.waitingThreads = new SortedSet();
    }
    waitAsync(bits, waitType, outBits, timeout, callbacks, state) {
      return new Promise((resolve, reject) => {
        const waitingSemaphoreThread = new EventFlagWaitingThread(bits, waitType, outBits, this, () => {
          this.waitingThreads.delete(waitingSemaphoreThread);
          resolve(0);
          state.throwEndCycles();
        });
        this.waitingThreads.add(waitingSemaphoreThread);
      });
    }
    poll(bitsToMatch, waitType, outBits) {
      if (outBits != null)
        outBits.writeInt32(this.currentPattern);
      if (waitType & EventFlagWaitTypeSet.Or ? (this.currentPattern & bitsToMatch) != 0 : (this.currentPattern & bitsToMatch) == bitsToMatch) {
        this._doClear(bitsToMatch, waitType);
        return true;
      }
      return false;
    }
    _doClear(bitsToMatch, waitType) {
      if (waitType & EventFlagWaitTypeSet.ClearAll)
        this.clearBits(~4294967295, false);
      if (waitType & EventFlagWaitTypeSet.Clear)
        this.clearBits(~bitsToMatch, false);
    }
    cancel(newPattern) {
      this.waitingThreads.forEach((item) => {
        item.wakeUp();
      });
    }
    clearBits(bitsToClear, doUpdateWaitingThreads = true) {
      this.currentPattern &= bitsToClear;
      if (doUpdateWaitingThreads)
        this.updateWaitingThreads();
    }
    setBits(bits, doUpdateWaitingThreads = true) {
      this.currentPattern |= bits;
      if (doUpdateWaitingThreads)
        this.updateWaitingThreads();
    }
    updateWaitingThreads() {
      this.waitingThreads.forEach((waitingThread) => {
        if (this.poll(waitingThread.bitsToMatch, waitingThread.waitType, waitingThread.outBits)) {
          waitingThread.wakeUp();
        }
      });
    }
  };
  var EventFlagInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.size = 0;
      this.name = "";
      this.attributes = 0;
      this.initialPattern = 0;
      this.currentPattern = 0;
      this.numberOfWaitingThreads = 0;
    }
  };
  __decorate([
    StructInt32
  ], EventFlagInfo.prototype, "size", 2);
  __decorate([
    StructStructStringz(32)
  ], EventFlagInfo.prototype, "name", 2);
  __decorate([
    StructInt32
  ], EventFlagInfo.prototype, "attributes", 2);
  __decorate([
    StructUInt32
  ], EventFlagInfo.prototype, "initialPattern", 2);
  __decorate([
    StructUInt32
  ], EventFlagInfo.prototype, "currentPattern", 2);
  __decorate([
    StructInt32
  ], EventFlagInfo.prototype, "numberOfWaitingThreads", 2);
  var EventFlagWaitTypeSet;
  (function(EventFlagWaitTypeSet2) {
    EventFlagWaitTypeSet2[EventFlagWaitTypeSet2["And"] = 0] = "And";
    EventFlagWaitTypeSet2[EventFlagWaitTypeSet2["Or"] = 1] = "Or";
    EventFlagWaitTypeSet2[EventFlagWaitTypeSet2["ClearAll"] = 16] = "ClearAll";
    EventFlagWaitTypeSet2[EventFlagWaitTypeSet2["Clear"] = 32] = "Clear";
    EventFlagWaitTypeSet2[EventFlagWaitTypeSet2["MaskValidBits"] = 49] = "MaskValidBits";
  })(EventFlagWaitTypeSet || (EventFlagWaitTypeSet = {}));

  // src/hle/module/threadman/ThreadManForUser_vpl.ts
  var ThreadManForUser_vpl_exports = {};
  __export(ThreadManForUser_vpl_exports, {
    ThreadManForUser: () => ThreadManForUser5
  });
  var ThreadManForUser5 = class {
    constructor(context) {
      this.context = context;
      this.vplUid = new UidCollection(1);
    }
    sceKernelCreateVpl(name2, partitionId, attribute, size, optionsPtr) {
      const partition = this.context.memoryManager.memoryPartitionsUid[partitionId];
      const allocatedPartition = partition.allocate(size, attribute & VplAttributeFlags.PSP_VPL_ATTR_ADDR_HIGH ? MemoryAnchor.High : MemoryAnchor.Low);
      const vpl = new Vpl(name2, allocatedPartition);
      return this.vplUid.allocate(vpl);
    }
    sceKernelTryAllocateVpl(vplId, size, addressPtr) {
      const vpl = this.vplUid.get(vplId);
      try {
        const item = vpl.partition.allocateLow(size);
        console.log("-->", item.low);
        if (addressPtr)
          addressPtr.writeInt32(item.low);
        return 0;
      } catch (e) {
        console.error(e);
        return SceKernelErrors.ERROR_KERNEL_NO_MEMORY;
      }
    }
  };
  __decorate([
    nativeFunction(1455438261, 150),
    U32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, PTR)
  ], ThreadManForUser5.prototype, "sceKernelCreateVpl", 1);
  __decorate([
    nativeFunction(2939606792, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR)
  ], ThreadManForUser5.prototype, "sceKernelTryAllocateVpl", 1);
  var Vpl = class {
    constructor(name2, partition) {
      this.name = name2;
      this.partition = partition;
    }
  };
  var VplAttributeFlags;
  (function(VplAttributeFlags2) {
    VplAttributeFlags2[VplAttributeFlags2["PSP_VPL_ATTR_MASK"] = 16895] = "PSP_VPL_ATTR_MASK";
    VplAttributeFlags2[VplAttributeFlags2["PSP_VPL_ATTR_ADDR_HIGH"] = 16384] = "PSP_VPL_ATTR_ADDR_HIGH";
    VplAttributeFlags2[VplAttributeFlags2["PSP_VPL_ATTR_EXT"] = 32768] = "PSP_VPL_ATTR_EXT";
  })(VplAttributeFlags || (VplAttributeFlags = {}));

  // src/hle/module/threadman/ThreadManForUser_fpl.ts
  var ThreadManForUser_fpl_exports = {};
  __export(ThreadManForUser_fpl_exports, {
    ThreadManForUser: () => ThreadManForUser6
  });
  var ThreadManForUser6 = class {
    constructor(context) {
      this.context = context;
      this.fplUid = new UidCollection(1);
    }
    sceKernelCreateFpl(name2, partitionId, attribute, size, blocks, optionsPtr) {
      const partition = this.context.memoryManager.memoryPartitionsUid[partitionId];
      const allocatedPartition = partition.allocate(size, attribute & FplAttributeFlags.PSP_FPL_ATTR_ADDR_HIGH ? MemoryAnchor.High : MemoryAnchor.Low);
      const vpl = new Fpl(name2, allocatedPartition, size, blocks);
      return this.fplUid.allocate(vpl);
    }
    sceKernelAllocateFpl(uid, dataAddr, timeoutAddr) {
      return this._sceKernelAllocateFpl(uid, dataAddr, timeoutAddr, true, false);
    }
    sceKernelFreeFpl(uid, dataAddr) {
      const fpl = this.fplUid.get(uid);
      fpl.free(dataAddr.position);
    }
    _sceKernelAllocateFpl(uid, dataAddr, timeoutAddr, wait, doCallbacks) {
      const fpl = this.fplUid.get(uid);
      if (dataAddr == null || dataAddr.isNull) {
        return SceKernelErrors.ERROR_INVALID_POINTER;
      }
      dataAddr.writeInt32(fpl.alloc());
      return 0;
    }
  };
  __decorate([
    nativeFunction(3229332592, 150),
    I32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32),
    __param(3, I32),
    __param(4, I32),
    __param(5, PTR)
  ], ThreadManForUser6.prototype, "sceKernelCreateFpl", 1);
  __decorate([
    nativeFunction(3648645567, 150),
    I32,
    __param(0, U32),
    __param(1, PTR),
    __param(2, PTR)
  ], ThreadManForUser6.prototype, "sceKernelAllocateFpl", 1);
  __decorate([
    nativeFunction(4131474033, 150),
    I32,
    __param(0, U32),
    __param(1, PTR)
  ], ThreadManForUser6.prototype, "sceKernelFreeFpl", 1);
  var Fpl = class {
    constructor(name2, partition, size, blocks) {
      this.name = name2;
      this.partition = partition;
      this.size = size;
      this.blocks = blocks;
      this.currentOffset = 0;
      this.allocList = new Set();
      this.freeList = new Set();
    }
    getAddress(index) {
      return this.partition.low + index * this.size;
    }
    getIndexFromAddress(address) {
      return Math.floor((address - this.partition.low) / this.size);
    }
    alloc() {
      return this.getAddress(this.allocIndex());
    }
    free(address) {
      const index = this.getIndexFromAddress(address);
      if (this.allocList.has(index)) {
        this.allocList.delete(index);
        this.freeList.add(index);
      }
    }
    allocIndex() {
      let index = -1;
      if (this.freeList.size > 0) {
        index = this.freeList.keys().next().value;
        this.freeList.delete(index);
      } else if (this.currentOffset < this.blocks) {
        index = this.currentOffset++;
      } else {
        throw new ProgramExitException("TODO: Fpl is full");
      }
      this.allocList.add(index);
      return index;
    }
  };
  var FplAttributeFlags;
  (function(FplAttributeFlags2) {
    FplAttributeFlags2[FplAttributeFlags2["PSP_FPL_ATTR_FIFO"] = 0] = "PSP_FPL_ATTR_FIFO";
    FplAttributeFlags2[FplAttributeFlags2["PSP_FPL_ATTR_PRIORITY"] = 256] = "PSP_FPL_ATTR_PRIORITY";
    FplAttributeFlags2[FplAttributeFlags2["PSP_FPL_ATTR_MASK"] = 16895] = "PSP_FPL_ATTR_MASK";
    FplAttributeFlags2[FplAttributeFlags2["PSP_FPL_ATTR_ADDR_HIGH"] = 16384] = "PSP_FPL_ATTR_ADDR_HIGH";
  })(FplAttributeFlags || (FplAttributeFlags = {}));

  // src/hle/module/threadman/ThreadManForUser_mutex.ts
  var ThreadManForUser_mutex_exports = {};
  __export(ThreadManForUser_mutex_exports, {
    ThreadManForUser: () => ThreadManForUser7
  });
  var ThreadManForUser7 = class {
    constructor(context) {
      this.context = context;
    }
    sceKernelCreateMutex(name2, attribute, options) {
      return -1;
    }
    sceKernelLockMutexCB(mutexId, count, timeout) {
      return -1;
    }
  };
  __decorate([
    nativeFunction(3083901126, 150),
    U32,
    __param(0, STRING),
    __param(1, I32),
    __param(2, I32)
  ], ThreadManForUser7.prototype, "sceKernelCreateMutex", 1);
  __decorate([
    nativeFunction(1542774055, 150),
    U32,
    __param(0, I32),
    __param(1, I32),
    __param(2, PTR)
  ], ThreadManForUser7.prototype, "sceKernelLockMutexCB", 1);

  // src/hle/pspmodules.ts
  function _registerSyscall(syscallManager, moduleManager, id, moduleName, functionName) {
    syscallManager.registerWithId(id, moduleManager.getByName(moduleName).getByName(functionName));
  }
  function registerModules(manager) {
    manager.registerModule(ExceptionManagerForKernel_exports);
    manager.registerModule(InterruptManager_exports);
    manager.registerModule(KDebugForKernel_exports);
    manager.registerModule(Kernel_Library_exports);
    manager.registerModule(LoadCoreForKernel_exports);
    manager.registerModule(LoadExecForUser_exports);
    manager.registerModule(ModuleMgrForUser_exports);
    manager.registerModule(sceAtrac3plus_exports);
    manager.registerModule(sceAudio_exports);
    manager.registerModule(sceCtrl_exports);
    manager.registerModule(sceDisplay_exports);
    manager.registerModule(sceDmac_exports);
    manager.registerModule(sceGe_user_exports);
    manager.registerModule(sceHprm_exports);
    manager.registerModule(sceHttp_exports);
    manager.registerModule(sceParseHttp_exports);
    manager.registerModule(sceParseUri_exports);
    manager.registerModule(sceImpose_exports);
    manager.registerModule(sceLibFont_exports);
    manager.registerModule(sceMp3_exports);
    manager.registerModule(sceMpeg_exports);
    manager.registerModule(sceNet_exports);
    manager.registerModule(sceNetAdhoc_exports);
    manager.registerModule(sceNetAdhocctl_exports);
    manager.registerModule(sceNetAdhocMatching_exports);
    manager.registerModule(sceNetApctl_exports);
    manager.registerModule(sceNetInet_exports);
    manager.registerModule(sceNetResolver_exports);
    manager.registerModule(sceNp_exports);
    manager.registerModule(sceNpAuth_exports);
    manager.registerModule(sceNpService_exports);
    manager.registerModule(sceOpenPSID_exports);
    manager.registerModule(scePower_exports);
    manager.registerModule(scePspNpDrm_user_exports);
    manager.registerModule(sceReg_exports);
    manager.registerModule(sceRtc_exports);
    manager.registerModule(sceSasCore_exports);
    manager.registerModule(sceSsl_exports);
    manager.registerModule(sceSuspendForUser_exports);
    manager.registerModule(sceUmdUser_exports);
    manager.registerModule(sceUtility_exports);
    manager.registerModule(sceVaudio_exports);
    manager.registerModule(sceWlanDrv_exports);
    manager.registerModule(StdioForUser_exports);
    manager.registerModule(SysMemUserForUser_exports);
    manager.registerModule(UtilsForKernel_exports);
    manager.registerModule(UtilsForUser_exports);
    manager.registerModule(IoFileMgrForUser_exports);
    manager.registerModule(ThreadManForUser_exports);
    manager.registerModule(ThreadManForUser_callbacks_exports);
    manager.registerModule(ThreadManForUser_sema_exports);
    manager.registerModule(ThreadManForUser_eventflag_exports);
    manager.registerModule(ThreadManForUser_vpl_exports);
    manager.registerModule(ThreadManForUser_fpl_exports);
    manager.registerModule(ThreadManForUser_mutex_exports);
  }
  function registerSyscalls(syscallManager, moduleManager) {
    _registerSyscall(syscallManager, moduleManager, 8301, "ThreadManForUser", "sceKernelCreateThread");
    _registerSyscall(syscallManager, moduleManager, 8303, "ThreadManForUser", "sceKernelStartThread");
    _registerSyscall(syscallManager, moduleManager, 8305, "ThreadManForUser", "sceKernelExitDeleteThread");
    _registerSyscall(syscallManager, moduleManager, 8383, "UtilsForUser", "sceKernelUtilsMt19937Init");
    _registerSyscall(syscallManager, moduleManager, 8384, "UtilsForUser", "sceKernelUtilsMt19937UInt");
    _registerSyscall(syscallManager, moduleManager, 8506, "sceDisplay", "sceDisplaySetMode");
    _registerSyscall(syscallManager, moduleManager, 8519, "sceDisplay", "sceDisplayWaitVblankStart");
    _registerSyscall(syscallManager, moduleManager, 8511, "sceDisplay", "sceDisplaySetFrameBuf");
    _registerSyscall(syscallManager, moduleManager, 8427, "LoadExecForUser", "sceKernelExitGame");
    _registerSyscall(syscallManager, moduleManager, 8528, "sceCtrl", "sceCtrlPeekBufferPositive");
  }
  function registerModulesAndSyscalls(syscallManager, moduleManager) {
    registerModules(moduleManager);
    registerSyscalls(syscallManager, moduleManager);
  }

  // src/format/psf.ts
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Binary"] = 0] = "Binary";
    DataType2[DataType2["Text"] = 2] = "Text";
    DataType2[DataType2["Int"] = 4] = "Int";
  })(DataType || (DataType = {}));
  var HeaderStruct = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.version = 0;
      this.keyTable = 0;
      this.valueTable = 0;
      this.numberOfPairs = 0;
    }
  };
  __decorate([
    StructUInt32
  ], HeaderStruct.prototype, "magic", 2);
  __decorate([
    StructUInt32
  ], HeaderStruct.prototype, "version", 2);
  __decorate([
    StructUInt32
  ], HeaderStruct.prototype, "keyTable", 2);
  __decorate([
    StructUInt32
  ], HeaderStruct.prototype, "valueTable", 2);
  __decorate([
    StructUInt32
  ], HeaderStruct.prototype, "numberOfPairs", 2);
  var EntryStruct = class extends Struct {
    constructor() {
      super(...arguments);
      this.keyOffset = 0;
      this.unknown = 0;
      this.dataType = 0;
      this.valueSize = 0;
      this.valueSizePad = 0;
      this.valueOffset = 0;
      this.key = "";
    }
  };
  __decorate([
    StructUInt16
  ], EntryStruct.prototype, "keyOffset", 2);
  __decorate([
    StructUInt8
  ], EntryStruct.prototype, "unknown", 2);
  __decorate([
    StructUInt8
  ], EntryStruct.prototype, "dataType", 2);
  __decorate([
    StructUInt32
  ], EntryStruct.prototype, "valueSize", 2);
  __decorate([
    StructUInt32
  ], EntryStruct.prototype, "valueSizePad", 2);
  __decorate([
    StructUInt32
  ], EntryStruct.prototype, "valueOffset", 2);
  var Psf = class {
    constructor() {
      this.entries = [];
      this.entriesByName = {};
    }
    static fromStream(stream) {
      const psf = new Psf();
      psf.load(stream);
      return psf;
    }
    load(stream) {
      const header = this.header = HeaderStruct.struct.read(stream);
      if (header.magic != 1179865088)
        throw "Not a PSF file";
      const entries = StructArray(EntryStruct.struct, header.numberOfPairs).read(stream);
      const entriesByName = {};
      const keysStream = stream.sliceWithLength(header.keyTable);
      const valuesStream = stream.sliceWithLength(header.valueTable);
      entries.forEach((entry) => {
        const key = keysStream.sliceWithLength(entry.keyOffset).readUtf8Stringz();
        const valueStream = valuesStream.sliceWithLength(entry.valueOffset, entry.valueSize);
        entry.key = key;
        switch (entry.dataType) {
          case 0:
            entry.value = valueStream.sliceWithLength(0);
            break;
          case 4:
            entry.value = valueStream.readInt32();
            break;
          case 2:
            entry.value = valueStream.readUtf8Stringz();
            break;
          default:
            throw `Unknown dataType: ${entry.dataType}`;
        }
        entriesByName[entry.key] = entry.value;
      });
      this.entries = entries;
      this.entriesByName = entriesByName;
    }
  };

  // src/format/format.ts
  async function detectFormatAsync(asyncStream) {
    const data = await asyncStream.readChunkAsync(0, 4);
    const stream = Stream.fromArrayBuffer(data);
    if (stream.length < 4) {
      console.error(asyncStream);
      throw new Error("detectFormatAsync: Buffer is too small (" + data.byteLength + ")");
    }
    const magic = stream.readString(4);
    switch (magic) {
      case "PK":
      case "PK":
      case "PK":
        return "zip";
      case "\0PBP":
        return "pbp";
      case "\x7FELF":
        return "elf";
      case "~PSP":
        return "psp";
      case "CISO":
        return "ciso";
      case "\0\0\0\0":
        const data2 = await asyncStream.readChunkAsync(16 * 2048, 6);
        const stream2 = Stream.fromArrayBuffer(data2);
        const magic2 = stream2.readString(6);
        switch (magic2) {
          case "CD001":
            return "iso";
          default:
            throw `Unknown format. Magic: '${magic2}'`;
        }
      default:
        break;
    }
    throw `Unknown format. Magic: '${magic}'`;
  }

  // src/format/zlib.ts
  "use strict";
  var Huffman = class {
    constructor(data, max, min) {
      this.data = data;
      this.max = max;
      this.min = min;
    }
    static buildHuffmanTable(lengths) {
      const listSize = lengths.length;
      let maxCodeLength = 0;
      let minCodeLength = Number.POSITIVE_INFINITY;
      for (let i = 0, il = listSize; i < il; ++i) {
        if (lengths[i] > maxCodeLength)
          maxCodeLength = lengths[i];
        if (lengths[i] < minCodeLength)
          minCodeLength = lengths[i];
      }
      const size = 1 << maxCodeLength;
      const table = new Uint32Array(size);
      for (let bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength; ) {
        for (let i = 0; i < listSize; ++i) {
          if (lengths[i] === bitLength) {
            let reversed = 0;
            for (let rtemp = code, j = 0; j < bitLength; ++j) {
              reversed = reversed << 1 | rtemp & 1;
              rtemp >>= 1;
            }
            const value = bitLength << 16 | i;
            for (let j = reversed; j < size; j += skip)
              table[j] = value;
            ++code;
          }
        }
        ++bitLength;
        code <<= 1;
        skip <<= 1;
      }
      return new Huffman(table, maxCodeLength, minCodeLength);
    }
  };
  var ZLIB_RAW_INFLATE_BUFFER_SIZE = 32768;
  var _RawInflate = class {
    constructor(input) {
      this.input = input;
      this.buffer = new Uint8Array(0);
      this.blocks = [];
      this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
      this.ip = 0;
      this.bitsbuf = 0;
      this.bitsbuflen = 0;
      this.output = new Uint8Array(this.bufferSize);
      this.op = 0;
      this.bfinal = false;
    }
    decompress() {
      while (!this.bfinal) {
        this.parseBlock();
      }
      return this.concatBufferDynamic();
    }
    parseBlock() {
      let hdr = this.readBits(3);
      if (hdr & 1)
        this.bfinal = true;
      hdr >>>= 1;
      switch (hdr) {
        case 0:
          this.parseUncompressedBlock();
          break;
        case 1:
          this.parseFixedHuffmanBlock();
          break;
        case 2:
          this.parseDynamicHuffmanBlock();
          break;
        default:
          throw new Error(`unknown BTYPE: ${hdr}`);
      }
    }
    readBits(length) {
      let bitsbuf = this.bitsbuf;
      let bitsbuflen = this.bitsbuflen;
      const input = this.input;
      let ip = this.ip;
      const inputLength = input.length;
      if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength)
        throw new Error("input buffer is broken");
      while (bitsbuflen < length) {
        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      }
      const octet = bitsbuf & (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    }
    readCodeByTable(table) {
      let bitsbuf = this.bitsbuf;
      let bitsbuflen = this.bitsbuflen;
      let ip = this.ip;
      const input = this.input;
      const inputLength = input.length;
      const codeTable = table.data;
      const maxCodeLength = table.max;
      while (bitsbuflen < maxCodeLength) {
        if (ip >= inputLength)
          break;
        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      }
      const codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      const codeLength = codeWithLength >>> 16;
      if (codeLength > bitsbuflen)
        throw new Error(`invalid code length: ${codeLength}`);
      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 65535;
    }
    parseUncompressedBlock() {
      const input = this.input;
      let ip = this.ip;
      let output = this.output;
      let op = this.op;
      const inputLength = input.length;
      this.bitsbuf = 0;
      this.bitsbuflen = 0;
      if (ip + 1 >= inputLength)
        throw new Error("invalid uncompressed block header: LEN");
      const len = input[ip++] | input[ip++] << 8;
      if (ip + 1 >= inputLength)
        throw new Error("invalid uncompressed block header: NLEN");
      const nlen = input[ip++] | input[ip++] << 8;
      if (len === ~nlen)
        throw new Error("invalid uncompressed block header: length verify");
      if (ip + len > input.length)
        throw new Error("input buffer is broken");
      while (op + len > output.length)
        output = this.expandBufferAdaptive(2);
      output.set(input.subarray(ip, ip + len), op);
      op += len;
      ip += len;
      this.ip = ip;
      this.op = op;
      this.output = output;
    }
    parseFixedHuffmanBlock() {
      this.decodeHuffmanAdaptive(_RawInflate.FixedLiteralLengthTable, _RawInflate.FixedDistanceTable);
    }
    parseDynamicHuffmanBlock() {
      const hlit = this.readBits(5) + 257;
      const hdist = this.readBits(5) + 1;
      const hclen = this.readBits(4) + 4;
      const codeLengths = new Uint8Array(_RawInflate.Order.length);
      let prev = 0;
      for (let i = 0; i < hclen; ++i)
        codeLengths[_RawInflate.Order[i]] = this.readBits(3);
      const codeLengthsTable = Huffman.buildHuffmanTable(codeLengths);
      const lengthTable = new Uint8Array(hlit + hdist);
      for (let i = 0, il = hlit + hdist; i < il; ) {
        const code = this.readCodeByTable(codeLengthsTable);
        switch (code) {
          case 16: {
            let repeat = 3 + this.readBits(2);
            while (repeat--)
              lengthTable[i++] = prev;
            break;
          }
          case 17: {
            let repeat = 3 + this.readBits(3);
            while (repeat--)
              lengthTable[i++] = 0;
            prev = 0;
            break;
          }
          case 18: {
            let repeat = 11 + this.readBits(7);
            while (repeat--)
              lengthTable[i++] = 0;
            prev = 0;
            break;
          }
          default:
            lengthTable[i++] = code;
            prev = code;
            break;
        }
      }
      const litlenTable = Huffman.buildHuffmanTable(lengthTable.subarray(0, hlit));
      const distTable = Huffman.buildHuffmanTable(lengthTable.subarray(hlit));
      this.decodeHuffmanAdaptive(litlenTable, distTable);
    }
    decodeHuffmanAdaptive(litlen, dist) {
      let output = this.output;
      let op = this.op;
      let code = 0;
      let olength = output.length;
      this.currentLitlenTable = litlen;
      const lengthCodeTable = _RawInflate.LengthCodeTable;
      const lengthExtraTable = _RawInflate.LengthExtraTable;
      const distCodeTable = _RawInflate.DistCodeTable;
      const distExtraTable = _RawInflate.DistExtraTable;
      while ((code = this.readCodeByTable(litlen)) !== 256) {
        if (code < 256) {
          if (op >= olength) {
            output = this.expandBufferAdaptive();
            olength = output.length;
          }
          output[op++] = code;
          continue;
        }
        const ti = code - 257;
        let codeLength = lengthCodeTable[ti];
        if (lengthExtraTable[ti] > 0)
          codeLength += this.readBits(lengthExtraTable[ti]);
        code = this.readCodeByTable(dist);
        let codeDist = distCodeTable[code];
        if (distExtraTable[code] > 0)
          codeDist += this.readBits(distExtraTable[code]);
        if (op + codeLength > olength) {
          output = this.expandBufferAdaptive();
          olength = output.length;
        }
        while (codeLength--)
          output[op] = output[op++ - codeDist];
      }
      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }
      this.op = op;
    }
    expandBufferAdaptive(ratio = this.input.length / this.ip + 1 | 0) {
      const input = this.input;
      const output = this.output;
      let newSize;
      if (ratio < 2) {
        const maxHuffCode = (input.length - this.ip) / this.currentLitlenTable.min;
        const maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      }
      const buffer = new Uint8Array(newSize);
      buffer.set(output);
      this.output = buffer;
      return this.output;
    }
    concatBufferDynamic() {
      let buffer;
      const op = this.op;
      buffer = this.output.subarray(0, op);
      this.buffer = buffer;
      return this.buffer;
    }
  };
  var RawInflate = _RawInflate;
  RawInflate.Order = new Uint16Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  RawInflate.LengthCodeTable = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    258,
    258
  ]);
  RawInflate.LengthExtraTable = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    0,
    0
  ]);
  RawInflate.DistCodeTable = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577
  ]);
  RawInflate.DistExtraTable = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
  ]);
  RawInflate.FixedLiteralLengthTable = (() => {
    const lengths = new Uint8Array(288);
    for (let i = 0, il = lengths.length; i < il; ++i)
      lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
    return Huffman.buildHuffmanTable(lengths);
  })();
  RawInflate.FixedDistanceTable = (() => {
    const lengths = new Uint8Array(30);
    for (let i = 0, il = lengths.length; i < il; ++i)
      lengths[i] = 5;
    return Huffman.buildHuffmanTable(lengths);
  })();
  function zlib_inflate_raw(data) {
    return new RawInflate(data).decompress();
  }

  // src/format/cso.ts
  var CSO_MAGIC = "CISO";
  var Header = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = "";
      this.headerSize = 0;
      this.totalBytes = Integer64.ZERO;
      this.blockSize = 0;
      this.version = 0;
      this.alignment = 0;
      this.reserved = 0;
    }
    get numberOfBlocks() {
      return Math.floor(this.totalBytes.number / this.blockSize);
    }
  };
  __decorate([
    StructStructStringz(4)
  ], Header.prototype, "magic", 2);
  __decorate([
    StructUInt32
  ], Header.prototype, "headerSize", 2);
  __decorate([
    StructInteger64_l
  ], Header.prototype, "totalBytes", 2);
  __decorate([
    StructUInt32
  ], Header.prototype, "blockSize", 2);
  __decorate([
    StructUInt8
  ], Header.prototype, "version", 2);
  __decorate([
    StructUInt8
  ], Header.prototype, "alignment", 2);
  __decorate([
    StructUInt16
  ], Header.prototype, "reserved", 2);
  var Block = class {
    constructor(index, raw1, raw2) {
      this.index = index;
      this._uncompressedData = null;
      this.compressedData = new Uint8Array();
      this.compressed = (raw1 & 2147483648) == 0;
      this.low = raw1 & 2147483647;
      this.high = raw2 & 2147483647;
    }
    get uncompresesdData() {
      if (!this._uncompressedData) {
        if (this.compressed) {
          this._uncompressedData = zlib_inflate_raw(this.compressedData);
        } else {
          this._uncompressedData = this.compressedData;
        }
      }
      return this._uncompressedData;
    }
    get size() {
      return this.high - this.low;
    }
    static getBlocksUncompressedData(blocks) {
      return ArrayBufferUtils.concatU8(blocks.map((b) => {
        return b.uncompresesdData;
      }));
    }
  };
  var Cso = class extends BaseAsyncStream {
    constructor() {
      super(...arguments);
      this.date = new Date();
    }
    getBlockInfo(index) {
      return new Block(index, this.offsets[index + 0], this.offsets[index + 1]);
    }
    static fromStreamAsync(stream) {
      return new Cso().loadAsync(stream);
    }
    get name() {
      return this.stream.name;
    }
    get size() {
      return this.header.totalBytes.number;
    }
    async readUncachedBlocksAsync(index, count) {
      const low = this.getBlockInfo(index).low;
      const high = this.getBlockInfo(index + count - 1).high;
      const data = await this.stream.readChunkAsync(low, high - low);
      const chunks = [];
      for (let n = 0; n < count; n++) {
        const chunk = this.getBlockInfo(index + n);
        chunk.compressedData = new Uint8Array(data, chunk.low - low, chunk.size);
        chunks.push(chunk);
      }
      return chunks;
    }
    async readChunkPromiseAsync(offset, count) {
      const blockIndexLow = Math.floor(offset / this.header.blockSize);
      const blockIndexHigh = Math.floor((offset + count - 1) / this.header.blockSize);
      const blockCount = blockIndexHigh - blockIndexLow + 2;
      const skip = offset % this.header.blockSize;
      const blocks = await this.readUncachedBlocksAsync(blockIndexLow, blockCount);
      return ArrayBufferUtils.copyUint8ToArrayBuffer(Block.getBlocksUncompressedData(blocks).subarray(skip, skip + count));
    }
    async loadAsync(stream) {
      this.stream = stream;
      this.date = stream.date;
      let buffer = await stream.readChunkAsync(0, Header.struct.length);
      const header = this.header = Header.struct.read(Stream.fromArrayBuffer(buffer));
      if (header.magic != CSO_MAGIC)
        throw "Not a CSO file";
      const buffer2 = await stream.readChunkAsync(Header.struct.length, (header.numberOfBlocks + 1) * 4);
      this.offsets = new Uint32Array(buffer2);
      return this;
    }
  };

  // src/format/pbp.ts
  var PbpMagic;
  (function(PbpMagic2) {
    PbpMagic2[PbpMagic2["expected"] = 1346523136] = "expected";
  })(PbpMagic || (PbpMagic = {}));
  var PbpHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.version = 0;
      this.offsets = [];
    }
  };
  __decorate([
    StructInt32
  ], PbpHeader.prototype, "magic", 2);
  __decorate([
    StructInt32
  ], PbpHeader.prototype, "version", 2);
  __decorate([
    StructStructArray(Int32, 8)
  ], PbpHeader.prototype, "offsets", 2);
  var Names = class {
  };
  Names.ParamSfo = "param.sfo";
  Names.Icon0Png = "icon0.png";
  Names.Icon1Pmf = "icon1.pmf";
  Names.Pic0Png = "pic0.png";
  Names.Pic1Png = "pic1.png";
  Names.Snd0At3 = "snd0.at3";
  Names.PspData = "psp.data";
  Names.PsarData = "psar.data";
  var PbpNames = Names;
  var _Pbp = class {
    constructor() {
    }
    static fromStream(stream) {
      const pbp = new _Pbp();
      pbp.load(stream);
      return pbp;
    }
    load(stream) {
      this.stream = stream;
      this.header = PbpHeader.struct.read(stream);
      if (this.header.magic != 1346523136)
        throw "Not a PBP file";
      this.header.offsets.push(stream.length);
    }
    get(name2) {
      const index = _Pbp.names.indexOf(name2);
      return this.getByIndex(index);
    }
    getByIndex(index) {
      const offsets = this.header.offsets;
      return this.stream.sliceWithLowHigh(offsets[index + 0], offsets[index + 1]);
    }
  };
  var Pbp = _Pbp;
  Pbp.names = [Names.ParamSfo, Names.Icon0Png, Names.Icon1Pmf, Names.Pic0Png, Names.Pic1Png, Names.Snd0At3, Names.PspData, Names.PsarData];

  // src/core/kirk/jsaes2.ts
  var SBOX = new Uint8Array(256);
  var INV_SBOX = new Uint8Array(256);
  var SUB_MIX_0 = new Uint32Array(256);
  var SUB_MIX_1 = new Uint32Array(256);
  var SUB_MIX_2 = new Uint32Array(256);
  var SUB_MIX_3 = new Uint32Array(256);
  var INV_SUB_MIX_0 = new Uint32Array(256);
  var INV_SUB_MIX_1 = new Uint32Array(256);
  var INV_SUB_MIX_2 = new Uint32Array(256);
  var INV_SUB_MIX_3 = new Uint32Array(256);
  (function() {
    const d = [];
    for (let i = 0; i < 256; i++) {
      d[i] = i << 1;
      if (i >= 128)
        d[i] ^= 283;
    }
    let x = 0;
    let xi = 0;
    for (let i = 0; i < 256; i++) {
      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      SBOX[x] = sx;
      INV_SBOX[sx] = x;
      const x2 = d[x];
      const x4 = d[x2];
      const x8 = d[x4];
      let t = d[sx] * 257 ^ sx * 16843008;
      SUB_MIX_0[x] = t << 24 | t >>> 8;
      SUB_MIX_1[x] = t << 16 | t >>> 16;
      SUB_MIX_2[x] = t << 8 | t >>> 24;
      SUB_MIX_3[x] = t << 0;
      t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
      INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
      INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
      INV_SUB_MIX_3[sx] = t << 0;
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  })();
  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var AES = class {
    constructor(key) {
      this._key = new Uint32Array([0, 0, 0, 0]);
      this._nRounds = -1;
      this._keySchedule = [];
      this._invKeySchedule = [];
      this._key = uint8array_to_words(key);
      this.reset();
    }
    reset() {
      const key = this._key;
      const keyWords = key;
      const keySize = key.length;
      const nRounds = this._nRounds = keySize + 6;
      const ksRows = (nRounds + 1) * 4;
      const keySchedule = this._keySchedule = [];
      for (let ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          keySchedule[ksRow] = keyWords[ksRow];
        } else {
          let t = keySchedule[ksRow - 1];
          if (!(ksRow % keySize)) {
            t = t << 8 | t >>> 24;
            t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
            t ^= RCON[ksRow / keySize | 0] << 24;
          } else if (keySize > 6 && ksRow % keySize == 4) {
            t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
          }
          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
        }
      }
      const invKeySchedule = this._invKeySchedule = [];
      for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        const ksRow = ksRows - invKsRow;
        let t;
        if (invKsRow % 4) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }
        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
        }
      }
    }
    encryptBlock(M, offset) {
      this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
    }
    decryptBlock(M, offset) {
      {
        let t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
      }
      this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
      {
        let t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
      }
    }
    _doCryptBlock(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
      const nRounds = this._nRounds;
      let s0 = M[offset + 0] ^ keySchedule[0];
      let s1 = M[offset + 1] ^ keySchedule[1];
      let s2 = M[offset + 2] ^ keySchedule[2];
      let s3 = M[offset + 3] ^ keySchedule[3];
      let ksRow = 4;
      for (let round = 1; round < nRounds; round++) {
        const t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 >>> 0 & 255] ^ keySchedule[ksRow++];
        const t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 >>> 0 & 255] ^ keySchedule[ksRow++];
        const t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 >>> 0 & 255] ^ keySchedule[ksRow++];
        const t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 >>> 0 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      {
        const t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 >>> 0 & 255]) ^ keySchedule[ksRow++];
        const t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 >>> 0 & 255]) ^ keySchedule[ksRow++];
        const t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 >>> 0 & 255]) ^ keySchedule[ksRow++];
        const t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 >>> 0 & 255]) ^ keySchedule[ksRow++];
        M[offset + 0] = t0;
        M[offset + 1] = t1;
        M[offset + 2] = t2;
        M[offset + 3] = t3;
      }
    }
  };
  function swap32(v) {
    return (v & 255) << 24 | (v & 65280) << 8 | v >> 8 & 65280 | v >> 24 & 255;
  }
  function uint8array_to_words(key) {
    const temp = new Uint32Array(key.buffer, key.byteOffset, key.length / 4);
    const words = new Uint32Array(key.length / 4);
    for (let n = 0; n < words.length; n++)
      words[n] = swap32(temp[n]);
    return words;
  }
  function words_to_uint8array(words) {
    const out = new Uint8Array(words.length * 4);
    const out2 = new Uint32Array(out.buffer);
    for (let n = 0; n < words.length; n++)
      out2[n] = swap32(words[n]);
    return out;
  }
  function decrypt_aes128_cbc(data, key) {
    const aes = new AES(key);
    const words = uint8array_to_words(data);
    const wordsLength = words.length;
    let t0 = 0, t1 = 0, t2 = 0, t3 = 0;
    let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
    for (let n = 0; n < wordsLength; n += 4) {
      t0 = words[n + 0];
      t1 = words[n + 1];
      t2 = words[n + 2];
      t3 = words[n + 3];
      aes.decryptBlock(words, n);
      words[n + 0] ^= s0;
      words[n + 1] ^= s1;
      words[n + 2] ^= s2;
      words[n + 3] ^= s3;
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }
    return words_to_uint8array(words);
  }

  // src/core/kirk/crypto.ts
  function aes_decrypt(data, key, iv) {
    const keyLength = key.length;
    if (iv === void 0)
      iv = new Uint8Array(keyLength);
    return decrypt_aes128_cbc(data, key);
  }

  // src/core/kirk/kirk.ts
  var kirk1_key = new Uint8Array([152, 201, 64, 151, 92, 29, 16, 232, 127, 230, 14, 163, 253, 3, 168, 186]);
  var kirk16_key = new Uint8Array([71, 94, 9, 244, 162, 55, 218, 155, 239, 255, 59, 192, 119, 20, 61, 138]);
  var kirk7_keys = {
    2: new Uint8Array([184, 19, 195, 94, 198, 68, 65, 227, 220, 60, 22, 245, 180, 94, 100, 132]),
    3: new Uint8Array([152, 2, 196, 230, 236, 158, 158, 47, 252, 99, 76, 228, 47, 187, 70, 104]),
    4: new Uint8Array([153, 36, 76, 210, 88, 245, 27, 203, 176, 97, 156, 167, 56, 48, 7, 95]),
    5: new Uint8Array([2, 37, 215, 186, 99, 236, 185, 74, 157, 35, 118, 1, 179, 246, 172, 23]),
    7: new Uint8Array([118, 54, 139, 67, 143, 119, 216, 126, 254, 95, 182, 17, 89, 57, 136, 92]),
    12: new Uint8Array([132, 133, 200, 72, 117, 8, 67, 188, 155, 154, 236, 167, 156, 127, 96, 24]),
    13: new Uint8Array([181, 177, 110, 222, 35, 169, 123, 14, 161, 124, 219, 162, 220, 222, 196, 110]),
    14: new Uint8Array([200, 113, 253, 179, 188, 197, 210, 242, 226, 215, 114, 157, 223, 130, 104, 130]),
    15: new Uint8Array([10, 187, 51, 108, 150, 212, 205, 216, 203, 95, 75, 224, 186, 219, 158, 3]),
    16: new Uint8Array([50, 41, 91, 213, 234, 247, 163, 66, 22, 200, 142, 72, 255, 80, 211, 113]),
    17: new Uint8Array([70, 242, 94, 142, 77, 42, 165, 64, 115, 11, 196, 110, 71, 238, 111, 10]),
    18: new Uint8Array([93, 199, 17, 57, 208, 25, 56, 188, 2, 127, 221, 220, 176, 131, 125, 157]),
    56: new Uint8Array([18, 70, 141, 126, 28, 66, 32, 155, 186, 84, 38, 131, 94, 176, 51, 3]),
    57: new Uint8Array([196, 59, 182, 214, 83, 238, 103, 73, 62, 169, 95, 188, 12, 237, 111, 138]),
    58: new Uint8Array([44, 195, 207, 140, 40, 120, 165, 166, 99, 226, 175, 45, 113, 94, 134, 186]),
    68: new Uint8Array([125, 244, 146, 101, 227, 250, 214, 120, 214, 254, 120, 173, 187, 61, 251, 99]),
    75: new Uint8Array([12, 253, 103, 154, 249, 180, 114, 79, 215, 141, 214, 233, 150, 66, 40, 139]),
    83: new Uint8Array([175, 254, 142, 177, 61, 209, 126, 216, 10, 97, 36, 28, 149, 146, 86, 182]),
    87: new Uint8Array([28, 155, 196, 144, 227, 6, 100, 129, 250, 89, 253, 182, 0, 187, 40, 112]),
    93: new Uint8Array([17, 90, 93, 32, 213, 58, 141, 211, 156, 197, 175, 65, 15, 15, 24, 111]),
    99: new Uint8Array([156, 155, 19, 114, 248, 198, 64, 207, 28, 98, 245, 213, 146, 221, 181, 130]),
    100: new Uint8Array([3, 179, 2, 232, 95, 243, 129, 177, 59, 141, 170, 42, 144, 255, 94, 97])
  };
  var ec_p = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 1, 255, 255, 255, 255, 255, 255, 255, 255]);
  var ec_a = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 1, 255, 255, 255, 255, 255, 255, 255, 252]);
  var ec_b2 = new Uint8Array([166, 139, 237, 195, 52, 24, 2, 156, 29, 60, 227, 59, 154, 50, 31, 204, 187, 158, 15, 11]);
  var ec_N2 = new Uint8Array([0, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 181, 174, 60, 82, 62, 99, 148, 79, 33, 39]);
  var Gx2 = new Uint8Array([18, 142, 196, 37, 100, 135, 253, 143, 223, 100, 226, 67, 123, 192, 161, 246, 213, 175, 222, 44]);
  var Gy2 = new Uint8Array([89, 88, 85, 126, 177, 219, 0, 18, 96, 66, 85, 36, 219, 195, 121, 213, 172, 95, 74, 223]);
  var ec_b1 = new Uint8Array([101, 209, 72, 140, 3, 89, 226, 52, 173, 201, 91, 211, 144, 128, 20, 189, 145, 165, 37, 249]);
  var ec_N1 = new Uint8Array([0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 1, 181, 198, 23, 242, 144, 234, 225, 219, 173, 143]);
  var Gx1 = new Uint8Array([34, 89, 172, 238, 21, 72, 156, 176, 150, 168, 130, 240, 174, 28, 249, 253, 142, 229, 248, 250]);
  var Gy1 = new Uint8Array([96, 67, 88, 69, 109, 10, 28, 178, 144, 141, 233, 15, 39, 215, 92, 130, 190, 193, 8, 192]);
  var Px1 = new Uint8Array([237, 156, 229, 130, 52, 230, 26, 83, 198, 133, 214, 77, 81, 208, 35, 107, 195, 181, 212, 185]);
  var Py1 = new Uint8Array([4, 157, 241, 160, 117, 192, 224, 79, 179, 68, 133, 139, 97, 183, 155, 105, 166, 61, 44, 57]);
  var KIRK_AES128CBC_HEADER = class extends Struct {
    constructor() {
      super(...arguments);
      this.mode = KirkMode.Invalid0;
      this.unk_4 = 0;
      this.unk_8 = 0;
      this.keyseed = 0;
      this.data_size = 0;
    }
  };
  __decorate([
    StructInt32
  ], KIRK_AES128CBC_HEADER.prototype, "mode", 2);
  __decorate([
    StructInt32
  ], KIRK_AES128CBC_HEADER.prototype, "unk_4", 2);
  __decorate([
    StructInt32
  ], KIRK_AES128CBC_HEADER.prototype, "unk_8", 2);
  __decorate([
    StructInt32
  ], KIRK_AES128CBC_HEADER.prototype, "keyseed", 2);
  __decorate([
    StructInt32
  ], KIRK_AES128CBC_HEADER.prototype, "data_size", 2);
  var AES128CMACHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.AES_key = [];
      this.CMAC_key = [];
      this.CMAC_header_hash = [];
      this.CMAC_data_hash = [];
      this.Unknown1 = [];
      this.Mode = 0;
      this.UseECDSAhash = 0;
      this.Unknown2 = [];
      this.DataSize = 0;
      this.DataOffset = 0;
      this.Unknown3 = [];
      this.Unknown4 = [];
    }
  };
  __decorate([
    StructStructArray(UInt8, 16)
  ], AES128CMACHeader.prototype, "AES_key", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], AES128CMACHeader.prototype, "CMAC_key", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], AES128CMACHeader.prototype, "CMAC_header_hash", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], AES128CMACHeader.prototype, "CMAC_data_hash", 2);
  __decorate([
    StructStructArray(UInt8, 32)
  ], AES128CMACHeader.prototype, "Unknown1", 2);
  __decorate([
    StructUInt8
  ], AES128CMACHeader.prototype, "Mode", 2);
  __decorate([
    StructUInt8
  ], AES128CMACHeader.prototype, "UseECDSAhash", 2);
  __decorate([
    StructStructArray(UInt8, 14)
  ], AES128CMACHeader.prototype, "Unknown2", 2);
  __decorate([
    StructUInt32
  ], AES128CMACHeader.prototype, "DataSize", 2);
  __decorate([
    StructUInt32
  ], AES128CMACHeader.prototype, "DataOffset", 2);
  __decorate([
    StructStructArray(UInt8, 8)
  ], AES128CMACHeader.prototype, "Unknown3", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], AES128CMACHeader.prototype, "Unknown4", 2);
  function kirk_4_7_get_key(key_type) {
    const key = kirk7_keys[key_type];
    if (!key)
      throw new Error("Unsupported key '" + key_type + "'");
    return key;
  }
  var KirkMode;
  (function(KirkMode2) {
    KirkMode2[KirkMode2["Invalid0"] = 0] = "Invalid0";
    KirkMode2[KirkMode2["Cmd1"] = 1] = "Cmd1";
    KirkMode2[KirkMode2["Cmd2"] = 2] = "Cmd2";
    KirkMode2[KirkMode2["Cmd3"] = 3] = "Cmd3";
    KirkMode2[KirkMode2["EncryptCbc"] = 4] = "EncryptCbc";
    KirkMode2[KirkMode2["DecryptCbc"] = 5] = "DecryptCbc";
  })(KirkMode || (KirkMode = {}));
  var CommandEnum;
  (function(CommandEnum2) {
    CommandEnum2[CommandEnum2["DECRYPT_PRIVATE"] = 1] = "DECRYPT_PRIVATE";
    CommandEnum2[CommandEnum2["ENCRYPT_SIGN"] = 2] = "ENCRYPT_SIGN";
    CommandEnum2[CommandEnum2["DECRYPT_SIGN"] = 3] = "DECRYPT_SIGN";
    CommandEnum2[CommandEnum2["ENCRYPT_IV_0"] = 4] = "ENCRYPT_IV_0";
    CommandEnum2[CommandEnum2["ENCRYPT_IV_FUSE"] = 5] = "ENCRYPT_IV_FUSE";
    CommandEnum2[CommandEnum2["ENCRYPT_IV_USER"] = 6] = "ENCRYPT_IV_USER";
    CommandEnum2[CommandEnum2["DECRYPT_IV_0"] = 7] = "DECRYPT_IV_0";
    CommandEnum2[CommandEnum2["DECRYPT_IV_FUSE"] = 8] = "DECRYPT_IV_FUSE";
    CommandEnum2[CommandEnum2["DECRYPT_IV_USER"] = 9] = "DECRYPT_IV_USER";
    CommandEnum2[CommandEnum2["PRIV_SIG_CHECK"] = 10] = "PRIV_SIG_CHECK";
    CommandEnum2[CommandEnum2["SHA1_HASH"] = 11] = "SHA1_HASH";
    CommandEnum2[CommandEnum2["ECDSA_GEN_KEYS"] = 12] = "ECDSA_GEN_KEYS";
    CommandEnum2[CommandEnum2["ECDSA_MULTIPLY_POINT"] = 13] = "ECDSA_MULTIPLY_POINT";
    CommandEnum2[CommandEnum2["PRNG"] = 14] = "PRNG";
    CommandEnum2[CommandEnum2["INIT"] = 15] = "INIT";
    CommandEnum2[CommandEnum2["ECDSA_SIGN"] = 16] = "ECDSA_SIGN";
    CommandEnum2[CommandEnum2["ECDSA_VERIFY"] = 17] = "ECDSA_VERIFY";
    CommandEnum2[CommandEnum2["CERT_VERIFY"] = 18] = "CERT_VERIFY";
  })(CommandEnum || (CommandEnum = {}));
  function CMD7(input) {
    const header = GetStruct(KIRK_AES128CBC_HEADER).read(input.slice());
    if (header.mode != 5)
      throw new Error("Kirk Invalid mode '" + header.mode + "'");
    if (header.data_size == 0)
      throw new Error("Kirk data size == 0");
    return aes_decrypt(input.sliceFrom(GetStruct(KIRK_AES128CBC_HEADER).length).readAllBytes(), kirk_4_7_get_key(header.keyseed));
  }
  function kirk_CMD7(output, input) {
    const output2 = Stream.fromUint8Array(CMD7(input.slice()));
    output.slice().writeStream(output2);
  }
  function kirk_CMD1(output, input) {
    const header = input.slice().readStruct(AES128CMACHeader.struct);
    if (header.Mode != 1)
      throw new Error("Kirk mode != Cmd1");
    const Keys = aes_decrypt(input.sliceWithLength(0, 16 * 2).readAllBytes(), kirk1_key);
    const KeyAes = Keys.subarray(0, 16);
    const KeyCmac = Keys.subarray(16, 16);
    const PaddedDataSize = header.DataSize + 15 & -16;
    const Output = aes_decrypt(input.sliceWithLength(header.DataOffset + AES128CMACHeader.struct.length, PaddedDataSize).readAllBytes(), KeyAes);
    output.slice().writeBytes(Output.subarray(0, header.DataSize));
  }
  function hleUtilsBufferCopyWithRange(output, input, command) {
    switch (command) {
      case 1:
        return kirk_CMD1(output, input);
      case 7:
        return kirk_CMD7(output, input);
    }
    throw new Error(`Not implemented hleUtilsBufferCopyWithRange! with command ${command}: ${CommandEnum[command]}`);
  }

  // src/hle/elf_crypted_prx_keys_144.ts
  var g_key0 = new Uint32Array([2065822654, 698113565, 480009841, 2529904197, 1016798176, 3951418941, 1249845282, 3256905386, 3574280805, 1433863527, 1007159360, 2552059378, 1608054515, 4002328773, 2488107346, 4163339857, 654686970, 2216748339, 655706857, 1209641522, 1503898176, 749981541, 4067706477, 979719685, 565246095, 3316747558, 1690406993, 3597257038, 3899667954, 2637846793, 1867411714, 3702081230, 2216069147, 3132135333, 613492166, 3008104562]);
  var g_key2 = new Uint32Array([3439175986, 1371565942, 74304719, 1239515678, 2101019212, 2648332389, 3431766053, 3521740213, 1752488139, 879872391, 1928180732, 2177381981, 3781288762, 4237482841, 537506284, 2980662500, 788752747, 2279749336, 992709865, 50718596, 4184934531, 2956581689, 2302405175, 3880609797, 710686909, 2962081811, 364061557, 1186874661, 17038736, 2836301730, 1386980970, 2243918720, 1172885091, 1305941715, 4125297965, 2939872342]);
  var g_key3 = new Uint32Array([2798187978, 1835516032, 2454670650, 75276394, 140771991, 1339336536, 3177732743, 2603024834, 2209753653, 1919636284, 3844274700, 3259696820, 1167924396, 2831499643, 1340760738, 102094658, 811765001, 3293555476, 1778348382, 3537404797, 3203206027, 510547886, 1642644482, 3191241222, 1413426014, 3678322776, 3196395637, 511593932, 358935125, 3967296948, 3226700973, 1895246975, 1239991248, 3987308229, 4103254180, 3764301866]);
  var g_key44 = new Uint32Array([4018200581, 978610335, 1137286349, 460793790, 1555562552, 3710844514, 4083808556, 370119877, 693501977, 3208384709, 4073608550, 3466774054, 3053551983, 1692878878, 204791485, 2566036656, 1069876439, 3371907568, 35763160, 1677276834, 2587510784, 1858876131, 2383547645, 2956334627, 2934040201, 1951728363, 3836134940, 1962032820, 3623507987, 2954434283, 305300567, 3535574994, 1684284888, 847478949, 1138395825, 1259481801]);
  var g_key20 = new Uint32Array([867502080, 4079968205, 1007978527, 1854548629, 704573397, 328526563, 3177960515, 136429699, 4206066131, 3860062565, 4121384147, 277555538, 172695061, 1642782394, 1433757151, 994464513, 2924801219, 1631728393, 1892286233, 1527440876, 2560487718, 2644015711, 1438414094, 3329145383, 770279656, 4150657242, 58907851, 1433007602, 2386760290, 680518611, 1701781895, 936455836, 794009268, 2761070990, 3979958519, 971597091]);
  var g_key3A = new Uint32Array([1736929385, 985486871, 3258626524, 2874626173, 107642688, 618592697, 116873700, 3707053233, 326712926, 56164909, 2867323298, 1991881466, 2585133888, 2273456058, 434278331, 2654177794, 3623911066, 3929111281, 1661366750, 191351420, 2253492911, 3929814310, 725912718, 2337903188, 1174596043, 1306619098, 3781481915, 132962446, 2583684600, 1988624577, 1404080621, 2214884404, 3022445500, 922306747, 1175724376, 1956361362]);
  var g_keyEBOOT1xx = new Uint32Array([415984111, 361662738, 3740864187, 1286667043, 914877976, 2257406574, 431343446, 3994440989, 3888852332, 2538063456, 3465876543, 693564535, 58870494, 554474993, 1344924452, 2178934431, 969448192, 2953612177, 4012767682, 3778712572, 2341774504, 1226690717, 1751793677, 3470051300, 2529736649, 514513960, 2752973700, 1348296156, 1571210191, 241039917, 1853430197, 3462277575, 2863455124, 1173818589, 1655125797, 3437647421]);
  var g_keyEBOOT2xx = new Uint32Array([3666753274, 1574532167, 1992398964, 2548399791, 480971197, 2553658054, 64197249, 61998543, 679667508, 3876910691, 3111004021, 3179982791, 500427817, 3970212204, 1600777351, 2241339026, 2096934433, 3135888662, 3869865988, 787350268, 1642039869, 3710977380, 2526536009, 3259318075, 4179461206, 970615752, 3018194677, 2311426979, 4217146044, 1812689426, 3775779787, 2563814056, 1607866439, 4040958807, 1996559978, 257702760]);
  var g_keyUPDATER = new Uint32Array([2774547647, 3611829313, 4132922572, 529532427, 1319583301, 3847344530, 3887553930, 1180323950, 1090195490, 740766544, 2157369924, 2571573646, 663613047, 1952253486, 3242785349, 2200273583, 1608222426, 3407201486, 623167023, 1815004081, 916186014, 4159381444, 508677658, 3607443188, 3276618200, 1947794195, 3821555169, 2971201596, 2718010702, 3872945933, 1461777296, 402219841, 1621403279, 321379624, 93604964, 204229650]);
  var g_keyMEIMG250 = new Uint32Array([2743205564, 2579092937, 1817578125, 808492949, 2032551628, 2192985694, 439964077, 169356996, 3294704052, 2009402506, 845092550, 47289390, 178490052, 714345158, 1728268070, 3844976947, 3538886919, 2244484752, 3369166010, 3280850461, 2492179061, 230180355, 3796317751, 3446996186, 1485716838, 1831397410, 2300466315, 4114412909, 196991846, 3300034218, 736869451, 4230356980, 2461591301, 3706612050, 1577337573, 2347466529]);
  var g_keyMEIMG260 = new Uint32Array([297784984, 3623465764, 3713157415, 371284870, 1347076973, 1480831511, 3852524103, 3144917479, 689298229, 928841018, 3144722693, 657190858, 781584273, 3926366651, 3092965064, 3385522035, 621733441, 115821214, 1380223325, 1181177253, 2592386899, 3775021428, 4005167902, 3984636366, 3157352306, 1478559359, 3895537752, 3536905990, 3872953150, 3620831156, 1347458756, 4255451963, 1177923133, 3947404426, 1110275629, 1519071793]);
  var g_keyDEMOS27X = new Uint32Array([448729135, 3583430769, 1875202738, 3572650783, 4029009369, 2946150147, 3771684815, 626300100, 1879271262, 2424031364, 2969316, 191396365, 2654643279, 4119845505, 3961957516, 986297501, 879870007, 2968748877, 282870801, 2721245745, 3806722667, 1163479811, 3829013639, 836426193, 147681283, 4204539871, 1518935333, 2606504244, 586376933, 1594378802, 1767184085, 574996127, 1332598533, 3300440225, 3155404288, 2008546363]);
  var g_keyUNK1 = new Uint32Array([867502080, 4079968205, 1007978527, 1854548629, 704573397, 328526563, 3177960515, 136429699, 4206066131, 3860062565, 4121384147, 277555538, 172695061, 1642782394, 1433757151, 994464513, 2924801219, 1631728393, 1892286233, 1527440876, 2560487718, 2644015711, 1438414094, 3329145383, 770279656, 4150657242, 58907851, 1433007602, 2386760290, 680518611, 1701781895, 936455836, 794009268, 2761070990, 3979958519, 971597091]);
  var g_key_GAMESHARE1xx = new Uint32Array([1914393576, 4231934406, 4166754978, 1022405746, 1424926635, 1499054027, 1421378411, 3158512403, 2560553679, 4040046258, 2562346232, 3916548401, 2687983048, 149237664, 2886587430, 1474614785, 3312345543, 4011506058, 3520723188, 1609148168, 1055956231, 4195097228, 2837375580, 1492419269, 746586882, 2129065667, 4285184955, 554750160, 3542710920, 2550141651, 3696871547, 2145146770, 3678363046, 4230199175, 577343187, 3061901330]);
  var g_key_GAMESHARE2xx = new Uint32Array([2493994951, 2681444403, 4166026097, 847973161, 750565850, 689486278, 2488029370, 4057786320, 1678522726, 3372956936, 4104984506, 1822488651, 4151737447, 2765333850, 1242061930, 1806856305, 4203428091, 1071329720, 2339477234, 3684429130, 1365400452, 1276412340, 4135908616, 817121136, 2477428340, 2428860860, 611240077, 772084226, 3346301998, 2709903767, 2049653469, 4270021485, 1351555149, 3947646739, 236557267, 3130449874]);
  var g_key_INDEXDAT1xx = new Uint32Array([1993015471, 287106607, 3081928246, 1838016761, 3578524010, 3655926643, 1973016962, 1375218446, 1667302317, 2386607157, 791882900, 4111706857, 3526033129, 70531463, 4233869324, 305438089, 346325435, 636304104, 2102398543, 1137817431, 2069495213, 1291566900, 3285283894, 3252298203, 2739768448, 2519409501, 1044514120, 164601854, 3565698908, 3641613493, 11465961, 4035472873, 1655016027, 1386566982, 2535014837, 4122451884]);
  function process2(_item) {
    const item = _item;
    item.key = new Uint8Array(_item.ikey.buffer);
    return item;
  }
  var g_tagInfo = [
    process2({tag: 0, ikey: g_key0, code: 66, codeExtra: 0}),
    process2({tag: 33554432, ikey: g_key2, code: 69, codeExtra: 0}),
    process2({tag: 50331648, ikey: g_key3, code: 70, codeExtra: 0}),
    process2({tag: 1147617629, ikey: g_key44, code: 89, codeExtra: 89}),
    process2({tag: 544980783, ikey: g_key20, code: 90, codeExtra: 90}),
    process2({tag: 986598862, ikey: g_key3A, code: 91, codeExtra: 91}),
    process2({tag: 117440512, ikey: g_key_INDEXDAT1xx, code: 74, codeExtra: 0}),
    process2({tag: 134217728, ikey: g_keyEBOOT1xx, code: 75, codeExtra: 0}),
    process2({tag: 3234535036, ikey: g_keyEBOOT2xx, code: 93, codeExtra: 93}),
    process2({tag: 184549376, ikey: g_keyUPDATER, code: 78, codeExtra: 0}),
    process2({tag: 201326592, ikey: g_keyDEMOS27X, code: 79, codeExtra: 0}),
    process2({tag: 251658240, ikey: g_keyMEIMG250, code: 82, codeExtra: 0}),
    process2({tag: 2250655953, ikey: g_keyMEIMG260, code: 82, codeExtra: 82}),
    process2({tag: 544980783, ikey: g_keyUNK1, code: 90, codeExtra: 90}),
    process2({tag: 150994944, ikey: g_key_GAMESHARE1xx, code: 76, codeExtra: 0}),
    process2({tag: 3144140191, ikey: g_key_GAMESHARE2xx, code: 94, codeExtra: 94})
  ];

  // src/hle/elf_crypted_prx_keys_16.ts
  var keys260_0 = new Uint8Array([195, 36, 137, 211, 128, 135, 178, 78, 76, 215, 73, 228, 157, 29, 52, 209]);
  var keys260_1 = new Uint8Array([243, 172, 110, 124, 4, 10, 35, 231, 13, 51, 216, 36, 115, 57, 43, 74]);
  var keys260_2 = new Uint8Array([114, 180, 57, 255, 52, 155, 174, 130, 48, 52, 74, 29, 162, 216, 180, 60]);
  var keys280_0 = new Uint8Array([202, 251, 191, 199, 80, 234, 180, 64, 142, 68, 92, 99, 83, 206, 128, 177]);
  var keys280_1 = new Uint8Array([64, 155, 198, 155, 169, 251, 132, 127, 114, 33, 210, 54, 150, 85, 9, 116]);
  var keys280_2 = new Uint8Array([3, 167, 204, 74, 91, 145, 194, 7, 255, 252, 38, 37, 30, 66, 75, 181]);
  var keys300_0 = new Uint8Array([159, 103, 26, 122, 34, 243, 89, 11, 170, 109, 164, 198, 139, 208, 3, 119]);
  var keys300_1 = new Uint8Array([21, 7, 99, 38, 219, 226, 105, 52, 86, 8, 42, 147, 78, 75, 138, 178]);
  var keys300_2 = new Uint8Array([86, 59, 105, 247, 41, 136, 47, 76, 219, 213, 222, 128, 198, 92, 200, 115]);
  var keys303_0 = new Uint8Array([123, 161, 226, 90, 145, 185, 211, 19, 119, 101, 74, 183, 194, 138, 16, 175]);
  var keys310_0 = new Uint8Array([162, 65, 232, 57, 102, 91, 250, 187, 27, 45, 110, 14, 51, 229, 215, 63]);
  var keys310_1 = new Uint8Array([164, 96, 143, 171, 171, 222, 165, 101, 93, 67, 58, 209, 94, 195, 255, 234]);
  var keys310_2 = new Uint8Array([231, 92, 133, 122, 89, 180, 227, 29, 208, 158, 206, 194, 214, 212, 189, 43]);
  var keys310_3 = new Uint8Array([46, 0, 246, 247, 82, 207, 149, 90, 161, 38, 180, 132, 155, 88, 118, 47]);
  var keys330_0 = new Uint8Array([59, 155, 26, 86, 33, 128, 20, 237, 142, 139, 8, 66, 250, 44, 220, 58]);
  var keys330_1 = new Uint8Array([232, 190, 47, 6, 177, 5, 42, 185, 24, 24, 3, 227, 235, 100, 125, 38]);
  var keys330_2 = new Uint8Array([171, 130, 37, 215, 67, 111, 108, 193, 149, 197, 247, 240, 99, 115, 63, 231]);
  var keys330_3 = new Uint8Array([168, 177, 71, 119, 220, 73, 106, 111, 56, 76, 77, 150, 189, 73, 236, 155]);
  var keys330_4 = new Uint8Array([236, 59, 210, 192, 250, 193, 238, 185, 154, 188, 255, 163, 137, 242, 96, 31]);
  var demokeys_280 = new Uint8Array([18, 153, 112, 94, 36, 7, 108, 208, 45, 6, 254, 126, 179, 12, 17, 38]);
  var demokeys_3XX_1 = new Uint8Array([71, 5, 213, 227, 86, 30, 129, 155, 9, 47, 6, 219, 107, 18, 146, 224]);
  var demokeys_3XX_2 = new Uint8Array([246, 98, 57, 110, 38, 34, 77, 202, 2, 100, 22, 153, 123, 154, 231, 184]);
  var ebootbin_271_new = new Uint8Array([244, 174, 244, 225, 134, 221, 210, 156, 124, 197, 66, 166, 149, 160, 131, 136]);
  var ebootbin_280_new = new Uint8Array([184, 140, 69, 139, 182, 231, 110, 184, 81, 89, 166, 83, 124, 94, 134, 49]);
  var ebootbin_300_new = new Uint8Array([237, 16, 224, 54, 196, 254, 131, 243, 117, 112, 94, 246, 164, 64, 5, 247]);
  var ebootbin_310_new = new Uint8Array([92, 119, 12, 187, 180, 194, 79, 162, 126, 59, 78, 180, 180, 200, 112, 175]);
  var gameshare_260_271 = new Uint8Array([249, 72, 56, 12, 150, 136, 167, 116, 79, 101, 160, 84, 194, 118, 217, 184]);
  var gameshare_280 = new Uint8Array([45, 134, 119, 58, 86, 164, 79, 221, 60, 22, 113, 147, 170, 142, 17, 67]);
  var gameshare_300 = new Uint8Array([120, 26, 210, 135, 36, 189, 162, 150, 24, 63, 137, 54, 114, 144, 146, 133]);
  var gameshare_310 = new Uint8Array([201, 125, 62, 10, 84, 129, 110, 199, 19, 116, 153, 116, 98, 24, 231, 221]);
  var keys360_0 = new Uint8Array([60, 43, 81, 212, 45, 133, 71, 218, 45, 202, 24, 223, 254, 84, 9, 237]);
  var keys360_1 = new Uint8Array([49, 31, 152, 213, 123, 88, 149, 69, 50, 171, 58, 227, 137, 50, 75, 52]);
  var keys370_0 = new Uint8Array([38, 56, 10, 172, 165, 216, 116, 209, 50, 183, 42, 191, 121, 158, 109, 219]);
  var keys370_1 = new Uint8Array([83, 231, 171, 185, 198, 74, 75, 119, 146, 23, 181, 116, 10, 218, 169, 234]);
  var keys370_2 = new Uint8Array([113, 16, 240, 164, 22, 20, 213, 147, 18, 255, 116, 150, 223, 31, 218, 137]);
  var oneseg_310 = new Uint8Array([199, 39, 114, 133, 171, 167, 247, 240, 76, 193, 134, 204, 227, 127, 23, 202]);
  var oneseg_300 = new Uint8Array([118, 64, 158, 8, 219, 155, 59, 161, 71, 138, 150, 142, 243, 247, 98, 146]);
  var oneseg_280 = new Uint8Array([35, 220, 59, 181, 169, 130, 214, 234, 99, 163, 110, 43, 43, 233, 225, 84]);
  var oneseg_260_271 = new Uint8Array([34, 67, 87, 104, 47, 65, 206, 101, 76, 163, 124, 198, 196, 172, 243, 96]);
  var oneseg_slim = new Uint8Array([18, 87, 13, 138, 22, 109, 135, 6, 3, 125, 200, 139, 98, 163, 50, 169]);
  var ms_app_main = new Uint8Array([30, 46, 56, 73, 218, 212, 22, 8, 39, 46, 243, 188, 55, 117, 128, 147]);
  var keys390_0 = new Uint8Array([69, 239, 92, 93, 237, 129, 153, 132, 18, 148, 143, 171, 232, 5, 109, 125]);
  var keys390_1 = new Uint8Array([112, 27, 8, 37, 34, 161, 77, 59, 105, 33, 249, 113, 10, 168, 65, 169]);
  var keys500_0 = new Uint8Array([235, 27, 83, 11, 98, 73, 50, 88, 31, 131, 10, 244, 153, 61, 117, 208]);
  var keys500_1 = new Uint8Array([186, 226, 163, 18, 7, 255, 4, 27, 100, 165, 17, 133, 247, 47, 153, 91]);
  var keys500_2 = new Uint8Array([44, 142, 175, 29, 255, 121, 115, 26, 173, 150, 171, 9, 234, 53, 89, 139]);
  var keys500_c = new Uint8Array([163, 93, 81, 230, 86, 200, 1, 202, 227, 119, 191, 205, 255, 36, 218, 77]);
  var keys505_a = new Uint8Array([123, 148, 114, 39, 76, 204, 84, 59, 174, 223, 70, 55, 172, 1, 77, 135]);
  var keys505_0 = new Uint8Array([46, 142, 151, 162, 133, 66, 112, 115, 24, 218, 160, 138, 248, 98, 162, 176]);
  var keys505_1 = new Uint8Array([88, 42, 76, 105, 25, 123, 131, 61, 210, 97, 97, 254, 20, 238, 170, 17]);
  var keys02G_E = new Uint8Array([157, 9, 253, 32, 243, 143, 16, 105, 13, 178, 111, 0, 204, 197, 81, 46]);
  var keys03G_E = new Uint8Array([79, 68, 92, 98, 179, 83, 196, 48, 252, 58, 164, 91, 236, 254, 81, 234]);
  var key_D91609F0 = new Uint8Array([208, 54, 18, 117, 128, 86, 32, 67, 196, 48, 148, 62, 28, 117, 209, 191]);
  var key_D9160AF0 = new Uint8Array([16, 169, 172, 22, 174, 25, 192, 126, 59, 96, 119, 134, 1, 111, 242, 99]);
  var key_D9160BF0 = new Uint8Array([131, 131, 241, 55, 83, 208, 190, 252, 141, 167, 50, 82, 70, 10, 194, 194]);
  var key_D91611F0 = new Uint8Array([97, 176, 192, 88, 113, 87, 217, 250, 116, 103, 14, 92, 126, 110, 149, 185]);
  var key_D91612F0 = new Uint8Array([158, 32, 225, 205, 215, 136, 222, 192, 49, 155, 16, 175, 197, 184, 115, 35]);
  var key_D91613F0 = new Uint8Array([235, 255, 64, 216, 180, 26, 225, 102, 145, 59, 143, 100, 182, 252, 183, 18]);
  var key_2E5E10F0 = new Uint8Array([157, 92, 91, 175, 140, 216, 105, 126, 81, 159, 112, 150, 230, 213, 196, 232]);
  var key_2E5E12F0 = new Uint8Array([138, 123, 201, 214, 82, 88, 136, 234, 81, 131, 96, 202, 22, 121, 226, 7]);
  var key_2E5E13F0 = new Uint8Array([255, 164, 104, 195, 49, 202, 183, 76, 241, 35, 255, 1, 101, 61, 38, 54]);
  var keys600_u1_457B0BF0 = new Uint8Array([123, 148, 114, 39, 76, 204, 84, 59, 174, 223, 70, 55, 172, 1, 77, 135]);
  var keys600_u1_457B0CF0 = new Uint8Array([172, 52, 186, 177, 151, 141, 174, 111, 186, 232, 177, 214, 223, 223, 241, 162]);
  var keys05G_E = new Uint8Array([93, 170, 114, 242, 38, 96, 77, 28, 231, 45, 200, 163, 47, 121, 197, 84]);
  var keys570_5k = new Uint8Array([109, 114, 164, 186, 127, 191, 209, 241, 169, 243, 187, 7, 27, 192, 179, 102]);
  var keys620_0 = new Uint8Array([214, 189, 206, 30, 18, 175, 154, 230, 105, 48, 222, 218, 136, 184, 255, 251]);
  var keys620_1 = new Uint8Array([29, 19, 233, 80, 4, 115, 61, 210, 225, 218, 185, 193, 230, 123, 37, 167]);
  var keys620_3 = new Uint8Array([163, 93, 81, 230, 86, 200, 1, 202, 227, 119, 191, 205, 255, 36, 218, 77]);
  var keys620_e = new Uint8Array([177, 179, 127, 118, 195, 251, 136, 230, 248, 96, 211, 53, 60, 163, 78, 243]);
  var keys620_5 = new Uint8Array([241, 188, 23, 7, 174, 183, 200, 48, 216, 52, 157, 64, 106, 142, 223, 78]);
  var keys620_5k = new Uint8Array([65, 138, 53, 79, 105, 58, 223, 4, 253, 57, 70, 162, 92, 45, 242, 33]);
  var keys620_5v = new Uint8Array([242, 143, 117, 167, 49, 145, 206, 158, 117, 189, 39, 38, 180, 180, 12, 50]);

  // src/hle/elf_crypted_prx.ts
  var Header2 = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.modAttr = 0;
      this.compModAttr = 0;
      this.modVerLo = 0;
      this.modVerHi = 0;
      this.moduleName = "";
      this.modVersion = 0;
      this.nsegments = 0;
      this.elfSize = 0;
      this.pspSize = 0;
      this.bootEntry = 0;
      this.modInfoOffset = 0;
      this.bssSize = 0;
      this.segAlign = [];
      this.segAddress = [];
      this.segSize = [];
      this.reserved = [];
      this.devkitVersion = 0;
      this.decMode = 0;
      this.pad = 0;
      this.overlapSize = 0;
      this.aesKey = [];
      this.cmacKey = [];
      this.cmacHeaderHash = [];
      this.compressedSize = 0;
      this.compressedOffset = 0;
      this.unk1 = 0;
      this.unk2 = 0;
      this.cmacDataHash = [];
      this.tag = 0;
      this.sigcheck = [];
      this.sha1Hash = [];
      this.keyData = [];
    }
  };
  __decorate([
    StructUInt32
  ], Header2.prototype, "magic", 2);
  __decorate([
    StructUInt16
  ], Header2.prototype, "modAttr", 2);
  __decorate([
    StructUInt16
  ], Header2.prototype, "compModAttr", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "modVerLo", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "modVerHi", 2);
  __decorate([
    StructStructStringz(28)
  ], Header2.prototype, "moduleName", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "modVersion", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "nsegments", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "elfSize", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "pspSize", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "bootEntry", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "modInfoOffset", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "bssSize", 2);
  __decorate([
    StructStructArray(UInt16, 4)
  ], Header2.prototype, "segAlign", 2);
  __decorate([
    StructStructArray(UInt32, 4)
  ], Header2.prototype, "segAddress", 2);
  __decorate([
    StructStructArray(UInt32, 4)
  ], Header2.prototype, "segSize", 2);
  __decorate([
    StructStructArray(UInt32, 5)
  ], Header2.prototype, "reserved", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "devkitVersion", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "decMode", 2);
  __decorate([
    StructUInt8
  ], Header2.prototype, "pad", 2);
  __decorate([
    StructUInt16
  ], Header2.prototype, "overlapSize", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], Header2.prototype, "aesKey", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], Header2.prototype, "cmacKey", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], Header2.prototype, "cmacHeaderHash", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "compressedSize", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "compressedOffset", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "unk1", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "unk2", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], Header2.prototype, "cmacDataHash", 2);
  __decorate([
    StructUInt32
  ], Header2.prototype, "tag", 2);
  __decorate([
    StructStructArray(UInt8, 88)
  ], Header2.prototype, "sigcheck", 2);
  __decorate([
    StructStructArray(UInt8, 20)
  ], Header2.prototype, "sha1Hash", 2);
  __decorate([
    StructStructArray(UInt8, 16)
  ], Header2.prototype, "keyData", 2);
  function getTagInfo(checkTag) {
    return g_tagInfo.first((item) => item.tag == checkTag);
  }
  function decrypt1(pbIn) {
    const cbTotal = pbIn.length;
    const _pbOut = new Uint8Array(cbTotal);
    const pbOut = Stream.fromUint8Array(_pbOut);
    pbOut.slice().writeStream(pbIn);
    const header = Header2.struct.read(pbIn.slice());
    const pti = getTagInfo(header.tag);
    if (!pti)
      throw new Error("Can't find tag " + header.tag);
    pbOut.slice().writeStream(pbIn);
    pbOut.slice().writeByteRepeated(0, 336);
    pbOut.slice().writeByteRepeated(85, 64);
    const h7_header = new KIRK_AES128CBC_HEADER();
    h7_header.mode = KirkMode.DecryptCbc;
    h7_header.unk_4 = 0;
    h7_header.unk_8 = 0;
    h7_header.keyseed = pti.code;
    h7_header.data_size = 112;
    GetStruct(KIRK_AES128CBC_HEADER).write(pbOut.sliceFrom(44), h7_header);
    const buffer1 = Stream.fromSize(336);
    buffer1.sliceWithLength(0).writeStream(pbIn.sliceWithLength(208, 128));
    buffer1.sliceWithLength(128).writeStream(pbIn.sliceWithLength(128, 80));
    buffer1.sliceWithLength(208).writeStream(pbIn.sliceWithLength(0, 128));
    if (pti.codeExtra != 0) {
      const buffer2 = Stream.fromSize(20 + 160);
      buffer2.slice().writeUInt32(5).writeUInt32(0).writeUInt32(0).writeUInt32(pti.codeExtra).writeUInt32(160).writeStream(buffer1.sliceWithLength(16, 160));
      hleUtilsBufferCopyWithRange(buffer2.sliceWithLength(0, 20 + 160), buffer2.sliceWithLength(0, 20 + 160), CommandEnum.DECRYPT_IV_0);
      buffer1.slice().writeStream(buffer2.sliceWithLength(0, 160));
    }
    pbOut.sliceFrom(64).writeStream(buffer1.sliceWithLength(64, 64));
    for (let iXOR = 0; iXOR < 112; iXOR++)
      pbOut.set(64 + iXOR, (pbOut.get(64 + iXOR) ^ pti.key[20 + iXOR]) & 255);
    hleUtilsBufferCopyWithRange(pbOut.sliceWithLength(44, 20 + 112), pbOut.sliceWithLength(44, 20 + 112), CommandEnum.DECRYPT_IV_0);
    for (let iXOR = 111; iXOR >= 0; iXOR--)
      pbOut.set(64 + iXOR, (pbOut.get(44 + iXOR) ^ pti.key[32 + iXOR]) & 255);
    pbOut.sliceFrom(128).writeByteRepeated(0, 48);
    pbOut.set(160, 1);
    pbOut.sliceFrom(176).writeStream(pbIn.sliceWithLength(176, 32));
    pbOut.sliceFrom(208).writeStream(pbIn.sliceWithLength(0, 128));
    hleUtilsBufferCopyWithRange(pbOut.sliceWithLength(0, cbTotal), pbOut.sliceWithLength(64, cbTotal - 64), CommandEnum.DECRYPT_PRIVATE);
    const outputSize = pbIn.sliceFrom(176).readUInt32();
    return pbOut.sliceWithLength(0, outputSize);
  }
  function decrypt(input) {
    return decrypt1(input.slice());
  }

  // src/format/zip.ts
  var ZipEntry = class {
    constructor(zip, name2, parent) {
      this.zip = zip;
      this.name = name2;
      this.parent = parent;
      this.children = {};
      this.isDirectory = false;
      this.normalizedName = ZipEntry.normalizeString(name2);
    }
    get size() {
      return this.uncompressedSize;
    }
    getChildList() {
      const list = [];
      for (const key in this.children)
        list.push(this.children[key]);
      return list;
    }
    get date() {
      const dosDate = this.zipDirEntry.dosDate;
      const dosTime = this.zipDirEntry.dosTime;
      const seconds = BitUtils.extract(dosTime, 0, 5) * 2;
      const minutes = BitUtils.extract(dosTime, 5, 6);
      const hours = BitUtils.extract(dosTime, 11, 6);
      const day = BitUtils.extract(dosDate, 0, 5);
      const month = BitUtils.extract(dosDate, 5, 4);
      const year = BitUtils.extract(dosDate, 9, 7) + 1980;
      return new Date(year, month - 1, day, hours, minutes, seconds);
    }
    get compressedSize() {
      return this.zipDirEntry.compressedSize;
    }
    get uncompressedSize() {
      return this.zipDirEntry.uncompressedSize;
    }
    get compressionType() {
      return this.zipDirEntry.compType;
    }
    static normalizeString(string) {
      return string.toUpperCase();
    }
    readRawCompressedAsync() {
      if (this.compressedData)
        return PromiseFast.resolve(this.compressedData);
      return this.zip.zipStream.readChunkAsync(this.zipDirEntry.headerOffset, this.zipDirEntry.compressedSize + 1024).thenFast((data) => {
        const stream = Stream.fromArrayBuffer(data);
        const zipFileRecord = ZipFileRecord.struct.read(stream);
        return this.compressedData = stream.readBytes(zipFileRecord.compressedSize);
      });
    }
    readChunkAsync(offset, length) {
      return this.readAsync().thenFast((data) => {
        return ArrayBufferUtils.fromUInt8Array(data.subarray(offset, offset + length));
      });
    }
    readAsync() {
      if (this.uncompressedData)
        return PromiseFast.resolve(this.uncompressedData);
      return this.readRawCompressedAsync().thenFast((data) => {
        switch (this.compressionType) {
          case ZipCompressionType.DEFLATE:
            return zlib_inflate_raw(data);
          case ZipCompressionType.STORED:
            return data;
          default:
            throw new Error("Unsupported compression type '" + this.compressionType + "'");
        }
      }).thenFast((data) => {
        return this.uncompressedData = data;
      });
    }
    access(path, create2 = false, fullPath = path) {
      if (path == "")
        return this;
      if (path == ".")
        return this;
      if (path == "..")
        return this.parent || this;
      const pathIndex = path.indexOf("/");
      if (pathIndex < 0) {
        const normalizedName = ZipEntry.normalizeString(path);
        let child = this.children[normalizedName];
        if (!child) {
          if (!create2) {
            throw new Error("ZIP: Can't access to path '" + fullPath + "'");
          } else {
            child = this.children[normalizedName] = new ZipEntry(this.zip, path, this);
          }
        }
        return child;
      } else {
        return this.access(path.substr(0, pathIndex), create2, fullPath).access(path.substr(pathIndex + 1), create2, fullPath);
      }
    }
  };
  var Zip = class {
    constructor(zipStream, zipDirEntries) {
      this.zipStream = zipStream;
      this.zipDirEntries = zipDirEntries;
      this.root = new ZipEntry(this, "", null);
      zipDirEntries.forEach((zipDirEntry) => {
        const item = this.root.access(zipDirEntry.fileName, true);
        item.isDirectory = zipDirEntry.fileName.substr(-1, 1) == "/";
        item.zipDirEntry = zipDirEntry;
      });
    }
    get(path) {
      return this.root.access(path);
    }
    has(path) {
      try {
        this.root.access(path);
        return true;
      } catch (e) {
        return false;
      }
    }
    static async fromStreamAsync(zipStream) {
      const data = await zipStream.readChunkAsync(zipStream.size - ZipEndLocator.struct.length, ZipEndLocator.struct.length);
      const zipEndLocator = ZipEndLocator.struct.read(Stream.fromArrayBuffer(data));
      const data2 = await zipStream.readChunkAsync(zipEndLocator.directoryOffset, zipEndLocator.directorySize);
      const dirEntries = StructArray(ZipDirEntry.struct, zipEndLocator.entriesInDirectory).read(Stream.fromArrayBuffer(data2));
      return new Zip(zipStream, dirEntries);
    }
  };
  var ZipCompressionType;
  (function(ZipCompressionType2) {
    ZipCompressionType2[ZipCompressionType2["STORED"] = 0] = "STORED";
    ZipCompressionType2[ZipCompressionType2["SHRUNK"] = 1] = "SHRUNK";
    ZipCompressionType2[ZipCompressionType2["REDUCED1"] = 2] = "REDUCED1";
    ZipCompressionType2[ZipCompressionType2["REDUCED2"] = 3] = "REDUCED2";
    ZipCompressionType2[ZipCompressionType2["REDUCED3"] = 4] = "REDUCED3";
    ZipCompressionType2[ZipCompressionType2["REDUCED4"] = 5] = "REDUCED4";
    ZipCompressionType2[ZipCompressionType2["IMPLODED"] = 6] = "IMPLODED";
    ZipCompressionType2[ZipCompressionType2["TOKEN"] = 7] = "TOKEN";
    ZipCompressionType2[ZipCompressionType2["DEFLATE"] = 8] = "DEFLATE";
    ZipCompressionType2[ZipCompressionType2["DEFLATE64"] = 9] = "DEFLATE64";
  })(ZipCompressionType || (ZipCompressionType = {}));
  var ZipEndLocator = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.currentDiskNumber = 0;
      this.startDiskNumber = 0;
      this.entriesOnDisk = 0;
      this.entriesInDirectory = 0;
      this.directorySize = 0;
      this.directoryOffset = 0;
      this.commentLength = 0;
    }
  };
  __decorate([
    StructUInt32
  ], ZipEndLocator.prototype, "magic", 2);
  __decorate([
    StructUInt16
  ], ZipEndLocator.prototype, "currentDiskNumber", 2);
  __decorate([
    StructUInt16
  ], ZipEndLocator.prototype, "startDiskNumber", 2);
  __decorate([
    StructUInt16
  ], ZipEndLocator.prototype, "entriesOnDisk", 2);
  __decorate([
    StructUInt16
  ], ZipEndLocator.prototype, "entriesInDirectory", 2);
  __decorate([
    StructUInt32
  ], ZipEndLocator.prototype, "directorySize", 2);
  __decorate([
    StructUInt32
  ], ZipEndLocator.prototype, "directoryOffset", 2);
  __decorate([
    StructUInt16
  ], ZipEndLocator.prototype, "commentLength", 2);
  var ZipFileRecord = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.version = 0;
      this.flags = 0;
      this.compType = 0;
      this.dosTime = 0;
      this.dosDate = 0;
      this.crc32 = 0;
      this.compressedSize = 0;
      this.uncompressedSize = 0;
      this.fileNameLength = 0;
      this.extraFieldLength = 0;
      this.fileName = "";
      this.extraField = "";
    }
  };
  __decorate([
    StructUInt32
  ], ZipFileRecord.prototype, "magic", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "version", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "flags", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "compType", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "dosTime", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "dosDate", 2);
  __decorate([
    StructUInt32
  ], ZipFileRecord.prototype, "crc32", 2);
  __decorate([
    StructUInt32
  ], ZipFileRecord.prototype, "compressedSize", 2);
  __decorate([
    StructUInt32
  ], ZipFileRecord.prototype, "uncompressedSize", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "fileNameLength", 2);
  __decorate([
    StructUInt16
  ], ZipFileRecord.prototype, "extraFieldLength", 2);
  __decorate([
    StructMember(StringWithSize((context) => context.fileNameLength))
  ], ZipFileRecord.prototype, "fileName", 2);
  __decorate([
    StructMember(StringWithSize((context) => context.extraFieldLength))
  ], ZipFileRecord.prototype, "extraField", 2);
  var ZipDirEntry = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = 0;
      this.versionMadeBy = 0;
      this.versionToExtract = 0;
      this.flags = 0;
      this.compType = 0;
      this.dosTime = 0;
      this.dosDate = 0;
      this.crc32 = 0;
      this.compressedSize = 0;
      this.uncompressedSize = 0;
      this.fileNameLength = 0;
      this.extraFieldLength = 0;
      this.fileCommentsLength = 0;
      this.diskNumberStart = 0;
      this.internalAttributes = 0;
      this.externalAttributes = 0;
      this.headerOffset = 0;
      this.fileName = "";
      this.extraField = "";
      this.fileComments = "";
    }
  };
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "magic", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "versionMadeBy", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "versionToExtract", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "flags", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "compType", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "dosTime", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "dosDate", 2);
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "crc32", 2);
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "compressedSize", 2);
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "uncompressedSize", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "fileNameLength", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "extraFieldLength", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "fileCommentsLength", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "diskNumberStart", 2);
  __decorate([
    StructUInt16
  ], ZipDirEntry.prototype, "internalAttributes", 2);
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "externalAttributes", 2);
  __decorate([
    StructUInt32
  ], ZipDirEntry.prototype, "headerOffset", 2);
  __decorate([
    StructMember(StringWithSize((context) => context.fileNameLength))
  ], ZipDirEntry.prototype, "fileName", 2);
  __decorate([
    StructMember(StringWithSize((context) => context.extraFieldLength))
  ], ZipDirEntry.prototype, "extraField", 2);
  __decorate([
    StructMember(StringWithSize((context) => context.fileCommentsLength))
  ], ZipDirEntry.prototype, "fileComments", 2);

  // src/format/iso.ts
  var SECTOR_SIZE = 2048;
  var DirectoryRecordDate = class extends Struct {
    constructor() {
      super(...arguments);
      this.year = 2004;
      this.month = 1;
      this.day = 1;
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
      this.offset = 0;
    }
    get date() {
      return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);
    }
  };
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "year", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "month", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "day", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "hour", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "minute", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "second", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecordDate.prototype, "offset", 2);
  var IsoStringDate = class extends Struct {
    constructor() {
      super(...arguments);
      this.data = "";
    }
    get year() {
      return parseInt(this.data.substr(0, 4));
    }
    get month() {
      return parseInt(this.data.substr(4, 2));
    }
    get day() {
      return parseInt(this.data.substr(6, 2));
    }
    get hour() {
      return parseInt(this.data.substr(8, 2));
    }
    get minute() {
      return parseInt(this.data.substr(10, 2));
    }
    get second() {
      return parseInt(this.data.substr(12, 2));
    }
    get hsecond() {
      return parseInt(this.data.substr(14, 2));
    }
    get offset() {
      return parseInt(this.data.substr(16, 1));
    }
  };
  __decorate([
    StructStructStringz(17)
  ], IsoStringDate.prototype, "data", 2);
  var VolumeDescriptorHeaderType;
  (function(VolumeDescriptorHeaderType2) {
    VolumeDescriptorHeaderType2[VolumeDescriptorHeaderType2["BootRecord"] = 0] = "BootRecord";
    VolumeDescriptorHeaderType2[VolumeDescriptorHeaderType2["VolumePartitionSetTerminator"] = 255] = "VolumePartitionSetTerminator";
    VolumeDescriptorHeaderType2[VolumeDescriptorHeaderType2["PrimaryVolumeDescriptor"] = 1] = "PrimaryVolumeDescriptor";
    VolumeDescriptorHeaderType2[VolumeDescriptorHeaderType2["SupplementaryVolumeDescriptor"] = 2] = "SupplementaryVolumeDescriptor";
    VolumeDescriptorHeaderType2[VolumeDescriptorHeaderType2["VolumePartitionDescriptor"] = 3] = "VolumePartitionDescriptor";
  })(VolumeDescriptorHeaderType || (VolumeDescriptorHeaderType = {}));
  var VolumeDescriptorHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.type = 0;
      this.id = "";
      this.version = 0;
    }
  };
  __decorate([
    StructUInt8
  ], VolumeDescriptorHeader.prototype, "type", 2);
  __decorate([
    StructStructStringz(5)
  ], VolumeDescriptorHeader.prototype, "id", 2);
  __decorate([
    StructUInt8
  ], VolumeDescriptorHeader.prototype, "version", 2);
  var DirectoryRecordFlags;
  (function(DirectoryRecordFlags2) {
    DirectoryRecordFlags2[DirectoryRecordFlags2["Unknown1"] = 1] = "Unknown1";
    DirectoryRecordFlags2[DirectoryRecordFlags2["Directory"] = 2] = "Directory";
    DirectoryRecordFlags2[DirectoryRecordFlags2["Unknown2"] = 4] = "Unknown2";
    DirectoryRecordFlags2[DirectoryRecordFlags2["Unknown3"] = 8] = "Unknown3";
    DirectoryRecordFlags2[DirectoryRecordFlags2["Unknown4"] = 16] = "Unknown4";
    DirectoryRecordFlags2[DirectoryRecordFlags2["Unknown5"] = 32] = "Unknown5";
  })(DirectoryRecordFlags || (DirectoryRecordFlags = {}));
  var DirectoryRecord = class extends Struct {
    constructor() {
      super(...arguments);
      this.length = 0;
      this.extendedAttributeLength = 0;
      this.extent = 0;
      this.size = 0;
      this.date = new DirectoryRecordDate();
      this.flags = 2;
      this.fileUnitSize = 0;
      this.interleave = 0;
      this.volumeSequenceNumber = 0;
      this.nameLength = 0;
      this.name = "";
    }
    get offset() {
      return this.extent * SECTOR_SIZE;
    }
    get isDirectory() {
      return (this.flags & 2) != 0;
    }
  };
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "length", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "extendedAttributeLength", 2);
  __decorate([
    StructUInt32_2lb
  ], DirectoryRecord.prototype, "extent", 2);
  __decorate([
    StructUInt32_2lb
  ], DirectoryRecord.prototype, "size", 2);
  __decorate([
    StructMember(DirectoryRecordDate.struct)
  ], DirectoryRecord.prototype, "date", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "flags", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "fileUnitSize", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "interleave", 2);
  __decorate([
    StructUInt16_2lb
  ], DirectoryRecord.prototype, "volumeSequenceNumber", 2);
  __decorate([
    StructUInt8
  ], DirectoryRecord.prototype, "nameLength", 2);
  var PrimaryVolumeDescriptor = class extends Struct {
    constructor() {
      super(...arguments);
      this._pad1 = 0;
      this.systemId = "";
      this.volumeId = "";
      this._pad2 = 0;
      this.volumeSpaceSize = 0;
      this._pad3 = null;
      this.volumeSetSize = 0;
      this.volumeSequenceNumber = 0;
      this.logicalBlockSize = 0;
      this.pathTableSize = 0;
      this.typeLPathTable = 0;
      this.optType1PathTable = 0;
      this.typeMPathTable = 0;
      this.optTypeMPathTable = 0;
      this._pad4 = 0;
      this.volumeSetId = "";
      this.publisherId = "";
      this.preparerId = "";
      this.applicationId = "";
      this.copyrightFileId = "";
      this.abstractFileId = "";
      this.bibliographicFileId = "";
      this.fileStructureVersion = 0;
      this.pad5 = 0;
      this.pad6 = 0;
      this.pad7 = [];
      this.applicationData = [];
    }
  };
  __decorate([
    StructMember(VolumeDescriptorHeader.struct)
  ], PrimaryVolumeDescriptor.prototype, "header", 2);
  __decorate([
    StructUInt8
  ], PrimaryVolumeDescriptor.prototype, "_pad1", 2);
  __decorate([
    StructStructStringz(32)
  ], PrimaryVolumeDescriptor.prototype, "systemId", 2);
  __decorate([
    StructStructStringz(32)
  ], PrimaryVolumeDescriptor.prototype, "volumeId", 2);
  __decorate([
    StructMember(Int64)
  ], PrimaryVolumeDescriptor.prototype, "_pad2", 2);
  __decorate([
    StructUInt32_2lb
  ], PrimaryVolumeDescriptor.prototype, "volumeSpaceSize", 2);
  __decorate([
    StructMember(StructArray(Int64, 4))
  ], PrimaryVolumeDescriptor.prototype, "_pad3", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "volumeSetSize", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "volumeSequenceNumber", 2);
  __decorate([
    StructUInt16_2lb
  ], PrimaryVolumeDescriptor.prototype, "logicalBlockSize", 2);
  __decorate([
    StructUInt32_2lb
  ], PrimaryVolumeDescriptor.prototype, "pathTableSize", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "typeLPathTable", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "optType1PathTable", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "typeMPathTable", 2);
  __decorate([
    StructUInt32
  ], PrimaryVolumeDescriptor.prototype, "optTypeMPathTable", 2);
  __decorate([
    StructMember(DirectoryRecord.struct)
  ], PrimaryVolumeDescriptor.prototype, "directoryRecord", 2);
  __decorate([
    StructUInt8
  ], PrimaryVolumeDescriptor.prototype, "_pad4", 2);
  __decorate([
    StructStructStringz(128)
  ], PrimaryVolumeDescriptor.prototype, "volumeSetId", 2);
  __decorate([
    StructStructStringz(128)
  ], PrimaryVolumeDescriptor.prototype, "publisherId", 2);
  __decorate([
    StructStructStringz(128)
  ], PrimaryVolumeDescriptor.prototype, "preparerId", 2);
  __decorate([
    StructStructStringz(128)
  ], PrimaryVolumeDescriptor.prototype, "applicationId", 2);
  __decorate([
    StructStructStringz(37)
  ], PrimaryVolumeDescriptor.prototype, "copyrightFileId", 2);
  __decorate([
    StructStructStringz(37)
  ], PrimaryVolumeDescriptor.prototype, "abstractFileId", 2);
  __decorate([
    StructStructStringz(37)
  ], PrimaryVolumeDescriptor.prototype, "bibliographicFileId", 2);
  __decorate([
    StructMember(IsoStringDate.struct)
  ], PrimaryVolumeDescriptor.prototype, "creationDate", 2);
  __decorate([
    StructMember(IsoStringDate.struct)
  ], PrimaryVolumeDescriptor.prototype, "modificationDate", 2);
  __decorate([
    StructMember(IsoStringDate.struct)
  ], PrimaryVolumeDescriptor.prototype, "expirationDate", 2);
  __decorate([
    StructMember(IsoStringDate.struct)
  ], PrimaryVolumeDescriptor.prototype, "effectiveDate", 2);
  __decorate([
    StructUInt8
  ], PrimaryVolumeDescriptor.prototype, "fileStructureVersion", 2);
  __decorate([
    StructUInt8
  ], PrimaryVolumeDescriptor.prototype, "pad5", 2);
  __decorate([
    StructStructArray(UInt8, 512)
  ], PrimaryVolumeDescriptor.prototype, "pad6", 2);
  __decorate([
    StructStructArray(UInt8, 653)
  ], PrimaryVolumeDescriptor.prototype, "pad7", 2);
  var IsoNode = class {
    constructor(iso, directoryRecord, parent = null) {
      this.iso = iso;
      this.directoryRecord = directoryRecord;
      this.parent = parent;
      this.childs = [];
      this.childsByName = {};
    }
    get isRoot() {
      return this.parent == null;
    }
    get size() {
      return this.directoryRecord.size;
    }
    get path() {
      return this.parent && !this.parent.isRoot ? `${this.parent.path}/${this.name}` : this.name;
    }
    get name() {
      return this.directoryRecord.name;
    }
    get isDirectory() {
      return this.directoryRecord.isDirectory;
    }
    get date() {
      return this.directoryRecord.date.date;
    }
    get extent() {
      return this.directoryRecord.extent;
    }
    readChunkAsync(offset, count) {
      const fileBaseLow = this.directoryRecord.offset;
      const low = fileBaseLow + offset;
      const high = Math.min(low + count, fileBaseLow + this.size);
      return this.iso.readChunkAsync(low, high - low);
    }
    addChild(child) {
      this.childs.push(child);
      this.childsByName[child.name] = child;
    }
    toString() {
      return `IsoNode(${this.path}, ${this.size})`;
    }
  };
  var Iso = class extends BaseAsyncStream {
    constructor() {
      super(...arguments);
      this.date = new Date();
    }
    get name() {
      return this.asyncStream.name;
    }
    get root() {
      return this._root;
    }
    get childrenByPath() {
      return this._childrenByPath;
    }
    get children() {
      return this._children.slice(0);
    }
    static fromStreamAsync(asyncStream) {
      return new Iso().loadAsync(asyncStream);
    }
    get(path) {
      path = path.replace(/^\/+/, "");
      const sce_file = path.match(/^sce_lbn(0x[0-9a-f]+|\d+)_size(0x[0-9a-f]+|\d+)$/i);
      if (sce_file) {
        const lba = parseIntFormat(sce_file[1]);
        const size = parseIntFormat(sce_file[2]);
        const dr = new DirectoryRecord();
        dr.extent = lba;
        dr.size = size;
        dr.name = "";
        return new IsoNode(this, dr, null);
      }
      if (path == "")
        return this.root;
      const node = this._childrenByPath[path];
      if (!node) {
        throw new Error(`Can't find node '${path}'`);
      }
      return node;
    }
    get size() {
      return this.asyncStream.size;
    }
    readChunkPromiseAsync(offset, count) {
      return this.asyncStream.readChunkPromiseAsync(offset, count);
    }
    async loadAsync(asyncStream) {
      this.asyncStream = asyncStream;
      this.date = asyncStream.date;
      if (PrimaryVolumeDescriptor.struct.length != SECTOR_SIZE)
        throw `Invalid PrimaryVolumeDescriptor.struct size ${PrimaryVolumeDescriptor.struct.length} != ${SECTOR_SIZE}`;
      const arrayBuffer = await asyncStream.readChunkAsync(SECTOR_SIZE * 16, 2048);
      const stream = Stream.fromArrayBuffer(arrayBuffer);
      const pvd = PrimaryVolumeDescriptor.struct.read(stream);
      if (pvd.header.type != 1)
        throw `Not an ISO file`;
      if (pvd.header.id != "CD001")
        throw `Not an ISO file`;
      this._children = [];
      this._childrenByPath = {};
      this._root = new IsoNode(this, pvd.directoryRecord);
      await this.processDirectoryRecordAsync(this._root);
      return this;
    }
    async processDirectoryRecordAsync(parentIsoNode) {
      const directoryStart = parentIsoNode.directoryRecord.extent * SECTOR_SIZE;
      const directoryLength = parentIsoNode.directoryRecord.size;
      const data = await this.asyncStream.readChunkAsync(directoryStart, directoryLength);
      const directoryStream = Stream.fromArrayBuffer(data);
      while (directoryStream.available) {
        const directoryRecordSize = directoryStream.readUInt8();
        if (directoryRecordSize == 0) {
          directoryStream.position = MathUtils.nextAligned(directoryStream.position, SECTOR_SIZE);
          continue;
        }
        directoryStream.position = directoryStream.position - 1;
        const directoryRecordStream = directoryStream.readStream(directoryRecordSize);
        const directoryRecord = GetStruct(DirectoryRecord).read(directoryRecordStream);
        directoryRecord.name = directoryRecordStream.readStringz(directoryRecordStream.available);
        if (directoryRecord.name == "" || directoryRecord.name == "")
          continue;
        const child = new IsoNode(this, directoryRecord, parentIsoNode);
        parentIsoNode.addChild(child);
        this._children.push(child);
        this._childrenByPath[child.path] = child;
      }
      for (const child of parentIsoNode.childs) {
        if (child.isDirectory) {
          await this.processDirectoryRecordAsync(child);
        }
      }
    }
  };

  // src/format/elf.ts
  var console8 = logger.named("elf");
  var ElfHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.magic = "";
      this.class = 0;
      this.data = 0;
      this.idVersion = 0;
      this._padding = [];
      this.type = 0;
      this.machine = 0;
      this.version = 0;
      this.entryPoint = 0;
      this.programHeaderOffset = 0;
      this.sectionHeaderOffset = 0;
      this.flags = 0;
      this.elfHeaderSize = 0;
      this.programHeaderEntrySize = 0;
      this.programHeaderCount = 0;
      this.sectionHeaderEntrySize = 0;
      this.sectionHeaderCount = 0;
      this.sectionHeaderStringTable = 0;
    }
    get hasValidMagic() {
      return this.magic == "\x7FELF";
    }
    get hasValidMachine() {
      return this.machine == ElfMachine.ALLEGREX;
    }
    get hasValidType() {
      return [ElfType.Executable, ElfType.Prx].indexOf(this.type) >= 0;
    }
  };
  __decorate([
    StructStructStringn(4)
  ], ElfHeader.prototype, "magic", 2);
  __decorate([
    StructInt8
  ], ElfHeader.prototype, "class", 2);
  __decorate([
    StructInt8
  ], ElfHeader.prototype, "data", 2);
  __decorate([
    StructInt8
  ], ElfHeader.prototype, "idVersion", 2);
  __decorate([
    StructStructArray(Int8, 9)
  ], ElfHeader.prototype, "_padding", 2);
  __decorate([
    StructUInt16
  ], ElfHeader.prototype, "type", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "machine", 2);
  __decorate([
    StructInt32
  ], ElfHeader.prototype, "version", 2);
  __decorate([
    StructInt32
  ], ElfHeader.prototype, "entryPoint", 2);
  __decorate([
    StructInt32
  ], ElfHeader.prototype, "programHeaderOffset", 2);
  __decorate([
    StructInt32
  ], ElfHeader.prototype, "sectionHeaderOffset", 2);
  __decorate([
    StructInt32
  ], ElfHeader.prototype, "flags", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "elfHeaderSize", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "programHeaderEntrySize", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "programHeaderCount", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "sectionHeaderEntrySize", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "sectionHeaderCount", 2);
  __decorate([
    StructInt16
  ], ElfHeader.prototype, "sectionHeaderStringTable", 2);
  var ElfProgramHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.type = ElfProgramHeaderType.NoLoad;
      this.offset = 0;
      this.virtualAddress = 0;
      this.psysicalAddress = 0;
      this.fileSize = 0;
      this.memorySize = 0;
      this.flags = ElfProgramHeaderFlags.Executable;
      this.alignment = 0;
    }
  };
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "type", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "offset", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "virtualAddress", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "psysicalAddress", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "fileSize", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "memorySize", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "flags", 2);
  __decorate([
    StructUInt32
  ], ElfProgramHeader.prototype, "alignment", 2);
  var ElfSectionHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.nameOffset = 0;
      this.type = ElfSectionHeaderType.Null;
      this.flags = ElfSectionHeaderFlags.None;
      this.address = 0;
      this.offset = 0;
      this.size = 0;
      this.link = 0;
      this.info = 0;
      this.addressAlign = 0;
      this.entitySize = 0;
      this.name = "";
    }
  };
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "nameOffset", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "type", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "flags", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "address", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "offset", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "size", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "link", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "info", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "addressAlign", 2);
  __decorate([
    StructUInt32
  ], ElfSectionHeader.prototype, "entitySize", 2);
  var ElfProgramHeaderType;
  (function(ElfProgramHeaderType2) {
    ElfProgramHeaderType2[ElfProgramHeaderType2["NoLoad"] = 0] = "NoLoad";
    ElfProgramHeaderType2[ElfProgramHeaderType2["Load"] = 1] = "Load";
    ElfProgramHeaderType2[ElfProgramHeaderType2["Reloc1"] = 1879048352] = "Reloc1";
    ElfProgramHeaderType2[ElfProgramHeaderType2["Reloc2"] = 1879048353] = "Reloc2";
  })(ElfProgramHeaderType || (ElfProgramHeaderType = {}));
  var ElfSectionHeaderType;
  (function(ElfSectionHeaderType2) {
    ElfSectionHeaderType2[ElfSectionHeaderType2["Null"] = 0] = "Null";
    ElfSectionHeaderType2[ElfSectionHeaderType2["ProgramBits"] = 1] = "ProgramBits";
    ElfSectionHeaderType2[ElfSectionHeaderType2["SYMTAB"] = 2] = "SYMTAB";
    ElfSectionHeaderType2[ElfSectionHeaderType2["STRTAB"] = 3] = "STRTAB";
    ElfSectionHeaderType2[ElfSectionHeaderType2["RELA"] = 4] = "RELA";
    ElfSectionHeaderType2[ElfSectionHeaderType2["HASH"] = 5] = "HASH";
    ElfSectionHeaderType2[ElfSectionHeaderType2["DYNAMIC"] = 6] = "DYNAMIC";
    ElfSectionHeaderType2[ElfSectionHeaderType2["NOTE"] = 7] = "NOTE";
    ElfSectionHeaderType2[ElfSectionHeaderType2["NoBits"] = 8] = "NoBits";
    ElfSectionHeaderType2[ElfSectionHeaderType2["Relocation"] = 9] = "Relocation";
    ElfSectionHeaderType2[ElfSectionHeaderType2["SHLIB"] = 10] = "SHLIB";
    ElfSectionHeaderType2[ElfSectionHeaderType2["DYNSYM"] = 11] = "DYNSYM";
    ElfSectionHeaderType2[ElfSectionHeaderType2["LOPROC"] = 1879048192] = "LOPROC";
    ElfSectionHeaderType2[ElfSectionHeaderType2["HIPROC"] = 2147483647] = "HIPROC";
    ElfSectionHeaderType2[ElfSectionHeaderType2["LOUSER"] = 2147483648] = "LOUSER";
    ElfSectionHeaderType2[ElfSectionHeaderType2["HIUSER"] = 4294967295] = "HIUSER";
    ElfSectionHeaderType2[ElfSectionHeaderType2["PrxRelocation"] = 1879048352] = "PrxRelocation";
    ElfSectionHeaderType2[ElfSectionHeaderType2["PrxRelocation_FW5"] = 1879048353] = "PrxRelocation_FW5";
  })(ElfSectionHeaderType || (ElfSectionHeaderType = {}));
  var ElfSectionHeaderFlags;
  (function(ElfSectionHeaderFlags2) {
    ElfSectionHeaderFlags2[ElfSectionHeaderFlags2["None"] = 0] = "None";
    ElfSectionHeaderFlags2[ElfSectionHeaderFlags2["Write"] = 1] = "Write";
    ElfSectionHeaderFlags2[ElfSectionHeaderFlags2["Allocate"] = 2] = "Allocate";
    ElfSectionHeaderFlags2[ElfSectionHeaderFlags2["Execute"] = 4] = "Execute";
  })(ElfSectionHeaderFlags || (ElfSectionHeaderFlags = {}));
  var ElfProgramHeaderFlags;
  (function(ElfProgramHeaderFlags2) {
    ElfProgramHeaderFlags2[ElfProgramHeaderFlags2["Executable"] = 1] = "Executable";
    ElfProgramHeaderFlags2[ElfProgramHeaderFlags2["Writable"] = 2] = "Writable";
    ElfProgramHeaderFlags2[ElfProgramHeaderFlags2["Readable"] = 4] = "Readable";
  })(ElfProgramHeaderFlags || (ElfProgramHeaderFlags = {}));
  var ElfType;
  (function(ElfType2) {
    ElfType2[ElfType2["Executable"] = 2] = "Executable";
    ElfType2[ElfType2["Prx"] = 65440] = "Prx";
  })(ElfType || (ElfType = {}));
  var ElfMachine;
  (function(ElfMachine2) {
    ElfMachine2[ElfMachine2["ALLEGREX"] = 8] = "ALLEGREX";
  })(ElfMachine || (ElfMachine = {}));
  var ElfPspModuleFlags;
  (function(ElfPspModuleFlags2) {
    ElfPspModuleFlags2[ElfPspModuleFlags2["User"] = 0] = "User";
    ElfPspModuleFlags2[ElfPspModuleFlags2["Kernel"] = 4096] = "Kernel";
  })(ElfPspModuleFlags || (ElfPspModuleFlags = {}));
  var ElfPspLibFlags;
  (function(ElfPspLibFlags2) {
    ElfPspLibFlags2[ElfPspLibFlags2["DirectJump"] = 1] = "DirectJump";
    ElfPspLibFlags2[ElfPspLibFlags2["Syscall"] = 16384] = "Syscall";
    ElfPspLibFlags2[ElfPspLibFlags2["SysLib"] = 32768] = "SysLib";
  })(ElfPspLibFlags || (ElfPspLibFlags = {}));
  var ElfPspModuleNids;
  (function(ElfPspModuleNids2) {
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_INFO"] = 4028461991] = "MODULE_INFO";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_BOOTSTART"] = 3547614176] = "MODULE_BOOTSTART";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_REBOOT_BEFORE"] = 788942758] = "MODULE_REBOOT_BEFORE";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_START"] = 3593645275] = "MODULE_START";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_START_THREAD_PARAMETER"] = 259794796] = "MODULE_START_THREAD_PARAMETER";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_STOP"] = 3471333692] = "MODULE_STOP";
    ElfPspModuleNids2[ElfPspModuleNids2["MODULE_STOP_THREAD_PARAMETER"] = 3473720983] = "MODULE_STOP_THREAD_PARAMETER";
  })(ElfPspModuleNids || (ElfPspModuleNids = {}));
  var ElfRelocType;
  (function(ElfRelocType2) {
    ElfRelocType2[ElfRelocType2["None"] = 0] = "None";
    ElfRelocType2[ElfRelocType2["Mips16"] = 1] = "Mips16";
    ElfRelocType2[ElfRelocType2["Mips32"] = 2] = "Mips32";
    ElfRelocType2[ElfRelocType2["MipsRel32"] = 3] = "MipsRel32";
    ElfRelocType2[ElfRelocType2["Mips26"] = 4] = "Mips26";
    ElfRelocType2[ElfRelocType2["MipsHi16"] = 5] = "MipsHi16";
    ElfRelocType2[ElfRelocType2["MipsLo16"] = 6] = "MipsLo16";
    ElfRelocType2[ElfRelocType2["MipsGpRel16"] = 7] = "MipsGpRel16";
    ElfRelocType2[ElfRelocType2["MipsLiteral"] = 8] = "MipsLiteral";
    ElfRelocType2[ElfRelocType2["MipsGot16"] = 9] = "MipsGot16";
    ElfRelocType2[ElfRelocType2["MipsPc16"] = 10] = "MipsPc16";
    ElfRelocType2[ElfRelocType2["MipsCall16"] = 11] = "MipsCall16";
    ElfRelocType2[ElfRelocType2["MipsGpRel32"] = 12] = "MipsGpRel32";
    ElfRelocType2[ElfRelocType2["StopRelocation"] = 255] = "StopRelocation";
  })(ElfRelocType || (ElfRelocType = {}));
  var ElfReloc = class extends Struct {
    constructor() {
      super(...arguments);
      this.pointerAddress = 0;
      this.info = 0;
    }
    get pointeeSectionHeaderBase() {
      return this.info >> 16 & 255;
    }
    get pointerSectionHeaderBase() {
      return this.info >> 8 & 255;
    }
    get type() {
      return this.info >> 0 & 255;
    }
  };
  __decorate([
    StructUInt32
  ], ElfReloc.prototype, "pointerAddress", 2);
  __decorate([
    StructUInt32
  ], ElfReloc.prototype, "info", 2);
  var ElfLoader = class {
    constructor() {
      this.programHeaders = [];
      this.sectionHeaders = [];
    }
    load(stream) {
      this.stream = stream;
      this.readAndCheckHeaders(stream);
      const programHeadersStream = stream.sliceWithLength(this.header.programHeaderOffset, this.header.programHeaderCount * this.header.programHeaderEntrySize);
      const sectionHeadersStream = stream.sliceWithLength(this.header.sectionHeaderOffset, this.header.sectionHeaderCount * this.header.sectionHeaderEntrySize);
      this.programHeaders = StructArray(ElfProgramHeader.struct, this.header.programHeaderCount).read(programHeadersStream);
      this.sectionHeaders = StructArray(ElfSectionHeader.struct, this.header.sectionHeaderCount).read(sectionHeadersStream);
      this.sectionHeaderStringTable = this.sectionHeaders[this.header.sectionHeaderStringTable];
      this.stringTableStream = this.getSectionHeaderFileStream(this.sectionHeaderStringTable);
      this.sectionHeadersByName = {};
      this.sectionHeaders.forEach((sectionHeader) => {
        const name2 = this.getStringFromStringTable(sectionHeader.nameOffset);
        sectionHeader.name = name2;
        if (sectionHeader.type != 0) {
          sectionHeader.stream = this.getSectionHeaderFileStream(sectionHeader);
        }
        this.sectionHeadersByName[name2] = sectionHeader;
      });
      console8.log(this.sectionHeadersByName);
    }
    readAndCheckHeaders(stream) {
      this.stream = stream;
      const header = this.header = ElfHeader.struct.read(stream);
      if (!header.hasValidMagic)
        throw new Error("Not an ELF file");
      if (!header.hasValidMachine)
        throw new Error("Not a PSP ELF file");
      if (!header.hasValidType)
        throw new Error(`Not a executable or a Prx but has type ${header.type}`);
    }
    getStringFromStringTable(index) {
      this.stringTableStream.position = index;
      return this.stringTableStream.readStringz();
    }
    getSectionHeaderFileStream(sectionHeader) {
      switch (sectionHeader.type) {
        case 8:
        case 0:
          return this.stream.sliceWithLength(0, 0);
        default:
          return this.stream.sliceWithLength(sectionHeader.offset, sectionHeader.size);
      }
    }
    static fromStream(stream) {
      const elf = new ElfLoader();
      elf.load(stream);
      return elf;
    }
    get isPrx() {
      return (this.header.type & 65440) != 0;
    }
    get needsRelocation() {
      return this.isPrx || this.header.entryPoint < Memory.MAIN_OFFSET;
    }
  };

  // src/format/elf_dwarf.ts
  var console9 = logger.named("elf.dwarf");
  var Uleb128Class = class {
    read(stream) {
      let val = 0;
      let b = 128;
      for (let shift = 0; stream.available > 0 && b & 128; shift += 7) {
        b = stream.readUInt8();
        val |= (b & 127) << shift;
      }
      return val;
    }
    write(stream, value) {
      throw new Error("Not implemented");
    }
    get length() {
      return 0;
    }
  };
  var Uleb128 = new Uleb128Class();
  var StructUleb128 = StructMember(Uleb128);
  var ElfDwarfHeader = class extends Struct {
    constructor() {
      super(...arguments);
      this.total_length = 0;
      this.version = 0;
      this.prologue_length = 0;
      this.minimum_instruction_length = 0;
      this.default_is_stmt = 0;
      this.line_base = 0;
      this.line_range = 0;
      this.opcode_base = 0;
    }
    get total_length_real() {
      return this.total_length + 4;
    }
  };
  __decorate([
    StructUInt32
  ], ElfDwarfHeader.prototype, "total_length", 2);
  __decorate([
    StructUInt16
  ], ElfDwarfHeader.prototype, "version", 2);
  __decorate([
    StructUInt32
  ], ElfDwarfHeader.prototype, "prologue_length", 2);
  __decorate([
    StructUInt8
  ], ElfDwarfHeader.prototype, "minimum_instruction_length", 2);
  __decorate([
    StructUInt8
  ], ElfDwarfHeader.prototype, "default_is_stmt", 2);
  __decorate([
    StructInt8
  ], ElfDwarfHeader.prototype, "line_base", 2);
  __decorate([
    StructInt8
  ], ElfDwarfHeader.prototype, "line_range", 2);
  __decorate([
    StructInt8
  ], ElfDwarfHeader.prototype, "opcode_base", 2);
  var DW_LNS;
  (function(DW_LNS2) {
    DW_LNS2[DW_LNS2["extended_op"] = 0] = "extended_op";
    DW_LNS2[DW_LNS2["copy"] = 1] = "copy";
    DW_LNS2[DW_LNS2["advance_pc"] = 2] = "advance_pc";
    DW_LNS2[DW_LNS2["advance_line"] = 3] = "advance_line";
    DW_LNS2[DW_LNS2["set_file"] = 4] = "set_file";
    DW_LNS2[DW_LNS2["set_column"] = 5] = "set_column";
    DW_LNS2[DW_LNS2["negate_stmt"] = 6] = "negate_stmt";
    DW_LNS2[DW_LNS2["set_basic_block"] = 7] = "set_basic_block";
    DW_LNS2[DW_LNS2["const_add_pc"] = 8] = "const_add_pc";
    DW_LNS2[DW_LNS2["fixed_advance_pc"] = 9] = "fixed_advance_pc";
  })(DW_LNS || (DW_LNS = {}));
  var DW_LNE;
  (function(DW_LNE2) {
    DW_LNE2[DW_LNE2["end_sequence"] = 1] = "end_sequence";
    DW_LNE2[DW_LNE2["set_address"] = 2] = "set_address";
    DW_LNE2[DW_LNE2["define_file"] = 3] = "define_file";
  })(DW_LNE || (DW_LNE = {}));
  var FileEntry = class extends Struct {
    constructor() {
      super(...arguments);
      this.name = "";
      this.directory_index = 0;
      this.time_mod = 0;
      this.size = 0;
      this.directory = "";
    }
    full_path() {
      if (this.directory.length) {
        return this.directory + "/" + this.name;
      } else {
        return name;
      }
    }
  };
  __decorate([
    StructStructStringzVariable
  ], FileEntry.prototype, "name", 2);
  __decorate([
    StructUleb128
  ], FileEntry.prototype, "directory_index", 2);
  __decorate([
    StructUleb128
  ], FileEntry.prototype, "time_mod", 2);
  __decorate([
    StructUleb128
  ], FileEntry.prototype, "size", 2);
  var ElfSymbol = class extends Struct {
    constructor() {
      super(...arguments);
      this.nameIndex = 0;
      this.value = 0;
      this.size = 0;
      this.info = 0;
      this.other = 0;
      this.shndx = 0;
      this.name = "";
      this.index = -1;
    }
    get type() {
      return BitUtils.extract(this.info, 0, 4);
    }
    get bind() {
      return BitUtils.extract(this.info, 4, 4);
    }
    get typeName() {
      return SymInfoType[this.type];
    }
    get bindName() {
      return SymInfoBind[this.bind];
    }
    get address() {
      return this.value;
    }
    get low() {
      return this.value;
    }
    get high() {
      return this.value + this.size;
    }
    toString() {
      return `ElfSymbol("${this.name}", ${addressToHex(this.low)}-${addressToHex(this.high)}`;
    }
    contains(address) {
      return address >= this.low && address < this.high;
    }
  };
  __decorate([
    StructUInt32
  ], ElfSymbol.prototype, "nameIndex", 2);
  __decorate([
    StructUInt32
  ], ElfSymbol.prototype, "value", 2);
  __decorate([
    StructUInt32
  ], ElfSymbol.prototype, "size", 2);
  __decorate([
    StructUInt8
  ], ElfSymbol.prototype, "info", 2);
  __decorate([
    StructUInt8
  ], ElfSymbol.prototype, "other", 2);
  __decorate([
    StructUInt16
  ], ElfSymbol.prototype, "shndx", 2);
  var SymInfoBind;
  (function(SymInfoBind2) {
    SymInfoBind2[SymInfoBind2["LOCAL"] = 0] = "LOCAL";
    SymInfoBind2[SymInfoBind2["GLOBAL"] = 1] = "GLOBAL";
    SymInfoBind2[SymInfoBind2["WEAK"] = 2] = "WEAK";
    SymInfoBind2[SymInfoBind2["OS_1"] = 10] = "OS_1";
    SymInfoBind2[SymInfoBind2["OS_2"] = 11] = "OS_2";
    SymInfoBind2[SymInfoBind2["OS_3"] = 12] = "OS_3";
    SymInfoBind2[SymInfoBind2["PROC_1"] = 13] = "PROC_1";
    SymInfoBind2[SymInfoBind2["PROC_2"] = 14] = "PROC_2";
    SymInfoBind2[SymInfoBind2["PROC_3"] = 15] = "PROC_3";
  })(SymInfoBind || (SymInfoBind = {}));
  var SymInfoType;
  (function(SymInfoType2) {
    SymInfoType2[SymInfoType2["NOTYPE"] = 0] = "NOTYPE";
    SymInfoType2[SymInfoType2["OBJECT"] = 1] = "OBJECT";
    SymInfoType2[SymInfoType2["FUNC"] = 2] = "FUNC";
    SymInfoType2[SymInfoType2["SECTION"] = 3] = "SECTION";
    SymInfoType2[SymInfoType2["FILE"] = 4] = "FILE";
    SymInfoType2[SymInfoType2["OS_1"] = 10] = "OS_1";
    SymInfoType2[SymInfoType2["OS_2"] = 11] = "OS_2";
    SymInfoType2[SymInfoType2["OS_3"] = 12] = "OS_3";
    SymInfoType2[SymInfoType2["PROC_1"] = 13] = "PROC_1";
    SymInfoType2[SymInfoType2["PROC_2"] = 14] = "PROC_2";
    SymInfoType2[SymInfoType2["PROC_3"] = 15] = "PROC_3";
  })(SymInfoType || (SymInfoType = {}));
  var ElfDwarfLoader = class {
    constructor() {
      this.symbolEntries = [];
    }
    parseElfLoader(elf) {
      this.parseSymtab(elf);
    }
    parseSymtab(elf) {
      console9.log("ElfDwarfLoader.parseSymtab");
      const symtabHeader = elf.sectionHeadersByName[".symtab"];
      if (!symtabHeader)
        return;
      const nameSection = elf.sectionHeaders[symtabHeader.link];
      const nameStream = nameSection.stream.sliceWithLength(0);
      const stream = symtabHeader.stream.sliceWithLength(0);
      let n = 0;
      try {
        while (stream.available > 0) {
          const entry = ElfSymbol.struct.read(stream);
          entry.name = nameStream.sliceWithLength(entry.nameIndex).readStringz();
          entry.index = n;
          this.symbolEntries.push(entry);
          n++;
        }
      } catch (e) {
        console9.warn(e);
      }
      this.symbolEntries.sortBy((item) => item.value);
    }
    getSymbolAt(address) {
      for (let n = 0; n < this.symbolEntries.length; n++) {
        const entry = this.symbolEntries[n];
        if (entry.contains(address))
          return entry;
      }
      return null;
    }
    parseDebugLine(elf) {
      console9.log("ElfDwarfLoader.parseDebugLine");
      const sectionHeader = elf.sectionHeadersByName[".debug_line"];
      console9.log(sectionHeader);
      const stream = sectionHeader.stream.sliceWithLength(0);
      const header = ElfDwarfHeader.struct.read(stream);
      console9.log(header);
      const opcodes = StructArray(Uleb128, header.opcode_base).read(stream);
      console9.log(opcodes);
      while (stream.available > 0) {
        console9.log("item:");
        const item = StringzVariable.read(stream);
        if (!item.length)
          break;
        console9.log(item);
      }
      while (stream.available > 0) {
        const entry = FileEntry.struct.read(stream);
        console9.log(entry);
        if (!entry.name.length)
          break;
      }
    }
  };

  // src/hle/pspmodules_database.ts
  var ModuleKnownFunctionNamesDatabase = {
    sceAmctrl_driver: {
      "0x0785C974": "sceDrmBBCipherUpdate",
      "0x1CCB66D2": "sceDrmBBCipherInit",
      "0x525B8218": "sceDrmBBMacInit",
      "0x58163FBE": "sceDrmBBMacUpdate",
      "0x9951C50F": "sceDrmBBCipherFinal",
      "0xEF95A213": "sceDrmBBMacFinal",
      "0xF5186D8E": "sceDrmBBMacFinal2"
    },
    sceAta_driver: {
      "0x110D3739": "sceAtaSetDriveStat",
      "0x12805193": "sceAtaAhbSetupBus",
      "0x3AA3FA39": "sceAtaSelectDevice",
      "0x68DEA2FF": "sceAtaClearIntrStateFlag",
      "0x6C58F096": "sceAtaWaitBusBusy1",
      "0x6E639701": "sceAtaScanDevice",
      "0x7BBA095C": "sceAtaClearDriveStat",
      "0xAC800B1D": "sceAtaDisableClkIo",
      "0xC74F04B7": "sceAtaExecPacketCmd",
      "0xD1E6E175": "sceAtaEnableClkIo"
    },
    sceAudio_driver: {},
    sceAudio: {
      "0x01562BA3": "sceAudioOutput2Reserve",
      "0x086E5895": "sceAudioInputBlocking",
      "0x136CAF51": "sceAudioOutputBlocking",
      "0x13F592BC": "sceAudioOutputPannedBlocking",
      "0x2D53F36E": "sceAudioOutput2OutputBlocking",
      "0x38553111": "sceAudioSRCChReserve",
      "0x41EFADE7": "sceAudioOneshotOutput",
      "0x43196845": "sceAudioOutput2Release",
      "0x5C37C0AE": "sceAudioSRCChRelease",
      "0x5EC81C55": "sceAudioChReserve",
      "0x63F2889C": "sceAudioOutput2ChangeLength",
      "0x647CEF33": "sceAudioOutput2GetRestSample",
      "0x6D4BEC68": "sceAudioInput",
      "0x6FC46853": "sceAudioChRelease",
      "0x7DE61688": "sceAudioInputInit",
      "0x87B2E651": "sceAudioWaitInputEnd",
      "0x8C1009B2": "sceAudioOutput",
      "0x95FD0C2D": "sceAudioChangeChannelConfig",
      "0xA633048E": "sceAudioPollInputEnd",
      "0xA708C6A6": "sceAudioGetInputLength",
      "0xB011922F": "sceAudioGetChannelRestLength",
      "0xB7E1D8E7": "sceAudioChangeChannelVolume",
      "0xCB2E439E": "sceAudioSetChannelDataLen",
      "0xE0727056": "sceAudioSRCOutputBlocking",
      "0xE2D56B2D": "sceAudioOutputPanned",
      "0xE926D3FB": "sceAudioInputInitEx",
      "0xE9D97901": "sceAudioGetChannelRestLen"
    },
    sceAudiocodec: {
      "0x29681260": "sceAudiocodecReleaseEDRAM",
      "0x3A20A200": "sceAudiocodecGetEDRAM",
      "0x5B37EB1D": "sceAudiocodecInit",
      "0x70A703F8": "sceAudiocodecDecode",
      "0x8ACA11D5": "sceAudiocodecGetInfo",
      "0x9D3F790C": "sceAudiocodecCheckNeedMem"
    },
    sceAvcodec_driver: {"0x4A0592C7": "sceAvcodecStartEntry", "0xC692C906": "sceAvcodecEndEntry"},
    sceVideocodec: {
      "0x17099F0A": "sceVideocodecInit",
      "0x26927D19": "sceVideocodecGetVersion",
      "0x2D31F5B1": "sceVideocodecGetEDRAM",
      "0x2F385E7F": "sceVideocodecScanHeader",
      "0x307E6E1C": "sceVideocodecDelete",
      "0x4F160BF4": "sceVideocodecReleaseEDRAM",
      "0x627B7D42": "sceVideocodecGetSEI",
      "0x745A7B7A": "sceVideocodecSetMemory",
      "0xA2F0564E": "sceVideocodecStop",
      "0xC01EC829": "sceVideocodecOpen",
      "0xDBA273FA": "sceVideocodecDecode"
    },
    sceMpegbase: {
      "0x304882E1": "sceMpegBaseCscAvcRange",
      "0x492B5E4B": "sceMpegBaseCscInit",
      "0x7AC0321A": "sceMpegBaseYCrCbCopy",
      "0x91929A21": "sceMpegBaseCscAvc",
      "0xBE45C284": "sceMpegBaseYCrCbCopyVme",
      "0xCE8EB837": "sceMpegBaseCscVme"
    },
    sceMpegbase_driver: {
      "0x27A2982F": "sceMpegBaseInit",
      "0x304882E1": "sceMpegBaseCscAvcRange",
      "0x492B5E4B": "sceMpegBaseCscInit",
      "0x7AC0321A": "sceMpegBaseYCrCbCopy",
      "0x91929A21": "sceMpegBaseCscAvc",
      "0xBE45C284": "sceMpegBaseYCrCbCopyVme",
      "0xCE8EB837": "sceMpegBaseCscVme"
    },
    sceJpeg: {
      "0x0425B986": "sceJpegDecompressAllImage",
      "0x04B5AE02": "sceJpegMJpegCsc",
      "0x04B93CEF": "sceJpegDecodeMJpeg",
      "0x227662D7": "sceJpegDecodeMJpegYCbCrSuccessively",
      "0x48B602B7": "sceJpegDeleteMJpeg",
      "0x64B6F978": "sceJpegDecodeMJpegSuccessively",
      "0x67F0ED84": "sceJpegCsc",
      "0x7D2F3D7F": "sceJpegFinishMJpeg",
      "0x8F2BB012": "sceJpegGetOutputInfo",
      "0x91EED83C": "sceJpegDecodeMJpegYCbCr",
      "0x9D47469C": "sceJpegCreateMJpeg",
      "0xAC9E70E6": "sceJpegInitMJpeg"
    },
    sceCertLoader_driver: {"0x11391041": "sceLoadCertInit", "0xE86A7DC1": "sceLoadCertEnd"},
    sceCertLoader: {"0xDD629A24": "sceLoadCertFromFlash"},
    sceChkreg_driver: {"0x54495B19": "sceChkregCheckRegion", "0x59F8491D": "sceChkregGetPsCode"},
    sceChnnlsv: {
      "0x850A7FA1": "sceSdSetMember",
      "0xABFDFC8B": "sceSdCreateList",
      "0xC4C494F8": "sceSdGetLastIndex",
      "0xE7833020": "sceSdSetIndex",
      "0xF21A1FCA": "sceSdRemoveValue"
    },
    sceChnnlsv_driver: {
      "0x850A7FA1": "sceSdSetMember",
      "0xABFDFC8B": "sceSdCreateList",
      "0xC4C494F8": "sceSdGetLastIndex",
      "0xE7833020": "sceSdSetIndex",
      "0xF21A1FCA": "sceSdRemoveValue"
    },
    sceClockgen_driver: {
      "0x29160F5D": "sceClockgenInit",
      "0x36F9B49D": "sceClockgenEnd",
      "0x7FF82F6F": "sceClockgenLeptonClkEnable",
      "0xDBE5F283": "sceClockgenLeptonClkDisable"
    },
    sceCodec_driver: {
      "0x02133959": "sceCodecStopEntry",
      "0x261C6EE8": "sceCodecSetOutputVolume",
      "0x359C2B9F": "sceCodecOutputDisable",
      "0x856E7487": "sceCodecOutputEnable",
      "0xBD8E0977": "sceCodecInitEntry"
    },
    sceVshCommonGui: {},
    sceVshCommonUtil: {},
    content_browser: {},
    sceCtrl: {
      "0x02BAAD91": "sceCtrlGetSamplingCycle",
      "0x0B588501": "sceCtrlReadLatch",
      "0x1F4011E6": "sceCtrlSetSamplingMode",
      "0x1F803938": "sceCtrlReadBufferPositive",
      "0x3A622550": "sceCtrlPeekBufferPositive",
      "0x60B81F86": "sceCtrlReadBufferNegative",
      "0x6841BE1A": "sceCtrlSetRapidFire",
      "0x687660FA": "sceCtrlGetIdleCancelThreshold",
      "0x6A2774F3": "sceCtrlSetSamplingCycle",
      "0xA68FD260": "sceCtrlClearRapidFire",
      "0xA7144800": "sceCtrlSetIdleCancelThreshold",
      "0xB1D0E5CD": "sceCtrlPeekLatch",
      "0xC152080A": "sceCtrlPeekBufferNegative",
      "0xDA6B76A1": "sceCtrlGetSamplingMode"
    },
    sceCtrl_driver: {},
    sceDisplay: {
      "0x0E20F177": "sceDisplaySetMode",
      "0x21038913": "sceDisplayIsVsync",
      "0x210EAB3A": "sceDisplayGetAccumulatedHcount",
      "0x289D82FE": "sceDisplaySetFrameBuf",
      "0x31C4BAA8": "sceDisplayGetBrightness",
      "0x36CDFADE": "sceDisplayWaitVblank",
      "0x46F186C3": "sceDisplayWaitVblankStartCB",
      "0x4D4E10EC": "sceDisplayIsVblank",
      "0x69B53541": "sceDisplayGetVblankRest",
      "0x773DD3A3": "sceDisplayGetCurrentHcount",
      "0x7ED59BC4": "sceDisplaySetHoldMode",
      "0x8EB9EC49": "sceDisplayWaitVblankCB",
      "0x984C27E7": "sceDisplayWaitVblankStart",
      "0x9C6EAAD7": "sceDisplayGetVcount",
      "0xA544C486": "sceDisplaySetResumeMode",
      "0xA83EF139": "sceDisplayAdjustAccumulatedHcount",
      "0xB4F378FA": "sceDisplayIsForeground",
      "0xBF79F646": "sceDisplayGetResumeMode",
      "0xDBA6C4C4": "sceDisplayGetFramePerSec",
      "0xDEA197D4": "sceDisplayGetMode",
      "0xEEDA2E54": "sceDisplayGetFrameBuf"
    },
    sceDisplay_driver: {
      "0x0E20F177": "sceDisplaySetMode",
      "0x206276C2": "sceDisplayInit",
      "0x7A10289D": "sceDisplayEnd",
      "0x96CFAC38": "sceDisplayGetBacklightSel",
      "0xDEA197D4": "sceDisplayGetMode",
      "0xE55F0D50": "sceDisplaySetBacklightSel"
    },
    sceHibari_driver: {},
    sceDve_driver: {},
    DmacManForKernel: {
      "0x1C46158A": "sceKernelDmaExit",
      "0x2E3BC333": "sceKernelDmaChReserve",
      "0x3BDEA96C": "sceKernelDmaOpEnQueue",
      "0x3FAD5844": "sceKernelDmaOpSetupMemcpy",
      "0x59615199": "sceKernelDmaOpAlloc",
      "0x5AF32783": "sceKernelDmaOpQuit",
      "0x745E19EF": "sceKernelDmaOpFree",
      "0x7B9634E1": "sceKernelDmaSoftRequest",
      "0x7D21A2EF": "sceKernelDmaOpSetupLink",
      "0x904110FC": "sceKernelDmaOpAssignMultiple",
      "0x92700CCD": "sceKernelDmaOpDeQueue",
      "0xA84B084B": "sceKernelDmaOpAllCancel",
      "0xA893DA2C": "sceKernelDmaOpFreeLink",
      "0xCE467D9B": "sceKernelDmaOpSetupNormal",
      "0xD0358BE9": "sceKernelDmaOpSetCallback",
      "0xD3F62265": "sceKernelDmaOnDebugMode",
      "0xD8BC3120": "sceKernelDmaChExclude",
      "0xDB286D65": "sceKernelDmaOpSync",
      "0xF64BAB99": "sceKernelDmaOpAssign"
    },
    ExceptionManagerForKernel: {
      "0x15ADC862": "sceKernelRegisterNmiHandler",
      "0xB15357C9": "sceKernelReleaseNmiHandler"
    },
    sceFileParserBase: {},
    sceG729_driver: {
      "0x13F1028A": "sceG729DecodeExit",
      "0x17C11696": "sceG729DecodeInitResource",
      "0x3489D1F3": "sceG729DecodeCore",
      "0x55E14F75": "sceG729DecodeInit",
      "0x5A409D1B": "sceG729EncodeExit",
      "0x74804D93": "sceG729DecodeReset",
      "0x890B86AE": "sceG729DecodeTermResource",
      "0x8C87A2CA": "sceG729EncodeReset",
      "0x94714D50": "sceG729EncodeTermResource",
      "0xAA1E5462": "sceG729EncodeInitResource",
      "0xCFCD367C": "sceG729EncodeInit",
      "0xDB7259D5": "sceG729EncodeCore"
    },
    sceG729: {
      "0x13F1028A": "sceG729DecodeExit",
      "0x17C11696": "sceG729DecodeInitResource",
      "0x3489D1F3": "sceG729DecodeCore",
      "0x55E14F75": "sceG729DecodeInit",
      "0x5A409D1B": "sceG729EncodeExit",
      "0x74804D93": "sceG729DecodeReset",
      "0x890B86AE": "sceG729DecodeTermResource",
      "0x8C87A2CA": "sceG729EncodeReset",
      "0x94714D50": "sceG729EncodeTermResource",
      "0xAA1E5462": "sceG729EncodeInitResource",
      "0xCFCD367C": "sceG729EncodeInit",
      "0xDB7259D5": "sceG729EncodeCore"
    },
    sceGe_driver: {},
    sceGe_user: {
      "0x03444EB4": "sceGeListSync",
      "0x05DB22CE": "sceGeUnsetCallback",
      "0x0BF608FB": "sceGeRestoreContext",
      "0x1C0D95A6": "sceGeListEnQueueHead",
      "0x1F6752AD": "sceGeEdramGetSize",
      "0x438A385A": "sceGeSaveContext",
      "0x4C06E472": "sceGeContinue",
      "0x57C8945B": "sceGeGetMtx",
      "0x5FB86AB0": "sceGeListDeQueue",
      "0xA4FC06A4": "sceGeSetCallback",
      "0xAB49E76A": "sceGeListEnQueue",
      "0xB287BD61": "sceGeDrawSync",
      "0xB448EC0D": "sceGeBreak",
      "0xB77905EA": "sceGeEdramSetAddrTranslation",
      "0xDC93CFEF": "sceGeGetCmd",
      "0xE0D68148": "sceGeListUpdateStallAddr",
      "0xE47E40E4": "sceGeEdramGetAddr",
      "0xE66CB92E": "sceGeGetStack"
    },
    sceHprm: {
      "0x1910B327": "sceHprmPeekCurrentKey",
      "0x208DB1BD": "sceHprmIsRemoteExist",
      "0x219C58F1": "sceHprmIsMicrophoneExist",
      "0x2BCEC83E": "sceHprmPeekLatch",
      "0x40D2F9F0": "sceHprmReadLatch",
      "0x444ED0B7": "sceHprmUnregitserCallback",
      "0x71B5FB67": "sceHprmGetHpDetect",
      "0x7E69EDA4": "sceHprmIsHeadphoneExist",
      "0xC7154136": "sceHprmRegisterCallback"
    },
    sceHprm_driver: {
      "0x1910B327": "sceHprmPeekCurrentKey",
      "0x1C5BC5A0": "sceHprmInit",
      "0x2C7B8B05": "sceHprmResume",
      "0x526BB7F4": "sceHprmSuspend",
      "0x588845DA": "sceHprmEnd"
    },
    sceHtmlViewerHelper: {},
    sceHVUI_Module: {},
    sceHttpStorage_driver: {
      "0x24AA94F4": "sceHttpStorageWrite",
      "0x2D8DAE58": "sceHttpStorageGetstat",
      "0x700AAD44": "sceHttpStorageOpen",
      "0xB33389CE": "sceHttpStorageLseek",
      "0xC59AC98A": "sceHttpStorageEnd",
      "0xCDA3D8F6": "sceHttpStorageClose",
      "0xCDDF1103": "sceHttpStorageRead"
    },
    sceHttpStorage: {
      "0x24AA94F4": "sceHttpStorageWrite",
      "0x2D8DAE58": "sceHttpStorageGetstat",
      "0x700AAD44": "sceHttpStorageOpen",
      "0xB33389CE": "sceHttpStorageLseek",
      "0xCDA3D8F6": "sceHttpStorageClose",
      "0xCDDF1103": "sceHttpStorageRead"
    },
    sceHttpStorage_bridge: {},
    sceHVAuth: {"0x5E335DF6": "sceHVAuthOpen", "0x816A5F92": "sceHVAuthAuth", "0x9DB7DE7C": "sceHVAuthClose"},
    sceIdMgr_driver: {"0xF464F91C": "sceIdMgrRegisterCallback"},
    sceIdStorage_driver: {
      "0x08A471A6": "sceIdStorageCreateLeaf",
      "0x1FA4D135": "sceIdStorageWriteLeaf",
      "0x2C97AB36": "sceIdStorageDeleteLeaf",
      "0x2CE0BE69": "sceIdStorageEnd",
      "0x2D633688": "sceIdStorageIsReadOnly",
      "0x31E08AFB": "sceIdStorageEnumId",
      "0x37833CB8": "sceIdStorageGetFreeLeaves",
      "0x3AD32523": "sceIdStorageFlush",
      "0x683AAC10": "sceIdStorageUpdate",
      "0x6FE062D1": "sceIdStorageLookup",
      "0x958089DB": "sceIdStorageFormat",
      "0x99ACCB71": "sceIdStorageCreateAtomicLeaves",
      "0xAB129D20": "sceIdStorageInit",
      "0xB9069BAD": "sceIdStorageIsDirty",
      "0xEB00C509": "sceIdStorageReadLeaf",
      "0xEB830733": "sceIdStorageGetLeafSize",
      "0xF4BCB3EE": "sceIdStorageUnformat",
      "0xF77565B6": "sceIdStorageSuspend",
      "0xFE51173D": "sceIdStorageResume",
      "0xFEFA40C2": "sceIdStorageIsFormatted"
    },
    sceNetIfhandle: {"0xC80181A2": "sceNetGetDropRate", "0xFD8585E1": "sceNetSetDropRate"},
    sceNetIfhandle_lib: {
      "0x0296C7D6": "sceNetIfhandleIfIoctl",
      "0x1560F143": "sceNetMCopyback",
      "0x15CFE3C0": "sceNetMallocInternal",
      "0x2162EE67": "sceNetIfhandlePollSema",
      "0x30602CE9": "sceNetIfhandleSignalSema",
      "0x30F69334": "sceNetIfhandleInit",
      "0x3E8DD3F8": "sceNetMCat",
      "0x456E3146": "sceNetMCopym",
      "0x49EDBB18": "sceNetMPullup",
      "0x4C2886CB": "sceNetGetMallocStatInternal",
      "0x4CF15C43": "sceNetMGethdr",
      "0x4FB43BCE": "sceNetIfhandleGetDetachEther",
      "0x59F0D619": "sceNetMGetclr",
      "0x6AB53C27": "sceNetMDup",
      "0x76BAD213": "sceNetFreeInternal",
      "0x8FCB05A1": "sceNetIfhandleIfUp",
      "0x9A6261EC": "sceNetMCopydata",
      "0xA493AA5F": "sceNetMGet",
      "0xB1F5BB87": "sceNetIfhandleIfStart",
      "0xB8188F96": "sceNetIfhandleGetAttachEther",
      "0xB9096E48": "sceNetIfhandleTerm",
      "0xBFF3CEA5": "sceNetMAdj",
      "0xC3325FDC": "sceNetMPrepend",
      "0xD5DA7B3C": "sceNetIfhandleWaitSema",
      "0xE440A7D8": "sceNetIfhandleIfDequeue",
      "0xE80F00A4": "sceNetMPulldown",
      "0xEAD3A759": "sceNetIfhandleIfDown",
      "0xF56FAC82": "sceNetMFreem",
      "0xF8825DC4": "sceNetMFree"
    },
    sceNetIfhandle_driver: {
      "0x0296C7D6": "sceNetIfhandleIfIoctl",
      "0x1560F143": "sceNetMCopyback",
      "0x15CFE3C0": "sceNetMallocInternal",
      "0x16042084": "sceNetCreateIfhandleEther",
      "0x16246B99": "sceNetIfPrepend",
      "0x2162EE67": "sceNetIfhandlePollSema",
      "0x263767F6": "sceNetFlagIfEvent",
      "0x30602CE9": "sceNetIfhandleSignalSema",
      "0x30F69334": "sceNetIfhandleInit",
      "0x3E8DD3F8": "sceNetMCat",
      "0x456E3146": "sceNetMCopym",
      "0x49EDBB18": "sceNetMPullup",
      "0x4C2886CB": "sceNetGetMallocStatInternal",
      "0x4CF15C43": "sceNetMGethdr",
      "0x4FB43BCE": "sceNetIfhandleGetDetachEther",
      "0x54D1AEA1": "sceNetDetachIfhandleEther",
      "0x59F0D619": "sceNetMGetclr",
      "0x6AB53C27": "sceNetMDup",
      "0x76BAD213": "sceNetFreeInternal",
      "0x8FCB05A1": "sceNetIfhandleIfUp",
      "0x9A6261EC": "sceNetMCopydata",
      "0xA493AA5F": "sceNetMGet",
      "0xAE81C0CB": "sceNetAttachIfhandleEther",
      "0xB1F5BB87": "sceNetIfhandleIfStart",
      "0xB8188F96": "sceNetIfhandleGetAttachEther",
      "0xB9096E48": "sceNetIfhandleTerm",
      "0xBFF3CEA5": "sceNetMAdj",
      "0xC28F6FF2": "sceNetIfEnqueue",
      "0xC3325FDC": "sceNetMPrepend",
      "0xC80181A2": "sceNetGetDropRate",
      "0xC9344A59": "sceNetDestroyIfhandleEther",
      "0xD5DA7B3C": "sceNetIfhandleWaitSema",
      "0xE2F4F1C9": "sceNetIfDequeue",
      "0xE440A7D8": "sceNetIfhandleIfDequeue",
      "0xE80F00A4": "sceNetMPulldown",
      "0xEAD3A759": "sceNetIfhandleIfDown",
      "0xF56FAC82": "sceNetMFreem",
      "0xF8825DC4": "sceNetMFree",
      "0xF94BAF52": "sceNetSendIfEvent",
      "0xFD8585E1": "sceNetSetDropRate"
    },
    sceImpose: {
      "0x0F341BE4": "sceImposeGetHomePopup",
      "0x24FD7BCF": "sceImposeGetLanguageMode",
      "0x36AA6E91": "sceImposeSetLanguageMode",
      "0x381BD9E7": "sceImposeHomeButton",
      "0x5595A71A": "sceImposeSetHomePopup",
      "0x72189C48": "sceImposeSetUMDPopup",
      "0x8C943191": "sceImposeGetBatteryIconStatus",
      "0x8F6E3518": "sceImposeGetBacklightOffTime",
      "0x967F6D4A": "sceImposeSetBacklightOffTime",
      "0xE0887BC8": "sceImposeGetUMDPopup"
    },
    sceImpose_driver: {},
    sceAudioRouting: {
      "0x28235C56": "sceAudioRoutingGetVolumeMode",
      "0x36FD8AA9": "sceAudioRoutingSetMode",
      "0x39240E7D": "sceAudioRoutingGetMode",
      "0xBB548475": "sceAudioRoutingSetVolumeMode"
    },
    sceAudioRouting_driver: {},
    InitForKernel: {
      "0x1D3256BA": "sceKernelRegisterChunk",
      "0x27932388": "sceKernelBootFrom",
      "0x2C6E9FE9": "sceKernelGetChunk",
      "0x7233B5BC": "sceKernelApplicationType",
      "0x7A2333AD": "sceKernelInitApitype",
      "0x9F9AE99C": "sceKernelSetInitCallback",
      "0xA6E71B93": "sceKernelInitFileName",
      "0xCE88E870": "sceKernelReleaseChunk"
    },
    InterruptManagerForKernel: {
      "0x02314986": "sceKernelCpuEnableIntr",
      "0x092968F4": "sceKernelCpuSuspendIntr",
      "0x30C08374": "sceKernelGetCpuClockCounter",
      "0x3B84732D": "sceKernelCpuResumeIntrWithSync",
      "0x4D6E7305": "sceKernelEnableIntr",
      "0x58DD8978": "sceKernelRegisterIntrHandler",
      "0x5F10D406": "sceKernelCpuResumeIntr",
      "0xD61E6961": "sceKernelReleaseSubIntrHandler",
      "0xD774BA45": "sceKernelDisableIntr",
      "0xF987B1F0": "sceKernelReleaseIntrHandler",
      "0xFB8E22EC": "sceKernelEnableSubIntr",
      "0xFE28C6D9": "sceKernelIsIntrContext"
    },
    InterruptManager: {
      "0x5CB5A78B": "sceKernelSuspendSubIntr",
      "0x7860E0DC": "sceKernelResumeSubIntr",
      "0x8A389411": "sceKernelDisableSubIntr",
      "0xCA04A2B9": "sceKernelRegisterSubIntrHandler",
      "0xD2E8363F": "QueryIntrHandlerInfo",
      "0xD61E6961": "sceKernelReleaseSubIntrHandler",
      "0xEEE43F47": "sceKernelRegisterUserSpaceIntrStack",
      "0xFB8E22EC": "sceKernelEnableSubIntr",
      "0xFC4374B8": "sceKernelIsSubInterruptOccurred"
    },
    StdioForUser: {
      "0x0CBB0571": "sceKernelStdioLseek",
      "0x172D316E": "sceKernelStdin",
      "0x3054D478": "sceKernelStdioRead",
      "0x432D8F5C": "sceKernelRegisterStdoutPipe",
      "0x6F797E03": "sceKernelRegisterStderrPipe",
      "0x924ABA61": "sceKernelStdioOpen",
      "0x9D061C19": "sceKernelStdioClose",
      "0xA3B931DB": "sceKernelStdioWrite",
      "0xA46785C9": "sceKernelStdioSendChar",
      "0xA6BAB2E9": "sceKernelStdout",
      "0xF78BA90A": "sceKernelStderr"
    },
    StdioForKernel: {
      "0x11A5127A": "fdgets",
      "0x172D316E": "sceKernelStdin",
      "0x2CCF071A": "fdprintf",
      "0x2D8551AB": "sceKernelStdoutReset",
      "0x36B23B8B": "fdputs",
      "0x432D8F5C": "sceKernelRegisterStdoutPipe",
      "0x4F78930A": "fdputc",
      "0x6F797E03": "sceKernelRegisterStderrPipe",
      "0x7E338487": "getchar",
      "0x9662BF86": "sceKernelStderrReset",
      "0x98220F3E": "sceKernelStdoutReopen",
      "0xA6BAB2E9": "sceKernelStdout",
      "0xBFF7E760": "gets",
      "0xCAB439DF": "printf",
      "0xD2B2A2A7": "fdgetc",
      "0xD768752A": "putchar",
      "0xD97C8CB9": "puts",
      "0xF78BA90A": "sceKernelStderr",
      "0xFB5380C5": "sceKernelStderrReopen"
    },
    IoFileMgrForUser: {
      "0x06A70004": "sceIoMkdir",
      "0x08BD7374": "sceIoGetDevType",
      "0x0FACAB19": "sceIoWriteAsync",
      "0x109F50BC": "sceIoOpen",
      "0x1117C65F": "sceIoRmdir",
      "0x1B385D8F": "sceIoLseek32Async",
      "0x27EB27B8": "sceIoLseek",
      "0x3251EA56": "sceIoPollAsync",
      "0x35DBD746": "sceIoWaitAsyncCB",
      "0x42EC03AC": "sceIoWrite",
      "0x54F5FB11": "sceIoDevctl",
      "0x55F4717D": "sceIoChdir",
      "0x5C2BE2CC": "sceIoGetFdList",
      "0x63632449": "sceIoIoctl",
      "0x68963324": "sceIoLseek32",
      "0x6A638D83": "sceIoRead",
      "0x6D08A871": "sceIoUnassign",
      "0x71B19E77": "sceIoLseekAsync",
      "0x779103A0": "sceIoRename",
      "0x810C4BC3": "sceIoClose",
      "0x89AA9906": "sceIoOpenAsync",
      "0xA0B5A7C2": "sceIoReadAsync",
      "0xA12A0514": "sceIoSetAsyncCallback",
      "0xAB96437F": "sceIoSync",
      "0xACE946E8": "sceIoGetstat",
      "0xB293727F": "sceIoChangeAsyncPriority",
      "0xB29DDF9C": "sceIoDopen",
      "0xB2A628C1": "sceIoAssign",
      "0xB8A740F4": "sceIoChstat",
      "0xCB05F8D6": "sceIoGetAsyncStat",
      "0xE23EEC33": "sceIoWaitAsync",
      "0xE3EB004C": "sceIoDread",
      "0xE8BC6571": "sceIoCancel",
      "0xE95A012B": "sceIoIoctlAsync",
      "0xEB092469": "sceIoDclose",
      "0xF27A9C51": "sceIoRemove",
      "0xFF5940B6": "sceIoCloseAsync"
    },
    IoFileMgrForKernel: {
      "0x06A70004": "sceIoMkdir",
      "0x08BD7374": "sceIoGetDevType",
      "0x0FACAB19": "sceIoWriteAsync",
      "0x109F50BC": "sceIoOpen",
      "0x1117C65F": "sceIoRmdir",
      "0x1B385D8F": "sceIoLseek32Async",
      "0x27EB27B8": "sceIoLseek",
      "0x3251EA56": "sceIoPollAsync",
      "0x35DBD746": "sceIoWaitAsyncCB",
      "0x42EC03AC": "sceIoWrite",
      "0x54F5FB11": "sceIoDevctl",
      "0x55F4717D": "sceIoChdir",
      "0x5C2BE2CC": "sceIoGetFdList",
      "0x63632449": "sceIoIoctl",
      "0x68963324": "sceIoLseek32",
      "0x6A638D83": "sceIoRead",
      "0x6D08A871": "sceIoUnassign",
      "0x71B19E77": "sceIoLseekAsync",
      "0x779103A0": "sceIoRename",
      "0x810C4BC3": "sceIoClose",
      "0x89AA9906": "sceIoOpenAsync",
      "0x8E982A74": "sceIoAddDrv",
      "0xA0B5A7C2": "sceIoReadAsync",
      "0xA12A0514": "sceIoSetAsyncCallback",
      "0xAB96437F": "sceIoSync",
      "0xACE946E8": "sceIoGetstat",
      "0xB293727F": "sceIoChangeAsyncPriority",
      "0xB29DDF9C": "sceIoDopen",
      "0xB2A628C1": "sceIoAssign",
      "0xB8A740F4": "sceIoChstat",
      "0xC7F35804": "sceIoDelDrv",
      "0xCB05F8D6": "sceIoGetAsyncStat",
      "0xE23EEC33": "sceIoWaitAsync",
      "0xE3EB004C": "sceIoDread",
      "0xE8BC6571": "sceIoCancel",
      "0xE95A012B": "sceIoIoctlAsync",
      "0xEB092469": "sceIoDclose",
      "0xF27A9C51": "sceIoRemove",
      "0xFF5940B6": "sceIoCloseAsync"
    },
    sceLed_driver: {
      "0xA13B3D38": "sceLedResume",
      "0xA8542C48": "sceLedEnd",
      "0xB0B6A883": "sceLedInit",
      "0xDE91D3A4": "sceLedSuspend",
      "0xEA24BE03": "sceLedSetMode"
    },
    sceLFatFs_driver: {"0x8F0560E0": "sceLfatfsStop", "0x933F6E29": "sceLfatfsWaitReady"},
    LflashFatfmt: {"0xB7A424A4": "sceLflashFatfmtStartFatfmt"},
    sceVshLftvMw: {
      "0x0DA3EB39": "eventMgrCallbackDetach",
      "0x3B433436": "sysInfoWriteMAC",
      "0x7535F226": "eventMgrCallbackAttach",
      "0x7CA858EC": "sysInfoWriteUniqueId",
      "0xD60D6F2D": "lfxReleaseFrameBuffer",
      "0xE16F62EC": "sysInfoWriteModelInfo",
      "0xE6A8CAC0": "lfxGetNextFrame"
    },
    sceAac: {
      "0x02098C69": "sceAacGetInfoToAddStreamData",
      "0x23D35CAE": "sceAacTermResource",
      "0x33B8C009": "sceAacExit",
      "0x506BF66C": "sceAacGetSumDecodedSample",
      "0x523347D9": "sceAacGetLoopNum",
      "0x5CFFC57C": "sceAacInitResource",
      "0x61AA43C9": "sceAacEndEntry",
      "0x6C05813B": "sceAacStartEntry",
      "0x6DC7758A": "sceAacGetMaxOutputSample",
      "0x7E4CFEE4": "sceAacDecode",
      "0xAC6DCBE3": "sceAacNotifyAddStreamData",
      "0xBBDD6403": "sceAacSetLoopNum",
      "0xD2DA2BBA": "sceAacResetPlayPosition",
      "0xD7C51541": "sceAacCheckStreamDataNeeded",
      "0xE0C89ACA": "sceAacInit"
    },
    sceAsfParser: {
      "0x2CB147F7": "sceAsfGetFrameData",
      "0x3CAAC462": "sceAsfReadData",
      "0x6B3AE857": "sceAsfSeekTime",
      "0x91B11F3A": "sceAsfInitParser",
      "0x95AD7B34": "sceAsfCheckNeedMem"
    },
    sceAtrac3plus: {
      "0x0E2A73AB": "sceAtracSetData",
      "0x0FAE370E": "sceAtracSetHalfwayBufferAndGetID",
      "0x132F1ECA": "sceAtracReinit",
      "0x31668BAA": "sceAtracGetChannel",
      "0x36FAABFB": "sceAtracGetNextSample",
      "0x3F6E26B5": "sceAtracSetHalfwayBuffer",
      "0x5622B7C1": "sceAtracSetAA3DataAndGetID",
      "0x5CF9D852": "sceAtracSetMOutHalfwayBuffer",
      "0x5D268707": "sceAtracGetStreamDataInfo",
      "0x5DD66588": "sceAtracSetAA3HalfwayBufferAndGetID",
      "0x61EB33F5": "sceAtracReleaseAtracID",
      "0x644E5607": "sceAtracResetPlayPosition",
      "0x6A8C3CD5": "sceAtracDecodeData",
      "0x780F88D1": "sceAtracGetAtracID",
      "0x7A20E7AF": "sceAtracSetDataAndGetID",
      "0x7DB31251": "sceAtracAddStreamData",
      "0x83BF7AFD": "sceAtracSetSecondBuffer",
      "0x83E85EA0": "sceAtracGetSecondBufferInfo",
      "0x868120B5": "sceAtracSetLoopNum",
      "0x9AE849A7": "sceAtracGetRemainFrame",
      "0x9CD7DE03": "sceAtracSetMOutHalfwayBufferAndGetID",
      "0xA2BBA8BE": "sceAtracGetSoundSample",
      "0xA554A158": "sceAtracGetBitrate",
      "0xB3B5D042": "sceAtracGetOutputChannel",
      "0xCA3CA3D2": "sceAtracGetBufferInfoForReseting",
      "0xD1F59FDB": "sceAtracStartEntry",
      "0xD5C28CC0": "sceAtracEndEntry",
      "0xD6A5F2F7": "sceAtracGetMaxSample",
      "0xE23E3A35": "sceAtracGetNextDecodePosition",
      "0xE88F759B": "sceAtracGetInternalErrorInfo",
      "0xECA32A99": "sceAtracIsSecondBufferNeeded",
      "0xFAA4F89B": "sceAtracGetLoopStatus"
    },
    sceAudiocodec2: {
      "0x21D5A83F": "sceAudiocodec2Decode",
      "0xAA2ED267": "sceAudiocodec2CheckNeedMem",
      "0xE063D402": "sceAudiocodec2Init"
    },
    sceDNAS_lib: {
      "0x0D560144": "sceDNASInit",
      "0x45C1AAF5": "sceDNASGetEventFlag",
      "0x6929100C": "sceDNASGetProductCode",
      "0x9FF48DD3": "sceDNASStop",
      "0xA646E771": "sceDNASGetState",
      "0xBE0998D7": "sceDNASTerm",
      "0xCA8B8909": "sceDNASNetStart",
      "0xF3787AD8": "sceDNASInternalStart"
    },
    sceDNASCore_lib: {
      "0x15096ECD": "sceDNASCoreGetHostname",
      "0x2370130E": "sceDNASCoreCheckProxyResponse",
      "0x26E1E2BD": "sceDNASCoreSetChallenge",
      "0x2B6C67EA": "sceDNASCoreCheckGameInfoFlag",
      "0x4108128B": "sceDNASCoreMakeConnect",
      "0x80CEC43A": "sceDNASCoreMakeResponse",
      "0x822357BB": "sceDNASCoreGetResponse",
      "0x8309549E": "sceDNASCoreSetResult",
      "0xB6C76A14": "sceDNASCoreCheckChallenge",
      "0xBA0A32CA": "sceDNASCoreCheckResult",
      "0xBF6A7475": "sceDNASCoreGetProductCode",
      "0xC54657B7": "sceDNASCoreSetProxyResponse",
      "0xD5E80301": "sceDNASCoreTerm",
      "0xDA5939B4": "sceDNASCoreGetProxyRequest",
      "0xF0EB4367": "sceDNASCoreGetConnect",
      "0xF479F616": "sceDNASCoreGetHostnameBase",
      "0xFA571A75": "sceDNASCoreInit"
    },
    sceLibFont_ARIB: {},
    sceLibFont_HV: {
      "0x02D7F94B": "sceFontFlush",
      "0x099EF33C": "sceFontFindOptimumFont",
      "0x0DA7535E": "sceFontGetFontInfo",
      "0x27F6E642": "sceFontGetNumFontList",
      "0x2F67356A": "sceFontCalcMemorySize",
      "0x3AEA8CB6": "sceFontClose",
      "0x3C4B7E82": "sceFontPointToPixelV",
      "0x472694CD": "sceFontPointToPixelH",
      "0x48293280": "sceFontSetResolution",
      "0x48B06520": "sceFontGetShadowImageRect",
      "0x5333322D": "sceFontGetFontInfoByIndexNumber",
      "0x568BE516": "sceFontGetShadowGlyphImage",
      "0x574B6FBC": "sceFontDoneLib",
      "0x57FCB733": "sceFontOpenUserFile",
      "0x5C3E4A9E": "sceFontGetCharImageRect",
      "0x5DCF6858": "sceFontGetShadowGlyphImage_Clip",
      "0x67F17ED7": "sceFontNewLib",
      "0x681E61A7": "sceFontFindFont",
      "0x74B21701": "sceFontPixelToPointH",
      "0x980F4895": "sceFontGetCharGlyphImage",
      "0xA834319D": "sceFontOpen",
      "0xAA3DE7B5": "sceFontGetShadowInfo",
      "0xBB8E7FE6": "sceFontOpenUserMemory",
      "0xBC75D85B": "sceFontGetFontList",
      "0xCA1E6945": "sceFontGetCharGlyphImage_Clip",
      "0xDCC80C2F": "sceFontGetCharInfo",
      "0xEE232411": "sceFontSetAltCharacterCode",
      "0xF8F0752E": "sceFontPixelToPointV"
    },
    sceHttp: {
      "0x0282A3BD": "sceHttpGetContentLength",
      "0x03D9526F": "sceHttpSetResolveRetry",
      "0x06488A1C": "sceHttpSetCookieSendCallback",
      "0x0809C831": "sceHttpEnableRedirect",
      "0x0B12ABFB": "sceHttpDisableCookie",
      "0x0DAFA58F": "sceHttpEnableCookie",
      "0x15540184": "sceHttpDeleteHeader",
      "0x1A0EBB69": "sceHttpDisableRedirect",
      "0x1CEDB9D4": "sceHttpFlushCache",
      "0x1F0FC3E3": "sceHttpSetRecvTimeOut",
      "0x2255551E": "sceHttpGetNetworkPspError",
      "0x267618F4": "sceHttpSetAuthInfoCallback",
      "0x2A6C3296": "sceHttpSetAuthInfoCB",
      "0x2C3C82CF": "sceHttpFlushAuthList",
      "0x3A67F306": "sceHttpSetCookieRecvCallback",
      "0x3EABA285": "sceHttpAddExtraHeader",
      "0x47347B50": "sceHttpCreateRequest",
      "0x47940436": "sceHttpSetResolveTimeOut",
      "0x4CC7D78F": "sceHttpGetStatusCode",
      "0x5152773B": "sceHttpDeleteConnection",
      "0x54E7DF75": "sceHttpIsRequestInCache",
      "0x569A1481": "sceHttpsSetSslCallback",
      "0x59E6D16F": "sceHttpEnableCache",
      "0x68AB0F86": "sceHttpsInitWithPath",
      "0x76D1363B": "sceHttpSaveSystemCookie",
      "0x7774BF4C": "sceHttpAddCookie",
      "0x77EE5319": "sceHttpLoadAuthList",
      "0x78A0D3EC": "sceHttpEnableKeepAlive",
      "0x78B54C09": "sceHttpEndCache",
      "0x87797BDD": "sceHttpsLoadDefaultCert",
      "0x8ACD1F73": "sceHttpSetConnectTimeOut",
      "0x8EEFD953": "sceHttpCreateConnection",
      "0x951D310E": "sceHttpDisableProxyAuth",
      "0x9668864C": "sceHttpSetRecvBlockSize",
      "0x96F16D3E": "sceHttpGetCookie",
      "0x9988172D": "sceHttpSetSendTimeOut",
      "0x9AFC98B2": "sceHttpSendRequestInCacheFirstMode",
      "0x9B1F1F36": "sceHttpCreateTemplate",
      "0x9FC5F10D": "sceHttpEnableAuth",
      "0xA4496DE5": "sceHttpSetRedirectCallback",
      "0xA5512E01": "sceHttpDeleteRequest",
      "0xA6800C34": "sceHttpInitCache",
      "0xAB1540D5": "sceHttpsGetSslError",
      "0xAB1ABE07": "sceHttpInit",
      "0xAE948FEE": "sceHttpDisableAuth",
      "0xB0C34B1D": "sceHttpSetCacheContentLengthMaxSize",
      "0xB3FAF831": "sceHttpsDisableOption",
      "0xB509B09E": "sceHttpCreateRequestWithURL",
      "0xBAC31BF1": "sceHttpsEnableOption",
      "0xBB70706F": "sceHttpSendRequest",
      "0xC10B6BD9": "sceHttpAbortRequest",
      "0xC6330B0D": "sceHttpChangeHttpVersion",
      "0xC7EF2559": "sceHttpDisableKeepAlive",
      "0xC98CBBA7": "sceHttpSetResHeaderMaxSize",
      "0xCCBD167A": "sceHttpDisableCache",
      "0xCDB0DC58": "sceHttpEnableProxyAuth",
      "0xCDF8ECB9": "sceHttpCreateConnectionWithURL",
      "0xD081EC8F": "sceHttpGetNetworkErrno",
      "0xD11DAB01": "sceHttpsGetCaList",
      "0xD1C8945E": "sceHttpEnd",
      "0xD70D4847": "sceHttpGetProxy",
      "0xDB266CCF": "sceHttpGetAllHeader",
      "0xDD6E7857": "sceHttpSaveAuthList",
      "0xE4D21302": "sceHttpsInit",
      "0xEDEEB999": "sceHttpReadData",
      "0xF0F46C62": "sceHttpSetProxy",
      "0xF1657B22": "sceHttpLoadSystemCookie",
      "0xF49934F6": "sceHttpSetMallocFunction",
      "0xF9D8EB63": "sceHttpsEnd",
      "0xFCF8C055": "sceHttpDeleteTemplate"
    },
    sceMp3: {
      "0x07EC321A": "sceMp3ReserveMp3Handle",
      "0x0DB149F4": "sceMp3NotifyAddStreamData",
      "0x2A368661": "sceMp3ResetPlayPosition",
      "0x354D27EA": "sceMp3GetSumDecodedSample",
      "0x35750070": "sceMp3InitResource",
      "0x3C2FA058": "sceMp3TermResource",
      "0x3CEF484F": "sceMp3SetLoopNum",
      "0x44E07129": "sceMp3Init",
      "0x732B042A": "sceMp3EndEntry",
      "0x7F696782": "sceMp3GetMp3ChannelNum",
      "0x87677E40": "sceMp3GetBitRate",
      "0x87C263D1": "sceMp3GetMaxOutputSample",
      "0x8AB81558": "sceMp3StartEntry",
      "0x8F450998": "sceMp3GetSamplingRate",
      "0xA703FE0F": "sceMp3GetInfoToAddStreamData",
      "0xD021C0FB": "sceMp3Decode",
      "0xD0A56296": "sceMp3CheckStreamDataNeeded",
      "0xD8F54A51": "sceMp3GetLoopNum",
      "0xF5478233": "sceMp3ReleaseMp3Handle"
    },
    sceParseHttp: {"0x8077A433": "sceParseHttpStatusLine", "0xAD7BFDEF": "sceParseHttpResponseHeader"},
    sceParseUri: {
      "0x062BB07E": "sceUriUnescape",
      "0x49E950EC": "sceUriEscape",
      "0x568518C9": "sceUriParse",
      "0x7EE318AF": "sceUriBuild",
      "0x8885A782": "sceUriSweepPath",
      "0x8AA55D17": "sceUriMerge"
    },
    pspvmc: {},
    sceHVSlim_Library: {},
    sceSsl: {
      "0x058D21C0": "sceSslGetNameEntryCount",
      "0x0EB43B06": "sceSslGetUsedMemoryCurrent",
      "0x17A10DCC": "sceSslGetNotBefore",
      "0x191CDEFF": "sceSslEnd",
      "0x1B7C8191": "sceSslGetIssuerName",
      "0x3DD5E023": "sceSslGetSubjectName",
      "0x5BFB6B61": "sceSslGetNotAfter",
      "0x957ECBE2": "sceSslInit",
      "0xB99EDE6A": "sceSslGetUsedMemoryMax",
      "0xCC0919B0": "sceSslGetSerialNumber",
      "0xD6D097B4": "sceSslGetNameEntryInfo"
    },
    sceSsl_lib: {
      "0x0217E73C": "PEM_ASN1_read_bio",
      "0x047AB6BB": "CRYPTO_time_cmp",
      "0x04E677AF": "ERR_clear_error",
      "0x064F5DF3": "CRYPTO_get_locked_mem_functions",
      "0x067173A8": "BIO_set_retry_write",
      "0x0861D934": "CRYPTO_malloc",
      "0x089FF1F1": "BIO_should_write",
      "0x09C45275": "EVP_PKEY_new",
      "0x0FD2F220": "BIO_method_name",
      "0x101D418A": "ERR_free_strings",
      "0x104F749D": "SSL_state",
      "0x19A0DB42": "BIO_method_type",
      "0x1BCA32E3": "BIO_retry_type",
      "0x1C2728A5": "RAND_set_rand_method",
      "0x1EC64594": "BIO_push",
      "0x21F2A35C": "RAND_bytes",
      "0x26A7CF72": "BIO_set_cb",
      "0x28B4DE33": "BIO_new_socket",
      "0x2E2E2B09": "SSL_get_rbio",
      "0x2FE7BB42": "CRYPTO_get_time_cb",
      "0x3454E622": "BIO_printf",
      "0x3E040FD4": "BIO_free",
      "0x3E3133D6": "SSL_shutdown",
      "0x4214B7AF": "SSL_CTX_set_timeout",
      "0x42DF4592": "SSL_CTX_set_quiet_shutdown",
      "0x47F7B97F": "ERR_peek_error",
      "0x4A6078CF": "BIO_get_retry_reason",
      "0x4AE72675": "RAND_get_rand_method",
      "0x4AF959E3": "SSL_set_quiet_shutdown",
      "0x4E0F2CCC": "SSL_CTX_flush_sessions",
      "0x54A7D8F3": "SSL_clear",
      "0x558CAA41": "BIO_get_cb",
      "0x5605C9FE": "SSL_set_verify_result",
      "0x56E19CEB": "RAND_cleanup",
      "0x57F2E960": "SSL_version",
      "0x58352068": "BIO_new_mem",
      "0x588F2FE8": "SSL_CTX_free",
      "0x5AD14F0B": "CRYPTO_set_id_cb",
      "0x5DED429A": "BIO_new",
      "0x5E5C873A": "CRYPTO_free",
      "0x6053B79C": "CRYPTO_malloc_locked",
      "0x624CB314": "BIO_copy_next_retry",
      "0x665D02F6": "CRYPTO_time_offset",
      "0x675AC5AA": "BIO_read",
      "0x69F1B678": "SSL_set_session",
      "0x6A19E0AA": "SSL_get_quiet_shutdown",
      "0x6CDEB823": "CRYPTO_get_id_cb",
      "0x7317C1BC": "EVP_PKEY_free",
      "0x732F4E44": "BIO_pop",
      "0x795B9EDF": "SSL_CTX_get_timeout",
      "0x80608663": "SSL_set_connect_state",
      "0x8390B321": "SSL_use_PrivateKey",
      "0x84833472": "SSL_free",
      "0x868C15DF": "SSL_get_wbio",
      "0x86D4034D": "SSL_set_shutdown",
      "0x88897D26": "SSL_get_current_cipher",
      "0x88A96ED0": "BIO_clear_retry_flags",
      "0x8A2F6963": "BIO_set_retry_read",
      "0x9052D21A": "BIO_should_retry",
      "0x9274BFE3": "SSL_library_init_custom",
      "0x9566709F": "BIO_ctrl",
      "0x959557F5": "BIO_free_all",
      "0x95E346AB": "SSL_get_info_cb",
      "0x9CDCA0D7": "ERR_put_error",
      "0x9D8A385E": "CRYPTO_thread_id",
      "0x9EF66756": "CRYPTO_time_export",
      "0xA1C3AB31": "RAND_default_method",
      "0xA2619268": "CRYPTO_set_mem_functions",
      "0xA2CE8DCD": "SSL_CIPHER_get_name",
      "0xA7BED83B": "CRYPTO_time",
      "0xA8F0AD39": "SSL_reuse",
      "0xA920B39E": "d2i_PrivateKey",
      "0xAA3B27CF": "SSL_get_verify_result",
      "0xABCD28B8": "BIO_should_io_special",
      "0xAEBF278B": "SSL_CTX_set_verify",
      "0xAFD1D124": "BIO_gets",
      "0xB0B90785": "CRYPTO_get_mem_functions",
      "0xB3B04C58": "SSL_get_error",
      "0xB40D11EA": "SSLv3_client_method",
      "0xB4D78E98": "SSL_CTX_ctrl",
      "0xB7CA8717": "SSL_write",
      "0xB81AD643": "SSL_CTX_remove_session",
      "0xB9C8CCE6": "SSL_set_bio",
      "0xBB1564A3": "SSL_get_ex_data_X509_STORE_CTX_idx",
      "0xBDAD0841": "SSL_SESSION_free",
      "0xBE5FF9F1": "PEM_do_header",
      "0xBF55C31C": "SSL_CTX_set_client_cert_cb",
      "0xC0ABBB57": "SSL_use_certificate",
      "0xC270B3A8": "SSL_set_info_cb",
      "0xC97D0510": "SSL_want",
      "0xCA6A3C74": "BIO_get_retry_flags",
      "0xCED07EAE": "BIO_write",
      "0xCF78BEFB": "SSL_library_cleanup",
      "0xD1205C58": "SSL_get_shutdown",
      "0xD49A570C": "SSL_get_default_timeout",
      "0xD84E2411": "CRYPTO_lock",
      "0xD8C05497": "ERR_remove_state",
      "0xDEA6EDB2": "RAND_seed",
      "0xE14101E4": "SSL_CTX_get_quiet_shutdown",
      "0xE3C30923": "BIO_should_read",
      "0xE5FC4992": "CRYPTO_free_locked",
      "0xE78AD94D": "ERR_get_error",
      "0xE7BFC0EF": "CRYPTO_time_import",
      "0xE7C29542": "SSL_read",
      "0xE92302C5": "SSL_get_SSL_CTX",
      "0xEBFB0E3C": "SSL_new",
      "0xEE624680": "BIO_set_retry_special",
      "0xEF5A4BD4": "SSL_get_session",
      "0xFB8273FE": "SSL_CTX_new"
    },
    sceLibUpdateDL: {
      "0x4F49C9C1": "sceUpdateDownloadAbort",
      "0xB5DB018D": "sceUpdateDownloadSetServerRegion",
      "0xC1AF1076": "sceUpdateDownloadSetVersion",
      "0xD6A09757": "sceUpdateDownloadEnd",
      "0xF6690A9A": "sceUpdateDownloadInitEx",
      "0xFA9AA797": "sceUpdateDownloadReadData",
      "0xFC1AB540": "sceUpdateDownloadInit",
      "0xFD675E8D": "sceUpdateDownloadConnectServer"
    },
    sceHVWWW_Library: {},
    LoadCoreForKernel: {},
    LoadExecForKernel: {},
    LoadExecForUser: {
      "0x05572A5F": "sceKernelExitGame",
      "0x2AC9954B": "sceKernelExitGameWithStatus",
      "0x4AC57943": "sceKernelRegisterExitCallback",
      "0xBD2F1094": "sceKernelLoadExec"
    },
    sceSysreg_driver: {
      "0x16909002": "sceSysregAtaBusClockEnable",
      "0x1C4C4C7A": "sceSysregEmcsmIoDisable",
      "0x20388C9E": "sceSysregSircsClkDisable",
      "0x26FA0928": "sceSysregSircsIoDisable",
      "0x2D0F7755": "sceSysregEmcsmBusClockDisable",
      "0x4C49A8BC": "sceSysregSircsIoEnable",
      "0x4F46EEDE": "sceSysregGetFuseId",
      "0x6417CDD6": "sceSysregSircsClkEnable",
      "0x7725CA08": "sceSysregUartClkEnable",
      "0x7FD7A631": "sceSysregUartIoEnable",
      "0x8835D1E1": "sceSysregSpiClkEnable",
      "0x8B90B8B5": "sceSysregSpiClkDisable",
      "0x8C5C53DE": "sceSysregSpiIoEnable",
      "0x8F4F4E96": "sceSysregGetFuseConfig",
      "0x9C863542": "sceSysregInit",
      "0x9DD1F821": "sceSysregEmcsmIoEnable",
      "0xA16E55F4": "sceSysregSpiIoDisable",
      "0xA3E4154C": "sceSysregUartClkDisable",
      "0xB6C10DF0": "sceSysregAtaBusClockDisable",
      "0xBB823481": "sceSysregUartIoDisable",
      "0xD6628A48": "sceSysregSpiClkSelect",
      "0xE2A5D1EE": "sceSysregGetTachyonVersion",
      "0xF2DEAA14": "sceSysregEnd",
      "0xF97D9D73": "sceSysregEmcsmBusClockEnable"
    },
    sceGpio_driver: {
      "0x103C3EB2": "sceGpioPortClear",
      "0x17DAA8C2": "sceGpioSuspend",
      "0x310F0CCF": "sceGpioPortSet",
      "0x317D9D2C": "sceGpioSetPortMode",
      "0x4A992B24": "sceGpioEnd",
      "0x64CD4536": "sceGpioResume",
      "0x95D7F3B8": "sceGpioDisableIntr",
      "0xEABDB328": "sceGpioInit"
    },
    scePwm_driver: {},
    sceI2c_driver: {},
    sceDmac: {"0x617F3FE6": "sceDmacMemcpy", "0xD97F94D8": "sceDmacTryMemcpy"},
    sceDmacplus_driver: {},
    sceLcdc_driver: {},
    sceNand_driver: {
      "0x01F09203": "sceNandIsBadBlock",
      "0x0ADC8686": "sceNandWriteAccess",
      "0x0BEE8F36": "sceNandSetScramble",
      "0x0F9BBBBD": "sceNandResume",
      "0x18B78661": "sceNandVerifyEcc",
      "0x2674CFFE": "sceNandEraseAllBlock",
      "0x2FF6081B": "sceNandDetectChipMakersBBM",
      "0x3F76BC21": "sceNandDumpWearBBMSize",
      "0x41FFA822": "sceNandUnlock",
      "0x5182C394": "sceNandReadExtraOnly",
      "0x5AC02755": "sceNandVerifyBlockWithRetry",
      "0x716CD2B2": "sceNandWriteBlock",
      "0x73A68408": "sceNandSuspend",
      "0x766756EF": "sceNandReadAccess",
      "0x7AF7B77A": "sceNandReset",
      "0x84EE5D76": "sceNandSetWriteProtect",
      "0x88CC9F72": "sceNandCorrectEcc",
      "0x8932166A": "sceNandWritePagesRawExtra",
      "0x8933B2E0": "sceNandEraseBlockWithRetry",
      "0x89BDCA08": "sceNandReadPages",
      "0x8AF0AB9F": "sceNandWritePages",
      "0x9B2AC433": "sceNandTestBlock",
      "0xA513BB12": "sceNandInit",
      "0xAE4438C7": "sceNandLock",
      "0xB07C41D4": "sceNandGetPagesPerBlock",
      "0xB2B021E5": "sceNandWriteBlockWithVerify",
      "0xB795D2ED": "sceNandCollectEcc",
      "0xBADD5D46": "sceNandWritePagesRawAll",
      "0xC1376222": "sceNandGetTotalBlocks",
      "0xC29DA136": "sceNandDoMarkAsBadBlock",
      "0xC32EA051": "sceNandReadBlockWithRetry",
      "0xC478C1DE": "sceNandReadPagesRawAll",
      "0xCE9843E6": "sceNandGetPageSize",
      "0xD305870E": "sceNandEnd",
      "0xD897C343": "sceNandDetectChip",
      "0xE05AE88D": "sceNandReadPagesRawExtra",
      "0xE41A11DE": "sceNandReadStatus",
      "0xEB0A0022": "sceNandEraseBlock",
      "0xEBA0E6C6": "sceNandCountChipMakersBBM",
      "0xEF55F193": "sceNandCalcEcc",
      "0xFCDF7610": "sceNandReadId"
    },
    sceDdr_driver: {
      "0x17D39E17": "sceDdrInit",
      "0x623A233F": "sceDdrSuspend",
      "0x8698F5DA": "sceDdrEnd",
      "0x87D86769": "sceDdrFlush",
      "0x92289EC0": "sceDdrResume"
    },
    sceMcctrl: {},
    mcore: {},
    sceMeWrapper_driver: {},
    sceMeVideo_driver: {},
    sceMeAudio_driver: {},
    sceMeMemory_driver: {},
    sceMeCore_driver: {},
    sceMePower_driver: {},
    sceUmd: {"0x8EF08FCE": "sceUmdWaitDriveStat", "0xC6183D47": "sceUmdActivate", "0xE83742BA": "sceUmdDeactivate"},
    sceUmdUser: {
      "0x20628E6F": "sceUmdGetErrorStat",
      "0x340B7686": "sceUmdGetDiscInfo",
      "0x46EBB729": "sceUmdCheckMedium",
      "0x4A9E5E29": "sceUmdWaitDriveStatCB",
      "0x56202973": "sceUmdWaitDriveStatWithTimer",
      "0x6AF9B50A": "sceUmdCancelWaitDriveStat",
      "0x6B4A146C": "sceUmdGetDriveStat",
      "0x87533940": "sceUmdReplaceProhibit",
      "0x8EF08FCE": "sceUmdWaitDriveStat",
      "0xAEE7404D": "sceUmdRegisterUMDCallBack",
      "0xBD2BDE07": "sceUmdUnRegisterUMDCallBack",
      "0xC6183D47": "sceUmdActivate",
      "0xCBE9F02A": "sceUmdReplacePermit",
      "0xE83742BA": "sceUmdDeactivate"
    },
    sceMemab_driver: {},
    memlmd: {},
    semaphore: {
      "0x00EEC06A": "sceUtilsBufferCopy",
      "0x4C537C72": "sceUtilsBufferCopyWithRange",
      "0x77E97079": "sceUtilsBufferCopyByPollingWithRange",
      "0x8EEB7BF2": "sceUtilsBufferCopyByPolling"
    },
    sceMesgLed_driver: {},
    sceResmap_driver: {"0x4434E59F": "sceResmapPrepareByPolling", "0xE5659590": "sceResmapPrepare"},
    sceDbman_driver: {"0x34B53D46": "sceDbmanSelectByPolling", "0xB2B8C3F9": "sceDbmanSelect"},
    sceNwman_driver: {},
    sceResmgr_driver: {},
    sceResmgr: {},
    sceMesgd_driver: {},
    sceWmd_driver: {},
    sceDbsvr_driver: {"0x94561901": "sceDbsvrGetData"},
    sceMesgIns_driver: {},
    scePauth_driver: {},
    scePauth: {},
    sceMgMemoryStick_driver: {},
    sceMgr_driver: {},
    sceMgVideo_driver: {},
    sceMlnBridge_driver: {},
    sceMlnBridge: {
      "0x13E68009": "sceMlnBridgeAesEcbEncrypt",
      "0x3505ECCE": "sceMlnBridgeHMAC",
      "0x54EDC552": "sceMlnBridgeSHA1",
      "0x7770FC23": "sceMlnBridgeAesCbcDecrypt",
      "0x8D7E61DD": "sceMlnBridgeAesEcbDecrypt",
      "0xDE730A46": "sceMlnBridgeAesCbcEncrypt"
    },
    mlnusb: {},
    sceHVFlash_Module: {},
    ModuleMgrForUser: {
      "0x1196472E": "sceKernelLoadModuleBufferMs",
      "0x24EC0641": "sceKernelLoadModuleBufferApp",
      "0x2E0911AA": "sceKernelUnloadModule",
      "0x50F0C1EC": "sceKernelStartModule",
      "0x644395E2": "sceKernelGetModuleIdList",
      "0x710F61B5": "sceKernelLoadModuleMs",
      "0x748CBED9": "sceKernelQueryModuleInfo",
      "0x977DE386": "sceKernelLoadModule",
      "0xB7F46618": "sceKernelLoadModuleByID",
      "0xCC1D3699": "sceKernelStopUnloadSelfModule",
      "0xD1FF982A": "sceKernelStopModule",
      "0xD2FBC957": "sceKernelGetModuleGPByAddress",
      "0xD675EBB8": "sceKernelSelfStopUnloadModule",
      "0xD8B73127": "sceKernelGetModuleIdByAddress",
      "0xF0A26395": "sceKernelGetModuleId",
      "0xF9275D98": "sceKernelLoadModuleBufferUsbWlan"
    },
    ModuleMgrForKernel: {
      "0x1CF0B794": "sceKernelLoadModuleBufferBootInitBtcnf",
      "0x253AA17C": "sceKernelLoadModuleBufferForExitVSHKernel",
      "0x2F3F9B6A": "sceKernelLoadModuleBufferForLoadExecBufferVSHUsbWlan",
      "0x4E38EA1D": "sceKernelLoadModuleBufferForRebootKernel",
      "0x4E62C48A": "sceKernelLoadModuleBufferForKernel",
      "0x61E3EC69": "sceKernelLoadModuleBufferForExitGame",
      "0x9236B422": "sceKernelLoadModuleBufferForExitVSHVSH",
      "0xC13E2DE5": "sceKernelLoadModuleBufferForLoadExecBufferVSHUsbWlanDebug",
      "0xC6DE0B9C": "sceKernelLoadModuleBufferVSH"
    },
    sceMpeg: {
      "0x01977054": "sceMpegQueryUserdataEsSize",
      "0x0E3C2E9D": "sceMpegAvcDecode",
      "0x0F6C18D7": "sceMpegAvcDecodeDetail",
      "0x11F95CF1": "sceMpegGetAvcNalAu",
      "0x13407F13": "sceMpegRingbufferDestruct",
      "0x167AFD9E": "sceMpegInitAu",
      "0x211A057C": "sceMpegAvcQueryYCbCrSize",
      "0x21FF80E4": "sceMpegQueryStreamOffset",
      "0x234586AE": "sceMpegChangeGetAvcAuMode",
      "0x31BD0272": "sceMpegAvcCsc",
      "0x37295ED8": "sceMpegRingbufferConstruct",
      "0x3C37A7A6": "sceMpegNextAvcRpAu",
      "0x42560F23": "sceMpegRegistStream",
      "0x4571CC64": "sceMpegAvcDecodeFlush",
      "0x500F0429": "sceMpegFlushStream",
      "0x591A4AA2": "sceMpegUnRegistStream",
      "0x606A4649": "sceMpegDelete",
      "0x611E9E11": "sceMpegQueryStreamSize",
      "0x67179B1B": "sceMpegAvcInitYCbCr",
      "0x682A619B": "sceMpegInit",
      "0x6F314410": "sceMpegAvcDecodeGetDecodeSEI",
      "0x707B7629": "sceMpegFlushAllStream",
      "0x740FCCD1": "sceMpegAvcDecodeStop",
      "0x769BEBB6": "sceMpegRingbufferQueryPackNum",
      "0x800C44DF": "sceMpegAtracDecode",
      "0x874624D6": "sceMpegFinish",
      "0x8C1E027D": "sceMpegGetPcmAu",
      "0x921FCCCF": "sceMpegGetAvcEsAu",
      "0x9DCFB7EA": "sceMpegChangeGetAuMode",
      "0xA11C7026": "sceMpegAvcDecodeMode",
      "0xA780CF7E": "sceMpegMallocAvcEsBuf",
      "0xB240A59E": "sceMpegRingbufferPut",
      "0xB5F6DC87": "sceMpegRingbufferAvailableSize",
      "0xC02CF6B5": "sceMpegQueryPcmEsSize",
      "0xC132E22F": "sceMpegQueryMemSize",
      "0xC45C99CC": "sceMpegQueryUserdataEsSize",
      "0xCEB870B1": "sceMpegFreeAvcEsBuf",
      "0xCF3547A2": "sceMpegAvcDecodeDetail2",
      "0xD1CE4950": "sceMpegAvcCscMode",
      "0xD7A29F46": "sceMpegRingbufferQueryMemSize",
      "0xD8C5F121": "sceMpegCreate",
      "0xDBB60658": "sceMpegFlushAu",
      "0xE1CE83A7": "sceMpegGetAtracAu",
      "0xE95838F6": "sceMpegAvcCscInfo",
      "0xF0EB1125": "sceMpegAvcDecodeYCbCr",
      "0xF2930C9C": "sceMpegAvcDecodeStopYCbCr",
      "0xF8DCB679": "sceMpegQueryAtracEsSize",
      "0xFE246728": "sceMpegGetAvcAu"
    },
    sceMSAudio_driver: {},
    sceMSstor_driver: {"0x6FC1E8AE": "sceMSstorEntry", "0x714782D6": "sceMSstorRegisterCLDMSelf"},
    sceMScm_driver: {
      "0x0128147B": "sceMScmWriteMSReg",
      "0x0A054CDA": "sceMScmHCLastStatus",
      "0x21183216": "sceMScmWriteDataPIO",
      "0x2AD0A649": "sceMScmGetSlotState",
      "0x2D7C40FA": "sceMScmWaitHCIntr",
      "0x907D7766": "sceMScmSendTPC",
      "0xBE455B5D": "sceMScmReadDataPIO",
      "0xF82AF926": "sceMScmTPCSetCmd",
      "0xFF6C50D8": "sceMScmTPCGetInt"
    },
    sceMsVideo: {},
    sceMsVideoPluginHeap: {},
    music_browser: {},
    music_parser: {},
    music_player: {},
    sceVshNetconf: {},
    sceVshNetconfAoss: {},
    sceVshNetconfRaku: {},
    sceHVNetfront_Module: {
      "0x18CB51AB": "inflateInit_",
      "0x216D1BF1": "inflate",
      "0x461C7724": "inflateEnd",
      "0x85C2B45D": "uncompress"
    },
    sceNp: {},
    sceUmdMan_driver: {
      "0x0D3EA203": "sceUmdManTerm",
      "0x0DC8D26D": "sceUmdManWaitSema",
      "0x14D3381C": "sceUmdExecTestCmd",
      "0x1B19A313": "sceUmdExecInquiryCmd",
      "0x1F9AFFF4": "sceUmdManMediaPresent",
      "0x2CBE959B": "sceUmdExecReqSenseCmd",
      "0x47E2B6D8": "sceUmdManGetUmdDrive",
      "0x4FB913A3": "sceUmdManGetIntrStateFlag",
      "0x8CFED611": "sceUmdManStart",
      "0x9F106F73": "sceUmdManPollSema",
      "0xB0A43DA7": "sceUmdManSignalSema",
      "0xCAD31025": "sceUmdManStop",
      "0xE779ECEF": "sceUmdManGetInquiry"
    },
    sceUmd9660_driver: {},
    sceNpAuth: {},
    sceNpCommerce2: {},
    sceNpCommerce2RegCam: {},
    sceNpCommerce2Store: {},
    sceNpCore: {},
    sceNpInstall_driver: {},
    sceNpInstall_user: {},
    sceNpMatching2: {},
    sceNpService: {},
    scePspNpDrm_driver: {
      "0x00AD67F8": "sceNpDrmGetFixedKey",
      "0x08D98894": "sceNpDrmEdataSetupKey",
      "0x0F9547E6": "sceNpDrmGetVersionKey",
      "0x17E3F4BB": "sceNpDrmVerifyAct",
      "0x219EF5CC": "sceNpDrmEdataGetDataSize",
      "0x275987D1": "sceNpDrmRenameCheck",
      "0x37B9B10D": "sceNpDrmVerifyRif",
      "0x5667B7B9": "sceNpDrmGetContentKey",
      "0x9B745542": "sceNpDrmClearLicenseeKey",
      "0xA1336091": "sceNpDrmSetLicenseeKey",
      "0xD36B4E6D": "sceNpDrmGetModuleKey"
    },
    scePspNpDrm_user: {
      "0x08D98894": "sceNpDrmEdataSetupKey",
      "0x219EF5CC": "sceNpDrmEdataGetDataSize",
      "0x275987D1": "sceNpDrmRenameCheck",
      "0x9B745542": "sceNpDrmClearLicenseeKey",
      "0xA1336091": "sceNpDrmSetLicenseeKey"
    },
    scePspNpDrmVideoKey_driver: {},
    onesegCore: {},
    onesegHalToolbox: {},
    sceOnesegLnch: {},
    onesegSal: {},
    onesegSdk: {},
    onesegSdkCore: {},
    sceOpenPSID: {"0xC69BEBCE": "sceOpenPSIDGetOpenPSID"},
    sceOpenPSID_driver: {"0x19D579F0": "sceOpenPSIDGetPSID", "0xC69BEBCE": "sceOpenPSIDGetOpenPSID"},
    sceDdrdb_driver: {
      "0x05D50F41": "sceDdrdbEncrypt",
      "0x370F456A": "sceDdrdbCertvry",
      "0x40CB752A": "sceDdrdbHash",
      "0xB24E1391": "sceDdrdbSiggen",
      "0xB33ACB44": "sceDdrdbDecrypt",
      "0xB8218473": "sceDdrdbPrngen",
      "0xE27CE4CB": "sceDdrdbSigvry",
      "0xEC05300A": "sceDdrdbMul2",
      "0xF970D54E": "sceDdrdbMul1"
    },
    scePcact_driver: {"0x08BB9677": "scePcactAuth2BB", "0xF9ECFDDD": "scePcactAuth1BB"},
    sceMlnpsnl_driver: {"0x6885F392": "sceMlnpsnlAuth2BB", "0x8523E178": "sceMlnpsnlAuth1BB"},
    sceDdrdb: {},
    scePaf: {},
    photo_browser: {},
    photo_player: {},
    scePopsMan: {"0x0090B2C8": "scePopsManExitVSHKernel", "0x29B3FB24": "scePopsManLoadModule"},
    sceMeAudio: {},
    scePower: {
      "0x0074EF9B": "scePowerGetResumeCount",
      "0x0442D852": "scePowerRequestColdReset",
      "0x04B7766E": "scePowerRegisterCallback",
      "0x0AFD0D8B": "scePowerIsBatteryExist",
      "0x0CD21B1F": "scePowerSetPowerSwMode",
      "0x165CE085": "scePowerGetPowerSwMode",
      "0x1E490401": "scePowerIsBatteryCharging",
      "0x2085D15D": "scePowerGetBatteryLifePercent",
      "0x23436A4A": "scePowerGetInnerTemp",
      "0x23C31FFE": "scePowerVolatileMemLock",
      "0x27F3292C": "scePowerBatteryUpdateInfo",
      "0x28E12023": "scePowerGetBatteryTemp",
      "0x2B7C7CF4": "scePowerRequestStandby",
      "0x34F9C463": "scePowerGetPllClockFrequencyInt",
      "0x3951AF53": "scePowerWaitRequestCompletion",
      "0x442BFBAC": "scePowerGetBacklightMaximum",
      "0x478FE6F5": "scePowerGetBusClockFrequency",
      "0x483CE86B": "scePowerGetBatteryVolt",
      "0x737486F2": "scePowerSetClockFrequency",
      "0x78A1A796": "scePowerIsSuspendRequired",
      "0x7F30B3B1": "scePowerIdleTimerEnable",
      "0x7FA406DD": "scePowerIsRequest",
      "0x843FBF43": "scePowerSetCpuClockFrequency",
      "0x862AE1A6": "scePowerGetBatteryElec",
      "0x87440F5E": "scePowerIsPowerOnline",
      "0x8EFB3FA2": "scePowerGetBatteryLifeTime",
      "0x94F5A53F": "scePowerGetBatteryRemainCapacity",
      "0x972CE941": "scePowerIdleTimerDisable",
      "0x9BADB3EB": "scePowerGetBusClockFrequencyFloat",
      "0xA9D22232": "scePowerSetCallbackMode",
      "0xAC32C9CC": "scePowerRequestSuspend",
      "0xB1A52C83": "scePowerGetCpuClockFrequencyFloat",
      "0xB3EDD801": "scePowerVolatileMemUnlock",
      "0xB4432BC8": "scePowerGetBatteryChargingStatus",
      "0xB8D7B3FB": "scePowerSetBusClockFrequency",
      "0xB999184C": "scePowerGetLowBatteryCapacity",
      "0xBAFA3DF0": "scePowerGetCallbackMode",
      "0xBD681969": "scePowerGetBusClockFrequencyInt",
      "0xCA3D34C1": "scePowerUnlock",
      "0xCB49F5CE": "scePowerGetBatteryChargeCycle",
      "0xD3075926": "scePowerIsLowBattery",
      "0xD6D016EF": "scePowerLock",
      "0xDB62C9CF": "scePowerCancelRequest",
      "0xDB9D28DD": "scePowerUnregitserCallback",
      "0xDFA8BAF8": "scePowerUnregisterCallback",
      "0xEA382A27": "scePowerGetPllClockFrequencyFloat",
      "0xEDC13FE5": "scePowerGetIdleTimer",
      "0xEFD3C963": "scePowerTick",
      "0xFA97A599": "scePowerVolatileMemTryLock",
      "0xFD18A0FF": "scePowerGetBatteryFullCapacity",
      "0xFDB5BFE9": "scePowerGetCpuClockFrequencyInt",
      "0xFEE03A2F": "scePowerGetCpuClockFrequency"
    },
    scePower_driver: {
      "0x1BA2FCAE": "scePowerSetIdleCallback",
      "0x9CE06934": "scePowerInit",
      "0xAD5BB433": "scePowerEnd",
      "0xDB62C9CF": "scePowerCancelRequest",
      "0xFDB5BFE9": "scePowerGetCpuClockFrequencyInt"
    },
    scePsheet: {
      "0x15355B0E": "sceDRMInstallGetPkgInfo",
      "0x226D9099": "sceDRMInstallAbort",
      "0x302AB4B8": "sceDRMInstallInit",
      "0x34E68A41": "sceDRMInstallGetFileInfo",
      "0x3CEC4078": "sceDRMInstallEnd",
      "0xE16F3A48": "sceDRMInstallInstall"
    },
    scePsheet_driver: {
      "0x15355B0E": "sceDRMInstallGetPkgInfo",
      "0x226D9099": "sceDRMInstallAbort",
      "0x302AB4B8": "sceDRMInstallInit",
      "0x34E68A41": "sceDRMInstallGetFileInfo",
      "0x3CEC4078": "sceDRMInstallEnd",
      "0xE16F3A48": "sceDRMInstallInstall"
    },
    sceNet: {
      "0x0BF0A3AE": "sceNetGetLocalEtherAddr",
      "0x281928A9": "sceNetTerm",
      "0x39AF39A6": "sceNetInit",
      "0x50647530": "sceNetFreeThreadinfo",
      "0x89360950": "sceNetEtherNtostr",
      "0xAD6844C6": "sceNetThreadAbort",
      "0xCC393E48": "sceNetGetMallocStat",
      "0xD27961C9": "sceNetEtherStrton"
    },
    sceNet_lib: {
      "0x13A8B98A": "_sce_pspnet_ifioctl",
      "0x1858883D": "sceNetRand",
      "0x1D10419C": "_sce_pspnet_ifunit",
      "0x1FB2FDDD": "sceNetAtoi",
      "0x205E8D17": "_sce_pspnet_tsleep",
      "0x25CC373A": "_sce_pspnet_callout_init",
      "0x2A73ADDC": "sceNetStrtoul",
      "0x2F305274": "sceNetBcopy",
      "0x41FD8B5C": "_sce_pspnet_hashdone",
      "0x435843CB": "_sce_pspnet_get_thread_errno",
      "0x45452B7B": "_sce_pspnet_thread_busycount",
      "0x4753D878": "sceNetMemmove",
      "0x4BF83CF4": "sceNetBcmp",
      "0x515B2F33": "_sce_pspnet_splunlock",
      "0x5216CBF5": "sceNetConfigUpInterface",
      "0x522A971B": "_sce_pspnet_if_exist",
      "0x5705F6F9": "sceNetStrcat",
      "0x57CC57DA": "sceNetMemset",
      "0x6D5D42D7": "_sce_pspnet_lock_threadinfo",
      "0x701DDDC3": "_sce_pspnet_if_attach",
      "0x710BD467": "_sce_pspnet_get_ifindex",
      "0x750F705D": "sceNetLook_ctype_table",
      "0x7574FDA1": "_sce_pspnet_wakeup",
      "0x75D9985C": "sceNetGetSystemClockSec",
      "0x7C86FBA4": "_sce_pspnet_callout_reset",
      "0x80C9F02A": "sceNetStrcpy",
      "0x80E1933E": "sceNetConfigGetIfEventFlag",
      "0x8687B5AB": "sceNetVsprintf",
      "0x8B615F52": "sceNetBzero",
      "0x8D33C11D": "sceNetConfigGetEtherAddr",
      "0x8E798A2F": "sceNetMemchr",
      "0x94B44F26": "_sce_pspnet_spllock",
      "0x94DCA9F0": "sceNetStrncmp",
      "0x96EF9DA1": "sceNetTolower",
      "0x976AB1E9": "sceNetEnablePSPWlanReset",
      "0x9CFBC7E3": "sceNetStrcasecmp",
      "0xA0F16ABD": "sceNetStrcmp",
      "0xA93A93E9": "_sce_pspnet_callout_stop",
      "0xAB7DD9A5": "sceNetConfigSetIfEventFlag",
      "0xB5CE388A": "sceNetStrncpy",
      "0xB8C4A858": "_sce_pspnet_tiwakeup",
      "0xB9085A96": "sceNetStrncasecmp",
      "0xB9C780C7": "_sce_pspnet_selwakeup",
      "0xBB2B3DDB": "_sce_pspnet_get_threadinfo",
      "0xBCBE14CF": "sceNetStrchr",
      "0xC21E18B2": "_sce_pspnet_unlock_threadinfo",
      "0xC4261339": "_sce_pspnet_hashinit",
      "0xC9C97945": "_sce_pspnet_tabort",
      "0xCA3CF5EB": "_sce_pspnet_thread_enter",
      "0xCF705E46": "sceNetSprintf",
      "0xD1BE2CE9": "sceNetConfigGetIfEvent",
      "0xD2422E4D": "sceNetConfigDownInterface",
      "0xD5A03BC0": "_sce_pspnet_if_detach",
      "0xD861EF33": "_sce_pspnet_set_thread_errno",
      "0xD8722983": "sceNetStrlen",
      "0xE0A81C7C": "sceNetMemcmp",
      "0xEA42B353": "_sce_pspnet_ifioctl_sync",
      "0xEDB11CB4": "_sce_pspnet_if_down",
      "0xEF097716": "sceNetMemcpy",
      "0xF48963C6": "sceNetStrrchr",
      "0xFA6DE6A6": "_sce_pspnet_if_up"
    },
    sceNetAdhoc: {
      "0x0B2228E9": "sceNetAdhocGameModeDeleteReplica",
      "0x157E6225": "sceNetAdhocPtpClose",
      "0x3278AB0C": "sceNetAdhocGameModeCreateReplica",
      "0x4D2CE199": "sceNetAdhocGetSocketAlert",
      "0x4DA4C788": "sceNetAdhocPtpSend",
      "0x6F92741B": "sceNetAdhocPdpCreate",
      "0x73BFD52D": "sceNetAdhocSetSocketAlert",
      "0x7A662D6B": "sceNetAdhocPollSocket",
      "0x7F27BB5E": "sceNetAdhocPdpDelete",
      "0x7F75C338": "sceNetAdhocGameModeCreateMaster",
      "0x877F6D66": "sceNetAdhocPtpOpen",
      "0x8BEA2B3E": "sceNetAdhocPtpRecv",
      "0x98C204C8": "sceNetAdhocGameModeUpdateMaster",
      "0x9AC2EEAC": "sceNetAdhocPtpFlush",
      "0x9DF81198": "sceNetAdhocPtpAccept",
      "0xA0229362": "sceNetAdhocGameModeDeleteMaster",
      "0xA62C6F57": "sceNetAdhocTerm",
      "0xABED3790": "sceNetAdhocPdpSend",
      "0xB9685118": "sceNetAdhocGetPtpStat",
      "0xC7C1FC57": "sceNetAdhocGetPdpStat",
      "0xDFE53E03": "sceNetAdhocPdpRecv",
      "0xE08BDAC1": "sceNetAdhocPtpListen",
      "0xE1D621D7": "sceNetAdhocInit",
      "0xFA324B4E": "sceNetAdhocGameModeUpdateReplica",
      "0xFC6FC07B": "sceNetAdhocPtpConnect"
    },
    sceNetAdhoc_lib: {"0xAF6DFB15": "sceNetAdhocGameModeUpdateReplicaInternal"},
    sceNetAdhocAuth_lib: {"0x6074D8F1": "sceNetAdhocAuthTerm", "0x86004235": "sceNetAdhocAuthInit"},
    sceNetAdhocAuth_driver: {"0x6074D8F1": "sceNetAdhocAuthTerm", "0x86004235": "sceNetAdhocAuthInit"},
    sceNetAdhocDiscover: {
      "0x52DE1B97": "sceNetAdhocDiscoverUpdate",
      "0x941B3877": "sceNetAdhocDiscoverInitStart",
      "0x944DDBC6": "sceNetAdhocDiscoverGetStatus",
      "0xA2246614": "sceNetAdhocDiscoverTerm",
      "0xA423A21B": "sceNetAdhocDiscoverRequestSuspend",
      "0xF7D13214": "sceNetAdhocDiscoverStop"
    },
    sceNetAdhocDownload: {
      "0x117CA01A": "sceNetAdhocDownloadTermServer",
      "0x13DAB550": "sceNetAdhocDownloadCreateServer",
      "0x1AD5CC88": "sceNetAdhocDownloadAbortRecv",
      "0x22C2BCC6": "sceNetAdhocDownloadGetServerList",
      "0x2B6FB0DA": "sceNetAdhocDownloadStartServer",
      "0x3082F4E2": "sceNetAdhocDownloadInitClient",
      "0x314ED31E": "sceNetAdhocDownloadStartClient",
      "0x378D4311": "sceNetAdhocDownloadDeleteClient",
      "0x469F6B83": "sceNetAdhocDownloadStopClient",
      "0x4E6029F1": "sceNetAdhocDownloadRequestSession",
      "0x57A51DD0": "sceNetAdhocDownloadCreateClient",
      "0x7A483F9E": "sceNetAdhocDownloadDeleteServer",
      "0x8846D2B0": "sceNetAdhocDownloadRecv",
      "0x8A5500E0": "sceNetAdhocDownloadAbortRequestSession",
      "0xA21FEF45": "sceNetAdhocDownloadInitServer",
      "0xA70FDFBE": "sceNetAdhocDownloadAbortSend",
      "0xBF1433F0": "sceNetAdhocDownloadTermClient",
      "0xC421875C": "sceNetAdhocDownloadAbortReplySession",
      "0xD0189004": "sceNetAdhocDownloadSend",
      "0xF76147B1": "sceNetAdhocDownloadStopServer",
      "0xF8FC359E": "sceNetAdhocDownloadReplySession"
    },
    sceNetAdhocMatching: {
      "0x2A2A1E07": "sceNetAdhocMatchingInit",
      "0x32B156B3": "sceNetAdhocMatchingStop",
      "0x40F8F435": "sceNetAdhocMatchingGetPoolMaxAlloc",
      "0x5E3D4B79": "sceNetAdhocMatchingSelectTarget",
      "0x7945ECDA": "sceNetAdhocMatchingTerm",
      "0x8F58BEDF": "sceNetAdhocMatchingCancelTargetWithOpt",
      "0x93EF3843": "sceNetAdhocMatchingStart",
      "0x9C5CFB7D": "sceNetAdhocMatchingGetPoolStat",
      "0xB58E61B7": "sceNetAdhocMatchingSetHelloOpt",
      "0xB5D96C2A": "sceNetAdhocMatchingGetHelloOpt",
      "0xC58BCD9E": "sceNetAdhocMatchingGetMembers",
      "0xCA5EDA6F": "sceNetAdhocMatchingCreate",
      "0xEA3C6108": "sceNetAdhocMatchingCancelTarget",
      "0xEC19337D": "sceNetAdhocMatchingAbortSendData",
      "0xF16EAF4F": "sceNetAdhocMatchingDelete",
      "0xF79472D7": "sceNetAdhocMatchingSendData"
    },
    sceNetAdhocTransInt: {
      "0x0B1F77E1": "sceNetAdhocTransferSocketAbortParent",
      "0x0CAE4A7B": "sceNetAdhocTransferRequestSession",
      "0x24F04EF8": "sceNetAdhocTransferDeleteChild",
      "0x40D77905": "sceNetAdhocTransferGetChildRequest",
      "0x48381015": "sceNetAdhocTransferAbortRequestSession",
      "0x541E3EAB": "sceNetAdhocTransferTermChild",
      "0x552E0C4F": "sceNetAdhocTransferInitParent",
      "0x645E312A": "sceNetAdhocTransferStopChild",
      "0x658833CC": "sceNetAdhocTransferStartParent",
      "0x69F19666": "sceNetAdhocTransferCreateParent",
      "0x6D8B0D00": "sceNetAdhocTransferRecvParent",
      "0x6F595DFA": "sceNetAdhocTransferSocketAbortChild",
      "0x75DAEB6B": "sceNetAdhocTransferInitChild",
      "0x7CFB68C9": "sceNetAdhocTransferGetMallocStatChild",
      "0x83FA2BBA": "sceNetAdhocTransferAbortReplySession",
      "0x8897358A": "sceNetAdhocTransferGetParentList",
      "0x97D389A3": "sceNetAdhocTransferSendChild",
      "0x9C6EE447": "sceNetAdhocTransferSendParent",
      "0xA64B28F7": "sceNetAdhocTransferStartChil",
      "0xA735B9B2": "sceNetAdhocTransferTermParent",
      "0xAD0E88C6": "sceNetAdhocTransferReplySession",
      "0xB0975880": "sceNetAdhocTransferGetMallocStatParent",
      "0xCD469448": "sceNetAdhocTransferStopParent",
      "0xCD9F1D46": "sceNetAdhocTransferCreateChild",
      "0xD438691D": "sceNetAdhocTransferRecvChild",
      "0xE3707672": "sceNetAdhocTransferDeleteParent"
    },
    sceNetAdhocctl: {
      "0x08FFF7A0": "sceNetAdhocctlScan",
      "0x0AD043ED": "sceNetAdhocctlConnect",
      "0x1FF89745": "sceNetAdhocctlJoinEnterGameMode",
      "0x20B317A0": "sceNetAdhocctlAddHandler",
      "0x34401D65": "sceNetAdhocctlDisconnect",
      "0x362CBE8F": "sceNetAdhocctlGetAdhocId",
      "0x5A014CE0": "sceNetAdhocctlGetGameModeInfo",
      "0x5E7F79C9": "sceNetAdhocctlJoin",
      "0x6402490B": "sceNetAdhocctlDelHandler",
      "0x75ECD386": "sceNetAdhocctlGetState",
      "0x81AEE1BE": "sceNetAdhocctlGetScanInfo",
      "0x8916C003": "sceNetAdhocctlGetNameByAddr",
      "0x8DB83FDC": "sceNetAdhocctlGetPeerInfo",
      "0x99560ABE": "sceNetAdhocctlGetAddrByName",
      "0x9D689E13": "sceNetAdhocctlTerm",
      "0xA5C055CE": "sceNetAdhocctlCreateEnterGameMode",
      "0xCF8E084D": "sceNetAdhocctlExitGameMode",
      "0xDED9D28E": "sceNetAdhocctlGetParameter",
      "0xE162CB14": "sceNetAdhocctlGetPeerList",
      "0xE26F226E": "sceNetAdhocctlInit",
      "0xEC0635C1": "sceNetAdhocctlCreate"
    },
    sceNetAdhocctl_lib: {"0x1593C05D": "sceNetThreadExitDeleteEventFlag", "0x1C679240": "LinkDiscoverSkip"},
    sceNetApctl: {
      "0x04776994": "sceNetApctlGetBSSDescEntryUser",
      "0x24FE91A1": "sceNetApctlDisconnect",
      "0x2935C45B": "sceNetApctlGetBSSDescEntry2",
      "0x2BEFDF23": "sceNetApctlGetInfo",
      "0x5963991B": "sceNetApctlDelHandler",
      "0x5DEAC81B": "sceNetApctlGetState",
      "0x6BDDCB8C": "sceNetApctlGetBSSDescIDListUser",
      "0x8ABADD51": "sceNetApctlAddHandler",
      "0xA3E77E13": "sceNetApctlScanSSID2",
      "0xB3EDD0EC": "sceNetApctlTerm",
      "0xCFB957C6": "sceNetApctlConnect",
      "0xE2F91F9B": "sceNetApctlInit",
      "0xE9B2E5E6": "sceNetApctlScanUser",
      "0xF25A5006": "sceNetApctlGetBSSDescIDList2"
    },
    sceNetApctl_lib: {
      "0x0C7FFA5C": "sceNetApctlGetBSSDescIDList",
      "0x7CFAB990": "sceNetApctlAddInternalHandler",
      "0x96BEB231": "sceNetApctlGetBSSDescEntry",
      "0xA9721D11": "sceNetApctlScanSSID",
      "0xB3CF6849": "sceNetApctlScan",
      "0xE11BAFAB": "sceNetApctlDelInternalHandler"
    },
    sceNetApctl_internal_user: {
      "0x04776994": "sceNetApctlGetBSSDescEntryUser",
      "0x6BDDCB8C": "sceNetApctlGetBSSDescIDListUser",
      "0xE9B2E5E6": "sceNetApctlScanUser"
    },
    sceNetApctl_lib2: {},
    sceNetInet: {
      "0x05038FC7": "sceNetInetSendto",
      "0x162E6FD5": "sceNetInetGetsockname",
      "0x17943399": "sceNetInetInit",
      "0x1A33F9AE": "sceNetInetBind",
      "0x1BDF5D13": "sceNetInetInetAton",
      "0x2FE71FE7": "sceNetInetSetsockopt",
      "0x39B0C7D3": "sceNetInetGetUdpcbstat",
      "0x410B34AA": "sceNetInetConnect",
      "0x4A114C7C": "sceNetInetGetsockopt",
      "0x4CFE4E56": "sceNetInetShutdown",
      "0x5BE8D595": "sceNetInetSelect",
      "0x774E36F4": "sceNetInetSendmsg",
      "0x7AA671BC": "sceNetInetSend",
      "0x805502DD": "sceNetInetCloseWithRST",
      "0x80A21ABD": "sceNetInetSocketAbort",
      "0x8B7B220F": "sceNetInetSocket",
      "0x8CA3A97E": "sceNetInetGetPspError",
      "0x8D7284EA": "sceNetInetClose",
      "0xA9ED66B9": "sceNetInetTerm",
      "0xB3888AD4": "sceNetInetGetTcpcbstat",
      "0xB75D5B0A": "sceNetInetInetAddr",
      "0xC91142E4": "sceNetInetRecvfrom",
      "0xCDA85C99": "sceNetInetRecv",
      "0xD0792666": "sceNetInetInetNtop",
      "0xD10A1A7A": "sceNetInetListen",
      "0xDB094E1B": "sceNetInetAccept",
      "0xE247B6D6": "sceNetInetGetpeername",
      "0xE30B8C19": "sceNetInetInetPton",
      "0xEECE61D2": "sceNetInetRecvmsg",
      "0xFAABB1DD": "sceNetInetPoll",
      "0xFBABE411": "sceNetInetGetErrno"
    },
    sceNetInet_lib: {},
    sceNetResolver: {
      "0x12748EB9": "sceNetResolverWaitAsync",
      "0x14C17EF9": "sceNetResolverStartNtoAAsync",
      "0x224C5F44": "sceNetResolverStartNtoA",
      "0x244172AF": "sceNetResolverCreate",
      "0x4EE99358": "sceNetResolverPollAsync",
      "0x6138194A": "sceNetResolverTerm",
      "0x629E2FB7": "sceNetResolverStartAtoN",
      "0x808F6063": "sceNetResolverStop",
      "0x94523E09": "sceNetResolverDelete",
      "0xAAC09184": "sceNetResolverStartAtoNAsync",
      "0xF3370E61": "sceNetResolverInit"
    },
    sceNetStun: {},
    sceNetUpnp: {},
    sceNetWispr: {
      "0x19235F8C": "sceNetWisprStart",
      "0x757BDC9F": "sceNetWisprStop",
      "0xBC05EC73": "sceNetWisprTerm",
      "0xBD745B6D": "sceNetWisprInit"
    },
    sceReg: {
      "0x0CAE832B": "sceRegCloseCategory",
      "0x0D69BF40": "sceRegFlushCategory",
      "0x17768E14": "sceRegSetKeyValue",
      "0x1D8A762E": "sceRegOpenCategory",
      "0x28A8E98A": "sceRegGetKeyValue",
      "0x2C0DB9DD": "sceRegGetKeysNum",
      "0x2D211135": "sceRegGetKeys",
      "0x30BE0259": "sceRegGetKeyValueByName",
      "0x3615BC87": "sceRegRemoveKey",
      "0x39461B4D": "sceRegFlushRegistry",
      "0x4CA16893": "sceRegRemoveCategory",
      "0x57641A81": "sceRegCreateKey",
      "0x92E41280": "sceRegOpenRegistry",
      "0x9B25EDF1": "sceRegExit",
      "0xC5768D02": "sceRegGetKeyInfoByName",
      "0xD4475AA8": "sceRegGetKeyInfo",
      "0xDEDA92BF": "sceRegRemoveRegistry",
      "0xFA8A5739": "sceRegCloseRegistry"
    },
    sceReg_driver: {},
    rss_browser: {},
    rss_common: {},
    rss_downloader: {},
    sceRtc: {
      "0x011F03C1": "sceRtcGetAccumulativeTime",
      "0x029CA3B3": "sceRtcGetAccumlativeTime",
      "0x0498FB3C": "sceRtcFormatRFC3339",
      "0x05EF322C": "sceRtcGetDaysInMonth",
      "0x1909C99B": "sceRtcSetTime64_t",
      "0x203CEB0D": "sceRtcGetLastReincarnatedTime",
      "0x26D25A5D": "sceRtcTickAddMicroseconds",
      "0x26D7A24A": "sceRtcTickAddHours",
      "0x27C4594C": "sceRtcGetTime_t",
      "0x27F98543": "sceRtcFormatRFC3339LocalTime",
      "0x28E1E988": "sceRtcParseRFC3339",
      "0x34885E0D": "sceRtcConvertUtcToLocalTime",
      "0x36075567": "sceRtcGetDosTime",
      "0x3A807CC8": "sceRtcSetTime_t",
      "0x3F7AD767": "sceRtcGetCurrentTick",
      "0x42307A17": "sceRtcIsLeapYear",
      "0x42842C77": "sceRtcTickAddYears",
      "0x44F45E05": "sceRtcTickAddTicks",
      "0x4B1B5E82": "sceRtcCheckValid",
      "0x4CFA57B0": "sceRtcGetCurrentClock",
      "0x57726BC1": "sceRtcGetDayOfWeek",
      "0x62685E98": "sceRtcGetLastAdjustedTime",
      "0x6A676D2D": "sceRtcUnregisterCallback",
      "0x6FF40ACC": "sceRtcGetTick",
      "0x779242A2": "sceRtcConvertLocalTimeToUTC",
      "0x7ACE4C04": "sceRtcSetWin32FileTime",
      "0x7DE6711B": "sceRtcFormatRFC2822LocalTime",
      "0x7ED29E40": "sceRtcSetTick",
      "0x81FCDA34": "sceRtcIsAlarmed",
      "0x9ED0AE87": "sceRtcCompareTick",
      "0xC41C2853": "sceRtcGetTickResolution",
      "0xC663B3B9": "sceRtcFormatRFC2822",
      "0xCF3A2CA8": "sceRtcTickAddWeeks",
      "0xCF561893": "sceRtcGetWin32FileTime",
      "0xDBF74F1B": "sceRtcTickAddMonths",
      "0xDFBC5F16": "sceRtcParseDateTime",
      "0xE1C93E47": "sceRtcGetTime64_t",
      "0xE51B4B7A": "sceRtcTickAddDays",
      "0xE6605BCA": "sceRtcTickAddMinutes",
      "0xE7C27D1B": "sceRtcGetCurrentClockLocalTime",
      "0xF006F264": "sceRtcSetDosTime",
      "0xF2A4AFE5": "sceRtcTickAddSeconds",
      "0xFB3B18CD": "sceRtcRegisterCallback"
    },
    sceRtc_driver: {
      "0x011F03C1": "sceRtcGetAccumulativeTime",
      "0x17C26C00": "sceRtcSetCurrentSecureTick",
      "0x3F7AD767": "sceRtcGetCurrentTick",
      "0x44F45E05": "sceRtcTickAddTicks",
      "0x48D07D70": "sceRtcResume",
      "0x4B1B5E82": "sceRtcCheckValid",
      "0x4CFA57B0": "sceRtcGetCurrentClock",
      "0x6FF40ACC": "sceRtcGetTick",
      "0x7ED29E40": "sceRtcSetTick",
      "0x912BEE56": "sceRtcInit",
      "0x9763C138": "sceRtcSetCurrentTick",
      "0x9CC2797E": "sceRtcSuspend",
      "0xB44BDAED": "sceRtcGetCurrentSecureTick",
      "0xC41C2853": "sceRtcGetTickResolution",
      "0xCE27DE2F": "sceRtcEnd",
      "0xF2A4AFE5": "sceRtcTickAddSeconds"
    },
    sceSasCore_driver: {"0xB0F9F98F": "sceSasCoreInit", "0xE143A1EA": "sceSasCoreExit"},
    sceSasCore: {
      "0x019B25EB": "__sceSasSetADSR",
      "0x07F58C24": "__sceSasGetAllEnvelopeHeights",
      "0x267A6DD2": "__sceSasRevParam",
      "0x2C8E6AB3": "__sceSasGetPauseFlag",
      "0x33D4AB37": "__sceSasRevType",
      "0x42778A9F": "__sceSasInit",
      "0x440CA7D8": "__sceSasSetVolume",
      "0x50A14DFC": "__sceSasCoreWithMix",
      "0x5F9529F6": "__sceSasSetSL",
      "0x68A46B95": "__sceSasGetEndFlag",
      "0x74AE582A": "__sceSasGetEnvelopeHeight",
      "0x76F01ACA": "__sceSasSetKeyOn",
      "0x787D04D5": "__sceSasSetPause",
      "0x99944089": "__sceSasSetVoice",
      "0x9EC3676A": "__sceSasSetADSRmode",
      "0xA0CF2FA4": "__sceSasSetKeyOff",
      "0xA232CBE6": "__sceSasSetTrianglarWave",
      "0xA3589D81": "__sceSasCore",
      "0xAD84D37F": "__sceSasSetPitch",
      "0xB7660A23": "__sceSasSetNoise",
      "0xBD11B7C2": "__sceSasGetGrain",
      "0xCBCD4F79": "__sceSasSetSimpleADSR",
      "0xD1E0A01E": "__sceSasSetGrain",
      "0xD5A229C9": "__sceSasRevEVOL",
      "0xD5EBBBCD": "__sceSasSetSteepWave",
      "0xE175EF66": "__sceSasGetOutputmode",
      "0xE1CD9561": "__sceSasSetVoicePCM",
      "0xE855BF76": "__sceSasSetOutputmode",
      "0xF983B186": "__sceSasRevVON"
    },
    sceP3da_driver: {"0x374500A5": "sceP3daBridgeInit", "0x43F756A2": "sceP3daBridgeExit"},
    sceP3da: {
      "0x013016F3": "sceP3daBridgeCore",
      "0x374500A5": "sceP3daBridgeInit",
      "0x43F756A2": "sceP3daBridgeExit"
    },
    sceSemawm: {},
    sceSircs: {"0x71EEF62D": "sceSircsSend", "0x83381633": "sceSircsReceive"},
    sceSircs_driver: {
      "0x19155A2F": "sceSircsEnd",
      "0x62411801": "sceSircsInit",
      "0x71EEF62D": "sceSircsSend",
      "0x83381633": "sceSircsReceive"
    },
    sceVe: {},
    sceSyscon_driver: {
      "0x081826B4": "sceSysconSuspend",
      "0x08234E6D": "sceSysconReceiveSetParam",
      "0x0A771482": "sceSysconInit",
      "0x138747DE": "sceSysconGetUmdSwitch",
      "0x1602ED0D": "sceSysconCmdCancel",
      "0x18BFBE65": "sceSysconCtrlLED",
      "0x204F23FF": "sceSysconGetBaryonStatus2",
      "0x3AC3D2A4": "sceSysconCmdExecAsync",
      "0x3DE38336": "sceSysconReadPommelReg",
      "0x56931095": "sceSysconResume",
      "0x5B9ACC97": "sceSysconCmdExec",
      "0x5EE92F3C": "sceSysconSetDebugHandlers",
      "0x7BCC5EAE": "sceSysconGetTimeStamp",
      "0x7EC5A957": "sceSysconGetBaryonVersion",
      "0x86D4CAD8": "sceSysconGetBaryonStatus",
      "0x8A4519F5": "sceSysconCtrlLeptonPower",
      "0x8CBC7987": "sceSysconResetDevice",
      "0x92D16FC7": "sceSysconEnd",
      "0x992C22C2": "sceSysconSendSetParam",
      "0xD1B501E8": "sceSysconWritePommelReg",
      "0xE6B74CB9": "sceSysconNop",
      "0xE7E87741": "sceSysconGetPommelVersion",
      "0xF350F666": "sceSysconCmdSync"
    },
    SysMemForKernel: {},
    SysMemUserForUser: {
      "0x13A5ABEF": "sceKernelPrintf",
      "0x237DBD4F": "sceKernelAllocPartitionMemory",
      "0x2A3E5280": "sceKernelQueryMemoryInfo",
      "0x3FC9AE6A": "sceKernelDevkitVersion",
      "0x7591C7DB": "sceKernelSetCompiledSdkVersion",
      "0x9D9A5BA1": "sceKernelGetBlockHeadAddr",
      "0xA291F107": "sceKernelMaxFreeMemSize",
      "0xB6D61D02": "sceKernelFreePartitionMemory",
      "0xF77D77CB": "sceKernelSetCompilerVersion",
      "0xF919F628": "sceKernelTotalFreeMemSize",
      "0xFC114573": "sceKernelGetCompiledSdkVersion"
    },
    SysclibForKernel: {
      "0x097049BD": "bcopy",
      "0x0D188658": "strstr",
      "0x0DFB7B6C": "strpbrk",
      "0x10F3BB61": "memset",
      "0x1493EBD9": "wmemset",
      "0x18FE80DB": "longjmp",
      "0x1AB53A58": "strtok_r",
      "0x1D83F344": "atob",
      "0x243665ED": "rindex",
      "0x279F9A12": "wmemclear",
      "0x32C767F2": "look_ctype_table",
      "0x3EC5BBF6": "tolower",
      "0x476FD94A": "strcat",
      "0x47DD934D": "strtol",
      "0x4C0E0274": "strrchr",
      "0x52DF196C": "strlen",
      "0x62AE052F": "strspn",
      "0x68A78817": "memchr",
      "0x6A7900E1": "strtoul",
      "0x7661E728": "sprintf",
      "0x7AB35214": "strncmp",
      "0x7F8A6F23": "bcmp",
      "0x81D0D1F7": "memcmp",
      "0x86FEFCE9": "bzero",
      "0x87C78FB6": "prnt",
      "0x87F8D2DA": "strtok",
      "0x89B79CB1": "strcspn",
      "0x909C228B": "setjmp",
      "0x90C5573D": "strnlen",
      "0xA48D2592": "memmove",
      "0xAB7592FF": "memcpy",
      "0xB1DC2AE8": "strchr",
      "0xB49A7697": "strncpy",
      "0xC0AB8932": "strcmp",
      "0xCE2F7487": "toupper",
      "0xD1CD40E5": "index",
      "0xD887CACD": "get_ctype_table",
      "0xEC6F1CF2": "strcpy"
    },
    sceSysEventForKernel: {
      "0x36331294": "sceKernelSysEventDispatch",
      "0x68D55505": "sceKernelReferSysEventHandler",
      "0xAEB300AE": "sceKernelIsRegisterSysEventHandler",
      "0xCD9E4BB5": "sceKernelRegisterSysEventHandler",
      "0xD7D3FDCD": "sceKernelUnregisterSysEventHandler"
    },
    sceSuspendForKernel: {
      "0x090CCB3F": "sceKernelPowerTick",
      "0x0AB0C6F3": "sceKernelDispatchResumeHandlers",
      "0x3AEE7261": "sceKernelPowerUnlock",
      "0x3E0271D3": "sceKernelVolatileMemLock",
      "0x8F58B1EC": "sceKernelDispatchSuspendHandlers",
      "0x91A77137": "sceKernelRegisterSuspendHandler",
      "0x98A1D061": "sceKernelPowerRebootStart",
      "0xA14F40B2": "sceKernelVolatileMemTryLock",
      "0xA569E425": "sceKernelVolatileMemUnlock",
      "0xB43D1A8C": "sceKernelRegisterResumeHandler",
      "0xB53B2147": "sceKernelPowerLockForUser",
      "0xBDE686CD": "sceKernelRegisterPowerHandlers",
      "0xC7C928C7": "sceKernelPowerUnlockForUser",
      "0xEADB1BD7": "sceKernelPowerLock"
    },
    sceSuspendForUser: {
      "0x090CCB3F": "sceKernelPowerTick",
      "0x3AEE7261": "sceKernelPowerUnlock",
      "0x3E0271D3": "sceKernelVolatileMemLock",
      "0xA14F40B2": "sceKernelVolatileMemTryLock",
      "0xA569E425": "sceKernelVolatileMemUnlock",
      "0xEADB1BD7": "sceKernelPowerLock"
    },
    UtilsForUser: {
      "0x06FB8A63": "sceKernelUtilsMt19937UInt",
      "0x16641D70": "sceKernelDcacheReadTag",
      "0x27CC57F0": "sceKernelLibcTime",
      "0x346F6DA8": "sceKernelUtilsSha1BlockUpdate",
      "0x34B9FA9E": "sceKernelDcacheWritebackInvalidateRange",
      "0x37FB5C42": "sceKernelGetGPI",
      "0x3EE30821": "sceKernelDcacheWritebackRange",
      "0x4FD31C9D": "sceKernelIcacheProbe",
      "0x585F1C09": "sceKernelUtilsSha1BlockResult",
      "0x61E1E525": "sceKernelUtilsMd5BlockUpdate",
      "0x6AD345D7": "sceKernelSetGPO",
      "0x71EC4271": "sceKernelLibcGettimeofday",
      "0x77DFF087": "sceKernelDcacheProbeRange",
      "0x79D1C3FA": "sceKernelDcacheWritebackAll",
      "0x80001C4C": "sceKernelDcacheProbe",
      "0x840259F1": "sceKernelUtilsSha1Digest",
      "0x87E81561": "sceKernelPutUserLog",
      "0x91E4F6A7": "sceKernelLibcClock",
      "0x920F104A": "sceKernelIcacheInvalidateAll",
      "0x9E5C5086": "sceKernelUtilsMd5BlockInit",
      "0xB435DEC5": "sceKernelDcacheWritebackInvalidateAll",
      "0xB8D24E78": "sceKernelUtilsMd5BlockResult",
      "0xBFA98062": "sceKernelDcacheInvalidateRange",
      "0xC2DF770E": "sceKernelIcacheInvalidateRange",
      "0xC8186A58": "sceKernelUtilsMd5Digest",
      "0xE860E75E": "sceKernelUtilsMt19937Init",
      "0xF8FCD5BA": "sceKernelUtilsSha1BlockInit",
      "0xFB05FAD0": "sceKernelIcacheReadTag"
    },
    UtilsForKernel: {
      "0x06FB8A63": "sceKernelUtilsMt19937UInt",
      "0x136F2419": "sceKernelSetPTRIGMask",
      "0x16641D70": "sceKernelDcacheReadTag",
      "0x193D4036": "sceKernelSetGPIMask",
      "0x23A0C5BA": "sceKernelRegisterRtcFunc",
      "0x23FFC828": "sceKernelGzipGetCompressedData",
      "0x27CC57F0": "sceKernelLibcTime",
      "0x346F6DA8": "sceKernelUtilsSha1BlockUpdate",
      "0x34B9FA9E": "sceKernelDcacheWritebackInvalidateRange",
      "0x37FB5C42": "sceKernelGetGPI",
      "0x39F49610": "sceKernelGetPTRIG",
      "0x3EE30821": "sceKernelDcacheWritebackRange",
      "0x41887EF4": "sceKernelReleaseRtcFunc",
      "0x4FD31C9D": "sceKernelIcacheProbe",
      "0x585F1C09": "sceKernelUtilsSha1BlockResult",
      "0x61E1E525": "sceKernelUtilsMd5BlockUpdate",
      "0x6231A71D": "sceKernelSetPTRIG",
      "0x6AD345D7": "sceKernelSetGPO",
      "0x71EC4271": "sceKernelLibcGettimeofday",
      "0x77DFF087": "sceKernelDcacheProbeRange",
      "0x78934841": "sceKernelGzipDecompress",
      "0x79D1C3FA": "sceKernelDcacheWritebackAll",
      "0x80001C4C": "sceKernelDcacheProbe",
      "0x840259F1": "sceKernelUtilsSha1Digest",
      "0x864A9D72": "sceKernelDcacheInvalidateAll",
      "0x87E81561": "sceKernelPutUserLog",
      "0x8C1FBE04": "sceKernelGzipGetComment",
      "0x91E4F6A7": "sceKernelLibcClock",
      "0x920F104A": "sceKernelIcacheInvalidateAll",
      "0x92282A47": "sceKernelRegisterUserLogHandler",
      "0x95035FEF": "sceKernelSetGPOMask",
      "0x9E5C5086": "sceKernelUtilsMd5BlockInit",
      "0xAF3616C0": "sceKernelGetGPO",
      "0xB0E9C31F": "sceKernelGzipGetInfo",
      "0xB435DEC5": "sceKernelDcacheWritebackInvalidateAll",
      "0xB8D24E78": "sceKernelUtilsMd5BlockResult",
      "0xBDBFCA89": "sceKernelRtcGetTick",
      "0xBFA98062": "sceKernelDcacheInvalidateRange",
      "0xC2DF770E": "sceKernelIcacheInvalidateRange",
      "0xC8186A58": "sceKernelUtilsMd5Digest",
      "0xE0CE3E29": "sceKernelGzipIsValid",
      "0xE0E6BA96": "sceKernelGzipGetName",
      "0xE860E75E": "sceKernelUtilsMt19937Init",
      "0xE8DB3CE6": "sceKernelDeflateDecompress",
      "0xF8FCD5BA": "sceKernelUtilsSha1BlockInit",
      "0xFB05FAD0": "sceKernelIcacheReadTag"
    },
    KDebugForKernel: {"0x84F370BC": "Kprintf", "0xD636B827": "sceKernelDipswAll"},
    SysTimerForKernel: {},
    ThreadManForUser: {
      "0x034A921F": "sceKernelGetVTimerTime",
      "0x0C106E53": "sceKernelRegisterThreadEventHandler",
      "0x0D81716A": "sceKernelPollMbx",
      "0x0DDCD2C9": "sceKernelTryLockMutex",
      "0x0E927AED": "_sceKernelReturnFromTimerHandler",
      "0x110DEC9A": "sceKernelUSec2SysClock",
      "0x1181E963": "sceKernelDelaySysClockThreadCB",
      "0x17C1684E": "sceKernelReferThreadStatus",
      "0x18260574": "sceKernelReceiveMbx",
      "0x19CFF145": "sceKernelCreateLwMutex",
      "0x1AF94D03": "sceKernelDonateWakeupThread",
      "0x1D371B8A": "sceKernelCancelVpl",
      "0x1FB15A32": "sceKernelSetEventFlag",
      "0x20FFF560": "sceKernelCreateVTimer",
      "0x278C0DF5": "sceKernelWaitThreadEnd",
      "0x27E22EC2": "sceKernelResumeDispatchThread",
      "0x28B6489C": "sceKernelDeleteSema",
      "0x293B45B8": "sceKernelGetThreadId",
      "0x2A3D44FF": "sceKernelGetCallbackCount",
      "0x2C34E053": "sceKernelReleaseWaitThread",
      "0x30FD48F0": "sceKernelPollEventFlag",
      "0x328C546A": "sceKernelWaitEventFlagCB",
      "0x328F9E52": "sceKernelDeleteVTimer",
      "0x33BE4024": "sceKernelReferMsgPipeStatus",
      "0x349B864D": "sceKernelCancelMsgPipe",
      "0x349D6D6C": "sceKernelCheckCallback",
      "0x369ED59D": "sceKernelGetSystemTimeLow",
      "0x369EEB6B": "sceKernelReferThreadEventHandlerStatus",
      "0x383F7BCC": "sceKernelTerminateDeleteThread",
      "0x39810265": "sceKernelReferVplStatus",
      "0x3AD58B8C": "sceKernelSuspendDispatchThread",
      "0x3B183E26": "sceKernelGetThreadExitStatus",
      "0x3F53E640": "sceKernelSignalSema",
      "0x402FCF22": "sceKernelWaitEventFlag",
      "0x446D8DE6": "sceKernelCreateThread",
      "0x4C145944": "sceKernelReferLwMutexStatusByID",
      "0x4E3A1105": "sceKernelWaitSema",
      "0x52089CA1": "sceKernelGetThreadStackFreeSize",
      "0x532A522E": "_sceKernelExitThread",
      "0x53B00E9A": "sceKernelSetVTimerHandlerWide",
      "0x542AD630": "sceKernelSetVTimerTime",
      "0x55C20A00": "sceKernelCreateEventFlag",
      "0x56C039B5": "sceKernelCreateVpl",
      "0x57CF62DD": "sceKernelGetThreadmanIdType",
      "0x58B1F937": "sceKernelPollSema",
      "0x5BF4DD27": "sceKernelLockMutexCB",
      "0x5F32BEAA": "sceKernelReferVTimerStatus",
      "0x60107536": "sceKernelDeleteLwMutex",
      "0x616403BA": "sceKernelTerminateThread",
      "0x623AE665": "sceKernelTryAllocateFpl",
      "0x627E6F3A": "sceKernelReferSystemStatus",
      "0x64D4540E": "sceKernelReferThreadProfiler",
      "0x6652B8CA": "sceKernelSetAlarm",
      "0x68DA9E36": "sceKernelDelayThreadCB",
      "0x6B30100F": "sceKernelUnlockMutex",
      "0x6D212BAC": "sceKernelWaitSemaCB",
      "0x6E9EA350": "_sceKernelReturnFromCallback",
      "0x71BC9871": "sceKernelChangeThreadPriority",
      "0x72F3C145": "sceKernelReleaseThreadEventHandler",
      "0x730ED8BC": "sceKernelReferCallbackStatus",
      "0x74829B76": "sceKernelReceiveMsgPipe",
      "0x75156E8F": "sceKernelResumeThread",
      "0x7C0DC2A0": "sceKernelCreateMsgPipe",
      "0x7C41F2C2": "sceKernelSendMsgPipeCB",
      "0x7E65B999": "sceKernelCancelAlarm",
      "0x809CE29B": "sceKernelExitDeleteThread",
      "0x812346E4": "sceKernelClearEventFlag",
      "0x8125221D": "sceKernelCreateMbx",
      "0x8218B4DD": "sceKernelReferGlobalProfiler",
      "0x82826F70": "sceKernelSleepThreadCB",
      "0x82BC5777": "sceKernelGetSystemTimeWide",
      "0x840E8133": "sceKernelWaitThreadEndCB",
      "0x86255ADA": "sceKernelDeleteMbx",
      "0x876DBFAD": "sceKernelSendMsgPipe",
      "0x87D4DD36": "sceKernelCancelReceiveMbx",
      "0x87D9223C": "sceKernelCancelMutex",
      "0x884C9F90": "sceKernelTrySendMsgPipe",
      "0x89B3D48C": "sceKernelDeleteVpl",
      "0x8FFDF9A2": "sceKernelCancelSema",
      "0x912354A7": "sceKernelRotateThreadReadyQueue",
      "0x94416130": "sceKernelGetThreadmanIdList",
      "0x94AA61EE": "sceKernelGetThreadCurrentPriority",
      "0x9944F31F": "sceKernelSuspendThread",
      "0x9ACE131E": "sceKernelSleepThread",
      "0x9FA03CD3": "sceKernelDeleteThread",
      "0xA66B0120": "sceKernelReferEventFlagStatus",
      "0xA8AA591F": "sceKernelCancelFpl",
      "0xA8E8C846": "sceKernelReferMbxStatus",
      "0xA9C2CB9A": "sceKernelReferMutexStatus",
      "0xAA73C935": "sceKernelExitThread",
      "0xAF36D708": "sceKernelTryAllocateVpl",
      "0xB011B11F": "sceKernelLockMutex",
      "0xB2C25152": "sceKernelSetSysClockAlarm",
      "0xB3A59970": "sceKernelGetVTimerBase",
      "0xB736E9FF": "sceKernelFreeVpl",
      "0xB7C18B77": "sceKernelGetVTimerBaseWide",
      "0xB7D098C6": "sceKernelCreateMutex",
      "0xBA4051D6": "sceKernelCancelCallback",
      "0xBA6B92E2": "sceKernelSysClock2USec",
      "0xBC6FEBC5": "sceKernelReferSemaStatus",
      "0xBD123D9E": "sceKernelDelaySysClockThread",
      "0xBED27435": "sceKernelAllocateVpl",
      "0xC07BB470": "sceKernelCreateFpl",
      "0xC0B3FFD2": "sceKernelGetVTimerTimeWide",
      "0xC11BA8C4": "sceKernelNotifyCallback",
      "0xC68D9437": "sceKernelStartVTimer",
      "0xC8CD158C": "sceKernelUSec2SysClockWide",
      "0xCD203292": "sceKernelCancelEventFlag",
      "0xCEADEB47": "sceKernelDelayThread",
      "0xD0AEEE87": "sceKernelStopVTimer",
      "0xD13BDE95": "sceKernelCheckThreadStack",
      "0xD2D615EF": "sceKernelCancelVTimerHandler",
      "0xD59EAD2F": "sceKernelWakeupThread",
      "0xD6DA4BA1": "sceKernelCreateSema",
      "0xD8199E4C": "sceKernelReferFplStatus",
      "0xD8B299AE": "sceKernelSetVTimerHandler",
      "0xD979E9BF": "sceKernelAllocateFpl",
      "0xDAA3F564": "sceKernelReferAlarmStatus",
      "0xDB738F35": "sceKernelGetSystemTime",
      "0xDF52098F": "sceKernelTryReceiveMsgPipe",
      "0xE1619D7C": "sceKernelSysClock2USecWide",
      "0xE7282CB6": "sceKernelAllocateFplCB",
      "0xE81CAF8F": "sceKernelCreateCallback",
      "0xE9B3061E": "sceKernelSendMbx",
      "0xEA748E31": "sceKernelChangeCurrentThreadAttr",
      "0xEC0A693F": "sceKernelAllocateVplCB",
      "0xED1410E0": "sceKernelDeleteFpl",
      "0xEDBA5844": "sceKernelDeleteCallback",
      "0xEF9E4C70": "sceKernelDeleteEventFlag",
      "0xF0B7DA1C": "sceKernelDeleteMsgPipe",
      "0xF3986382": "sceKernelReceiveMbxCB",
      "0xF475845D": "sceKernelStartThread",
      "0xF6414A71": "sceKernelFreeFpl",
      "0xF8170FBE": "sceKernelDeleteMutex",
      "0xFB6425C3": "sceKernelSetVTimerTimeWide",
      "0xFBFA697D": "sceKernelReceiveMsgPipeCB",
      "0xFCCFAD26": "sceKernelCancelWakeupThread",
      "0xFFC36A14": "sceKernelReferThreadRunStatus"
    },
    ThreadManForKernel: {
      "0x034A921F": "sceKernelGetVTimerTime",
      "0x04E72261": "sceKernelAllocateKTLS",
      "0x0C106E53": "sceKernelRegisterThreadEventHandler",
      "0x0D81716A": "sceKernelPollMbx",
      "0x0DDCD2C9": "sceKernelTryLockMutex",
      "0x110DEC9A": "sceKernelUSec2SysClock",
      "0x1181E963": "sceKernelDelaySysClockThreadCB",
      "0x17C1684E": "sceKernelReferThreadStatus",
      "0x18260574": "sceKernelReceiveMbx",
      "0x1AF94D03": "sceKernelDonateWakeupThread",
      "0x1D371B8A": "sceKernelCancelVpl",
      "0x1FB15A32": "sceKernelSetEventFlag",
      "0x20FFF560": "sceKernelCreateVTimer",
      "0x278C0DF5": "sceKernelWaitThreadEnd",
      "0x27E22EC2": "sceKernelResumeDispatchThread",
      "0x28B6489C": "sceKernelDeleteSema",
      "0x293B45B8": "sceKernelGetThreadId",
      "0x2A3D44FF": "sceKernelGetCallbackCount",
      "0x2C34E053": "sceKernelReleaseWaitThread",
      "0x30FD48F0": "sceKernelPollEventFlag",
      "0x328C546A": "sceKernelWaitEventFlagCB",
      "0x328F9E52": "sceKernelDeleteVTimer",
      "0x33BE4024": "sceKernelReferMsgPipeStatus",
      "0x349B864D": "sceKernelCancelMsgPipe",
      "0x349D6D6C": "sceKernelCheckCallback",
      "0x369ED59D": "sceKernelGetSystemTimeLow",
      "0x369EEB6B": "sceKernelReferThreadEventHandlerStatus",
      "0x383F7BCC": "sceKernelTerminateDeleteThread",
      "0x39810265": "sceKernelReferVplStatus",
      "0x3AD58B8C": "sceKernelSuspendDispatchThread",
      "0x3AD875C3": "sceKernelGetThreadKTLS",
      "0x3B183E26": "sceKernelGetThreadExitStatus",
      "0x3F53E640": "sceKernelSignalSema",
      "0x402FCF22": "sceKernelWaitEventFlag",
      "0x446D8DE6": "sceKernelCreateThread",
      "0x4C145944": "sceKernelReferLwMutexStatusByID",
      "0x4E3A1105": "sceKernelWaitSema",
      "0x4FE44D5E": "sceKernelCheckThreadKernelStack",
      "0x52089CA1": "sceKernelGetThreadStackFreeSize",
      "0x53B00E9A": "sceKernelSetVTimerHandlerWide",
      "0x542AD630": "sceKernelSetVTimerTime",
      "0x55C20A00": "sceKernelCreateEventFlag",
      "0x56C039B5": "sceKernelCreateVpl",
      "0x57CF62DD": "sceKernelGetThreadmanIdType",
      "0x58B1F937": "sceKernelPollSema",
      "0x5BF4DD27": "sceKernelLockMutexCB",
      "0x5F32BEAA": "sceKernelReferVTimerStatus",
      "0x616403BA": "sceKernelTerminateThread",
      "0x623AE665": "sceKernelTryAllocateFpl",
      "0x627E6F3A": "sceKernelReferSystemStatus",
      "0x6652B8CA": "sceKernelSetAlarm",
      "0x68DA9E36": "sceKernelDelayThreadCB",
      "0x6B30100F": "sceKernelUnlockMutex",
      "0x6D212BAC": "sceKernelWaitSemaCB",
      "0x71BC9871": "sceKernelChangeThreadPriority",
      "0x72F3C145": "sceKernelReleaseThreadEventHandler",
      "0x730ED8BC": "sceKernelReferCallbackStatus",
      "0x74829B76": "sceKernelReceiveMsgPipe",
      "0x75156E8F": "sceKernelResumeThread",
      "0x7C0DC2A0": "sceKernelCreateMsgPipe",
      "0x7C41F2C2": "sceKernelSendMsgPipeCB",
      "0x7E65B999": "sceKernelCancelAlarm",
      "0x809CE29B": "sceKernelExitDeleteThread",
      "0x812346E4": "sceKernelClearEventFlag",
      "0x8125221D": "sceKernelCreateMbx",
      "0x82826F70": "sceKernelSleepThreadCB",
      "0x82BC5777": "sceKernelGetSystemTimeWide",
      "0x840E8133": "sceKernelWaitThreadEndCB",
      "0x85A2A5BF": "sceKernelIsUserModeThread",
      "0x86255ADA": "sceKernelDeleteMbx",
      "0x876DBFAD": "sceKernelSendMsgPipe",
      "0x87D4DD36": "sceKernelCancelReceiveMbx",
      "0x87D9223C": "sceKernelCancelMutex",
      "0x884C9F90": "sceKernelTrySendMsgPipe",
      "0x89B3D48C": "sceKernelDeleteVpl",
      "0x8FD9F70C": "sceKernelSuspendAllUserThreads",
      "0x8FFDF9A2": "sceKernelCancelSema",
      "0x912354A7": "sceKernelRotateThreadReadyQueue",
      "0x94416130": "sceKernelGetThreadmanIdList",
      "0x94AA61EE": "sceKernelGetThreadCurrentPriority",
      "0x9944F31F": "sceKernelSuspendThread",
      "0x9ACE131E": "sceKernelSleepThread",
      "0x9FA03CD3": "sceKernelDeleteThread",
      "0xA249EAAE": "sceKernelGetKTLS",
      "0xA66B0120": "sceKernelReferEventFlagStatus",
      "0xA8AA591F": "sceKernelCancelFpl",
      "0xA8E8C846": "sceKernelReferMbxStatus",
      "0xA9C2CB9A": "sceKernelReferMutexStatus",
      "0xAA73C935": "sceKernelExitThread",
      "0xAF36D708": "sceKernelTryAllocateVpl",
      "0xB011B11F": "sceKernelLockMutex",
      "0xB2C25152": "sceKernelSetSysClockAlarm",
      "0xB3A59970": "sceKernelGetVTimerBase",
      "0xB736E9FF": "sceKernelFreeVpl",
      "0xB7C18B77": "sceKernelGetVTimerBaseWide",
      "0xB7D098C6": "sceKernelCreateMutex",
      "0xBA4051D6": "sceKernelCancelCallback",
      "0xBA6B92E2": "sceKernelSysClock2USec",
      "0xBC31C1B9": "sceKernelExtendKernelStack",
      "0xBC6FEBC5": "sceKernelReferSemaStatus",
      "0xBD123D9E": "sceKernelDelaySysClockThread",
      "0xBED27435": "sceKernelAllocateVpl",
      "0xC07BB470": "sceKernelCreateFpl",
      "0xC0B3FFD2": "sceKernelGetVTimerTimeWide",
      "0xC11BA8C4": "sceKernelNotifyCallback",
      "0xC68D9437": "sceKernelStartVTimer",
      "0xC8CD158C": "sceKernelUSec2SysClockWide",
      "0xCD203292": "sceKernelCancelEventFlag",
      "0xCEADEB47": "sceKernelDelayThread",
      "0xD0AEEE87": "sceKernelStopVTimer",
      "0xD13BDE95": "sceKernelCheckThreadStack",
      "0xD198B811": "sceKernelFreeKTLS",
      "0xD2D615EF": "sceKernelCancelVTimerHandler",
      "0xD59EAD2F": "sceKernelWakeupThread",
      "0xD6DA4BA1": "sceKernelCreateSema",
      "0xD8199E4C": "sceKernelReferFplStatus",
      "0xD890B370": "sceKernelGetThreadKernelStackFreeSize",
      "0xD8B299AE": "sceKernelSetVTimerHandler",
      "0xD979E9BF": "sceKernelAllocateFpl",
      "0xDAA3F564": "sceKernelReferAlarmStatus",
      "0xDB738F35": "sceKernelGetSystemTime",
      "0xDF52098F": "sceKernelTryReceiveMsgPipe",
      "0xE1619D7C": "sceKernelSysClock2USecWide",
      "0xE7282CB6": "sceKernelAllocateFplCB",
      "0xE81CAF8F": "sceKernelCreateCallback",
      "0xE9B3061E": "sceKernelSendMbx",
      "0xEA748E31": "sceKernelChangeCurrentThreadAttr",
      "0xEC0A693F": "sceKernelAllocateVplCB",
      "0xED1410E0": "sceKernelDeleteFpl",
      "0xEDBA5844": "sceKernelDeleteCallback",
      "0xEF9E4C70": "sceKernelDeleteEventFlag",
      "0xF0B7DA1C": "sceKernelDeleteMsgPipe",
      "0xF3986382": "sceKernelReceiveMbxCB",
      "0xF475845D": "sceKernelStartThread",
      "0xF6414A71": "sceKernelFreeFpl",
      "0xF6427665": "sceKernelGetUserLevel",
      "0xF8170FBE": "sceKernelDeleteMutex",
      "0xFB6425C3": "sceKernelSetVTimerTimeWide",
      "0xFBFA697D": "sceKernelReceiveMsgPipeCB",
      "0xFCB5EB49": "sceKernelGetSystemStatusFlag",
      "0xFCCFAD26": "sceKernelCancelWakeupThread",
      "0xFFC36A14": "sceKernelReferThreadRunStatus"
    },
    sceUmdCache_driver: {},
    sceUmdCacheUser: {"0x03D67340": "sceUmdCacheGetCacheParam", "0x86B3196A": "sceUmdCacheGetCacheNum"},
    sceUsb: {
      "0x112CC951": "sceUsbGetDrvState",
      "0x1C360735": "sceUsbWaitCancel",
      "0x4E537366": "sceUsbGetDrvList",
      "0x586DB82C": "sceUsbActivate",
      "0x5BE0E002": "sceUsbWaitState",
      "0x616F2B61": "sceUsbWaitStateCB",
      "0xAE5DE6AF": "sceUsbStart",
      "0xC21645A4": "sceUsbGetState",
      "0xC2464FA0": "sceUsbStop",
      "0xC572A9C8": "sceUsbDeactivate",
      "0xE20B23A6": "sceUsbActivateWithCharging"
    },
    sceUsb_driver: {
      "0x112CC951": "sceUsbGetDrvState",
      "0x1C360735": "sceUsbWaitCancel",
      "0x4E537366": "sceUsbGetDrvList",
      "0x586DB82C": "sceUsbActivate",
      "0x5BE0E002": "sceUsbWaitState",
      "0x616F2B61": "sceUsbWaitStateCB",
      "0xAE5DE6AF": "sceUsbStart",
      "0xC21645A4": "sceUsbGetState",
      "0xC2464FA0": "sceUsbStop",
      "0xC572A9C8": "sceUsbDeactivate",
      "0xE20B23A6": "sceUsbActivateWithCharging",
      "0xEDA8A020": "sceUsbRestart"
    },
    sceUsbBus_driver: {
      "0x23E51D8F": "sceUsbbdReqSend",
      "0x913EC15D": "sceUsbbdReqRecv",
      "0x951A24CC": "sceUsbbdClearFIFO",
      "0xB1644BE7": "sceUsbbdRegister",
      "0xC1E2A540": "sceUsbbdUnregister",
      "0xC21645A4": "sceUsbGetState",
      "0xC5E53685": "sceUsbbdReqCancelAll",
      "0xCC57EC9D": "sceUsbbdReqCancel",
      "0xE65441C1": "sceUsbbdStall",
      "0xEDA8A020": "sceUsbRestart"
    },
    sceUsb1Seg: {},
    sceUsb1Seg_driver: {},
    sceUsbAcc_internal: {
      "0x0CD7D4AA": "sceUsbAccGetInfo",
      "0x18B04C82": "sceUsbAccUnregisterType",
      "0x2E251404": "sceUsbAccRegisterType",
      "0x79A1C743": "sceUsbAccGetAuthStat"
    },
    sceUsbAcc: {"0x0CD7D4AA": "sceUsbAccGetInfo", "0x79A1C743": "sceUsbAccGetAuthStat"},
    sceUsbAcc_driver: {"0x0CD7D4AA": "sceUsbAccGetInfo", "0x79A1C743": "sceUsbAccGetAuthStat"},
    sceUsbCam: {
      "0x03ED7A82": "sceUsbCamSetupMic",
      "0x08AEE98A": "sceUsbCamSetMicGain",
      "0x09C26C7E": "sceUsbCamSetContrast",
      "0x0A41A298": "sceUsbCamSetupStillEx",
      "0x11A1F128": "sceUsbCamGetAutoImageReverseState",
      "0x17F7B2FB": "sceUsbCamSetupVideo",
      "0x1A46CFE7": "sceUsbCamStillPollInputEnd",
      "0x1D686870": "sceUsbCamSetEvLevel",
      "0x1E958148": "sceUsbCamIoctl",
      "0x2BCD50C0": "sceUsbCamGetEvLevel",
      "0x2E930264": "sceUsbCamSetupMicEx",
      "0x36636925": "sceUsbCamReadMicBlocking",
      "0x383E9FA8": "sceUsbCamGetSaturation",
      "0x3DC0088E": "sceUsbCamReadMic",
      "0x3F0CF289": "sceUsbCamSetupStill",
      "0x41E73E95": "sceUsbCamPollReadVideoFrameEnd",
      "0x41EE8797": "sceUsbCamUnregisterLensRotationCallback",
      "0x4C34F553": "sceUsbCamGetLensDirection",
      "0x4F3D84D5": "sceUsbCamSetBrightness",
      "0x5145868A": "sceUsbCamStopMic",
      "0x574A8C3F": "sceUsbCamStartVideo",
      "0x5778B452": "sceUsbCamGetMicDataLength",
      "0x61BE5CAC": "sceUsbCamStillInputBlocking",
      "0x622F83CC": "sceUsbCamSetSharpness",
      "0x6784E6A8": "sceUsbCamSetAntiFlicker",
      "0x6CF32CB9": "sceUsbCamStopVideo",
      "0x6E205974": "sceUsbCamSetSaturation",
      "0x70F522C5": "sceUsbCamGetBrightness",
      "0x7563AFA1": "sceUsbCamStillWaitInputEnd",
      "0x7DAC0C71": "sceUsbCamReadVideoFrameBlocking",
      "0x82A64030": "sceUsbCamStartMic",
      "0x951BEDF5": "sceUsbCamSetReverseMode",
      "0x95F8901E": "sceUsbCamGetFwUpdateResult",
      "0x994471E0": "sceUsbCamGetImageEffectMode",
      "0x99D86281": "sceUsbCamReadVideoFrame",
      "0x9E8AAF8D": "sceUsbCamGetZoom",
      "0xA063A957": "sceUsbCamGetContrast",
      "0xA720937C": "sceUsbCamStillCancelInput",
      "0xAA7D94BA": "sceUsbCamGetAntiFlicker",
      "0xB048A67D": "sceUsbCamWaitReadMicEnd",
      "0xC484901F": "sceUsbCamSetZoom",
      "0xC72ED6D3": "sceUsbCamEnterFwUpdateMode",
      "0xCFE9E999": "sceUsbCamSetupVideoEx",
      "0xD293A100": "sceUsbCamRegisterLensRotationCallback",
      "0xD4876173": "sceUsbCamSetImageEffectMode",
      "0xD5279339": "sceUsbCamGetReverseMode",
      "0xD865997B": "sceUsbCamSetResolution",
      "0xDF9D0C92": "sceUsbCamGetReadVideoFrameSize",
      "0xE5959C36": "sceUsbCamStillGetInputLength",
      "0xF8847F60": "sceUsbCamPollReadMicEnd",
      "0xF90B2293": "sceUsbCamWaitReadVideoFrameEnd",
      "0xF93C4669": "sceUsbCamAutoImageReverseSW",
      "0xFB0A6C5D": "sceUsbCamStillInput",
      "0xFDB68C23": "sceUsbCamGetSharpness"
    },
    sceUsbCam_driver: {
      "0x03ED7A82": "sceUsbCamSetupMic",
      "0x08AEE98A": "sceUsbCamSetMicGain",
      "0x09C26C7E": "sceUsbCamSetContrast",
      "0x0A41A298": "sceUsbCamSetupStillEx",
      "0x11A1F128": "sceUsbCamGetAutoImageReverseState",
      "0x17F7B2FB": "sceUsbCamSetupVideo",
      "0x1A46CFE7": "sceUsbCamStillPollInputEnd",
      "0x1D686870": "sceUsbCamSetEvLevel",
      "0x1E958148": "sceUsbCamIoctl",
      "0x2BCD50C0": "sceUsbCamGetEvLevel",
      "0x2E930264": "sceUsbCamSetupMicEx",
      "0x36636925": "sceUsbCamReadMicBlocking",
      "0x383E9FA8": "sceUsbCamGetSaturation",
      "0x3DC0088E": "sceUsbCamReadMic",
      "0x3F0CF289": "sceUsbCamSetupStill",
      "0x41EE8797": "sceUsbCamUnregisterLensRotationCallback",
      "0x4C34F553": "sceUsbCamGetLensDirection",
      "0x4F3D84D5": "sceUsbCamSetBrightness",
      "0x5145868A": "sceUsbCamStopMic",
      "0x574A8C3F": "sceUsbCamStartVideo",
      "0x5778B452": "sceUsbCamGetMicDataLength",
      "0x61BE5CAC": "sceUsbCamStillInputBlocking",
      "0x622F83CC": "sceUsbCamSetSharpness",
      "0x6784E6A8": "sceUsbCamSetAntiFlicker",
      "0x6CF32CB9": "sceUsbCamStopVideo",
      "0x6E205974": "sceUsbCamSetSaturation",
      "0x70F522C5": "sceUsbCamGetBrightness",
      "0x7563AFA1": "sceUsbCamStillWaitInputEnd",
      "0x7DAC0C71": "sceUsbCamReadVideoFrameBlocking",
      "0x82A64030": "sceUsbCamStartMic",
      "0x951BEDF5": "sceUsbCamSetReverseMode",
      "0x95F8901E": "sceUsbCamGetFwUpdateResult",
      "0x994471E0": "sceUsbCamGetImageEffectMode",
      "0x99D86281": "sceUsbCamReadVideoFrame",
      "0x9E8AAF8D": "sceUsbCamGetZoom",
      "0xA063A957": "sceUsbCamGetContrast",
      "0xA720937C": "sceUsbCamStillCancelInput",
      "0xAA7D94BA": "sceUsbCamGetAntiFlicker",
      "0xB048A67D": "sceUsbCamWaitReadMicEnd",
      "0xC484901F": "sceUsbCamSetZoom",
      "0xC72ED6D3": "sceUsbCamEnterFwUpdateMode",
      "0xCFE9E999": "sceUsbCamSetupVideoEx",
      "0xD293A100": "sceUsbCamRegisterLensRotationCallback",
      "0xD4876173": "sceUsbCamSetImageEffectMode",
      "0xD5279339": "sceUsbCamGetReverseMode",
      "0xD865997B": "sceUsbCamSetResolution",
      "0xDF9D0C92": "sceUsbCamGetReadVideoFrameSize",
      "0xE5959C36": "sceUsbCamStillGetInputLength",
      "0xF8847F60": "sceUsbCamPollReadMicEnd",
      "0xF90B2293": "sceUsbCamWaitReadVideoFrameEnd",
      "0xF93C4669": "sceUsbCamAutoImageReverseSW",
      "0xFB0A6C5D": "sceUsbCamStillInput",
      "0xFDB68C23": "sceUsbCamGetSharpness"
    },
    sceUsbDmb: {},
    sceUsbDmb_driver: {},
    sceUsbGps: {
      "0x268F95CA": "sceUsbGpsSetInitDataLocation",
      "0x31F95CDE": "sceUsbGpsGetPowerSaveMode",
      "0x54D26AA4": "sceUsbGpsGetInitDataLocation",
      "0x63D1F89D": "sceUsbGpsResetInitialPosition",
      "0x69E4AAA8": "sceUsbGpsSaveInitData",
      "0x6EED4811": "sceUsbGpsClose",
      "0x7C16AC3A": "sceUsbGpsGetState",
      "0x934EC2B2": "sceUsbGpsGetData",
      "0x9D8F99E8": "sceUsbGpsSetPowerSaveMode",
      "0x9F267D34": "sceUsbGpsOpen",
      "0xA259CD67": "sceUsbGpsReset"
    },
    sceUsbGps_driver: {
      "0x268F95CA": "sceUsbGpsSetInitDataLocation",
      "0x31F95CDE": "sceUsbGpsGetPowerSaveMode",
      "0x54D26AA4": "sceUsbGpsGetInitDataLocation",
      "0x69E4AAA8": "sceUsbGpsSaveInitData",
      "0x6EED4811": "sceUsbGpsClose",
      "0x7C16AC3A": "sceUsbGpsGetState",
      "0x934EC2B2": "sceUsbGpsGetData",
      "0x9D8F99E8": "sceUsbGpsSetPowerSaveMode",
      "0x9F267D34": "sceUsbGpsOpen",
      "0xA259CD67": "sceUsbGpsReset"
    },
    sceUsbMic: {
      "0x06128E42": "sceUsbMicPollInputEnd",
      "0x2E6DCDCD": "sceUsbMicInputBlocking",
      "0x45310F07": "sceUsbMicInputInitEx",
      "0x5F7F368D": "sceUsbMicInput",
      "0x63400E20": "sceUsbMicGetInputLength",
      "0xB8E536EB": "sceUsbMicInputInit",
      "0xF899001C": "sceUsbMicWaitInputEnd"
    },
    sceUsbMic_driver: {
      "0x06128E42": "sceUsbMicPollInputEnd",
      "0x2E6DCDCD": "sceUsbMicInputBlocking",
      "0x45310F07": "sceUsbMicInputInitEx",
      "0x5F7F368D": "sceUsbMicInput",
      "0x63400E20": "sceUsbMicGetInputLength",
      "0xB8E536EB": "sceUsbMicInputInit",
      "0xF899001C": "sceUsbMicWaitInputEnd"
    },
    sceUsbstor: {"0x60066CFE": "sceUsbstorGetStatus"},
    sceUsbstor_driver: {"0x60066CFE": "sceUsbstorGetStatus"},
    sceUsbstor_internal: {
      "0x50F99EAD": "sceUsbstorGetString",
      "0xDC1A5833": "sceUsbstorSendData",
      "0xEC57ED1D": "sceUsbstorGetSubClass",
      "0xF03FCB48": "sceUsbstorSetSubClass",
      "0xFC4D0080": "sceUsbstorRecvData"
    },
    sceUsbstormln_driver: {},
    sceUsbstormln: {
      "0x1F4AC19C": "sceUsbstormlnGetCommand",
      "0x25B6F372": "sceUsbstormlnUnregisterBuffer",
      "0x382898DE": "sceUsbstormlnRegisterBuffer",
      "0x5821060D": "sceUsbstormlnNotifyResponse",
      "0xDEC0FE8C": "sceUsbstormlnWaitStatus",
      "0xE11DEFDF": "sceUsbstormlnCancelWaitStatus"
    },
    sceUSB_Stor_Ms_driver: {
      "0x16173D42": "sceUsbstorMsSetNickname",
      "0x2241C828": "sceUsbstorMsGetVSHInfo",
      "0x4B10A7F5": "sceUsbstorMsRegisterEventFlag",
      "0x576E7F6F": "sceUsbstorMsSetProductInfo",
      "0x762F7FDF": "sceUsbstorMsNotifyEventDone",
      "0x7B810720": "sceUsbstorMsSetWorkBuf",
      "0x9569F268": "sceUsbstorMsSetVSHInfo",
      "0xABE9F2C7": "sceUsbstorMsGetApInfo",
      "0xCF2AF7B3": "sceUsbstorMsGetNickname",
      "0xFF0C3873": "sceUsbstorMsUnregisterEventFlag"
    },
    Kernel_Library: {
      "0x092968F4": "sceKernelCpuSuspendIntr",
      "0x15B6446B": "sceKernelUnlockLwMutex",
      "0x1FC64E09": "sceKernelLockLwMutexCB",
      "0x3B84732D": "sceKernelCpuResumeIntrWithSync",
      "0x47A0B729": "sceKernelIsCpuIntrSuspended",
      "0x5F10D406": "sceKernelCpuResumeIntr",
      "0xB55249D2": "sceKernelIsCpuIntrEnable",
      "0xBEA46419": "sceKernelLockLwMutex",
      "0xC1734599": "sceKernelReferLwMutexStatus",
      "0xDC692EE3": "sceKernelTryLockLwMutex"
    },
    sceGe_lazy: {},
    sceUtility_driver: {"0x20C68C34": "sceUtilityEnd", "0xF062AEA6": "sceUtilityInit"},
    sceUtility: {
      "0x05AFB9E4": "sceUtilityHtmlViewerUpdate",
      "0x0D5BC6D2": "sceUtilityLoadUsbModule",
      "0x1281DA8E": "sceUtilityInstallInitStart",
      "0x1579A159": "sceUtilityLoadNetModule",
      "0x2A2B3DE0": "sceUtilityLoadModule",
      "0x2AD8E239": "sceUtilityMsgDialogInitStart",
      "0x34B78343": "sceUtilityGetSystemParamString",
      "0x3AD50AE7": "sceNetplayDialogInitStart",
      "0x3DFAEBA9": "sceUtilityOskShutdownStart",
      "0x417BED54": "sceNetplayDialogUpdate",
      "0x41E30674": "sceUtilitySetSystemParamString",
      "0x434D4B3A": "sceUtilityGetNetParam",
      "0x45C18506": "sceUtilitySetSystemParamInt",
      "0x4928BD96": "sceUtilityMsgDialogAbort",
      "0x4B85C861": "sceUtilityOskUpdate",
      "0x4DB1E739": "sceUtilityNetconfInitStart",
      "0x4FED24D8": "sceUtilityGetNetParamLatestID",
      "0x50C4CD57": "sceUtilitySavedataInitStart",
      "0x5EEE6548": "sceUtilityCheckNetParam",
      "0x5EF1C24A": "sceUtilityInstallShutdownStart",
      "0x6332AA39": "sceUtilityNetconfGetStatus",
      "0x64D50C56": "sceUtilityUnloadNetModule",
      "0x67AF3428": "sceUtilityMsgDialogShutdownStart",
      "0x7853182D": "sceUtilityGameSharingUpdate",
      "0x8874DBE0": "sceUtilitySavedataGetStatus",
      "0x91E70E35": "sceUtilityNetconfUpdate",
      "0x946963F3": "sceUtilityGameSharingGetStatus",
      "0x95FC253B": "sceUtilityMsgDialogUpdate",
      "0x9790B33C": "sceUtilitySavedataShutdownStart",
      "0x9A1C91D7": "sceUtilityMsgDialogGetStatus",
      "0xA03D29BA": "sceUtilityInstallUpdate",
      "0xA5DA2406": "sceUtilityGetSystemParamInt",
      "0xB6CEE597": "sceNetplayDialogGetStatus",
      "0xBC6B6296": "sceNetplayDialogShutdownStart",
      "0xBDA7D894": "sceUtilityHtmlViewerGetStatus",
      "0xC4700FA3": "sceUtilityInstallGetStatus",
      "0xC492F751": "sceUtilityGameSharingInitStart",
      "0xC629AF26": "sceUtilityLoadAvModule",
      "0xCDC3AA41": "sceUtilityHtmlViewerInitStart",
      "0xD4B95FFB": "sceUtilitySavedataUpdate",
      "0xE49BFE92": "sceUtilityUnloadModule",
      "0xEFC6F80F": "sceUtilityGameSharingShutdownStart",
      "0xF3F76017": "sceUtilityOskGetStatus",
      "0xF5CE1134": "sceUtilityHtmlViewerShutdownStart",
      "0xF6269B82": "sceUtilityOskInitStart",
      "0xF64910F0": "sceUtilityUnloadUsbModule",
      "0xF7D8D092": "sceUtilityUnloadAvModule",
      "0xF88155F6": "sceUtilityNetconfShutdownStart"
    },
    sceUtility_private: {},
    sceUtility_netparam_internal: {},
    sceVaudio_driver: {
      "0x03B6807D": "sceVaudioChReserve",
      "0x67585DFD": "sceVaudioChRelease",
      "0x8986295E": "sceVaudioOutputBlocking",
      "0xCBD4AC51": "sceVaudioSetAlcMode"
    },
    sceVaudio: {
      "0x03B6807D": "sceVaudioChReserve",
      "0x67585DFD": "sceVaudioChRelease",
      "0x8986295E": "sceVaudioOutputBlocking"
    },
    sceVideo: {},
    sceVideocodec_driver: {"0xCB3312D1": "sceVideocodecEndEntry"},
    sceVshBridge_driver: {"0x39B14120": "_vshVshBridgeStart", "0x92A3B940": "_vshVshBridgeStop"},
    sceVshBridge: {
      "0x2380DC08": "vshIoDevctl",
      "0x41C54ADF": "vshKernelLoadModuleVSHByID",
      "0x4A596D2D": "vshImposeSetParam",
      "0x4DB43867": "vshIdStorageLookup",
      "0x4E4E4DA3": "vshImposeSetStatus",
      "0x53BFD101": "vshMSAudioCheckICV",
      "0x5894C339": "vshImposeChanges",
      "0x5C2983C2": "vshChkregCheckRegion",
      "0x61001D64": "vshChkregGetPsCode",
      "0x639C3CB3": "vshImposeGetParam",
      "0x6CAEB765": "vshMSAudioAuth",
      "0x74DA9D25": "vshLflashFatfmtStartFatfmt",
      "0x7EA32357": "vshMSAudioDeauth",
      "0xA5628F0D": "vshKernelLoadModuleVSH",
      "0xC6395C03": "vshCtrlReadBufferPositive",
      "0xC949966C": "vshPowerSetWakeupCondition",
      "0xC9626587": "vshKernelLoadModuleBufferVSH",
      "0xCA719C34": "vshImposeGetStatus",
      "0xCE32CBEF": "vshMSAudioInit",
      "0xE174218C": "vshMSAudioCheckICVn",
      "0xE5DA5E95": "vshMSAudioEnd"
    },
    vsh: {},
    sceWlanDrv: {
      "0x0C622081": "sceWlanGetEtherAddr",
      "0x93440B11": "sceWlanDevIsPowerOn",
      "0xD7763699": "sceWlanGetSwitchState"
    },
    sceWlanDrv_lib: {
      "0x05FE320C": "sceWlanDevGetStateGPIO",
      "0x19E51F54": "sceWlanDevGetMacAddr",
      "0x44A99F9D": "sceWlanGetDropRate",
      "0x482CAE9A": "sceWlanDevAttach",
      "0x4C7F62E0": "sceWlanGPUnRegisterCallback",
      "0x5E7C8D94": "sceWlanDevIsGameMode",
      "0x5ED4049A": "sceWlanGPPrevEstablishActive",
      "0x749B813A": "sceWlanSetHostDiscover",
      "0x7FF54BD2": "sceWlanDevSetGPIO",
      "0x9658C9F7": "sceWlanGPRegisterCallback",
      "0xA447103A": "sceWlanGPRecv",
      "0xB4D7CB74": "sceWlanGPSend",
      "0xC9A8CAB7": "sceWlanDevDetach",
      "0xEB3235B5": "sceWlanSetDropRate",
      "0xFBD385FB": "sceWlanDropCheck",
      "0xFE8A0B46": "sceWlanSetWakeUp"
    },
    sceWlanDrv_driver: {"0x19E51F54": "sceWlanDevGetMacAddr"}
  };

  // src/hle/elf_psp.ts
  var console10 = logger.named("elf.psp");
  var ElfPspModuleInfo = class extends Struct {
    constructor() {
      super(...arguments);
      this.moduleAtributes = 0;
      this.moduleVersion = 0;
      this.name = "";
      this.gp = 0;
      this.exportsStart = 0;
      this.exportsEnd = 0;
      this.importsStart = 0;
      this.importsEnd = 0;
      this.pc = 0;
    }
  };
  __decorate([
    StructUInt16
  ], ElfPspModuleInfo.prototype, "moduleAtributes", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleInfo.prototype, "moduleVersion", 2);
  __decorate([
    StructStructStringz(28)
  ], ElfPspModuleInfo.prototype, "name", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleInfo.prototype, "gp", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleInfo.prototype, "exportsStart", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleInfo.prototype, "exportsEnd", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleInfo.prototype, "importsStart", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleInfo.prototype, "importsEnd", 2);
  var ElfPspModuleImport = class extends Struct {
    constructor() {
      super(...arguments);
      this.nameOffset = 0;
      this.version = 0;
      this.flags = 0;
      this.entrySize = 0;
      this.variableCount = 0;
      this.functionCount = 0;
      this.nidAddress = 0;
      this.callAddress = 0;
      this.name = "";
    }
  };
  __decorate([
    StructUInt32
  ], ElfPspModuleImport.prototype, "nameOffset", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleImport.prototype, "version", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleImport.prototype, "flags", 2);
  __decorate([
    StructUInt8
  ], ElfPspModuleImport.prototype, "entrySize", 2);
  __decorate([
    StructUInt8
  ], ElfPspModuleImport.prototype, "variableCount", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleImport.prototype, "functionCount", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleImport.prototype, "nidAddress", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleImport.prototype, "callAddress", 2);
  var ElfPspModuleExport = class extends Struct {
    constructor() {
      super(...arguments);
      this.nameOffset = 0;
      this.version = 0;
      this.flags = 0;
      this.entrySize = 0;
      this.variableCount = 0;
      this.functionCount = 0;
      this.exports = 0;
      this.name = "";
    }
  };
  __decorate([
    StructUInt32
  ], ElfPspModuleExport.prototype, "nameOffset", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleExport.prototype, "version", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleExport.prototype, "flags", 2);
  __decorate([
    StructUInt8
  ], ElfPspModuleExport.prototype, "entrySize", 2);
  __decorate([
    StructUInt8
  ], ElfPspModuleExport.prototype, "variableCount", 2);
  __decorate([
    StructUInt16
  ], ElfPspModuleExport.prototype, "functionCount", 2);
  __decorate([
    StructUInt32
  ], ElfPspModuleExport.prototype, "exports", 2);
  var ElfPspModuleInfoAtributesEnum;
  (function(ElfPspModuleInfoAtributesEnum2) {
    ElfPspModuleInfoAtributesEnum2[ElfPspModuleInfoAtributesEnum2["UserMode"] = 0] = "UserMode";
    ElfPspModuleInfoAtributesEnum2[ElfPspModuleInfoAtributesEnum2["KernelMode"] = 256] = "KernelMode";
  })(ElfPspModuleInfoAtributesEnum || (ElfPspModuleInfoAtributesEnum = {}));
  var InstructionReader = class {
    constructor(memory2) {
      this.memory = memory2;
    }
    read(address) {
      return new Instruction(address, this.memory.readUInt32(address));
    }
    write(address, instruction) {
      this.memory.writeInt32(address, instruction.IDATA);
    }
  };
  var PspElfLoader = class {
    constructor(memory2, memoryManager, moduleManager, syscallManager) {
      this.memory = memory2;
      this.memoryManager = memoryManager;
      this.moduleManager = moduleManager;
      this.syscallManager = syscallManager;
      this.assembler = new MipsAssembler();
      this.baseAddress = 0;
    }
    load(stream) {
      this.elfLoader = ElfLoader.fromStream(stream);
      this.allocateMemory();
      this.writeToMemory();
      this.relocateFromHeaders();
      this.readModuleInfo();
      this.updateModuleImports();
      this.elfDwarfLoader = new ElfDwarfLoader();
      this.elfDwarfLoader.parseElfLoader(this.elfLoader);
    }
    getSymbolAt(address) {
      return this.elfDwarfLoader.getSymbolAt(address);
    }
    getSectionHeaderMemoryStream(sectionHeader) {
      return this.memory.getPointerStream(this.baseAddress + sectionHeader.address, sectionHeader.size);
    }
    readModuleInfo() {
      this.moduleInfo = ElfPspModuleInfo.struct.read(this.getSectionHeaderMemoryStream(this.elfLoader.sectionHeadersByName[".rodata.sceModuleInfo"]));
      this.moduleInfo.pc = this.baseAddress + this.elfLoader.header.entryPoint;
    }
    allocateMemory() {
      this.baseAddress = 0;
      if (this.elfLoader.needsRelocation) {
        this.baseAddress = this.memoryManager.userPartition.childPartitions.sortBy((partition) => partition.size).reverse().first().low;
        this.baseAddress = MathUtils.nextAligned(this.baseAddress, 4096);
      }
      let lowest = 4294967295;
      let highest = 0;
      this.elfLoader.sectionHeaders.filter((section) => (section.flags & ElfSectionHeaderFlags.Allocate) != 0).forEach((section) => {
        lowest = Math.min(lowest, this.baseAddress + section.address);
        highest = Math.max(highest, this.baseAddress + section.address + section.size);
      });
      this.elfLoader.programHeaders.forEach((program) => {
        lowest = Math.min(lowest, this.baseAddress + program.virtualAddress);
        highest = Math.max(highest, this.baseAddress + program.virtualAddress + program.memorySize);
      });
      const memorySegment = this.memoryManager.userPartition.allocateSet(highest - lowest, lowest, "Elf");
    }
    relocateFromHeaders() {
      const RelocProgramIndex = 0;
      this.elfLoader.programHeaders.forEach((programHeader) => {
        switch (programHeader.type) {
          case ElfProgramHeaderType.Reloc1:
            console10.warn("SKIPPING Elf.ProgramHeader.TypeEnum.Reloc1!");
            break;
          case ElfProgramHeaderType.Reloc2:
            throw "Not implemented";
        }
      });
      const RelocSectionIndex = 0;
      this.elfLoader.sectionHeaders.forEach((sectionHeader) => {
        switch (sectionHeader.type) {
          case ElfSectionHeaderType.Relocation:
            console10.log(sectionHeader);
            console10.error("Not implemented ElfSectionHeaderType.Relocation");
            break;
          case ElfSectionHeaderType.PrxRelocation:
            const relocs = StructArray(ElfReloc.struct, sectionHeader.stream.length / ElfReloc.struct.length).read(sectionHeader.stream);
            this.relocateRelocs(relocs);
            break;
          case ElfSectionHeaderType.PrxRelocation_FW5:
            throw "Not implemented ElfSectionHeader.Type.PrxRelocation_FW5";
        }
      });
    }
    relocateRelocs(relocs) {
      const baseAddress = this.baseAddress;
      let hiValue = 0;
      let deferredHi16 = [];
      const instructionReader = new InstructionReader(this.memory);
      for (let index = 0; index < relocs.length; index++) {
        const reloc = relocs[index];
        if (reloc.type == ElfRelocType.StopRelocation)
          break;
        const pointerBaseOffset = this.elfLoader.programHeaders[reloc.pointerSectionHeaderBase].virtualAddress;
        const pointeeBaseOffset = this.elfLoader.programHeaders[reloc.pointeeSectionHeaderBase].virtualAddress;
        const RelocatedPointerAddress = baseAddress + reloc.pointerAddress + pointerBaseOffset;
        const instruction = instructionReader.read(RelocatedPointerAddress);
        const S = baseAddress + pointeeBaseOffset;
        const GP_ADDR = baseAddress + reloc.pointerAddress;
        const GP_OFFSET = GP_ADDR - (baseAddress & 4294901760);
        switch (reloc.type) {
          case ElfRelocType.None:
            break;
          case ElfRelocType.Mips16:
            instruction.u_imm16 += S;
            break;
          case ElfRelocType.Mips32:
            instruction.IDATA += S;
            break;
          case ElfRelocType.MipsRel32:
            throw "Not implemented MipsRel32";
          case ElfRelocType.Mips26:
            instruction.jump_real = instruction.jump_real + S;
            break;
          case ElfRelocType.MipsHi16:
            hiValue = instruction.u_imm16;
            deferredHi16.push(RelocatedPointerAddress);
            break;
          case ElfRelocType.MipsLo16:
            const A = instruction.u_imm16;
            instruction.u_imm16 = (hiValue << 16 | A & 65535) + S;
            deferredHi16.forEach((data_addr2) => {
              const data2 = instructionReader.read(data_addr2);
              let result = ((data2.IDATA & 65535) << 16) + A + S;
              if ((A & 32768) != 0)
                result -= 65536;
              if ((result & 32768) != 0)
                result += 65536;
              data2.u_imm16 = result >>> 16;
              instructionReader.write(data_addr2, data2);
            });
            deferredHi16 = [];
            break;
          case ElfRelocType.MipsGpRel16:
            break;
          default:
            throw new Error(sprintf("RelocType %d not implemented", reloc.type));
        }
        instructionReader.write(RelocatedPointerAddress, instruction);
      }
    }
    writeToMemory() {
      const needsRelocate = this.elfLoader.needsRelocation;
      const loadAddress = this.baseAddress;
      console10.info(sprintf("PspElfLoader: needsRelocate=%s, loadAddress=%08X", needsRelocate, loadAddress));
      this.elfLoader.programHeaders.filter((programHeader) => programHeader.type == 1).forEach((programHeader) => {
        const fileOffset = programHeader.offset;
        const memOffset = this.baseAddress + programHeader.virtualAddress;
        const fileSize = programHeader.fileSize;
        const memSize = programHeader.memorySize;
        this.elfLoader.stream.sliceWithLength(fileOffset, fileSize).copyTo(this.memory.getPointerStream(memOffset, fileSize));
        this.memory.memset(memOffset + fileSize, 0, memSize - fileSize);
        console10.info("Program Header: ", sprintf("%08X:%08X, %08X:%08X", fileOffset, fileSize, memOffset, memSize));
      });
      this.elfLoader.sectionHeaders.filter((sectionHeader) => (sectionHeader.flags & ElfSectionHeaderFlags.Allocate) != 0).forEach((sectionHeader) => {
        const low = loadAddress + sectionHeader.address;
        console10.info("Section Header: ", sectionHeader, sprintf("LOW:%08X, SIZE:%08X", low, sectionHeader.size));
        switch (sectionHeader.type) {
          case ElfSectionHeaderType.NoBits:
            for (let n = 0; n < sectionHeader.size; n++)
              this.memory.writeInt8(low + n, 0);
            break;
          default:
            break;
          case ElfSectionHeaderType.ProgramBits:
            const stream = sectionHeader.stream;
            const length = stream.length;
            this.memory.writeStream(low, stream);
            break;
        }
      });
    }
    updateModuleImports() {
      const moduleInfo = this.moduleInfo;
      console10.log(moduleInfo);
      const importsBytesSize = moduleInfo.importsEnd - moduleInfo.importsStart;
      const importsStream = this.memory.sliceWithBounds(moduleInfo.importsStart, moduleInfo.importsEnd);
      const importsCount = importsBytesSize / ElfPspModuleImport.struct.length;
      const imports = StructArray(ElfPspModuleImport.struct, importsCount).read(importsStream);
      imports.forEach((_import) => {
        _import.name = this.memory.readStringz(_import.nameOffset);
        const imported = this.updateModuleFunctions(_import);
        this.updateModuleVars(_import);
        console10.info("Imported: ", imported.name, imported.registeredNativeFunctions.map((i) => i.name));
      });
    }
    updateModuleFunctions(moduleImport) {
      const _module = this.moduleManager.getByName(moduleImport.name);
      const nidsStream = this.memory.sliceWithSize(moduleImport.nidAddress, moduleImport.functionCount * 4);
      const callStream = this.memory.sliceWithSize(moduleImport.callAddress, moduleImport.functionCount * 8);
      const registeredNativeFunctions = [];
      const unknownFunctions = [];
      const registerN = (nid, n) => {
        let nfunc;
        nfunc = _module.getByNid(nid);
        if (!nfunc) {
          const nidHex = sprintf("0x%08X", nid);
          unknownFunctions.push(sprintf("'%s':%s", _module.moduleName, nidHex));
          const knownModule = ModuleKnownFunctionNamesDatabase?.[_module.moduleName];
          const knownFuncName = knownModule?.[nidHex];
          nfunc = new NativeFunction();
          if (knownFuncName) {
            nfunc.name = sprintf("%s:%s:0x%08X", _module.moduleName, knownFuncName, nid);
          } else {
            nfunc.name = sprintf("%s:0x%08X", moduleImport.name, nid);
          }
          nfunc.nid = nid;
          nfunc.firmwareVersion = 150;
          nfunc.nativeCall = () => {
            const errorString = `updateModuleFunctions: Not implemented '${nfunc.name}'`;
            console10.info(_module);
            console10.error(errorString);
            debugger;
            throw new ProgramExitException(errorString);
          };
          nfunc.call = (context, state) => {
            nfunc.nativeCall();
          };
        }
        registeredNativeFunctions.push(nfunc);
        return this.syscallManager.register(nfunc);
      };
      for (let n = 0; n < moduleImport.functionCount; n++) {
        const nid = nidsStream.readUInt32();
        const syscall = registerN(nid, n);
        callStream.writeInt32(this.assembler.assemble(0, sprintf("jr $31"))[0].IDATA);
        callStream.writeInt32(this.assembler.assemble(0, sprintf("syscall %d", syscall))[0].IDATA);
      }
      if (unknownFunctions.length > 0) {
        console10.warn("Can't find functions", unknownFunctions);
      }
      return {
        name: moduleImport.name,
        registeredNativeFunctions
      };
    }
    updateModuleVars(moduleImport) {
    }
  };

  // src/hle/manager/file.ts
  var Device = class {
    constructor(name2, vfs) {
      this.name = name2;
      this.vfs = vfs;
      this.cwd = "";
    }
    devctlAsync(command, input, output) {
      return this.vfs.devctlAsync(command, input, output);
    }
    openAsync(uri, flags, mode) {
      return this.vfs.openAsync(uri.pathWithoutDevice, flags, mode);
    }
    openDirectoryAsync(uri) {
      return this.vfs.openDirectoryAsync(uri.pathWithoutDevice);
    }
    getStatAsync(uri) {
      return this.vfs.getStatAsync(uri.pathWithoutDevice);
    }
    getStatPromiseAsync(uri) {
      return this.vfs.getStatPromiseAsync(uri.pathWithoutDevice);
    }
  };
  var HleFile = class {
    constructor(entry) {
      this.entry = entry;
      this.cursor = 0;
      this._asyncResult = null;
      this._asyncPromise = null;
    }
    get asyncResult() {
      return this._asyncResult;
    }
    get asyncOperation() {
      return this._asyncPromise;
    }
    startAsyncOperation() {
      this._asyncResult = null;
    }
    setAsyncOperation(operation) {
      this._asyncResult = null;
      this._asyncPromise = PromiseFast.ensure(operation).thenFast((value) => {
        this._asyncResult = value;
        return value;
      });
    }
    setAsyncOperationNow(value) {
      this._asyncResult = value;
      this._asyncPromise = PromiseFast.resolve(value);
    }
    close() {
      this.entry.close();
    }
  };
  var HleDirectory = class {
    constructor(childs) {
      this.childs = childs;
      this.cursor = 0;
    }
    read() {
      return this.childs[this.cursor++];
    }
    get left() {
      return this.childs.length - this.cursor;
    }
    close() {
    }
  };
  var Uri = class {
    constructor(path) {
      this.path = path;
    }
    get device() {
      return this.path.split(":")[0];
    }
    get pathWithoutDevice() {
      return this.path.split(":")[1];
    }
    get isAbsolute() {
      return this.path.indexOf(":") >= 0;
    }
    append(that) {
      if (that.isAbsolute)
        return that;
      return new Uri(`${this.path}/${that.path}`);
    }
  };
  var FileManager = class {
    constructor() {
      this.devices = {};
      this.cwd = new Uri("ms0:/");
    }
    chdir(cwd) {
      this.cwd = new Uri(cwd);
    }
    getDevice(name2) {
      name2 = name2.replace(/:$/, "");
      const device = this.devices[name2];
      if (!device)
        throw new Error(sprintf("Can't find device '%s'", name2));
      return device;
    }
    openAsync(name2, flags, mode) {
      const uri = this.cwd.append(new Uri(name2));
      return this.getDevice(uri.device).openAsync(uri, flags, mode).thenFast((entry) => new HleFile(entry));
    }
    devctlAsync(deviceName, command, input, output) {
      return this.getDevice(deviceName).devctlAsync(command, input, output);
    }
    openDirectoryAsync(name2) {
      const uri = this.cwd.append(new Uri(name2));
      return this.getDevice(uri.device).openDirectoryAsync(uri).thenFast((entry) => {
        return entry.enumerateAsync().thenFast((items) => {
          entry.close();
          return new HleDirectory(items);
        });
      });
    }
    getStatAsync(name2) {
      const uri = this.cwd.append(new Uri(name2));
      return this.getDevice(uri.device).getStatAsync(uri);
    }
    mount(device, vfs) {
      this.devices[device] = new Device(device, vfs);
      return this;
    }
  };

  // src/hle/manager/net.ts
  var NetManager = class {
    constructor() {
      this.connected = false;
      this.ws = null;
      this._onmessageSignals = {};
      this.onopen = new Signal0();
      this.onclose = new Signal0();
      this.mac = new Uint8Array(6);
    }
    onmessage(port) {
      if (!this._onmessageSignals[port])
        this._onmessageSignals[port] = new Signal1();
      return this._onmessageSignals[port];
    }
    connectOnce() {
      if (this.ws)
        return;
      this.ws = new WebSocket(`ws://${location.host}/adhoc`, "adhoc");
      this.ws.onopen = (e) => {
      };
      this.ws.onclose = (e) => {
        this.connected = false;
        this.onclose.dispatch();
        setTimeout(() => {
          this.ws = null;
          this.connectOnce();
        }, 5e3);
      };
      this.ws.onmessage = (e) => {
        const info = JSON.parse(e.data);
        if (info.from == "ff:ff:ff:ff:ff:ff") {
          console.info("NetManager: from_server:", info);
          switch (info.type) {
            case "setid":
              this.mac = string2mac(info.payload);
              this.connected = true;
              this.onopen.dispatch();
              break;
          }
        } else {
          const packet = {
            port: info.port,
            type: info.type,
            mac: string2mac(info.from),
            payload: Stream.fromBase64(info.payload).toUInt8Array()
          };
          this.onmessage(info.port).dispatch(packet);
        }
      };
      this.ws.onerror = (e) => {
        this.connected = false;
        console.error(e);
        setTimeout(() => {
          this.connectOnce();
          this.ws = null;
        }, 1e4);
      };
    }
    send(port, type, toMac, data) {
      this.connectOnce();
      this.ws.send(JSON.stringify({type, port, to: mac2string(toMac), payload: Stream.fromUint8Array(data).toBase64()}));
    }
  };

  // src/hle/manager/module.ts
  var ModuleWrapper = class {
    constructor(moduleName, _modules) {
      this.moduleName = moduleName;
      this._modules = _modules;
      this.names = {};
      this.nids = {};
      _modules.forEach((_module) => {
        if (typeof _module.natives != "undefined") {
          const natives = _module.natives;
          for (let nativeGenerator of natives) {
            this.registerNative(nativeGenerator(_module));
          }
        }
        for (const key in _module) {
          if (key == "natives")
            continue;
          const item = _module[key];
          if (item && item instanceof NativeFunction) {
            const nativeFunction2 = item;
            nativeFunction2.name = key;
            this.registerNative(nativeFunction2);
          }
        }
      });
    }
    registerNative(nf) {
      this.nids[nf.nid] = nf;
      this.names[nf.name] = nf;
    }
    getByName(name2) {
      return this.names[name2];
    }
    getByNid(nid) {
      const result = this.nids[nid];
      return result;
    }
  };
  var ModuleManager = class {
    constructor(context) {
      this.context = context;
      this.names = {};
      this.moduleWrappers = {};
    }
    registerClass(clazz) {
      this.add(clazz.name, clazz);
    }
    registerModule(_module) {
      for (const key in _module) {
        if (key == "createNativeFunction")
          continue;
        if (key == "natives")
          continue;
        const _class = _module[key];
        this.add(key, _class);
      }
    }
    getByName(name2) {
      const _moduleWrapper = this.moduleWrappers[name2];
      if (_moduleWrapper)
        return _moduleWrapper;
      const _classes = this.names[name2];
      if (!_classes)
        throw new Error("Can't find module '" + name2 + "'");
      const _modules = _classes.map((_class) => new _class(this.context));
      return this.moduleWrappers[name2] = new ModuleWrapper(name2, _modules);
    }
    add(name2, _class) {
      if (!_class)
        throw new Error("Can't find module '" + name2 + "'");
      if (!this.names[name2])
        this.names[name2] = [];
      this.names[name2].push(_class);
    }
  };

  // src/hle/vfs/vfs_memory.ts
  var console11 = logger.named("memory_vfs");
  var MemoryVfs = class extends Vfs {
    constructor() {
      super(...arguments);
      this.files = {};
    }
    addFile(name2, data) {
      this.files[name2] = new MemoryVfsEntry(name2, data);
    }
    async openPromiseAsync(path, flags, mode) {
      if (flags & FileOpenFlags.Write) {
        if (!this.files[path]) {
          this.addFile(path, new ArrayBuffer(0));
        }
      }
      if (flags & FileOpenFlags.Truncate) {
        this.addFile(path, new ArrayBuffer(0));
      }
      const file = this.files[path];
      if (!file) {
        throw new Error(`MemoryVfs: Can't find '${path}'`);
      } else {
        return file;
      }
    }
  };
  var MemoryVfsEntry = class extends VfsEntry {
    constructor(name2, data) {
      super();
      this.name = name2;
      this.data = data;
    }
    get isDirectory() {
      return false;
    }
    readChunkAsync(offset, length) {
      return PromiseFast.resolve(this.data.slice(offset, offset + length));
    }
    writeChunkAsync(offset, data) {
      const newData = new ArrayBuffer(Math.max(this.data.byteLength, offset + data.byteLength));
      const newDataArray = new Uint8Array(newData);
      newDataArray.set(new Uint8Array(this.data), 0);
      newDataArray.set(new Uint8Array(data), offset);
      this.data = newData;
      return PromiseFast.resolve(data.byteLength);
    }
    stat() {
      return {
        name: this.name,
        size: this.data.byteLength,
        isDirectory: false,
        timeCreation: new Date(),
        timeLastAccess: new Date(),
        timeLastModification: new Date()
      };
    }
    close() {
    }
    enumerateAsync() {
      return PromiseFast.resolve([]);
    }
  };

  // src/hle/vfs/vfs_mountable.ts
  var MountableVfs = class extends Vfs {
    constructor() {
      super(...arguments);
      this.mounts = [];
    }
    mountVfs(path, vfs) {
      this.mounts.unshift(new MountableEntry(this.normalizePath(path), vfs, null));
      return this;
    }
    mountFileData(path, data) {
      this.mounts.unshift(new MountableEntry(this.normalizePath(path), null, new MemoryVfsEntry(path, data)));
    }
    normalizePath(path) {
      return path.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
    }
    transformPath(path) {
      path = this.normalizePath(path);
      for (let n = 0; n < this.mounts.length; n++) {
        const mount = this.mounts[n];
        if (path.startsWith(mount.path)) {
          const part = path.substr(mount.path.length);
          return {mount, part};
        }
      }
      console.info(this.mounts);
      throw new Error("MountableVfs: Can't find file '" + path + "'");
    }
    async openPromiseAsync(path, flags, mode) {
      const info = this.transformPath(path);
      if (info.mount.file) {
        return info.mount.file;
      } else {
        return await info.mount.vfs.openAsync(info.part, flags, mode);
      }
    }
    openDirectoryAsync(path) {
      const info = this.transformPath(path);
      if (info.mount.file) {
        return PromiseFast.resolve(info.mount.file);
      } else {
        return info.mount.vfs.openDirectoryAsync(info.part);
      }
    }
    async getStatPromiseAsync(path) {
      const info = this.transformPath(path);
      if (info.mount.file) {
        return info.mount.file.stat();
      } else {
        return await info.mount.vfs.getStatPromiseAsync(info.part);
      }
    }
    deleteAsync(path) {
      const info = this.transformPath(path);
      return info.mount.vfs.deleteAsync(info.part);
    }
  };
  var MountableEntry = class {
    constructor(path, vfs, file) {
      this.path = path;
      this.vfs = vfs;
      this.file = file;
    }
  };

  // src/hle/manager/interop.ts
  var Interop = class {
    execute(state, address, gprArray) {
      state.preserveRegisters(() => {
        state.setRA(CpuSpecialAddresses.EXIT_INTERRUPT);
        for (let n = 0; n < gprArray.length; n++) {
          state.setGPR(4 + n, gprArray[n]);
        }
        state.setPC(address);
        CpuExecutor.executeAtPCAsync(state);
      });
    }
  };

  // src/hle/vfs/indexeddb.ts
  var console12 = logger.named("indexeddb");
  var MyStorageIndexedDb = class {
    constructor(db) {
      this.db = db;
    }
    static async openAsync(name2) {
      console12.info(`MyStorageIndexedDb.openAsync("${name2}")`);
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(name2, 1);
        request.onupgradeneeded = function(e) {
          const db = request.result;
          console12.log("upgrade!");
          if (db.objectStoreNames.contains("items"))
            db.deleteObjectStore("items");
          db.createObjectStore("items", {keyPath: "key"});
        };
        request.onerror = (event) => {
          reject(new Error("Can't open indexedDB"));
        };
        request.onsuccess = (event) => {
          resolve(new MyStorageIndexedDb(request.result));
        };
      });
    }
    getItemsStore() {
      return this.db.transaction(["items"], "readwrite").objectStore("items");
    }
    async putAsync(key, value) {
      console12.log("putAsync", key, value);
      const store = this.getItemsStore();
      return new Promise((resolve, reject) => {
        const request = store.put({key, value});
        request.onsuccess = function(e) {
          resolve();
        };
        request.onerror = function(e) {
          reject(e["value"]);
        };
      });
    }
    async deleteAsync(key) {
      console12.log("deleteAsync", key);
      const store = this.getItemsStore();
      return new Promise((resolve, reject) => {
        const request = store.delete(key);
        request.onsuccess = function(e) {
          resolve();
        };
        request.onerror = function(e) {
          reject(e["value"]);
        };
      });
    }
    async hasAsync(key) {
      console12.log("hasAsync", key);
      try {
        await this.getAsync(key);
        return true;
      } catch (e) {
        return false;
      }
    }
    async getAsync(key) {
      const store = this.getItemsStore();
      return new Promise((resolve, reject) => {
        const request = store.get(key);
        request.onsuccess = (e) => {
          const result = e.target["result"];
          if (!result) {
            console12.log("getAsync", key, void 0);
            resolve(void 0);
          } else {
            console12.log("getAsync", key, result.value);
            resolve(result.value);
          }
        };
        request.onerror = (e) => {
          console12.log("getAsync", key, e);
          reject(e["value"]);
        };
      });
    }
  };
  var MyStorageFake = class {
    constructor(name2) {
      this.name = name2;
      this.items = {};
    }
    putAsync(key, value) {
      console12.log("putAsync", key, value);
      this.items[key] = value;
      return Promise.resolve();
    }
    deleteAsync(key) {
      console12.log("deleteAsync", key);
      delete this.items[key];
      return Promise.resolve();
    }
    hasAsync(key) {
      const value = this.items[key] !== void 0;
      console12.log("hasAsync", key, value);
      return Promise.resolve(value);
    }
    getAsync(key) {
      const result = this.items[key];
      console12.log("getAsync", key, result);
      return Promise.resolve(result);
    }
  };
  async function indexedDbOpenAsync(name2, version, stores) {
    if (typeof indexedDB == "undefined") {
      return new MyStorageFake(name2);
    } else {
      return await MyStorageIndexedDb.openAsync(name2 + "_v2");
    }
  }

  // src/hle/vfs/vfs_storage.ts
  var console13 = logger.named("vfs.storage");
  var StorageVfs = class extends Vfs {
    constructor(key) {
      super();
      this.key = key;
    }
    initializeOnceAsync() {
      if (!this.openDbPromise) {
        this.openDbPromise = (async () => {
          const db = await indexedDbOpenAsync(this.key, 3, ["files"]);
          this.db = db;
          return this;
        })();
      }
      return this.openDbPromise;
    }
    async openPromiseAsync(path, flags, mode) {
      await this.initializeOnceAsync();
      return await StorageVfsEntry.fromNameAsync(this.db, path, flags, mode);
    }
    deleteAsync(path) {
      return PromiseFast.ensure(this._deleteAsync(path));
    }
    async _deleteAsync(path) {
      await this.initializeOnceAsync();
      return this.db.deleteAsync(path);
    }
  };
  var StorageVfsEntry = class extends VfsEntry {
    constructor(db, name2) {
      super();
      this.db = db;
      this.name = name2;
    }
    initAsync(flags, mode) {
      return this._getFileAsync().thenFast((file) => {
        console13.info("initAsync", file);
        if (!file.exists) {
          if (!(flags & FileOpenFlags.Create)) {
            throw new Error(`File '${file.name}' doesn't exist`);
          }
        }
        if (flags & FileOpenFlags.Truncate) {
          file.content = new Uint8Array([]);
        }
        this.file = file;
        return this;
      });
    }
    static fromNameAsync(db, name2, flags, mode) {
      return new StorageVfsEntry(db, name2).initAsync(flags, mode);
    }
    async _getFileAsync() {
      let file = await this.db.getAsync(this.name);
      if (!file)
        file = {name: this.name, content: new ArrayBuffer(0), date: new Date(), exists: false};
      return file;
    }
    async _writeAllAsync(data) {
      return await this.db.putAsync(this.name, {
        name: this.name,
        content: new Uint8Array(data),
        date: new Date(),
        exists: true
      });
    }
    enumerateAsync() {
      throw new Error("Must override enumerateAsync : " + this);
    }
    readChunkAsync(offset, length) {
      return PromiseFast.resolve(this.file.content.buffer.slice(offset, offset + length));
    }
    writeChunkAsync(offset, data) {
      return PromiseFast.ensure(this._writeChunkAsync(offset, data));
    }
    async _writeChunkAsync(offset, data) {
      const newContent = new ArrayBuffer(Math.max(this.file.content.byteLength, offset + data.byteLength));
      const newContentArray = new Uint8Array(newContent);
      newContentArray.set(new Uint8Array(this.file.content), 0);
      newContentArray.set(new Uint8Array(data), offset);
      this.file.content = newContentArray;
      await this._writeAllAsync(newContent);
      return data.byteLength;
    }
    stat() {
      return {
        name: this.file.name,
        size: this.file.content.byteLength,
        isDirectory: false,
        timeCreation: this.file.date,
        timeLastAccess: this.file.date,
        timeLastModification: this.file.date,
        dependentData0: 0,
        dependentData1: 0
      };
    }
    close() {
    }
  };

  // src/hle/vfs/vfs_emulator.ts
  var EmulatorVfs = class extends Vfs {
    constructor(context) {
      super();
      this.context = context;
      this.output = "";
      this.screenshot = null;
    }
    devctlAsync(command, input, output) {
      switch (command) {
        case EmulatorDevclEnum.GetHasDisplay:
          if (output)
            output.writeInt32(0);
          break;
        case EmulatorDevclEnum.SendOutput:
          const str = input.readString(input.length);
          this.output += str;
          this.context.onStdout.dispatch(str);
          return PromiseFast.resolve(0);
        case EmulatorDevclEnum.IsEmulator:
          return 0;
        case EmulatorDevclEnum.EmitScreenshot:
          this.screenshot = input.toUInt8Array();
          console.warn("emit screenshot!");
          return 0;
        default:
          throw new Error(`Can't handle EmulatorVfs devctlAsync. Command '${command}'`);
      }
      return 0;
    }
  };
  var EmulatorDevclEnum;
  (function(EmulatorDevclEnum2) {
    EmulatorDevclEnum2[EmulatorDevclEnum2["GetHasDisplay"] = 1] = "GetHasDisplay";
    EmulatorDevclEnum2[EmulatorDevclEnum2["SendOutput"] = 2] = "SendOutput";
    EmulatorDevclEnum2[EmulatorDevclEnum2["IsEmulator"] = 3] = "IsEmulator";
    EmulatorDevclEnum2[EmulatorDevclEnum2["SendCtrlData"] = 16] = "SendCtrlData";
    EmulatorDevclEnum2[EmulatorDevclEnum2["EmitScreenshot"] = 32] = "EmitScreenshot";
  })(EmulatorDevclEnum || (EmulatorDevclEnum = {}));

  // src/hle/vfs/vfs_ms.ts
  var MemoryStickVfs = class extends ProxyVfs {
    constructor(parentVfsList, callbackManager, memory2) {
      super(parentVfsList);
      this.callbackManager = callbackManager;
      this.memory = memory2;
    }
    devctlAsync(command, input, output) {
      switch (command) {
        case CommandType.CheckInserted:
          if (output == null || output.length < 4)
            return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
          output.writeInt32(1);
          return 0;
        case CommandType.MScmRegisterMSInsertEjectCallback:
          if (input == null || input.length < 4)
            return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
          const callbackId = input.readInt32();
          this.callbackManager.notify(callbackId, 1);
          return 0;
        case CommandType.MScmUnregisterMSInsertEjectCallback:
          return 0;
        case CommandType.GetMemoryStickCapacity:
          if (input == null || input.length < 4)
            return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
          const structAddress = input.readInt32();
          const structStream = this.memory.getPointerStream(structAddress, SizeInfoStruct.struct.length);
          const sizeInfo = new SizeInfoStruct();
          const memoryStickSectorSize = 32 * 1024;
          const freeSpaceInBytes = 1 * 1024 * 1024 * 1024;
          sizeInfo.sectorSize = 512;
          sizeInfo.sectorCount = memoryStickSectorSize / sizeInfo.sectorSize;
          sizeInfo.maxClusters = freeSpaceInBytes * 95 / 100 / (sizeInfo.sectorSize * sizeInfo.sectorCount);
          sizeInfo.freeClusters = sizeInfo.maxClusters;
          sizeInfo.maxSectors = sizeInfo.maxClusters;
          SizeInfoStruct.struct.write(structStream, sizeInfo);
          return 0;
        case CommandType.CheckMemoryStickIsInserted:
          output.writeInt32(1);
          return 0;
        case CommandType.CheckMemoryStickStatus:
          output.writeInt32(4);
          return 0;
        default:
          throw new Error(`Invalid MemoryStick command '${command}'`);
      }
    }
  };
  var CommandType;
  (function(CommandType2) {
    CommandType2[CommandType2["CheckInserted"] = 37902371] = "CheckInserted";
    CommandType2[CommandType2["MScmRegisterMSInsertEjectCallback"] = 37836833] = "MScmRegisterMSInsertEjectCallback";
    CommandType2[CommandType2["MScmUnregisterMSInsertEjectCallback"] = 37836834] = "MScmUnregisterMSInsertEjectCallback";
    CommandType2[CommandType2["GetMemoryStickCapacity"] = 37902360] = "GetMemoryStickCapacity";
    CommandType2[CommandType2["CheckMemoryStickIsInserted"] = 33708038] = "CheckMemoryStickIsInserted";
    CommandType2[CommandType2["CheckMemoryStickStatus"] = 33708033] = "CheckMemoryStickStatus";
  })(CommandType || (CommandType = {}));
  var SizeInfoStruct = class extends Struct {
    constructor() {
      super(...arguments);
      this.maxClusters = 0;
      this.freeClusters = 0;
      this.maxSectors = 0;
      this.sectorSize = 0;
      this.sectorCount = 0;
    }
  };
  __decorate([
    StructUInt32
  ], SizeInfoStruct.prototype, "maxClusters", 2);
  __decorate([
    StructUInt32
  ], SizeInfoStruct.prototype, "freeClusters", 2);
  __decorate([
    StructUInt32
  ], SizeInfoStruct.prototype, "maxSectors", 2);
  __decorate([
    StructUInt32
  ], SizeInfoStruct.prototype, "sectorSize", 2);
  __decorate([
    StructUInt32
  ], SizeInfoStruct.prototype, "sectorCount", 2);

  // src/hle/vfs/vfs_uri.ts
  var UriVfs = class extends Vfs {
    constructor(baseUri) {
      super();
      this.baseUri = baseUri;
    }
    getAbsoluteUrl(path) {
      return `${this.baseUri}/${path}`;
    }
    async openPromiseAsync(path, flags, mode) {
      if (flags & FileOpenFlags.Write) {
        return PromiseFast.resolve(new MemoryVfsEntry(path, new ArrayBuffer(0)));
      }
      const url = this.getAbsoluteUrl(path);
      const stream = await UrlAsyncStream.fromUrlAsync(url);
      return new VfsEntryStream(stream);
    }
    openDirectoryAsync(path) {
      return PromiseFast.resolve(new MemoryVfsEntry(path, new ArrayBuffer(0)));
    }
    async getStatPromiseAsync(path) {
      const url = this.getAbsoluteUrl(path);
      return await statUrlAsync(url);
    }
  };
  function urlStatToVfsStat(url, info) {
    return {
      name: url,
      size: info.size,
      isDirectory: false,
      timeCreation: info.date,
      timeLastAccess: info.date,
      timeLastModification: info.date
    };
  }
  async function statUrlAsync(url) {
    const info = await statFileAsync(url);
    return await urlStatToVfsStat(url, info);
  }

  // src/hle/vfs/vfs_zip.ts
  var ZipVfs = class extends Vfs {
    constructor(zip, writeVfs) {
      super();
      this.zip = zip;
      this.writeVfs = writeVfs;
    }
    async openPromiseAsync(path, flags, mode) {
      return new ZipVfsFile(this.zip.get(path));
    }
  };
  var ZipVfsFile = class extends VfsEntry {
    constructor(node) {
      super();
      this.node = node;
    }
    get isDirectory() {
      return this.node.isDirectory;
    }
    get size() {
      return this.node.size;
    }
    readChunkAsync(offset, length) {
      return this.node.readChunkAsync(offset, length);
    }
    close() {
    }
    static statNode(node) {
      return {
        name: node.name,
        size: node.size,
        isDirectory: node.isDirectory,
        timeCreation: node.date,
        timeLastAccess: node.date,
        timeLastModification: node.date
      };
    }
    stat() {
      return ZipVfsFile.statNode(this.node);
    }
    enumerateAsync() {
      return PromiseFast.resolve(this.node.getChildList().map((node) => ZipVfsFile.statNode(node)));
    }
  };

  // src/hle/vfs/vfs_iso.ts
  var IsoVfs = class extends Vfs {
    constructor(iso) {
      super();
      this.iso = iso;
    }
    async openPromiseAsync(path, flags, mode) {
      return new IsoVfsFile(this.iso.get(path));
    }
  };
  var IsoVfsFile = class extends VfsEntry {
    constructor(node) {
      super();
      this.node = node;
    }
    get isDirectory() {
      return this.node.isDirectory;
    }
    get size() {
      return this.node.size;
    }
    readChunkAsync(offset, length) {
      return this.node.readChunkAsync(offset, length);
    }
    close() {
    }
    static statNode(node) {
      return {
        name: node.name,
        size: node.size,
        isDirectory: node.isDirectory,
        timeCreation: node.date,
        timeLastAccess: node.date,
        timeLastModification: node.date,
        dependentData0: node.extent
      };
    }
    stat() {
      return IsoVfsFile.statNode(this.node);
    }
    enumerateAsync() {
      return PromiseFast.resolve(this.node.childs.map((node) => IsoVfsFile.statNode(node)));
    }
  };

  // src/html5/Html5Gamepad.ts
  var navigator2 = typeof window != "undefined" ? window.navigator : null;
  var getGamepads = navigator2?.getGamepads?.bind(navigator2);
  var gamepadButtonMapping = [
    PspCtrlButtons.cross,
    PspCtrlButtons.circle,
    PspCtrlButtons.square,
    PspCtrlButtons.triangle,
    PspCtrlButtons.leftTrigger,
    PspCtrlButtons.rightTrigger,
    PspCtrlButtons.volumeUp,
    PspCtrlButtons.volumeDown,
    PspCtrlButtons.select,
    PspCtrlButtons.start,
    PspCtrlButtons.home,
    PspCtrlButtons.note,
    PspCtrlButtons.up,
    PspCtrlButtons.down,
    PspCtrlButtons.left,
    PspCtrlButtons.right
  ];
  var Html5Gamepad = class extends PspControllerContributor {
    checkButton(button) {
      if (typeof button == "number") {
        return button != 0;
      } else {
        return button ? button.pressed : false;
      }
    }
    computeFrame() {
      if (!getGamepads)
        return void 0;
      const gamepads = getGamepads();
      const firstGamePad = gamepads[0];
      if (!firstGamePad)
        return void 0;
      const buttons = firstGamePad.buttons;
      const axes = firstGamePad.axes;
      this.data.x = MathUtils.transformRange(axes[0], -0.6, 0.6, -1, 1);
      this.data.y = MathUtils.transformRange(axes[1], -0.6, 0.6, -1, 1);
      this.data.buttons = PspCtrlButtons.none;
      for (let n = 0; n < 16; n++) {
        this.data.buttons = BitUtils.withMask(this.data.buttons, gamepadButtonMapping[n], this.checkButton(buttons[n]));
      }
    }
    register() {
    }
    unregister() {
    }
  };

  // src/html5/Html5Keyboard.ts
  var Html5Keyboard = class extends PspControllerContributor {
    constructor() {
      super();
      this.keyDown = (e) => {
        this.setKeyDown(e.keyCode);
      };
      this.keyUp = (e) => {
        this.setKeyUp(e.keyCode);
      };
      this.buttonMapping = {};
      this.fieldMapping = {};
      this.analogUp = false;
      this.analogDown = false;
      this.analogLeft = false;
      this.analogRight = false;
      this.analogAddX = 0;
      this.analogAddY = 0;
      this.addX = 0;
      this.addY = 0;
      this.buttonMapping = {};
      this.buttonMapping[HtmlKeyCodes.up] = PspCtrlButtons.up;
      this.buttonMapping[HtmlKeyCodes.left] = PspCtrlButtons.left;
      this.buttonMapping[HtmlKeyCodes.right] = PspCtrlButtons.right;
      this.buttonMapping[HtmlKeyCodes.down] = PspCtrlButtons.down;
      this.buttonMapping[HtmlKeyCodes.enter] = PspCtrlButtons.start;
      this.buttonMapping[HtmlKeyCodes.space] = PspCtrlButtons.select;
      this.buttonMapping[HtmlKeyCodes.q] = PspCtrlButtons.leftTrigger;
      this.buttonMapping[HtmlKeyCodes.e] = PspCtrlButtons.rightTrigger;
      this.buttonMapping[HtmlKeyCodes.w] = PspCtrlButtons.triangle;
      this.buttonMapping[HtmlKeyCodes.s] = PspCtrlButtons.cross;
      this.buttonMapping[HtmlKeyCodes.a] = PspCtrlButtons.square;
      this.buttonMapping[HtmlKeyCodes.d] = PspCtrlButtons.circle;
      this.fieldMapping[HtmlKeyCodes.i] = "analogUp";
      this.fieldMapping[HtmlKeyCodes.k] = "analogDown";
      this.fieldMapping[HtmlKeyCodes.j] = "analogLeft";
      this.fieldMapping[HtmlKeyCodes.l] = "analogRight";
    }
    register() {
      window.document?.addEventListener("keydown", this.keyDown);
      window.document?.addEventListener("keyup", this.keyUp);
    }
    unregister() {
      window.document?.removeEventListener("keydown", this.keyDown);
      window.document?.removeEventListener("keyup", this.keyUp);
    }
    computeFrame() {
      if (this.analogUp) {
        this.analogAddY -= 0.25;
      } else if (this.analogDown) {
        this.analogAddY += 0.25;
      } else {
        this.analogAddY *= 0.3;
      }
      if (this.analogLeft) {
        this.analogAddX -= 0.25;
      } else if (this.analogRight) {
        this.analogAddX += 0.25;
      } else {
        this.analogAddX *= 0.3;
      }
      this.analogAddX = MathUtils.clamp(this.analogAddX, -1, 1);
      this.analogAddY = MathUtils.clamp(this.analogAddY, -1, 1);
      this.data.x = this.analogAddX;
      this.data.y = this.analogAddY;
      this.data.x = MathUtils.clamp(this.data.x + this.addX, -1, 1);
      this.data.y = MathUtils.clamp(this.data.y + this.addY, -1, 1);
    }
    setKeyDown(keyCode) {
      const button = this.buttonMapping[keyCode];
      if (button !== void 0)
        this.data.buttons |= button;
      const field = this.fieldMapping[keyCode];
      if (field !== void 0)
        this[field] = true;
    }
    setKeyUp(keyCode) {
      const button = this.buttonMapping[keyCode];
      if (button !== void 0)
        this.data.buttons &= ~button;
      const field = this.fieldMapping[keyCode];
      if (field !== void 0)
        this[field] = false;
    }
  };
  var HtmlKeyCodes;
  (function(HtmlKeyCodes2) {
    HtmlKeyCodes2[HtmlKeyCodes2["backspace"] = 8] = "backspace";
    HtmlKeyCodes2[HtmlKeyCodes2["tab"] = 9] = "tab";
    HtmlKeyCodes2[HtmlKeyCodes2["enter"] = 13] = "enter";
    HtmlKeyCodes2[HtmlKeyCodes2["shift"] = 16] = "shift";
    HtmlKeyCodes2[HtmlKeyCodes2["ctrl"] = 17] = "ctrl";
    HtmlKeyCodes2[HtmlKeyCodes2["alt"] = 18] = "alt";
    HtmlKeyCodes2[HtmlKeyCodes2["pause"] = 19] = "pause";
    HtmlKeyCodes2[HtmlKeyCodes2["caps_lock"] = 20] = "caps_lock";
    HtmlKeyCodes2[HtmlKeyCodes2["escape"] = 27] = "escape";
    HtmlKeyCodes2[HtmlKeyCodes2["space"] = 32] = "space";
    HtmlKeyCodes2[HtmlKeyCodes2["page_up"] = 33] = "page_up";
    HtmlKeyCodes2[HtmlKeyCodes2["page_down"] = 34] = "page_down";
    HtmlKeyCodes2[HtmlKeyCodes2["end"] = 35] = "end";
    HtmlKeyCodes2[HtmlKeyCodes2["home"] = 36] = "home";
    HtmlKeyCodes2[HtmlKeyCodes2["left"] = 37] = "left";
    HtmlKeyCodes2[HtmlKeyCodes2["up"] = 38] = "up";
    HtmlKeyCodes2[HtmlKeyCodes2["right"] = 39] = "right";
    HtmlKeyCodes2[HtmlKeyCodes2["down"] = 40] = "down";
    HtmlKeyCodes2[HtmlKeyCodes2["insert"] = 45] = "insert";
    HtmlKeyCodes2[HtmlKeyCodes2["_delete"] = 46] = "_delete";
    HtmlKeyCodes2[HtmlKeyCodes2["k0"] = 48] = "k0";
    HtmlKeyCodes2[HtmlKeyCodes2["k1"] = 49] = "k1";
    HtmlKeyCodes2[HtmlKeyCodes2["k2"] = 50] = "k2";
    HtmlKeyCodes2[HtmlKeyCodes2["k3"] = 51] = "k3";
    HtmlKeyCodes2[HtmlKeyCodes2["k4"] = 52] = "k4";
    HtmlKeyCodes2[HtmlKeyCodes2["k5"] = 53] = "k5";
    HtmlKeyCodes2[HtmlKeyCodes2["k6"] = 54] = "k6";
    HtmlKeyCodes2[HtmlKeyCodes2["k7"] = 55] = "k7";
    HtmlKeyCodes2[HtmlKeyCodes2["k8"] = 56] = "k8";
    HtmlKeyCodes2[HtmlKeyCodes2["k9"] = 57] = "k9";
    HtmlKeyCodes2[HtmlKeyCodes2["a"] = 65] = "a";
    HtmlKeyCodes2[HtmlKeyCodes2["b"] = 66] = "b";
    HtmlKeyCodes2[HtmlKeyCodes2["c"] = 67] = "c";
    HtmlKeyCodes2[HtmlKeyCodes2["d"] = 68] = "d";
    HtmlKeyCodes2[HtmlKeyCodes2["e"] = 69] = "e";
    HtmlKeyCodes2[HtmlKeyCodes2["f"] = 70] = "f";
    HtmlKeyCodes2[HtmlKeyCodes2["g"] = 71] = "g";
    HtmlKeyCodes2[HtmlKeyCodes2["h"] = 72] = "h";
    HtmlKeyCodes2[HtmlKeyCodes2["i"] = 73] = "i";
    HtmlKeyCodes2[HtmlKeyCodes2["j"] = 74] = "j";
    HtmlKeyCodes2[HtmlKeyCodes2["k"] = 75] = "k";
    HtmlKeyCodes2[HtmlKeyCodes2["l"] = 76] = "l";
    HtmlKeyCodes2[HtmlKeyCodes2["m"] = 77] = "m";
    HtmlKeyCodes2[HtmlKeyCodes2["n"] = 78] = "n";
    HtmlKeyCodes2[HtmlKeyCodes2["o"] = 79] = "o";
    HtmlKeyCodes2[HtmlKeyCodes2["p"] = 80] = "p";
    HtmlKeyCodes2[HtmlKeyCodes2["q"] = 81] = "q";
    HtmlKeyCodes2[HtmlKeyCodes2["r"] = 82] = "r";
    HtmlKeyCodes2[HtmlKeyCodes2["s"] = 83] = "s";
    HtmlKeyCodes2[HtmlKeyCodes2["t"] = 84] = "t";
    HtmlKeyCodes2[HtmlKeyCodes2["u"] = 85] = "u";
    HtmlKeyCodes2[HtmlKeyCodes2["v"] = 86] = "v";
    HtmlKeyCodes2[HtmlKeyCodes2["w"] = 87] = "w";
    HtmlKeyCodes2[HtmlKeyCodes2["x"] = 88] = "x";
    HtmlKeyCodes2[HtmlKeyCodes2["y"] = 89] = "y";
    HtmlKeyCodes2[HtmlKeyCodes2["z"] = 90] = "z";
    HtmlKeyCodes2[HtmlKeyCodes2["left_window_key"] = 91] = "left_window_key";
    HtmlKeyCodes2[HtmlKeyCodes2["right_window_key"] = 92] = "right_window_key";
    HtmlKeyCodes2[HtmlKeyCodes2["select_key"] = 93] = "select_key";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_0"] = 96] = "numpad_0";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_1"] = 97] = "numpad_1";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_2"] = 98] = "numpad_2";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_3"] = 99] = "numpad_3";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_4"] = 100] = "numpad_4";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_5"] = 101] = "numpad_5";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_6"] = 102] = "numpad_6";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_7"] = 103] = "numpad_7";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_8"] = 104] = "numpad_8";
    HtmlKeyCodes2[HtmlKeyCodes2["numpad_9"] = 105] = "numpad_9";
    HtmlKeyCodes2[HtmlKeyCodes2["multiply"] = 106] = "multiply";
    HtmlKeyCodes2[HtmlKeyCodes2["add"] = 107] = "add";
    HtmlKeyCodes2[HtmlKeyCodes2["subtract"] = 109] = "subtract";
    HtmlKeyCodes2[HtmlKeyCodes2["decimal_point"] = 110] = "decimal_point";
    HtmlKeyCodes2[HtmlKeyCodes2["divide"] = 111] = "divide";
    HtmlKeyCodes2[HtmlKeyCodes2["f1"] = 112] = "f1";
    HtmlKeyCodes2[HtmlKeyCodes2["f2"] = 113] = "f2";
    HtmlKeyCodes2[HtmlKeyCodes2["f3"] = 114] = "f3";
    HtmlKeyCodes2[HtmlKeyCodes2["f4"] = 115] = "f4";
    HtmlKeyCodes2[HtmlKeyCodes2["f5"] = 116] = "f5";
    HtmlKeyCodes2[HtmlKeyCodes2["f6"] = 117] = "f6";
    HtmlKeyCodes2[HtmlKeyCodes2["f7"] = 118] = "f7";
    HtmlKeyCodes2[HtmlKeyCodes2["f8"] = 119] = "f8";
    HtmlKeyCodes2[HtmlKeyCodes2["f9"] = 120] = "f9";
    HtmlKeyCodes2[HtmlKeyCodes2["f10"] = 121] = "f10";
    HtmlKeyCodes2[HtmlKeyCodes2["f11"] = 122] = "f11";
    HtmlKeyCodes2[HtmlKeyCodes2["f12"] = 123] = "f12";
    HtmlKeyCodes2[HtmlKeyCodes2["num_lock"] = 144] = "num_lock";
    HtmlKeyCodes2[HtmlKeyCodes2["scroll_lock"] = 145] = "scroll_lock";
    HtmlKeyCodes2[HtmlKeyCodes2["semi_colon"] = 186] = "semi_colon";
    HtmlKeyCodes2[HtmlKeyCodes2["equal_sign"] = 187] = "equal_sign";
    HtmlKeyCodes2[HtmlKeyCodes2["comma"] = 188] = "comma";
    HtmlKeyCodes2[HtmlKeyCodes2["dash"] = 189] = "dash";
    HtmlKeyCodes2[HtmlKeyCodes2["period"] = 190] = "period";
    HtmlKeyCodes2[HtmlKeyCodes2["forward_slash"] = 191] = "forward_slash";
    HtmlKeyCodes2[HtmlKeyCodes2["grave_accent"] = 192] = "grave_accent";
    HtmlKeyCodes2[HtmlKeyCodes2["open_bracket"] = 219] = "open_bracket";
    HtmlKeyCodes2[HtmlKeyCodes2["back_slash"] = 220] = "back_slash";
    HtmlKeyCodes2[HtmlKeyCodes2["close_braket"] = 221] = "close_braket";
    HtmlKeyCodes2[HtmlKeyCodes2["single_quote"] = 222] = "single_quote";
  })(HtmlKeyCodes || (HtmlKeyCodes = {}));

  // src/emu/emulator.ts
  var console14 = logger.named("emulator");
  var Emulator = class {
    constructor(memory2) {
      this.audio = new PspAudio();
      this.gpuStats = new GpuStats();
      this.battery = new Battery();
      this.config = new Config();
      this.cpuConfig = new CpuConfig();
      this.doFrameRunning = false;
      this.doFrame = () => {
        if (this.doFrameRunning)
          requestAnimationFrame(this.doFrame);
        Microtask.queueExecuteNow(() => {
          this.display.frame();
          this.controller.frame();
          this.audio.frame();
          this.threadManager.frame();
        });
      };
      this.gameTitle = "";
      this.onPic0 = new Signal1();
      this.onPic1 = new Signal1();
      this.onDrawBatches = new Signal2();
      if (!memory2)
        memory2 = getMemoryInstance();
      this.memory = memory2;
    }
    get interpreted() {
      return this.cpuConfig.interpreted;
    }
    set interpreted(value) {
      this.cpuConfig.interpreted = value;
    }
    stop() {
      this.doFrameRunning = false;
      if (!this.display)
        return;
      this.controller?.unregister();
      this.display.unregister();
      this.gpu.unregister();
      this.audio.unregister();
      this.threadManager.unregister();
    }
    start() {
      this.stop();
      this.memory.reset();
      this.controller = new PspController();
      this.controller.addContributor(new Html5Gamepad());
      this.controller.addContributor(new Html5Keyboard());
      this.controller.register();
      this.context = new EmulatorContext();
      this.memoryManager = new MemoryManager();
      this.interruptManager = new InterruptManager();
      this.syscallManager = new SyscallManager(this.context);
      this.fileManager = new FileManager();
      this.interop = new Interop();
      this.callbackManager = new CallbackManager(this.interop);
      this.rtc = new PspRtc();
      this.display = new PspDisplay(this.memory, this.interruptManager, this.canvas, this.webgl_canvas);
      this.gpu = new PspGpu(this.memory, this.display, this.interop, this.gpuStats);
      this.gpu.onDrawBatches.pipeTo(this.onDrawBatches);
      this.threadManager = new ThreadManager(this.memory, this.interruptManager, this.callbackManager, this.memoryManager, this.display, this.syscallManager, this.cpuConfig);
      this.moduleManager = new ModuleManager(this.context);
      this.netManager = new NetManager();
      this.emulatorVfs = new EmulatorVfs(this.context);
      this.ms0Vfs = new MountableVfs().mountVfs("/", new MemoryVfs());
      this.storageVfs = new StorageVfs("psp_storage");
      const memStickVfsList = [this.storageVfs, this.ms0Vfs, this.storageVfs];
      if (hasDropboxToken()) {
      }
      const msvfs = new MemoryStickVfs(memStickVfsList, this.callbackManager, this.memory);
      this.fileManager.mount("fatms0", msvfs).mount("ms0", msvfs).mount("mscmhc0", msvfs).mount("host0", new MemoryVfs()).mount("flash0", new UriVfs("data/flash0")).mount("emulator", this.emulatorVfs).mount("kemulator", this.emulatorVfs);
      registerModulesAndSyscalls(this.syscallManager, this.moduleManager);
      this.context.init(this.interruptManager, this.display, this.controller, this.gpu, this.memoryManager, this.threadManager, this.audio, this.memory, this.fileManager, this.rtc, this.callbackManager, this.moduleManager, this.config, this.interop, this.netManager, this.battery);
      this.display.register();
      this.gpu.register();
      this.audio.register();
      this.threadManager.register();
      this.doFrameRunning = true;
      this.doFrame();
    }
    processParamsPsf(psf) {
      this.gameTitle = psf.entriesByName["TITLE"];
      console14.log(psf.entriesByName);
    }
    loadIcon0(data) {
      this.onPic0.dispatch(data.toUInt8Array());
    }
    loadPic1(data) {
      this.onPic1.dispatch(data.toUInt8Array());
    }
    async _loadAndExecuteAsync(asyncStream, pathToFile) {
      const fileFormat = await detectFormatAsync(asyncStream);
      console14.info(`File:: size: ${asyncStream.size}, format: "${fileFormat}", name: "${asyncStream.name}", pathToFile: "${pathToFile}"`);
      switch (fileFormat) {
        case "ciso": {
          const asyncStream2 = await Cso.fromStreamAsync(asyncStream);
          return await this._loadAndExecuteAsync(asyncStream2, pathToFile);
        }
        case "pbp": {
          const executableArrayBuffer = await asyncStream.readChunkAsync(0, asyncStream.size);
          const pbp = Pbp.fromStream(Stream.fromArrayBuffer(executableArrayBuffer));
          const psf = Psf.fromStream(pbp.get(PbpNames.ParamSfo));
          this.processParamsPsf(psf);
          this.loadIcon0(pbp.get(PbpNames.Icon0Png));
          this.loadPic1(pbp.get(PbpNames.Pic1Png));
          return await this._loadAndExecuteAsync(new MemoryAsyncStream(pbp.get(PbpNames.PspData).toArrayBuffer()), pathToFile);
        }
        case "psp": {
          const executableArrayBuffer = await asyncStream.readChunkAsync(0, asyncStream.size);
          return await this._loadAndExecuteAsync(new MemoryAsyncStream(decrypt(Stream.fromArrayBuffer(executableArrayBuffer)).slice().readAllBytes().buffer, pathToFile + ".CryptedPSP"), pathToFile);
        }
        case "zip": {
          const zip = await Zip.fromStreamAsync(asyncStream);
          const zipFs = new ZipVfs(zip, this.storageVfs);
          const mountableVfs = this.ms0Vfs;
          mountableVfs.mountVfs("/PSP/GAME/virtual", zipFs);
          const availableElf = ["/EBOOT.ELF", "/BOOT.ELF", "/EBOOT.PBP"].first((item) => zip.has(item));
          console14.log(`elf: ${availableElf}`);
          const node = await zipFs.openAsync(availableElf, FileOpenFlags.Read, parseInt("0777", 8));
          const data = await node.readAllAsync();
          return await this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(data), "ms0:/PSP/GAME/virtual/EBOOT.ELF");
        }
        case "iso": {
          const iso = await Iso.fromStreamAsync(asyncStream);
          const isoFs = new IsoVfs(iso);
          this.fileManager.mount("umd0", isoFs);
          this.fileManager.mount("umd1", isoFs);
          this.fileManager.mount("disc0", isoFs);
          this.fileManager.mount("disc1", isoFs);
          const exists = await isoFs.existsAsync("PSP_GAME/PARAM.SFO");
          if (!exists) {
            const mountableVfs = this.ms0Vfs;
            mountableVfs.mountVfs("/PSP/GAME/virtual", new ProxyVfs([isoFs, this.storageVfs]));
            const bootBinData = await isoFs.readAllAsync("EBOOT.PBP");
            return await this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(bootBinData), "ms0:/PSP/GAME/virtual/EBOOT.PBP");
          } else {
            const paramSfoData = await isoFs.readAllAsync("PSP_GAME/PARAM.SFO");
            const psf = Psf.fromStream(Stream.fromArrayBuffer(paramSfoData));
            this.processParamsPsf(psf);
            try {
              this.loadIcon0(Stream.fromArrayBuffer(await isoFs.readAllAsync("PSP_GAME/ICON0.PNG")));
              this.loadPic1(Stream.fromArrayBuffer(await isoFs.readAllAsync("PSP_GAME/PIC1.PNG")));
            } catch (e) {
              console14.error(e);
            }
            const exists2 = await isoFs.existsAsync("PSP_GAME/SYSDIR/BOOT.BIN");
            const path = exists2 ? "PSP_GAME/SYSDIR/BOOT.BIN" : "PSP_GAME/SYSDIR/EBOOT.BIN";
            const bootBinData = await isoFs.readAllAsync(path);
            return await this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(bootBinData), `umd0:/${path}`);
          }
        }
        case "elf": {
          const executableArrayBuffer = await asyncStream.readChunkAsync(0, asyncStream.size);
          if (typeof document != "undefined") {
            document.title = this.gameTitle ? `${this.gameTitle} - jspspemu` : "jspspemu";
          }
          const mountableVfs = this.ms0Vfs;
          mountableVfs.mountFileData("/PSP/GAME/virtual/EBOOT.ELF", executableArrayBuffer);
          const elfStream = Stream.fromArrayBuffer(executableArrayBuffer);
          this.fileManager.cwd = new Uri("ms0:/PSP/GAME/virtual");
          const args = [pathToFile];
          const argumentsPartition = this.memoryManager.userPartition.allocateLow(16384);
          const argument = args.map((argument2) => argument2 + String.fromCharCode(0)).join("");
          this.memory.getPointerStream(argumentsPartition.low).writeString(argument);
          const pspElf = new PspElfLoader(this.memory, this.memoryManager, this.moduleManager, this.syscallManager);
          pspElf.load(elfStream);
          this.context.symbolLookup = pspElf;
          this.context.gameTitle = this.gameTitle;
          this.context.gameId = pspElf.moduleInfo.name;
          const moduleInfo = pspElf.moduleInfo;
          const thread = this.threadManager.create("main", moduleInfo.pc, 10);
          thread.state.GP = moduleInfo.gp;
          thread.state.setGPR(4, argument.length);
          thread.state.setGPR(5, argumentsPartition.low);
          thread.start();
          return;
        }
        default:
          throw new Error(`"Unhandled format '${fileFormat}'`);
      }
    }
    async loadExecuteAndWaitAsync(asyncStream, url, afterStartCallback) {
      this.gameTitle = "";
      await this.loadAndExecuteAsync(asyncStream, url);
      try {
        if (afterStartCallback)
          afterStartCallback();
        await this.threadManager.waitExitGameAsync();
        this.stop();
        return this.emulatorVfs.output;
      } catch (e) {
        console14.error(e);
        console14.error(e.stack);
        throw e;
      }
    }
    static disableLog() {
      loggerPolicies.disableAll = true;
    }
    async loadAndExecuteAsync(asyncStream, url) {
      if (typeof document != "undefined")
        DomHelp.fromId("game_menu").hide();
      url = String(url);
      this.gameTitle = "";
      this.loadIcon0(Stream.fromArray([]));
      this.loadPic1(Stream.fromArray([]));
      try {
        this.start();
        const parentUrl = url.replace(/\/[^//]+$/, "");
        console14.info(`parentUrl: ${parentUrl}`);
        this.ms0Vfs.mountVfs("/PSP/GAME/virtual", new UriVfs(parentUrl));
        return await this._loadAndExecuteAsync(asyncStream, "ms0:/PSP/GAME/virtual/EBOOT.PBP");
      } catch (e) {
        console14.error(e);
        console14.error(e.stack);
        throw e;
      }
    }
    async downloadAndExecuteAsync(url) {
      const stream = await UrlAsyncStream.fromUrlAsync(url);
      await this.loadAndExecuteAsync(stream, url);
    }
    async downloadAndExecuteAndWaitAsync(url, afterStartCallback) {
      const stream = await UrlAsyncStream.fromUrlAsync(url);
      return await this.loadExecuteAndWaitAsync(stream, url, afterStartCallback);
    }
    async executeFileAsync(file) {
      await this.loadAndExecuteAsync(new BufferedAsyncStream(new FileAsyncStream(file)), ".");
    }
  };

  // src/html5/Html5Audio.ts
  var PspAudioBuffer = class {
    constructor(readedCallback, data) {
      this.readedCallback = readedCallback;
      this.data = data;
      this.offset = 0;
    }
    resolve() {
      if (this.readedCallback)
        this.readedCallback();
      this.readedCallback = null;
    }
    get hasMore() {
      return this.offset < this.length;
    }
    read() {
      return this.data[this.offset++];
    }
    get available() {
      return this.length - this.offset;
    }
    get length() {
      return this.data.length;
    }
  };
  var Audio2Channel = class {
    constructor(id, context) {
      this.id = id;
      this.context = context;
      this.buffers = [];
      if (this.context) {
        this.node = this.context.createScriptProcessor(1024, 2, 2);
        this.node.addEventListener("audioprocess", (e) => {
          this.process(e);
        });
      }
    }
    start() {
      if (this.node)
        this.node.connect(this.context.destination);
    }
    stop() {
      if (this.node)
        this.node.disconnect();
    }
    process(e) {
      const left = e.outputBuffer.getChannelData(0);
      const right = e.outputBuffer.getChannelData(1);
      const sampleCount = left.length;
      const hidden = document.hidden;
      for (let n = 0; n < sampleCount; n++) {
        if (!this.currentBuffer) {
          if (this.buffers.length == 0) {
            break;
          }
          for (let m = 0; m < Math.min(3, this.buffers.length); m++) {
            this.buffers[m].resolve();
          }
          this.currentBuffer = this.buffers.shift();
          this.currentBuffer?.resolve();
        }
        if (this.currentBuffer != null && this.currentBuffer.available >= 2) {
          left[n] = this.currentBuffer.read();
          right[n] = this.currentBuffer.read();
        } else {
          this.currentBuffer = null;
          n--;
        }
        if (hidden)
          left[n] = right[n] = 0;
      }
    }
    async playAsync(data) {
      if (!this.node) {
        await waitAsync(10);
        return 0;
      }
      if (this.buffers.length < 8) {
        this.buffers.push(new PspAudioBuffer(null, data));
        return 0;
      } else {
        return new Promise((resolved, rejected) => {
          this.buffers.push(new PspAudioBuffer(resolved, data));
          return 0;
        });
      }
    }
    playDataAsync(channels, data, leftVolume, rightVolume) {
      return this.playAsync(convertS16ToF32(channels, data, leftVolume, rightVolume));
    }
  };
  var Html5Audio2 = class {
    constructor() {
      this.channels = new Map();
      this.context = null;
      try {
        this.context = new AudioContext();
      } catch (e) {
        console.error("Error creating AudioContext", e);
      }
      const unlock = () => {
        document.removeEventListener("keydown", unlock, true);
        document.removeEventListener("touchstart", unlock, true);
        document.removeEventListener("mousedown", unlock, true);
        const ctx = this.context;
        if (ctx != null) {
          ctx.resume();
          const source = ctx.createBufferSource();
          source.buffer = ctx.createBuffer(1, 1, 22050);
          source.connect(ctx.destination);
          source.start(0);
          if (ctx.resume)
            ctx.resume();
          source.onended = () => {
            source.disconnect(0);
            console.warn("Web Audio was successfully unlocked");
          };
        }
      };
      document.addEventListener("keydown", unlock, true);
      document.addEventListener("touchstart", unlock, true);
      document.addEventListener("mousedown", unlock, true);
    }
    getChannel(id) {
      if (!this.channels.has(id))
        this.channels.set(id, new Audio2Channel(id, this.context));
      return this.channels.get(id);
    }
    startChannel(id) {
      return this.getChannel(id).start();
    }
    stopChannel(id) {
      return this.getChannel(id).stop();
    }
    playDataAsync(id, channels, data, leftVolume, rightVolume) {
      return this.getChannel(id).playDataAsync(channels, data, leftVolume, rightVolume);
    }
  };

  // src/html5/Html5Battery.ts
  var _Html5Battery = class {
    constructor(manager) {
      this.manager = manager;
      _Html5Battery.instance = this;
    }
    get lifetime() {
      if (this.manager != null)
        return Math.min(10 * 3600, this.manager.dischargingTime);
      return 3 * 3600;
    }
    get charging() {
      if (this.manager != null)
        return this.manager.charging;
      return true;
    }
    get level() {
      if (this.manager != null)
        return this.manager.level;
      return 1;
    }
    static async getAsync() {
      if (this.instance)
        return Promise.resolve(this.instance);
      if (this.promise)
        return this.promise;
      if (navigator.battery)
        return Promise.resolve(new _Html5Battery(navigator.battery));
      if (navigator.getBattery) {
        return this.promise = (async () => {
          const v = await navigator.getBattery();
          return new _Html5Battery(v);
        })();
      }
      return Promise.resolve(new _Html5Battery(null));
    }
    static async registerAndSetCallback(callback) {
      await waitAsync(0);
      const battery = await _Html5Battery.getAsync();
      function sendData() {
        callback({
          charging: battery.charging,
          level: battery.level,
          lifetime: battery.lifetime
        });
      }
      setInterval(() => {
        sendData();
      }, 300);
      sendData();
    }
  };
  var Html5Battery = _Html5Battery;
  Html5Battery.instance = null;
  Html5Battery.promise = null;

  // src/html5/Html5Icons.ts
  function changeFavicon(src) {
    if (typeof document == "undefined")
      return;
    const link = document.createElement("link");
    const oldLink = document.getElementById("dynamic-favicon");
    link.id = "dynamic-favicon";
    link.rel = "shortcut icon";
    link.href = src;
    if (oldLink) {
      document.head.removeChild(oldLink);
    }
    document.head.appendChild(link);
  }
  var Html5Icons = class {
    static setPic0(data) {
      changeFavicon(Stream.fromUint8Array(data).toImageUrl());
    }
    static setPic1(data) {
      document.body.style.backgroundRepeat = "no-repeat";
      document.body.style.backgroundSize = "cover";
      document.body.style.backgroundPosition = "center center";
      document.body.style.backgroundImage = `url("${Stream.fromUint8Array(data).toImageUrl()}")`;
    }
  };

  // src/emu/emulator_controller_normal.ts
  var EmulatorControllerNormal = class {
    constructor() {
      this.documentLocation = document.location.href.replace(/#.*$/, "").replace(/\/[^\/]*$/, "");
      this.emulator = new Emulator();
      this.audio = new Html5Audio2();
    }
    getOrCreateCanvas() {
      return document.getElementById("canvas");
    }
    getOrCreateWebglCanvas() {
      return document.getElementById("webgl_canvas");
    }
    async init() {
      if (!document.getElementById("canvas_container")) {
        const canvas_container = document.createElement("div");
        canvas_container.id = "canvas_container";
        canvas_container.innerHTML = `
                <div id="touch_buttons">
                  <span id="directional_pad">
                    <span class="psp_button" id="button_left">2</span>
                    <span class="psp_button" id="button_up">3</span>
                    <span class="psp_button" id="button_right">1</span>
                    <span class="psp_button" id="button_down">4</span>
                  </span>
            
                  <span id="button_pad">
                    <span class="psp_button" id="button_cross">X</span>
                    <span class="psp_button" id="button_circle">C</span>
                    <span class="psp_button" id="button_triangle">T</span>
                    <span class="psp_button" id="button_square">S</span>
                  </span>
            
                  <span id="lr_pad">
                    <span class="psp_button" id="button_l">l</span>
                    <span class="psp_button" id="button_r">r</span>
                  </span>
            
                  <span id="select_start_pad">
                    <span class="psp_button" id="button_menu">MENU</span>
                    <span class="psp_button" id="button_start">A</span>
                    <span class="psp_button" id="button_select">B</span>
                  </span>
                </div>
            
                <canvas id="canvas" width="480" height="272" style="background: black; width: 960px; height: 544px; border: 0; display: block;"></canvas>
                <canvas id="webgl_canvas" width="960" height="544" style="background: black; width: 960px; height: 544px; border: 0; display: none; "></canvas>
            `;
        document.body.appendChild(canvas_container);
        document.body.style.padding = "0";
        document.body.style.margin = "0";
      }
      let emulator = this.emulator;
      let audio = this.audio;
      self.emulator = emulator;
      const canvas = this.getOrCreateCanvas();
      const webgl_canvas = this.getOrCreateWebglCanvas();
      const webglDriver = new WebGlPspDrawDriver(webgl_canvas, emulator.gpuStats);
      webglDriver.register(emulator.memory);
      let debugOverlay = new DebugOverlay(webglDriver);
      debugOverlay.register();
      emulator.canvas = canvas;
      emulator.webgl_canvas = webgl_canvas;
      try {
        emulator.start();
        console.info("emulator started");
        emulator.onPic0.add((data) => {
          Html5Icons.setPic0(data);
        });
        emulator.onPic1.add((data) => {
          Html5Icons.setPic1(data);
        });
        debugOverlay.linkTo(emulator);
        emulator.onDrawBatches.add(async function onDrawBatchesFrame(drawBufferData, batches) {
          emulator.display.setEnabledDisplay(false);
          const transferData = OptimizedDrawBufferTransfer.buildBatchesTransfer(drawBufferData, batches);
          webglDriver.invalidatedMemoryAll();
          debugOverlay.overlay.updateAndReset();
          webglDriver.drawBatchesTransfer(transferData);
          await debugOverlay.freezing.waitUntilValueAsync(false);
          emulator.gpu.sync();
        });
        emulator.memory.invalidateDataAll.add(() => {
        });
        emulator.memory.invalidateDataRange.add((low, high) => {
        });
        emulator.audio.onPlayDataAsync.add((id, channels, data, leftvolume, rightvolume) => {
          return audio.playDataAsync(id, channels, ArrayBufferUtils.cloneInt16Array(data), leftvolume, rightvolume);
        });
        emulator.audio.onStart.add((id) => {
          audio.startChannel(id);
        });
        emulator.audio.onStop.add((id) => {
          audio.stopChannel(id);
        });
      } catch (e) {
        console.error(e);
      }
      console.log("base path", this.documentLocation);
      emulator.config.language = Config.detectLanguage();
      debugOverlay.gpuFreezing.add((value) => {
        emulator.gpu.freezing.value = value;
      });
      debugOverlay.gpuDumpCommands.add(() => {
        emulator.gpu.dumpCommands();
      });
      Html5Battery.registerAndSetCallback((binfo) => {
        emulator.battery.charging = binfo.charging;
        emulator.battery.level = binfo.level;
        emulator.battery.lifetime = binfo.lifetime;
      });
      Microtask.execute();
    }
    executeUrl(url) {
      if (url.match(/^https?:\/\//)) {
        url = url;
      } else {
        url = `${this.documentLocation}/${url}`;
      }
      console.info("executeUrl:", url);
      this.emulator.downloadAndExecuteAsync(url);
    }
    executeFile(file) {
      console.info("executeFile:", file);
      this.emulator.executeFileAsync(file);
    }
  };

  // src/emu/emulator_controller.ts
  var controller = new EmulatorControllerNormal();
  var EmulatorController = class {
    static executeUrl(url) {
      controller.executeUrl(url);
    }
    static executeFile(file) {
      controller.executeFile(file);
    }
  };
  controller.init();

  // src/app.ts
  globalReferenced();
  var demos = [
    "-CPU",
    "data/benchmark/benchmark.prx",
    "compilerPerf.elf",
    "counter.elf",
    "fputest.elf",
    "vfputest.elf",
    "mytest.elf",
    "-OS",
    "rtctest.elf",
    "rtctest.pbp",
    "threadstatus.elf",
    "taskScheduler.prx",
    "power.pbp",
    "controller.elf",
    "-IO",
    "mstick.pbp",
    "cwd.elf",
    "ioasync.pbp",
    "-AUDIO",
    "polyphonic.elf",
    "-DISPLAY",
    "displayWait.prx",
    "minifire.elf",
    "HelloWorldPSP.elf",
    "-GPU",
    "2dstudio.prx",
    "3dstudio.pbp",
    "ortho.elf",
    "cube.elf",
    "cube.cso",
    "cube.iso",
    "cubevfpu.prx",
    "lights.pbp",
    "skinning.pbp",
    "morph.pbp",
    "morphskin.pbp",
    "sprite.pbp",
    "lines.pbp",
    "clut.pbp",
    "reflection.pbp",
    "text.elf",
    "intraFontTest.elf",
    "blend.pbp",
    "nehetutorial02.pbp",
    "nehetutorial03.pbp",
    "nehetutorial04.pbp",
    "nehetutorial05.pbp",
    "nehetutorial06.pbp",
    "nehetutorial07.pbp",
    "nehetutorial08.pbp",
    "nehetutorial09.pbp",
    "nehetutorial10.pbp",
    "zbufferfog.elf",
    "-GAMES",
    "cavestory.zip",
    "TrigWars.zip",
    "goldminer.zip",
    "Doom.zip",
    "cdogs.zip",
    "jazz.zip",
    "SkyRoads.zip",
    "PSPTris.zip",
    "Alex4C.zip"
  ];
  DomHelp.fromId("demo_list").html = "";
  DomHelp.fromId("files").html = "";
  demos.forEach(function(fileName) {
  });
  var FillScreenPlugin = class {
    static use() {
      function updateScaleWith(scale) {
        const width = 480 * scale, height = 272 * scale;
        DomHelp.fromId("body").width = width;
        DomHelp.fromId("canvas").css("width", width + "px").css("height", height + "px");
        DomHelp.fromId("webgl_canvas").css("width", width + "px").css("height", height + "px");
        DomHelp.fromId("touch_buttons").css("width", width + "px").css("height", height + "px").css("font-size", scale + "em");
      }
      function onResize() {
        const position = DomHelp.fromId("canvas_container").position;
        const windowSize = new DomHelp(window).size;
        const availableHeight = windowSize.height - position.top;
        const availableWidth = windowSize.width;
        const scale1 = availableHeight / 272;
        const scale2 = availableWidth / 480;
        const steps = 0.5;
        let scale = Math.min(scale1, scale2);
        if (scale < steps)
          scale = steps;
        updateScaleWith(scale);
        const _document = document;
        let isFullScreen = _document.webkitIsFullScreen || _document.mozIsFullScreen || (screen.availHeight || screen.height - 30) <= window.innerHeight;
        if (window.innerHeight > window.innerWidth)
          isFullScreen = false;
        new DomHelp(document.body).toggleClass("fullscreen", isFullScreen);
        DomHelp.fromId("touch_buttons").css("display", isTouchDevice() ? "block" : "none");
        if (windowSize.height >= DomHelp.fromId("canvas").height * 2) {
          DomHelp.fromId("touch_buttons").e.className = "standalone";
        } else {
          DomHelp.fromId("touch_buttons").e.className = "";
        }
      }
      new DomHelp(window).on("resize", (e) => {
        onResize();
      });
      onResize();
    }
  };
  window.addEventListener("load", () => {
    const _window = window;
    let sampleDemo = void 0;
    if (document.location.hash) {
      sampleDemo = document.location.hash.substr(1);
    }
    if (sampleDemo) {
      EmulatorController.executeUrl(sampleDemo);
    }
    const selectedItem = document.location.hash.substr(1);
    function selectFile(file) {
      console.clear();
      document.location.hash = file;
      document.location.reload();
    }
    if (!document.getElementById("load_file")) {
      const input = document.createElement("input");
      input.type = "file";
      input.id = "load_file";
      input.style.position = "absolute";
      input.style.top = "0";
      input.style.left = "0";
      console.info("Created load_file input");
      document.body.appendChild(input);
    }
    DomHelp.fromId("files").on("change", () => {
      selectFile(DomHelp.fromId("files").val());
    });
    new DomHelp(window).on("hashchange", function() {
      console.clear();
    });
    FillScreenPlugin.use();
    DomHelp.fromId("load_file").on("change", (e) => {
      const target = e.target;
      if (target.files && target.files.length > 0) {
        document.getElementById("load_file").blur();
        EmulatorController.executeFile(target.files[0]);
      }
    });
    DomHelp.fromId("body").removeClass("unready");
  });
  referenceDropbox();
})();
